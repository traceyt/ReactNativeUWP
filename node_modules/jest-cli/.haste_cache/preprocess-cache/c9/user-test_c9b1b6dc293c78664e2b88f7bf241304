'use strict';

jest.unmock('../user');var _user = require('../user');var 

user = _interopRequireWildcard(_user);function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {return step("next", value);}, function (err) {return step("throw", err);});}}return step("next");});};}

describe('async testing', function () {
  // Use `pit` instead of `it` for testing promises.
  // The promise that is being tested should be returned.
  pit('works with promises', function () {
    return user.getUserName(5).
    then(function (name) {return expect(name).toEqual('Paul');});});


  pit('works with async/await', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {var 
    userName;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return user.getUserName(4);case 2:userName = _context.sent;

            expect(userName).toEqual('Mark');case 4:case 'end':return _context.stop();}}}, _callee, undefined);})));});