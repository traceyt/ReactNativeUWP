/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.
dontMock('RelayMutationTransaction').
dontMock('RelayMutationTransactionStatus');













describe('RelayMutationQueue', function () {
  var RelayNetworkLayer;
  var storeData;
  var mutationQueue;

  beforeEach(function () {
    jest.resetModuleRegistry();

    RelayNetworkLayer = jest.genMockFromModule('RelayNetworkLayer');
    jest.setMock('RelayNetworkLayer', RelayNetworkLayer);

    require('RelayStoreData').prototype.handleUpdatePayload = jest.genMockFunction();
    storeData = require('RelayStore').getStoreData();
    mutationQueue = storeData.getMutationQueue();

    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  describe('constructor', function () {
    var mockMutation, mutationNode, fatQuery;

    beforeEach(function () {
      mutationNode = (function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'RelayMutationQueue', responseType: 'CommentCreateResponsePayload' };})();
      fatQuery = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'likers', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'LikersOfContentConnection' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'FPTVT00Lu+yT:0', kind: 'Fragment', metadata: {}, name: 'Comment', type: 'Comment' }], id: 'FPTVT00Lu+yT:1', kind: 'Fragment', metadata: { pattern: true }, name: 'RelayMutationQueueRelayQL', type: 'Comment' };})();





      mockMutation = new (require('RelayMutation'))();
      mockMutation.getFatQuery.mockReturnValue(fatQuery);
      mockMutation.getMutation.mockReturnValue(mutationNode);
      mockMutation.getConfigs.mockReturnValue('configs');});


    it('does not update store if there is no optimistic response', function () {
      var transaction = mutationQueue.createTransaction(mockMutation);

      expect(transaction.getStatus()).toBe(
      require('RelayMutationTransactionStatus').UNCOMMITTED);

      expect(storeData.handleUpdatePayload).not.toBeCalled();});


    it('updates store if there is a optimistic response', function () {
      var input = { foo: 'bar' };
      mockMutation.getVariables.mockReturnValue(input);
      mockMutation.getOptimisticResponse.mockReturnValue({});
      mockMutation.getOptimisticConfigs.mockReturnValue('optimisticConfigs');
      require('RelayMutationQuery').buildQuery.mockReturnValue('optimisticQuery');

      var transaction = mutationQueue.createTransaction(mockMutation);

      expect(transaction.getStatus()).toBe(
      require('RelayMutationTransactionStatus').UNCOMMITTED);

      var buildQueryCalls = require('RelayMutationQuery').buildQuery.mock.calls;
      expect(buildQueryCalls.length).toBe(1);
      expect(buildQueryCalls[0][0].configs).toBe('optimisticConfigs');
      expect(buildQueryCalls[0][0].input).toEqual(_extends({}, 
      input, _defineProperty({}, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0')));

      expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);
      expect(buildQueryCalls[0][0].mutationName).toBe('RelayMutation');
      expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());
      expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(
      require('flattenRelayQuery')(require('fromGraphQL').Fragment(fatQuery), { 
        preserveEmptyNodes: true, 
        shouldRemoveFragments: true }));


      expect(storeData.handleUpdatePayload.mock.calls).toEqual([[
      'optimisticQuery', _defineProperty({}, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), 
      { configs: 'optimisticConfigs', isOptimisticUpdate: true }]]);});



    it('infers optimistic query if mutation does not have one', function () {
      mockMutation.getOptimisticResponse.mockReturnValue({});
      require('RelayMutationQuery').buildQueryForOptimisticUpdate.mockReturnValue(
      'optimisticQuery');


      mutationQueue.createTransaction(mockMutation);

      var buildQueryCalls = 
      require('RelayMutationQuery').buildQueryForOptimisticUpdate.mock.calls;
      expect(buildQueryCalls.length).toBe(1);
      expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);
      expect(buildQueryCalls[0][0].response).toEqual(_defineProperty({}, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'));

      expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());
      expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(
      require('flattenRelayQuery')(require('fromGraphQL').Fragment(fatQuery), { 
        preserveEmptyNodes: true, 
        shouldRemoveFragments: true }));


      expect(storeData.handleUpdatePayload.mock.calls).toEqual([[
      'optimisticQuery', _defineProperty({}, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), 
      { configs: 'configs', isOptimisticUpdate: true }]]);});});




  describe('commit', function () {
    var mockMutation1, mockMutation2, mockMutation3, mutationNode, fatQuery;

    beforeEach(function () {
      fatQuery = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'XG+H4Udep25K:0', kind: 'Fragment', metadata: {}, name: 'Comment', type: 'Comment' }], id: 'XG+H4Udep25K:1', kind: 'Fragment', metadata: { pattern: true }, name: 'RelayMutationQueueRelayQL', type: 'Comment' };})();




      mutationNode = (function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'RelayMutationQueue', responseType: 'CommentCreateResponsePayload' };})();

      require('RelayMutation').prototype.getFatQuery.mockReturnValue(fatQuery);
      require('RelayMutation').prototype.getMutation.mockReturnValue(mutationNode);
      require('RelayMutation').prototype.getCollisionKey.mockReturnValue(null);
      require('RelayMutation').prototype.getVariables.mockReturnValue({});
      require('RelayMutation').prototype.getConfigs.mockReturnValue('configs');

      mockMutation1 = new (require('RelayMutation'))();
      mockMutation2 = new (require('RelayMutation'))();
      mockMutation3 = new (require('RelayMutation'))();
      mockMutation1.getCollisionKey.mockReturnValue('key');
      mockMutation2.getCollisionKey.mockReturnValue('anotherKey');});


    it('throws if commit is called more than once', function () {
      var transaction = mutationQueue.createTransaction(mockMutation1);
      transaction.commit();
      expect(function () {return transaction.commit();}).toThrowError(
      'RelayMutationTransaction: Only transactions with status ' + 
      '`UNCOMMITTED` can be comitted.');});



    it('calls `onSuccess` with response', function () {
      var successCallback1 = jest.genMockFunction();
      var transaction1 = mutationQueue.createTransaction(
      mockMutation1, 
      { onSuccess: successCallback1 });

      transaction1.commit();
      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);

      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];
      request.resolve({ response: { 'res': 'ponse' } });
      jest.runAllTimers();
      expect(successCallback1.mock.calls).toEqual([[{ 'res': 'ponse' }]]);});


    it('calls `onFailure` with transaction', function () {
      var failureCallback1 = jest.genMockFunction().mockImplementation(
      function (transaction) {
        expect(transaction).toBe(transaction1);
        expect(transaction.getError()).toBe(mockError);});


      var transaction1 = mutationQueue.createTransaction(
      mockMutation1, 
      { onFailure: failureCallback1 });

      var mockError = new Error('error');
      transaction1.commit();

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);
      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];
      request.reject(mockError);
      jest.runAllTimers();
      expect(failureCallback1).toBeCalled();});


    it('queues commits for colliding transactions', function () {
      var successCallback1 = jest.genMockFunction();
      var transaction1 = mutationQueue.createTransaction(
      mockMutation1, 
      { onSuccess: successCallback1 });

      transaction1.commit();

      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);


      var transaction2 = mutationQueue.createTransaction(mockMutation1);
      transaction2.commit();

      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);

      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];
      request.resolve({ response: {} });
      jest.runAllTimers();

      expect(successCallback1).toBeCalled();
      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);});


    it('does not queue commits for non-colliding transactions', function () {
      var transaction1 = mutationQueue.createTransaction(mockMutation1);
      transaction1.commit();

      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);

      var transaction2 = mutationQueue.createTransaction(mockMutation2);
      transaction2.commit();

      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);});


    it('does not queue commits for `null` collision key transactions', function () {
      var transaction1 = mutationQueue.createTransaction(mockMutation3);
      transaction1.commit();

      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);

      var transaction2 = mutationQueue.createTransaction(mockMutation3);
      transaction2.commit();

      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);});


    it('empties collision queue after a failure', function () {
      var failureCallback1 = jest.genMockFunction().mockImplementation(
      function (transaction, preventAutoRollback) {
        expect(transaction).toBe(transaction1);
        expect(transaction.getStatus()).toBe(
        require('RelayMutationTransactionStatus').COMMIT_FAILED);});



      var transaction1 = mutationQueue.createTransaction(
      mockMutation1, 
      { onFailure: failureCallback1 });

      transaction1.commit();

      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);

      var failureCallback2 = jest.genMockFunction().mockImplementation(
      function (transaction, preventAutoRollback) {
        expect(transaction).toBe(transaction2);
        expect(transaction.getStatus()).toBe(
        require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);


        preventAutoRollback();});


      var transaction2 = mutationQueue.createTransaction(
      mockMutation1, 
      { onFailure: failureCallback2 });

      transaction2.commit();

      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);

      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];
      request.reject(new Error('error'));
      jest.runAllTimers();

      expect(failureCallback1).toBeCalled();
      expect(failureCallback2).toBeCalled();
      expect(function () {return transaction1.getStatus();}).toThrowError(
      'RelayMutationQueue: `0` is not a valid pending transaction ID.');

      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);


      var transaction3 = mutationQueue.createTransaction(mockMutation1);
      transaction3.commit();

      expect(transaction3.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);});


    it('rolls back colliding transactions on failure unless prevented', function () {
      var failureCallback1 = jest.genMockFunction().mockImplementation(
      function (transaction, preventAutoRollback) {
        expect(transaction).toBe(transaction1);
        expect(transaction.getStatus()).toBe(
        require('RelayMutationTransactionStatus').COMMIT_FAILED);

        preventAutoRollback();});


      var transaction1 = mutationQueue.createTransaction(
      mockMutation1, 
      { onFailure: failureCallback1 });

      transaction1.commit();

      var failureCallback2 = jest.genMockFunction().mockImplementation(
      function (transaction, preventAutoRollback) {
        expect(transaction).toBe(transaction2);
        expect(transaction.getStatus()).toBe(
        require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);});



      var transaction2 = mutationQueue.createTransaction(
      mockMutation1, 
      { onFailure: failureCallback2 });

      transaction2.commit();

      var failureCallback3 = jest.genMockFunction().mockImplementation(
      function (transaction, preventAutoRollback) {
        expect(transaction).toBe(transaction3);
        expect(transaction.getStatus()).toBe(
        require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);

        preventAutoRollback();});


      var transaction3 = mutationQueue.createTransaction(
      mockMutation1, 
      { onFailure: failureCallback3 });

      transaction3.commit();

      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(transaction2.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);

      expect(transaction3.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);


      var failureCallback4 = jest.genMockFunction().mockImplementation();
      var transaction4 = mutationQueue.createTransaction(
      mockMutation2, 
      { onFailure: failureCallback4 });

      transaction4.commit();

      var failureCallback5 = jest.genMockFunction().mockImplementation();
      var transaction5 = mutationQueue.createTransaction(
      mockMutation2, 
      { onFailure: failureCallback5 });

      transaction5.commit();

      expect(transaction4.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(transaction5.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);

      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];
      request.reject(new Error('error'));
      jest.runAllTimers();

      expect(failureCallback1).toBeCalled();
      expect(failureCallback2).toBeCalled();
      expect(failureCallback3).toBeCalled();
      expect(failureCallback4).not.toBeCalled();
      expect(failureCallback5).not.toBeCalled();
      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_FAILED);

      expect(function () {return transaction2.getStatus();}).toThrowError(
      'RelayMutationQueue: `1` is not a valid pending transaction ID.');

      expect(transaction3.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);

      expect(transaction4.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);

      expect(transaction5.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);});});




  describe('recommit', function () {
    var mockMutation, mutationNode, fatQuery;

    beforeEach(function () {
      fatQuery = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'BXCrWJU2Kl+s:0', kind: 'Fragment', metadata: {}, name: 'Comment', type: 'Comment' }], id: 'BXCrWJU2Kl+s:1', kind: 'Fragment', metadata: { pattern: true }, name: 'RelayMutationQueueRelayQL', type: 'Comment' };})();




      mutationNode = (function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'RelayMutationQueue', responseType: 'CommentCreateResponsePayload' };})();
      require('RelayMutation').prototype.getFatQuery.mockReturnValue(fatQuery);
      require('RelayMutation').prototype.getMutation.mockReturnValue(mutationNode);
      require('RelayMutation').prototype.getCollisionKey.mockReturnValue('key');
      require('RelayMutation').prototype.getVariables.mockReturnValue({});
      require('RelayMutation').prototype.getConfigs.mockReturnValue('configs');

      mockMutation = new (require('RelayMutation'))();});


    it('re-queues the transaction', function () {
      var successCallback1 = jest.genMockFunction();
      var failureCallback1 = jest.genMockFunction().mockImplementation(
      function (transaction, preventAutoRollback) {
        preventAutoRollback();});


      var transaction1 = mutationQueue.createTransaction(
      mockMutation, 
      { 
        onSuccess: successCallback1, 
        onFailure: failureCallback1 });


      transaction1.commit();

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);
      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];
      request.reject(new Error('error'));
      jest.runAllTimers();

      expect(failureCallback1).toBeCalled();
      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_FAILED);


      var successCallback2 = jest.genMockFunction();
      var transaction2 = mutationQueue.createTransaction(
      mockMutation, 
      { onSuccess: successCallback2 });

      transaction2.commit();

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);

      transaction1.recommit();
      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMIT_QUEUED);


      request = RelayNetworkLayer.sendMutation.mock.calls[1][0];
      request.resolve({ response: {} });
      jest.runAllTimers();
      expect(successCallback2).toBeCalled();

      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(3);
      expect(transaction1.getStatus()).toBe(
      require('RelayMutationTransactionStatus').COMMITTING);


      request = RelayNetworkLayer.sendMutation.mock.calls[2][0];
      request.resolve({ response: {} });
      jest.runAllTimers();

      expect(successCallback1).toBeCalled();});});});