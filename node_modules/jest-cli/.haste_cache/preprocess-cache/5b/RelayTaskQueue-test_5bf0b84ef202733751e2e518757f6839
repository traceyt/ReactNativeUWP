/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

jest.dontMock('RelayTaskQueue');






describe('RelayTaskQueue', function () {
  beforeEach(function () {
    jest.resetModuleRegistry();
    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  describe('default scheduler', function () {
    var taskQueue = undefined;

    beforeEach(function () {
      taskQueue = new (require('RelayTaskQueue'))();});


    it('resolves to undefined when no callbacks are supplied', function () {
      var mockFunction = jest.genMockFunction();
      taskQueue.enqueue().done(mockFunction);
      jest.runAllTimers();
      expect(mockFunction).toBeCalledWith(undefined);});


    it('immediately invokes tasks', function () {
      var mockFunction = jest.genMockFunction();
      taskQueue.enqueue(mockFunction);
      jest.runAllTimers();
      expect(mockFunction).toBeCalled();});


    it('invokes multiple enqueued tasks in order', function () {
      var mockOrdering = [];
      taskQueue.enqueue(function () {return mockOrdering.push('foo');});
      taskQueue.enqueue(function () {return mockOrdering.push('bar');});
      taskQueue.enqueue(function () {return mockOrdering.push('baz');});
      jest.runAllTimers();
      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);});


    it('enqueues tasks enqueued by other tasks contiguously', function () {
      var mockOrdering = [];
      taskQueue.enqueue(function () {
        mockOrdering.push('foo');
        taskQueue.enqueue(function () {return mockOrdering.push('bar');});});

      // Although `baz` is enqueued before `bar`, `bar` should execute first.
      taskQueue.enqueue(function () {return mockOrdering.push('baz');});
      jest.runAllTimers();
      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);});


    it('resolves to the task\'s return value', function () {
      var mockFunction = jest.genMockFunction();
      taskQueue.enqueue(function () {return 42;}).done(mockFunction);
      jest.runAllTimers();
      expect(mockFunction).toBeCalledWith(42);});


    it('forwards return values for multiple callbacks', function () {
      var mockOrdering = [];
      taskQueue.enqueue(
      function () {
        mockOrdering.push('foo');
        return 'bar';}, 

      function (prevValue) {
        mockOrdering.push(prevValue);
        return 'baz';}).

      done(
      function (returnValue) {
        mockOrdering.push(returnValue);});


      jest.runAllTimers();
      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);});


    it('aborts and rejects if a callback throws', function () {
      var mockError = new Error('Expected error.');
      var mockCallback = jest.genMockFunction();
      var mockFailureCallback = jest.genMockFunction();
      taskQueue.enqueue(
      function () {return 'foo';}, 
      function () {throw mockError;}, 
      mockCallback)['catch'](
      mockFailureCallback);
      jest.runAllTimers();
      expect(mockCallback).not.toBeCalled();
      expect(mockFailureCallback).toBeCalledWith(mockError);});


    it('does not affect next chain of callbacks after rejection', function () {
      var mockError = new Error('Expected error.');
      var mockCallback = jest.genMockFunction();
      var mockFailureCallback = jest.genMockFunction();
      var mockSuccessCallback = jest.genMockFunction();
      taskQueue.enqueue(
      function () {throw mockError;})['catch'](
      mockFailureCallback);
      taskQueue.enqueue(
      mockCallback).
      done(mockSuccessCallback);
      jest.runAllTimers();
      expect(mockFailureCallback).toBeCalledWith(mockError);
      expect(mockCallback).toBeCalled();
      expect(mockSuccessCallback).toBeCalled();});});



  describe('injected scheduler', function () {
    var mockScheduler = undefined;
    var mockTasks = undefined;
    var taskQueue = undefined;

    beforeEach(function () {
      mockTasks = [];
      mockScheduler = function (executeTask) {
        require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/resolveImmediate')(function () {return mockTasks.push(executeTask);});};

      taskQueue = new (require('RelayTaskQueue'))(mockScheduler);});


    it('allows injection of a scheduler to defer task execution', function () {
      var mockFunction = jest.genMockFunction();
      taskQueue.enqueue(mockFunction);
      jest.runAllTimers();
      expect(mockFunction).not.toBeCalled();
      expect(mockTasks.length).toBe(1);
      // Execute the task, which should not return anything.
      expect(mockTasks[0]()).toBe(undefined);
      expect(mockFunction).toBeCalled();});


    it('allows an injected scheduler to defer multiple tasks', function () {
      var mockOrdering = [];
      taskQueue.enqueue(function () {
        mockOrdering.push('foo');
        taskQueue.enqueue(function () {return mockOrdering.push('bar');});});

      taskQueue.enqueue(function () {return mockOrdering.push('baz');});
      jest.runAllTimers();
      // Scheduler only sees one task at a time.
      expect(mockTasks.length).toBe(1);
      mockTasks[0]();
      expect(mockOrdering).toEqual(['foo']);
      // Scheduler only sees the next task after `resolveImmediate`.
      expect(mockTasks.length).toBe(1);
      jest.runAllTimers();
      expect(mockTasks.length).toBe(2);
      mockTasks[1]();
      expect(mockOrdering).toEqual(['foo', 'bar']);
      jest.runAllTimers();
      expect(mockTasks.length).toBe(3);
      mockTasks[2]();
      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);});


    it('throws if the same task is executed more than once', function () {
      var mockFunction = jest.genMockFunction();
      taskQueue.enqueue(mockFunction);
      jest.runAllTimers();
      mockTasks[0]();
      expect(function () {
        mockTasks[0]();}).
      toFailInvariant(
      'RelayTaskQueue: Tasks can only be executed once.');});



    it('preserves execution order despite scheduler changes', function () {
      var mockOrdering = [];
      // This task is enqueued with a scheduler that defers the work
      taskQueue.injectScheduler(require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/resolveImmediate'));
      taskQueue.enqueue(function () {return mockOrdering.push('foo');});
      // This task is enqueued with no scheduler
      taskQueue.injectScheduler(undefined);
      taskQueue.enqueue(function () {return mockOrdering.push('bar');});
      jest.runAllTimers();
      // Make sure the work units get done in order
      expect(mockOrdering).toEqual(['foo', 'bar']);});});});