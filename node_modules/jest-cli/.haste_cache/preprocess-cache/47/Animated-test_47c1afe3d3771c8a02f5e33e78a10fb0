'use strict';









jest.
autoMockOff().
setMock('Text',{}).
setMock('View',{}).
setMock('Image',{}).
setMock('React',{Component:function Component(){babelHelpers.classCallCheck(this,Component);}});



describe('Animated',function(){

it('works end to end',function(){
var anim=new (require('Animated').Value)(0);

var callback=jest.genMockFunction();

var node=new (require('Animated').__PropsOnlyForTests)({
style:{
backgroundColor:'red',
opacity:anim,
transform:[
{translateX:anim.interpolate({
inputRange:[0,1],
outputRange:[100,200]})},

{scale:anim}]}},


callback);

expect(anim.__getChildren().length).toBe(3);

expect(node.__getValue()).toEqual({
style:{
backgroundColor:'red',
opacity:0,
transform:[
{translateX:100},
{scale:0}]}});




anim.setValue(0.5);

expect(callback).toBeCalled();

expect(node.__getValue()).toEqual({
style:{
backgroundColor:'red',
opacity:0.5,
transform:[
{translateX:150},
{scale:0.5}]}});




node.__detach();
expect(anim.__getChildren().length).toBe(0);

anim.setValue(1);
expect(callback.mock.calls.length).toBe(1);});


it('does not detach on updates',function(){
var anim=new (require('Animated').Value)(0);
anim.__detach=jest.genMockFunction();

var c=new (require('Animated').View)();
c.props={
style:{
opacity:anim}};


c.componentWillMount();

expect(anim.__detach).not.toBeCalled();
c.componentWillReceiveProps({
style:{
opacity:anim}});


expect(anim.__detach).not.toBeCalled();

c.componentWillUnmount();
expect(anim.__detach).toBeCalled();});



it('stops animation when detached',function(){

if(!window.cancelAnimationFrame){
window.cancelAnimationFrame=jest.genMockFunction();}


var anim=new (require('Animated').Value)(0);
var callback=jest.genMockFunction();

var c=new (require('Animated').View)();
c.props={
style:{
opacity:anim}};


c.componentWillMount();

require('Animated').timing(anim,{toValue:10,duration:1000}).start(callback);

c.componentWillUnmount();

expect(callback).toBeCalledWith({finished:false});
expect(callback).toBeCalledWith({finished:false});});


it('triggers callback when spring is at rest',function(){
var anim=new (require('Animated').Value)(0);
var callback=jest.genMockFunction();
require('Animated').spring(anim,{toValue:0,velocity:0}).start(callback);
expect(callback).toBeCalled();});


it('send toValue when a spring stops',function(){
var anim=new (require('Animated').Value)(0);
var listener=jest.genMockFunction();
anim.addListener(listener);
require('Animated').spring(anim,{toValue:15}).start();
jest.runAllTimers();
var lastValue=listener.mock.calls[listener.mock.calls.length-2][0].value;
expect(lastValue).not.toBe(15);
expect(lastValue).toBeCloseTo(15);
expect(anim.__getValue()).toBe(15);});});





describe('Animated Sequence',function(){

it('works with an empty sequence',function(){
var cb=jest.genMockFunction();
require('Animated').sequence([]).start(cb);
expect(cb).toBeCalledWith({finished:true});});


it('sequences well',function(){
var anim1={start:jest.genMockFunction()};
var anim2={start:jest.genMockFunction()};
var cb=jest.genMockFunction();

var seq=require('Animated').sequence([anim1,anim2]);

expect(anim1.start).not.toBeCalled();
expect(anim2.start).not.toBeCalled();

seq.start(cb);

expect(anim1.start).toBeCalled();
expect(anim2.start).not.toBeCalled();
expect(cb).not.toBeCalled();

anim1.start.mock.calls[0][0]({finished:true});

expect(anim2.start).toBeCalled();
expect(cb).not.toBeCalled();

anim2.start.mock.calls[0][0]({finished:true});
expect(cb).toBeCalledWith({finished:true});});


it('supports interrupting sequence',function(){
var anim1={start:jest.genMockFunction()};
var anim2={start:jest.genMockFunction()};
var cb=jest.genMockFunction();

require('Animated').sequence([anim1,anim2]).start(cb);

anim1.start.mock.calls[0][0]({finished:false});

expect(anim1.start).toBeCalled();
expect(anim2.start).not.toBeCalled();
expect(cb).toBeCalledWith({finished:false});});


it('supports stopping sequence',function(){
var anim1={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var anim2={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var cb=jest.genMockFunction();

var seq=require('Animated').sequence([anim1,anim2]);
seq.start(cb);
seq.stop();

expect(anim1.stop).toBeCalled();
expect(anim2.stop).not.toBeCalled();
expect(cb).not.toBeCalled();

anim1.start.mock.calls[0][0]({finished:false});

expect(cb).toBeCalledWith({finished:false});});});




describe('Animated Parallel',function(){

it('works with an empty parallel',function(){
var cb=jest.genMockFunction();
require('Animated').parallel([]).start(cb);
expect(cb).toBeCalledWith({finished:true});});


it('works with an empty element in array',function(){
var anim1={start:jest.genMockFunction()};
var cb=jest.genMockFunction();
require('Animated').parallel([null,anim1]).start(cb);

expect(anim1.start).toBeCalled();
anim1.start.mock.calls[0][0]({finished:true});

expect(cb).toBeCalledWith({finished:true});});


it('parellelizes well',function(){
var anim1={start:jest.genMockFunction()};
var anim2={start:jest.genMockFunction()};
var cb=jest.genMockFunction();

var par=require('Animated').parallel([anim1,anim2]);

expect(anim1.start).not.toBeCalled();
expect(anim2.start).not.toBeCalled();

par.start(cb);

expect(anim1.start).toBeCalled();
expect(anim2.start).toBeCalled();
expect(cb).not.toBeCalled();

anim1.start.mock.calls[0][0]({finished:true});
expect(cb).not.toBeCalled();

anim2.start.mock.calls[0][0]({finished:true});
expect(cb).toBeCalledWith({finished:true});});


it('supports stopping parallel',function(){
var anim1={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var anim2={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var cb=jest.genMockFunction();

var seq=require('Animated').parallel([anim1,anim2]);
seq.start(cb);
seq.stop();

expect(anim1.stop).toBeCalled();
expect(anim2.stop).toBeCalled();
expect(cb).not.toBeCalled();

anim1.start.mock.calls[0][0]({finished:false});
expect(cb).not.toBeCalled();

anim2.start.mock.calls[0][0]({finished:false});
expect(cb).toBeCalledWith({finished:false});});



it('does not call stop more than once when stopping',function(){
var anim1={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var anim2={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var anim3={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var cb=jest.genMockFunction();

var seq=require('Animated').parallel([anim1,anim2,anim3]);
seq.start(cb);

anim1.start.mock.calls[0][0]({finished:false});

expect(anim1.stop.mock.calls.length).toBe(0);
expect(anim2.stop.mock.calls.length).toBe(1);
expect(anim3.stop.mock.calls.length).toBe(1);

anim2.start.mock.calls[0][0]({finished:false});

expect(anim1.stop.mock.calls.length).toBe(0);
expect(anim2.stop.mock.calls.length).toBe(1);
expect(anim3.stop.mock.calls.length).toBe(1);

anim3.start.mock.calls[0][0]({finished:false});

expect(anim1.stop.mock.calls.length).toBe(0);
expect(anim2.stop.mock.calls.length).toBe(1);
expect(anim3.stop.mock.calls.length).toBe(1);});});



describe('Animated delays',function(){
it('should call anim after delay in sequence',function(){
var anim={start:jest.genMockFunction(),stop:jest.genMockFunction()};
var cb=jest.genMockFunction();
require('Animated').sequence([
require('Animated').delay(1000),
anim]).
start(cb);
jest.runAllTimers();
expect(anim.start.mock.calls.length).toBe(1);
expect(cb).not.toBeCalled();
anim.start.mock.calls[0][0]({finished:true});
expect(cb).toBeCalledWith({finished:true});});

it('should run stagger to end',function(){
var cb=jest.genMockFunction();
require('Animated').stagger(1000,[
require('Animated').delay(1000),
require('Animated').delay(1000),
require('Animated').delay(1000)]).
start(cb);
jest.runAllTimers();
expect(cb).toBeCalledWith({finished:true});});});



describe('Animated Events',function(){
it('should map events',function(){
var value=new (require('Animated').Value)(0);
var handler=require('Animated').event(
[null,{state:{foo:value}}]);

handler({bar:'ignoreBar'},{state:{baz:'ignoreBaz',foo:42}});
expect(value.__getValue()).toBe(42);});

it('should call listeners',function(){
var value=new (require('Animated').Value)(0);
var listener=jest.genMockFunction();
var handler=require('Animated').event(
[{foo:value}],
{listener:listener});

handler({foo:42});
expect(value.__getValue()).toBe(42);
expect(listener.mock.calls.length).toBe(1);
expect(listener).toBeCalledWith({foo:42});});});



describe('Animated Interactions',function(){

var Animated;

var InteractionManager;

beforeEach(function(){
jest.mock('InteractionManager');
Animated=require('Animated');
InteractionManager=require('InteractionManager');});


afterEach(function(){
jest.dontMock('InteractionManager');});


it('registers an interaction by default',function(){
InteractionManager.createInteractionHandle.mockReturnValue(777);

var value=new Animated.Value(0);
var callback=jest.genMockFunction();
Animated.timing(value,{
toValue:100,
duration:100}).
start(callback);
jest.runAllTimers();

expect(InteractionManager.createInteractionHandle).toBeCalled();
expect(InteractionManager.clearInteractionHandle).toBeCalledWith(777);
expect(callback).toBeCalledWith({finished:true});});


it('does not register an interaction when specified',function(){
var value=new Animated.Value(0);
var callback=jest.genMockFunction();
Animated.timing(value,{
toValue:100,
duration:100,
isInteraction:false}).
start(callback);
jest.runAllTimers();

expect(InteractionManager.createInteractionHandle).not.toBeCalled();
expect(InteractionManager.clearInteractionHandle).not.toBeCalled();
expect(callback).toBeCalledWith({finished:true});});});



describe('Animated Tracking',function(){
it('should track values',function(){
var value1=new (require('Animated').Value)(0);
var value2=new (require('Animated').Value)(0);
require('Animated').timing(value2,{
toValue:value1,
duration:0}).
start();
value1.setValue(42);
expect(value2.__getValue()).toBe(42);
value1.setValue(7);
expect(value2.__getValue()).toBe(7);});


it('should track interpolated values',function(){
var value1=new (require('Animated').Value)(0);
var value2=new (require('Animated').Value)(0);
require('Animated').timing(value2,{
toValue:value1.interpolate({
inputRange:[0,2],
outputRange:[0,1]}),

duration:0}).
start();
value1.setValue(42);
expect(value2.__getValue()).toBe(42/2);});


it('should stop tracking when animated',function(){
var value1=new (require('Animated').Value)(0);
var value2=new (require('Animated').Value)(0);
require('Animated').timing(value2,{
toValue:value1,
duration:0}).
start();
value1.setValue(42);
expect(value2.__getValue()).toBe(42);
require('Animated').timing(value2,{
toValue:7,
duration:0}).
start();
value1.setValue(1492);
expect(value2.__getValue()).toBe(7);});});



describe('Animated Vectors',function(){
it('should animate vectors',function(){
var vec=new (require('Animated').ValueXY)();

var callback=jest.genMockFunction();

var node=new (require('Animated').__PropsOnlyForTests)({
style:babelHelpers.extends({
opacity:vec.x.interpolate({
inputRange:[0,42],
outputRange:[0.2,0.8]}),

transform:vec.getTranslateTransform()},
vec.getLayout())},

callback);

expect(node.__getValue()).toEqual({
style:{
opacity:0.2,
transform:[
{translateX:0},
{translateY:0}],

left:0,
top:0}});



vec.setValue({x:42,y:1492});

expect(callback.mock.calls.length).toBe(2);

expect(node.__getValue()).toEqual({
style:{
opacity:0.8,
transform:[
{translateX:42},
{translateY:1492}],

left:42,
top:1492}});



node.__detach();

vec.setValue({x:1,y:1});
expect(callback.mock.calls.length).toBe(2);});


it('should track vectors',function(){
var value1=new (require('Animated').ValueXY)();
var value2=new (require('Animated').ValueXY)();
require('Animated').timing(value2,{
toValue:value1,
duration:0}).
start();
value1.setValue({x:42,y:1492});
expect(value2.__getValue()).toEqual({x:42,y:1492});



value1.setValue({x:3,y:4});
expect(value2.__getValue()).toEqual({x:3,y:4});});


it('should track with springs',function(){
var value1=new (require('Animated').ValueXY)();
var value2=new (require('Animated').ValueXY)();
require('Animated').spring(value2,{
toValue:value1,
tension:3000,
friction:60}).
start();
value1.setValue({x:1,y:1});
jest.runAllTimers();
expect(Math.round(value2.__getValue().x)).toEqual(1);
expect(Math.round(value2.__getValue().y)).toEqual(1);
value1.setValue({x:2,y:2});
jest.runAllTimers();
expect(Math.round(value2.__getValue().x)).toEqual(2);
expect(Math.round(value2.__getValue().y)).toEqual(2);});});



describe('Animated Listeners',function(){
it('should get updates',function(){
var value1=new (require('Animated').Value)(0);
var listener=jest.genMockFunction();
var id=value1.addListener(listener);
value1.setValue(42);
expect(listener.mock.calls.length).toBe(1);
expect(listener).toBeCalledWith({value:42});
expect(value1.__getValue()).toBe(42);
value1.setValue(7);
expect(listener.mock.calls.length).toBe(2);
expect(listener).toBeCalledWith({value:7});
expect(value1.__getValue()).toBe(7);
value1.removeListener(id);
value1.setValue(1492);
expect(listener.mock.calls.length).toBe(2);
expect(value1.__getValue()).toBe(1492);});


it('should removeAll',function(){
var value1=new (require('Animated').Value)(0);
var listener=jest.genMockFunction();
[1,2,3,4].forEach(function(){return value1.addListener(listener);});
value1.setValue(42);
expect(listener.mock.calls.length).toBe(4);
expect(listener).toBeCalledWith({value:42});
value1.removeAllListeners();
value1.setValue(7);
expect(listener.mock.calls.length).toBe(4);});});