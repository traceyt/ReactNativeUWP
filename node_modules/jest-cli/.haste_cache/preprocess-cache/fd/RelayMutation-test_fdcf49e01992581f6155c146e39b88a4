/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError('Cannot call a class as a function');}}function _inherits(subClass, superClass) {if (typeof superClass !== 'function' && superClass !== null) {throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;}

require('configureForRelayOSS');

jest.
dontMock('RelayMutation');







describe('RelayMutation', function () {
  var MockMutation = undefined;
  var initialVariables = undefined;
  var mockBarPointer = undefined;
  var mockFooPointer = undefined;
  var mockRoute = undefined;var 

  getNode = require('RelayTestUtils').getNode;var getPointer = require('RelayTestUtils').getPointer;

  beforeEach(function () {
    jest.resetModuleRegistry();

    initialVariables = { isRelative: false };

    var makeMockMutation = function () {var 
      MockMutationClass = (function (_Relay$Mutation) {_inherits(MockMutationClass, _Relay$Mutation);function MockMutationClass() {_classCallCheck(this, MockMutationClass);_Relay$Mutation.apply(this, arguments);}return MockMutationClass;})(require('Relay').Mutation);
      MockMutationClass.fragments = { 
        foo: function () {return (function () {return { children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'relative', value: { kind: 'CallVariable', callVariableName: 'isRelative' } }], fieldName: 'url', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'FsOW8ddCqTx2:0', kind: 'Fragment', metadata: {}, name: 'RelayMutationRelayQL', type: 'Comment' };})();}, 




        bar: function () {return (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'f+YJ4ic+IFF0:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayMutationRelayQL', type: 'Node' };})();} };





      MockMutationClass.initialVariables = initialVariables;
      return MockMutationClass;};

    MockMutation = makeMockMutation();

    var mockFooRequiredFragment = 
    MockMutation.getFragment('foo').getFragment({});
    var mockBarRequiredFragment = 
    MockMutation.getFragment('bar').getFragment({});
    mockFooPointer = getPointer('foo', getNode(mockFooRequiredFragment));
    mockBarPointer = getPointer('bar', getNode(mockBarRequiredFragment));

    // RelayMetaRoute.get(...)
    mockRoute = { name: '$RelayMutation_MockMutationClass' };

    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  it('resolves props', function () {
    /* eslint-disable no-new */
    new MockMutation({ 
      bar: mockBarPointer, 
      foo: mockFooPointer });

    /* eslint-enable no-new */
    var fooFragment = require('RelayQuery').Fragment.create(
    require('buildRQL').Fragment(MockMutation.fragments.foo, initialVariables), 
    mockRoute, 
    initialVariables);

    var barFragment = require('RelayQuery').Fragment.create(
    require('buildRQL').Fragment(MockMutation.fragments.bar, initialVariables), 
    mockRoute, 
    initialVariables);

    expect(require('Relay').Store.read.mock.calls).toEqual([
    [/* fragment */fooFragment, /* dataID */'foo'], 
    [/* fragment */barFragment, /* dataID */'bar']]);});



  it('throws if mutation defines invalid `Relay.QL` fragment', function () {var 
    BadMutation = (function (_Relay$Mutation2) {_inherits(BadMutation, _Relay$Mutation2);function BadMutation() {_classCallCheck(this, BadMutation);_Relay$Mutation2.apply(this, arguments);}return BadMutation;})(require('Relay').Mutation);
    BadMutation.fragments = { 
      foo: function () {return (function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayMutation', type: 'Node' };})();} };

    var badFragmentReference = BadMutation.getFragment('foo');
    expect(function () {
      badFragmentReference.getFragment();}).
    toFailInvariant(
    'Relay.QL defined on mutation `BadMutation` named `foo` is not a valid ' + 
    'fragment. A typical fragment is defined using: ' + 
    'Relay.QL`fragment on Type {...}`');});});