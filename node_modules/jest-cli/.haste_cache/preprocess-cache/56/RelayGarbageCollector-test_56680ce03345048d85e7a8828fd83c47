/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.
dontMock('GraphQLRange').
dontMock('GraphQLSegment').
dontMock('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/performanceNow');









describe('RelayGarbageCollector', function () {var 
  getNode = require('RelayTestUtils').getNode;var 
  HAS_NEXT_PAGE = require('RelayNodeInterface').HAS_NEXT_PAGE;var HAS_PREV_PAGE = require('RelayNodeInterface').HAS_PREV_PAGE;var PAGE_INFO = require('RelayNodeInterface').PAGE_INFO;

  function defaultScheduler(run) {
    // collect everything without pausing
    while (run()) {}}


  function createGC(records, scheduler) {
    scheduler = scheduler || defaultScheduler;

    var storeData = new (require('RelayStoreData'))();
    storeData.initializeGarbageCollector(scheduler);
    var nodeData = storeData.getNodeData();
    if (records) {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/forEachObject')(records, function (data, dataID) {
        nodeData[dataID] = data;});}



    return { 
      garbageCollector: storeData.getGarbageCollector(), 
      storeData: storeData };}



  beforeEach(function () {
    jest.resetModuleRegistry();
    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  describe('collect()', function () {
    it('collects all unreferenced nodes', function () {
      var records = { 
        referenced: { __dataID__: 'referenced' }, 
        unreferenced: { __dataID__: 'unreferenced' } };var _createGC = 

      createGC(records);var garbageCollector = _createGC.garbageCollector;var storeData = _createGC.storeData;
      garbageCollector.register('unreferenced');
      garbageCollector.incrementReferenceCount('unreferenced');
      garbageCollector.decrementReferenceCount('unreferenced');
      garbageCollector.register('referenced');
      garbageCollector.incrementReferenceCount('referenced');
      garbageCollector.collect();
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({ 
        referenced: records.referenced });});});




  describe('collectFromNode()', function () {
    it('collects reachable unreferenced nodes', function () {
      var records = { 
        a: { 
          __dataID__: 'a', 
          field: { __dataID__: 'b' } }, 

        b: { 
          __dataID__: 'b', 
          field: { __dataID__: 'c' } }, 

        c: { 
          __dataID__: 'c' }, 

        unreachable: { 
          __dataID__: 'unreachable' } };var _createGC2 = 


      createGC(records);var garbageCollector = _createGC2.garbageCollector;var storeData = _createGC2.storeData;
      garbageCollector.register('a');
      garbageCollector.register('b');
      garbageCollector.register('c');
      garbageCollector.register('unreachable');

      garbageCollector.collectFromNode('a');
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({ 
        unreachable: { __dataID__: 'unreachable' } });});



    it('skips referenced nodes', function () {
      var records = { 
        a: { 
          __dataID__: 'a', 
          unreferenced: { __dataID__: 'unreferenced' }, 
          referenced: { __dataID__: 'referenced' } }, 

        unreferenced: { 
          __dataID__: 'unreferenced' }, 

        referenced: { 
          __dataID__: 'referenced' } };var _createGC3 = 


      createGC(records);var garbageCollector = _createGC3.garbageCollector;var storeData = _createGC3.storeData;
      garbageCollector.register('a');
      garbageCollector.register('referenced');
      garbageCollector.register('unreferenced');
      garbageCollector.incrementReferenceCount('referenced');

      garbageCollector.collectFromNode('a');
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({ 
        referenced: { __dataID__: 'referenced' } });});



    it('handles deleted/removed nodes', function () {
      var records = { 
        a: { 
          __dataID__: 'a', 
          removed: { __dataID__: 'removed' }, 
          deleted: { __dataID__: 'deleted' }, 
          b: { __dataID__: 'b' } }, 

        deleted: null, 
        b: { 
          __dataID__: 'b' } };var _createGC4 = 


      createGC(records);var garbageCollector = _createGC4.garbageCollector;var storeData = _createGC4.storeData;
      garbageCollector.register('a');
      garbageCollector.register('b');
      garbageCollector.register('deleted');

      garbageCollector.collectFromNode('a');
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({});});


    it('collects connection edges and nodes', function () {var _PAGE_INFO;
      var records = { 
        unreachable: { 
          __dataID__: 'unreachable' } };var _createGC5 = 


      createGC(records);var garbageCollector = _createGC5.garbageCollector;var storeData = _createGC5.storeData;
      var payload = { 
        viewer: { 
          newsFeed: _defineProperty({ 
            edges: [
            { 
              cursor: 'c1', 
              node: { 
                id: 's1', 
                message: { 
                  text: 's1' }, 

                __typename: 'Story' } }] }, 



          PAGE_INFO, (_PAGE_INFO = {}, _defineProperty(_PAGE_INFO, 
          HAS_NEXT_PAGE, true), _defineProperty(_PAGE_INFO, 
          HAS_PREV_PAGE, false), _PAGE_INFO)) } };




      var query = getNode((function () {return { children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ children: [{ fieldName: 'text', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'message', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Text' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, isAbstract: true, isRequisite: true }, type: 'FeedUnit' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'NewsFeedEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'newsFeed', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'NewsFeedConnection' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayGarbageCollector', type: 'Viewer' };})());














      storeData.handleQueryPayload(
      query, 
      require('transformRelayQueryPayload')(query, payload));

      var viewerID = storeData.getRecordStore().getDataID('viewer', null);
      garbageCollector.collectFromNode(viewerID);
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({ 
        unreachable: { __dataID__: 'unreachable' } });});});




  describe('acquireHold()', function () {
    it('collects nodes if no holds are acquired', function () {
      // base case
      var records = { 
        a: { __dataID__: 'a' } };var _createGC6 = 

      createGC(records);var garbageCollector = _createGC6.garbageCollector;var storeData = _createGC6.storeData;
      garbageCollector.register('a');
      garbageCollector.collectFromNode('a');
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({});});


    it('waits to collect until holds are released', function () {
      var records = { 
        a: { __dataID__: 'a' } };var _createGC7 = 

      createGC(records);var garbageCollector = _createGC7.garbageCollector;var storeData = _createGC7.storeData;var _garbageCollector$acquireHold = 
      garbageCollector.acquireHold();var release = _garbageCollector$acquireHold.release;
      garbageCollector.register('a');
      garbageCollector.collectFromNode('a');
      jest.runAllTimers();
      // not collected while hold is active
      expect(storeData.getNodeData()).toEqual(records);
      release();
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual({});});


    it('throws if a hold is released more than once', function () {var _createGC8 = 
      createGC({});var garbageCollector = _createGC8.garbageCollector;var _garbageCollector$acquireHold2 = 
      garbageCollector.acquireHold();var release = _garbageCollector$acquireHold2.release;
      release();
      expect(function () {return release();}).toFailInvariant(
      'RelayGarbageCollector: hold can only be released once.');});



    it('skips collection if a hold is active', function () {
      var records = { 
        a: { __dataID__: 'a' } };

      var run = null;var _createGC9 = 
      createGC(
      records, 
      function (_run) {return run = _run;});var garbageCollector = _createGC9.garbageCollector;var storeData = _createGC9.storeData;

      garbageCollector.register('a');
      garbageCollector.collect();
      jest.runAllTimers();var _garbageCollector$acquireHold3 = 

      garbageCollector.acquireHold();var release = _garbageCollector$acquireHold3.release;
      run();
      // not collected while hold is active
      expect(storeData.getNodeData()).toEqual(records);
      release();
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual(records);
      run();
      expect(storeData.getNodeData()).toEqual({});});});



  describe('scheduling', function () {
    it('does not call scheduler if there is nothing to collect', function () {
      var records = { 
        a: { __dataID__: 'a' } };

      var scheduler = jest.genMockFunction();var _createGC10 = 
      createGC(records, scheduler);var garbageCollector = _createGC10.garbageCollector;
      garbageCollector.register('a');
      garbageCollector.incrementReferenceCount('a');
      garbageCollector.collectFromNode('a');
      expect(scheduler).not.toBeCalled();});


    it('does not call scheduler if no collections are enqueued', function () {
      var records = { 
        a: { __dataID__: 'a' } };

      var scheduler = jest.genMockFunction();var _createGC11 = 
      createGC(records, scheduler);var garbageCollector = _createGC11.garbageCollector;
      garbageCollector.register('a');var _garbageCollector$acquireHold4 = 

      garbageCollector.acquireHold();var release = _garbageCollector$acquireHold4.release;
      release();
      expect(scheduler).not.toBeCalled();});


    it('calls the injected scheduler and collects one record at a time', function () {
      var records = { 
        a: { 
          __dataID__: 'a', 
          field: { __dataID__: 'b' } }, 

        b: { 
          __dataID__: 'b', 
          field: { __dataID__: 'c' } }, 

        c: { 
          __dataID__: 'c', 
          field: { __dataID__: 'd' } }, 

        d: { 
          __dataID__: 'd' } };


      var run = null;var _createGC12 = 
      createGC(
      records, 
      function (_run) {return run = _run;});var garbageCollector = _createGC12.garbageCollector;var storeData = _createGC12.storeData;

      garbageCollector.register('a');
      garbageCollector.register('b');
      garbageCollector.register('c');
      garbageCollector.register('d');

      garbageCollector.collectFromNode('a', 1);
      jest.runAllTimers();
      expect(storeData.getNodeData()).toEqual(records);
      expect(run()).toBe(true);
      expect(storeData.getNodeData()).toEqual({ 
        b: records.b, 
        c: records.c, 
        d: records.d });

      expect(run()).toBe(true);
      expect(storeData.getNodeData()).toEqual({ 
        c: records.c, 
        d: records.d });

      expect(run()).toBe(true);
      expect(storeData.getNodeData()).toEqual({ 
        d: records.d });

      expect(run()).toBe(false);
      expect(storeData.getNodeData()).toEqual({});});


    it('does not overlap collections', function () {
      var records = { 
        a: { __dataID__: 'a' }, 
        b: { __dataID__: 'b' } };

      var run = null;
      var scheduler = jest.genMockFunction().mockImplementation(
      function (_run) {return run = _run;});var _createGC13 = 

      createGC(records, scheduler);var garbageCollector = _createGC13.garbageCollector;
      garbageCollector.register('a');
      garbageCollector.register('b');
      garbageCollector.collectFromNode('a');
      garbageCollector.collectFromNode('a');
      jest.runAllTimers();
      expect(scheduler.mock.calls.length).toBe(1);
      run();
      run(); // 'a' is enqueued twice
      scheduler.mockClear();
      garbageCollector.collectFromNode('b');
      jest.runAllTimers();
      jest.runAllTimers();
      expect(scheduler.mock.calls.length).toBe(1);});});});