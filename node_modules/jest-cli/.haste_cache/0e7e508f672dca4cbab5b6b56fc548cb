{"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-jest-fn.js":{"metadata":{"mtime":1456952568000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', () => {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-jest-fn-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(() => {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('jest.fn', () => {\n    pit('creates mock functions', () => {\n      return buildLoader().then(loader => {\n        const root = loader.requireModule(null, rootPath);\n        const mock = root.jest.fn();\n        expect(mock._isMockFunction).toBe(true);\n        mock();\n        expect(mock).toBeCalled();\n      });\n    });\n\n    pit('creates mock functions with mock implementations', () => {\n      return buildLoader().then(loader => {\n        const root = loader.requireModule(null, rootPath);\n        const mock = root.jest.fn(string => string + ' implementation');\n        expect(mock._isMockFunction).toBe(true);\n        const value = mock('mock');\n        expect(value).toEqual('mock implementation');\n        expect(mock).toBeCalled();\n      });\n    });\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', () => {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-jest-fn-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(() => {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('jest.fn', () => {\n    pit('creates mock functions', () => {\n      return buildLoader().then(loader => {\n        const root = loader.requireModule(null, rootPath);\n        const mock = root.jest.fn();\n        expect(mock._isMockFunction).toBe(true);\n        mock();\n        expect(mock).toBeCalled();\n      });\n    });\n\n    pit('creates mock functions with mock implementations', () => {\n      return buildLoader().then(loader => {\n        const root = loader.requireModule(null, rootPath);\n        const mock = root.jest.fn(string => string + ' implementation');\n        expect(mock._isMockFunction).toBe(true);\n        const value = mock('mock');\n        expect(value).toEqual('mock implementation');\n        expect(mock).toBeCalled();\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-jest-fn.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir2/__mocks__/MyModule.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir2/__mocks__/MyModule.js';\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir2/__mocks__/MyModule.js';\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir2/__mocks__/MyModule.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir1/__mocks__/MyModule.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir1/__mocks__/MyModule.js';\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir1/__mocks__/MyModule.js';\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir1/__mocks__/MyModule.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/__mocks__/ManuallyMocked.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nlet OnlyRequiredFromMock;\ntry {\n  OnlyRequiredFromMock = require.requireActual('OnlyRequiredFromMock');\n} catch (e) {\n  // If the module cannot be loaded, use a dummy value. There is one test\n  // that specifically tests for the correct value which ensures this feature\n  // works. If the feature is broken, it doesn't cause additional log-spew in\n  // surrounding tests.\n  OnlyRequiredFromMock = {value: 'module OnlyRequiredFromMock not found'};\n}\n\nvar moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nexports.onlyRequiredFromMockModuleValue = OnlyRequiredFromMock.value;\nexports.getModuleStateValue = getModuleStateValue;\nexports.isManualMockModule = true;\nexports.setModuleStateValue = setModuleStateValue;\n","dependencies":["OnlyRequiredFromMock"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nlet OnlyRequiredFromMock;\ntry {\n  OnlyRequiredFromMock = require.requireActual('OnlyRequiredFromMock');\n} catch (e) {\n  // If the module cannot be loaded, use a dummy value. There is one test\n  // that specifically tests for the correct value which ensures this feature\n  // works. If the feature is broken, it doesn't cause additional log-spew in\n  // surrounding tests.\n  OnlyRequiredFromMock = {value: 'module OnlyRequiredFromMock not found'};\n}\n\nvar moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nexports.onlyRequiredFromMockModuleValue = OnlyRequiredFromMock.value;\nexports.getModuleStateValue = getModuleStateValue;\nexports.isManualMockModule = true;\nexports.setModuleStateValue = setModuleStateValue;\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/__mocks__/ManuallyMocked.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/__mocks__/ExclusivelyManualMock.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.isExclusivelyManualMockModule = true;\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.isExclusivelyManualMockModule = true;\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/__mocks__/ExclusivelyManualMock.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir1/MyModule.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir1/MyModule.js';\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir1/MyModule.js';\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir1/MyModule.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir2/MyModule.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir2/MyModule.js';\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir2/MyModule.js';\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/subdir2/MyModule.js"}},"/Users/cpojer/Projects/jest/src/__tests__/test_root/__testtests__/test.js":{"metadata":{"mtime":1447743524000},"data":{"isHaste":false,"moduleData":{"code":"// Copyright 2004-present Facebook. All Rights Reserved.\n\n// test.js\n\nrequire('../module.jsx');\n","dependencies":["../module.jsx"],"source":"// Copyright 2004-present Facebook. All Rights Reserved.\n\n// test.js\n\nrequire('../module.jsx');\n"},"name":"/Users/cpojer/Projects/jest/src/__tests__/test_root/__testtests__/test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/NODE_PATH_dir/RegularModuleInNodePath.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nexports.getModuleStateValue = getModuleStateValue;\nexports.isRealModule = true;\nexports.setModuleStateValue = setModuleStateValue;\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nexports.getModuleStateValue = getModuleStateValue;\nexports.isRealModule = true;\nexports.setModuleStateValue = setModuleStateValue;\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/NODE_PATH_dir/RegularModuleInNodePath.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/throwing.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nthrow new Error('throwing');\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nthrow new Error('throwing');\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/throwing.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/throwing-fn.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = function sum() {\n  throw new Error('throwing fn');\n};\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = function sum() {\n  throw new Error('throwing fn');\n};\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/throwing-fn.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/root.js":{"metadata":{"mtime":1456289197000},"data":{"name":"root","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule root\n */\n\n'use strict';\n\nrequire('ManuallyMocked');\nrequire('ModuleWithSideEffects');\nrequire('RegularModule');\nrequire('ExclusivelyManualMock');\n\n// We only care about the static analysis, not about the runtime.\n() => {\n  require('image!not-really-a-module');\n  require('cat.png');\n  require('dog.png');\n};\n\nexports.jest = jest;\n","dependencies":["ManuallyMocked","ModuleWithSideEffects","RegularModule","ExclusivelyManualMock","image!not-really-a-module","cat.png","dog.png"],"id":"root","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule root\n */\n\n'use strict';\n\nrequire('ManuallyMocked');\nrequire('ModuleWithSideEffects');\nrequire('RegularModule');\nrequire('ExclusivelyManualMock');\n\n// We only care about the static analysis, not about the runtime.\n() => {\n  require('image!not-really-a-module');\n  require('cat.png');\n  require('dog.png');\n};\n\nexports.jest = jest;\n"}}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/RelativeImageStub.js":{"metadata":{"mtime":1456289197000},"data":{"name":"RelativeImageStub","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelativeImageStub\n */\n\n'use strict';\n\nexports.isRelativeImageStub = true;\n","dependencies":[],"id":"RelativeImageStub","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelativeImageStub\n */\n\n'use strict';\n\nexports.isRelativeImageStub = true;\n"}}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/RegularModule.js":{"metadata":{"mtime":1456289197000},"data":{"name":"RegularModule","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RegularModule\n */\n\n'use strict';\n\n// For some reason thinks it's a strict violation.\nif (exports !== this) {\n  throw new Error('Invalid module context');\n}\n\nvar moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\n() => {\n  // Make sure ModuleWithSideEffects is part of the module map for\n  // RegularModule.\n  require('ModuleWithSideEffects');\n};\n\nexports.getModuleStateValue = getModuleStateValue;\nexports.isRealModule = true;\nexports.setModuleStateValue = setModuleStateValue;\nexports.parent = module.parent;\nexports.jest = jest;\n","dependencies":["ModuleWithSideEffects"],"id":"RegularModule","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RegularModule\n */\n\n'use strict';\n\n// For some reason thinks it's a strict violation.\nif (exports !== this) {\n  throw new Error('Invalid module context');\n}\n\nvar moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\n() => {\n  // Make sure ModuleWithSideEffects is part of the module map for\n  // RegularModule.\n  require('ModuleWithSideEffects');\n};\n\nexports.getModuleStateValue = getModuleStateValue;\nexports.isRealModule = true;\nexports.setModuleStateValue = setModuleStateValue;\nexports.parent = module.parent;\nexports.jest = jest;\n"}}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/OnlyRequiredFromMock.js":{"metadata":{"mtime":1456289197000},"data":{"name":"OnlyRequiredFromMock","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule OnlyRequiredFromMock\n */\n\n'use strict';\n\nexports.value = 'banana banana banana';\n","dependencies":[],"id":"OnlyRequiredFromMock","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule OnlyRequiredFromMock\n */\n\n'use strict';\n\nexports.value = 'banana banana banana';\n"}}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/ModuleWithSideEffects.js":{"metadata":{"mtime":1456289197000},"data":{"name":"ModuleWithSideEffects","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ModuleWithSideEffects\n */\n\n'use strict';\n\nvar RegularModule = require('RegularModule');\n\nRegularModule.setModuleStateValue('Side effect value');\n\nexports.fn = () => '42';\n","dependencies":["RegularModule"],"id":"ModuleWithSideEffects","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ModuleWithSideEffects\n */\n\n'use strict';\n\nvar RegularModule = require('RegularModule');\n\nRegularModule.setModuleStateValue('Side effect value');\n\nexports.fn = () => '42';\n"}}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/ManuallyMocked.js":{"metadata":{"mtime":1456289197000},"data":{"name":"ManuallyMocked","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ManuallyMocked\n */\n\n'use strict';\n\nexports.isManualMockModule = false;\n","dependencies":["ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked","ManuallyMocked"],"id":"ManuallyMocked","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ManuallyMocked\n */\n\n'use strict';\n\nexports.isManualMockModule = false;\n"}}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/GlobalImageStub.js":{"metadata":{"mtime":1456289197000},"data":{"name":"GlobalImageStub","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GlobalImageStub\n */\n\n'use strict';\n\nexports.isGlobalImageStub = true;\n","dependencies":[],"id":"GlobalImageStub","source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GlobalImageStub\n */\n\n'use strict';\n\nexports.isGlobalImageStub = true;\n"}}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/jasmineTestRunner-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('jasmineTestRunner', function() {\n  describe('custom matchers', function() {\n    it('has toBeCalled', function() {\n      var mockFn = jest.genMockFunction();\n\n      mockFn();\n\n      expect(mockFn).toBeCalled();\n    });\n\n    it('has toBeCalledWith', function() {\n      var mockFn = jest.genMockFunction();\n\n      mockFn('foo', 'bar');\n      expect(mockFn).toBeCalledWith('foo', 'bar');\n\n      mockFn('baz');\n      expect(mockFn).toBeCalledWith('foo', 'bar');\n      expect(mockFn).toBeCalledWith('baz');\n    });\n\n    it('has lastCalledWith', function() {\n      var mockFn = jest.genMockFunction();\n\n      mockFn('foo', 'bar');\n      expect(mockFn).lastCalledWith('foo', 'bar');\n\n      mockFn('another', 'bar');\n      expect(mockFn).lastCalledWith('another', 'bar');\n\n    });\n  });\n});\n","dependencies":[],"source":"/**\n * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('jasmineTestRunner', function() {\n  describe('custom matchers', function() {\n    it('has toBeCalled', function() {\n      var mockFn = jest.genMockFunction();\n\n      mockFn();\n\n      expect(mockFn).toBeCalled();\n    });\n\n    it('has toBeCalledWith', function() {\n      var mockFn = jest.genMockFunction();\n\n      mockFn('foo', 'bar');\n      expect(mockFn).toBeCalledWith('foo', 'bar');\n\n      mockFn('baz');\n      expect(mockFn).toBeCalledWith('foo', 'bar');\n      expect(mockFn).toBeCalledWith('baz');\n    });\n\n    it('has lastCalledWith', function() {\n      var mockFn = jest.genMockFunction();\n\n      mockFn('foo', 'bar');\n      expect(mockFn).lastCalledWith('foo', 'bar');\n\n      mockFn('another', 'bar');\n      expect(mockFn).lastCalledWith('another', 'bar');\n\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/jasmineTestRunner-test.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/JasmineReporter-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('JasmineReporter', function() {\n  // modules\n  var JasmineReporter;\n  var chalk;\n\n  // other variables\n  var reporter;\n\n  beforeEach(function() {\n    JasmineReporter = require('../JasmineReporter');\n    chalk = require('chalk');\n\n    reporter = new JasmineReporter();\n  });\n\n  describe('colorization', function() {\n    function getRunner(item) {\n      return {\n        suites: function() {\n          return [\n            {\n              parentSuite: null,\n              specs: function() {\n                return [\n                  {\n                    results: function() {\n                      return {\n                        getItems: function() {\n                          return [item];\n                        },\n                      };\n                    },\n                  },\n                ];\n              },\n              suites: function() { return []; },\n            },\n          ];\n        },\n      };\n    }\n\n    function getExpectedRunner(actualResult, expectedResult, passed) {\n      return getRunner({\n        actual: actualResult,\n        expected: expectedResult,\n        message: '',\n        isNot: false,\n        matcherName: 'toBe',\n        passed: function() { return passed; },\n        trace: {},\n        type: 'expect',\n      });\n    }\n\n    function getExceptionRunner(message, passed) {\n      return getRunner({\n        passed: function() { return passed; },\n        trace: {\n          stack: message,\n        },\n        type: 'expect',\n      });\n    }\n\n    function errorize(str) {\n      return chalk.bold.underline.red(str);\n    }\n\n    function highlight(str) {\n      return chalk.bgRed(str);\n    }\n\n    pit('colorizes single-line failures using a per-char diff', function() {\n      var runner = getExpectedRunner('foo', 'foobar', false);\n      reporter.reportRunnerResults(runner);\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\' ' +\n          errorize('toBe:') + ' \\'foo' + highlight('bar') + '\\''\n        );\n      });\n    });\n\n    pit('colorizes multi-line failures using a per-line diff', function() {\n      var runner = getExpectedRunner('foo\\nbar\\nbaz', 'foo\\nxxx\\nbaz', false);\n      reporter.reportRunnerResults(runner);\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\n' + highlight('bar\\n') + 'baz\\' ' +\n          errorize('toBe:') + ' \\'foo\\n' + highlight('xxx\\n') + 'baz\\''\n        );\n      });\n    });\n\n    pit('colorizes exception messages', function() {\n      var runner = getExceptionRunner(\n        'Error: foobar = {\\n' +\n        '      attention: \"bar\"\\n' +\n        '    }\\n' +\n        '    at Error (<anonymous>)\\n' +\n        '    at Baz.js (<anonymous>)',\n        false\n      );\n      reporter.reportRunnerResults(runner);\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize(\n            'Error: foobar = {\\n' +\n            '      attention: \"bar\"\\n' +\n            '    }'\n          ) + '\\n    at Error (<anonymous>)\\n' +\n          '    at Baz.js (<anonymous>)'\n        );\n      });\n    });\n  });\n});\n","dependencies":["../JasmineReporter","chalk"],"source":"/**\n * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('JasmineReporter', function() {\n  // modules\n  var JasmineReporter;\n  var chalk;\n\n  // other variables\n  var reporter;\n\n  beforeEach(function() {\n    JasmineReporter = require('../JasmineReporter');\n    chalk = require('chalk');\n\n    reporter = new JasmineReporter();\n  });\n\n  describe('colorization', function() {\n    function getRunner(item) {\n      return {\n        suites: function() {\n          return [\n            {\n              parentSuite: null,\n              specs: function() {\n                return [\n                  {\n                    results: function() {\n                      return {\n                        getItems: function() {\n                          return [item];\n                        },\n                      };\n                    },\n                  },\n                ];\n              },\n              suites: function() { return []; },\n            },\n          ];\n        },\n      };\n    }\n\n    function getExpectedRunner(actualResult, expectedResult, passed) {\n      return getRunner({\n        actual: actualResult,\n        expected: expectedResult,\n        message: '',\n        isNot: false,\n        matcherName: 'toBe',\n        passed: function() { return passed; },\n        trace: {},\n        type: 'expect',\n      });\n    }\n\n    function getExceptionRunner(message, passed) {\n      return getRunner({\n        passed: function() { return passed; },\n        trace: {\n          stack: message,\n        },\n        type: 'expect',\n      });\n    }\n\n    function errorize(str) {\n      return chalk.bold.underline.red(str);\n    }\n\n    function highlight(str) {\n      return chalk.bgRed(str);\n    }\n\n    pit('colorizes single-line failures using a per-char diff', function() {\n      var runner = getExpectedRunner('foo', 'foobar', false);\n      reporter.reportRunnerResults(runner);\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\' ' +\n          errorize('toBe:') + ' \\'foo' + highlight('bar') + '\\''\n        );\n      });\n    });\n\n    pit('colorizes multi-line failures using a per-line diff', function() {\n      var runner = getExpectedRunner('foo\\nbar\\nbaz', 'foo\\nxxx\\nbaz', false);\n      reporter.reportRunnerResults(runner);\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\n' + highlight('bar\\n') + 'baz\\' ' +\n          errorize('toBe:') + ' \\'foo\\n' + highlight('xxx\\n') + 'baz\\''\n        );\n      });\n    });\n\n    pit('colorizes exception messages', function() {\n      var runner = getExceptionRunner(\n        'Error: foobar = {\\n' +\n        '      attention: \"bar\"\\n' +\n        '    }\\n' +\n        '    at Error (<anonymous>)\\n' +\n        '    at Baz.js (<anonymous>)',\n        false\n      );\n      reporter.reportRunnerResults(runner);\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize(\n            'Error: foobar = {\\n' +\n            '      attention: \"bar\"\\n' +\n            '    }'\n          ) + '\\n    at Error (<anonymous>)\\n' +\n          '    at Baz.js (<anonymous>)'\n        );\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/JasmineReporter-test.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/JasmineFormatter-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst VENDOR_PATH = path.resolve(__dirname, '../../../../vendor');\n\nconst jasmine = require(`${VENDOR_PATH}/jasmine/jasmine-1.3.0`).jasmine;\nconst jasmine2Require = require(`${VENDOR_PATH}/jasmine/jasmine-2.3.4.js`);\nconst jasmine2 = jasmine2Require.core(jasmine2Require);\n\nconst JasmineFormatter = require('../JasmineFormatter');\n\nconst jsdom = require('jsdom').jsdom;\nconst fixture = '<html><body id=\"foo\"></body></html>';\n\nlet formatter;\n\ndescribe('JasmineFormatter', () => {\n  describe('pretty printer', () => {\n    it('should handle JSDOM nodes with Jasmine 1.x', () => {\n      formatter = new JasmineFormatter(jasmine);\n\n      expect(() => formatter.prettyPrint(jsdom(fixture).body)).not.toThrow();\n    });\n\n    it('should handle JSDOM nodes with Jasmine 2.x', () => {\n      formatter = new JasmineFormatter(jasmine2);\n\n      expect(() => formatter.prettyPrint(jsdom(fixture).body)).not.toThrow();\n    });\n  });\n});\n","dependencies":["path","../JasmineFormatter","jsdom"],"source":"/**\n * Copyright (c) 2016-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst VENDOR_PATH = path.resolve(__dirname, '../../../../vendor');\n\nconst jasmine = require(`${VENDOR_PATH}/jasmine/jasmine-1.3.0`).jasmine;\nconst jasmine2Require = require(`${VENDOR_PATH}/jasmine/jasmine-2.3.4.js`);\nconst jasmine2 = jasmine2Require.core(jasmine2Require);\n\nconst JasmineFormatter = require('../JasmineFormatter');\n\nconst jsdom = require('jsdom').jsdom;\nconst fixture = '<html><body id=\"foo\"></body></html>';\n\nlet formatter;\n\ndescribe('JasmineFormatter', () => {\n  describe('pretty printer', () => {\n    it('should handle JSDOM nodes with Jasmine 1.x', () => {\n      formatter = new JasmineFormatter(jasmine);\n\n      expect(() => formatter.prettyPrint(jsdom(fixture).body)).not.toThrow();\n    });\n\n    it('should handle JSDOM nodes with Jasmine 2.x', () => {\n      formatter = new JasmineFormatter(jasmine2);\n\n      expect(() => formatter.prettyPrint(jsdom(fixture).body)).not.toThrow();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/JasmineFormatter-test.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/Jasmine2Reporter-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('Jasmine2Reporter', function() {\n  var JasmineReporter;\n  var chalk;\n  var reporter;\n\n  beforeEach(function() {\n    JasmineReporter = require('../Jasmine2Reporter');\n    chalk = require('chalk');\n\n    reporter = new JasmineReporter();\n  });\n\n  describe('suites', function() {\n\n    pit('reports nested suites', function() {\n      var makeSpec = function(name) {\n        return {\n          fullName: name,\n          description: 'description',\n          failedExpectations: [],\n        };\n      };\n      reporter.suiteStarted({description: 'parent'});\n      reporter.suiteStarted({description: 'child'});\n      reporter.specDone(makeSpec('spec 1'));\n      reporter.suiteDone();\n      reporter.suiteStarted({description: 'child 2'});\n      reporter.specDone(makeSpec('spec 2'));\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(runResults) {\n\n        var firstResult = runResults.testResults[0];\n        expect(firstResult.ancestorTitles[0]).toBe('parent');\n        expect(firstResult.ancestorTitles[1]).toBe('child');\n        var secondResult = runResults.testResults[1];\n        expect(secondResult.ancestorTitles[1]).toBe('child 2');\n\n      });\n    });\n\n  });\n\n  describe('colorization', function() {\n\n    function getFailedResult(actualResult, expectedResult) {\n      var desc = 'comparing ' + actualResult + ' to ' + expectedResult;\n      return {\n        fullName: desc,\n        description: desc,\n        failedExpectations: [\n          {\n            actual: actualResult,\n            expected: expectedResult,\n            matcherName: 'toBe',\n            passed: false,\n          },\n        ],\n      };\n    }\n\n    function getExceptionResult(stack) {\n      return {\n        fullName: '',\n        description: '',\n        failedExpectations: [\n          {\n            matcherName: '',\n            stack: stack,\n            passed: false,\n          },\n        ],\n      };\n    }\n\n    function errorize(str) {\n      return chalk.bold.underline.red(str);\n    }\n\n    function highlight(str) {\n      return chalk.bgRed(str);\n    }\n\n    pit('colorizes single-line failures using a per-char diff', function() {\n      var result = getFailedResult('foo', 'foobar');\n      reporter.specDone(result);\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\' ' +\n          errorize('toBe:') + ' \\'foo' + highlight('bar') + '\\''\n        );\n      });\n    });\n\n    pit('colorizes multi-line failures using a per-line diff', function() {\n      var result = getFailedResult('foo\\nbar\\nbaz', 'foo\\nxxx\\nbaz');\n      reporter.specDone(result);\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\n' + highlight('bar\\n') + 'baz\\' ' +\n          errorize('toBe:') + ' \\'foo\\n' + highlight('xxx\\n') + 'baz\\''\n        );\n      });\n    });\n\n    pit('colorizes exception messages', function() {\n      var result = getExceptionResult(\n        'Error: foobar = {\\n' +\n        '      attention: \"bar\"\\n' +\n        '    }\\n' +\n        '    at Error (<anonymous>)\\n' +\n        '    at Baz.js (<anonymous>)'\n      );\n      reporter.specDone(result);\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize(\n            'Error: foobar = {\\n' +\n            '      attention: \"bar\"\\n' +\n            '    }'\n          ) + '\\n    at Error (<anonymous>)\\n' +\n          '    at Baz.js (<anonymous>)'\n        );\n      });\n\n    });\n\n  });\n});\n","dependencies":["../Jasmine2Reporter","chalk"],"source":"/**\n * Copyright (c) 2015-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('Jasmine2Reporter', function() {\n  var JasmineReporter;\n  var chalk;\n  var reporter;\n\n  beforeEach(function() {\n    JasmineReporter = require('../Jasmine2Reporter');\n    chalk = require('chalk');\n\n    reporter = new JasmineReporter();\n  });\n\n  describe('suites', function() {\n\n    pit('reports nested suites', function() {\n      var makeSpec = function(name) {\n        return {\n          fullName: name,\n          description: 'description',\n          failedExpectations: [],\n        };\n      };\n      reporter.suiteStarted({description: 'parent'});\n      reporter.suiteStarted({description: 'child'});\n      reporter.specDone(makeSpec('spec 1'));\n      reporter.suiteDone();\n      reporter.suiteStarted({description: 'child 2'});\n      reporter.specDone(makeSpec('spec 2'));\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(runResults) {\n\n        var firstResult = runResults.testResults[0];\n        expect(firstResult.ancestorTitles[0]).toBe('parent');\n        expect(firstResult.ancestorTitles[1]).toBe('child');\n        var secondResult = runResults.testResults[1];\n        expect(secondResult.ancestorTitles[1]).toBe('child 2');\n\n      });\n    });\n\n  });\n\n  describe('colorization', function() {\n\n    function getFailedResult(actualResult, expectedResult) {\n      var desc = 'comparing ' + actualResult + ' to ' + expectedResult;\n      return {\n        fullName: desc,\n        description: desc,\n        failedExpectations: [\n          {\n            actual: actualResult,\n            expected: expectedResult,\n            matcherName: 'toBe',\n            passed: false,\n          },\n        ],\n      };\n    }\n\n    function getExceptionResult(stack) {\n      return {\n        fullName: '',\n        description: '',\n        failedExpectations: [\n          {\n            matcherName: '',\n            stack: stack,\n            passed: false,\n          },\n        ],\n      };\n    }\n\n    function errorize(str) {\n      return chalk.bold.underline.red(str);\n    }\n\n    function highlight(str) {\n      return chalk.bgRed(str);\n    }\n\n    pit('colorizes single-line failures using a per-char diff', function() {\n      var result = getFailedResult('foo', 'foobar');\n      reporter.specDone(result);\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\' ' +\n          errorize('toBe:') + ' \\'foo' + highlight('bar') + '\\''\n        );\n      });\n    });\n\n    pit('colorizes multi-line failures using a per-line diff', function() {\n      var result = getFailedResult('foo\\nbar\\nbaz', 'foo\\nxxx\\nbaz');\n      reporter.specDone(result);\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize('Expected:') + ' \\'foo\\n' + highlight('bar\\n') + 'baz\\' ' +\n          errorize('toBe:') + ' \\'foo\\n' + highlight('xxx\\n') + 'baz\\''\n        );\n      });\n    });\n\n    pit('colorizes exception messages', function() {\n      var result = getExceptionResult(\n        'Error: foobar = {\\n' +\n        '      attention: \"bar\"\\n' +\n        '    }\\n' +\n        '    at Error (<anonymous>)\\n' +\n        '    at Baz.js (<anonymous>)'\n      );\n      reporter.specDone(result);\n      reporter.jasmineDone();\n\n      return reporter.getResults().then(function(result) {\n        var message = result.testResults[0].failureMessages[0];\n        expect(message).toBe(\n          errorize(\n            'Error: foobar = {\\n' +\n            '      attention: \"bar\"\\n' +\n            '    }'\n          ) + '\\n    at Error (<anonymous>)\\n' +\n          '    at Baz.js (<anonymous>)'\n        );\n      });\n\n    });\n\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/__tests__/Jasmine2Reporter-test.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/JasmineReporter.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst jasmine = require('../../../vendor/jasmine/jasmine-1.3.0').jasmine;\nconst JasmineFormatter = require('./JasmineFormatter');\n\nclass JasmineReporter extends jasmine.Reporter {\n\n  constructor(config) {\n    super();\n    this._formatter = new JasmineFormatter(jasmine, config);\n    this._config = config || {};\n    this._resolve = null;\n    this._resultsPromise = new Promise(resolve => this._resolve = resolve);\n  }\n\n  reportRunnerResults(runner) {\n    const testResults = [];\n    // Find the top-level suite in order to flatten test results from there\n    if (runner.suites().length) {\n      runner.suites().forEach(suite => {\n        if (suite.parentSuite === null) {\n          this._extractSuiteResults(testResults, [], suite);\n        }\n      });\n    }\n    let numFailingTests = 0;\n    let numPassingTests = 0;\n    testResults.forEach(testResult => {\n      if (testResult.failureMessages.length > 0) {\n        numFailingTests++;\n      } else {\n        numPassingTests++;\n      }\n    });\n    this._resolve({numFailingTests, numPassingTests, testResults});\n  }\n\n  getResults() {\n    return this._resultsPromise;\n  }\n\n  _extractSuiteResults(container, ancestorTitles, suite) {\n    ancestorTitles = ancestorTitles.concat([suite.description]);\n    suite.specs().forEach(\n      this._extractSpecResults.bind(this, container, ancestorTitles)\n    );\n    suite.suites().forEach(\n      this._extractSuiteResults.bind(this, container, ancestorTitles)\n    );\n  }\n\n  _extractSpecResults(container, ancestorTitles, spec) {\n    const results = {\n      title: 'it ' + spec.description,\n      ancestorTitles: ancestorTitles,\n      failureMessages: [],\n      numPassingAsserts: 0,\n    };\n\n    spec.results().getItems().forEach(result => {\n      switch (result.type) {\n        case 'expect':\n          if (result.passed()) {\n            results.numPassingAsserts++;\n          } else if (!result.matcherName && result.trace.stack) {\n            results.failureMessages.push(\n              this._formatter.formatException(result.trace.stack)\n            );\n          } else {\n            results.failureMessages.push(\n              this._formatter.formatMatchFailure(result)\n            );\n          }\n          break;\n        default:\n          throw new Error('Unexpected jasmine spec result type: ', result.type);\n      }\n    });\n\n    container.push(results);\n  }\n}\n\nmodule.exports = JasmineReporter;\n","dependencies":["../../../vendor/jasmine/jasmine-1.3.0","./JasmineFormatter"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst jasmine = require('../../../vendor/jasmine/jasmine-1.3.0').jasmine;\nconst JasmineFormatter = require('./JasmineFormatter');\n\nclass JasmineReporter extends jasmine.Reporter {\n\n  constructor(config) {\n    super();\n    this._formatter = new JasmineFormatter(jasmine, config);\n    this._config = config || {};\n    this._resolve = null;\n    this._resultsPromise = new Promise(resolve => this._resolve = resolve);\n  }\n\n  reportRunnerResults(runner) {\n    const testResults = [];\n    // Find the top-level suite in order to flatten test results from there\n    if (runner.suites().length) {\n      runner.suites().forEach(suite => {\n        if (suite.parentSuite === null) {\n          this._extractSuiteResults(testResults, [], suite);\n        }\n      });\n    }\n    let numFailingTests = 0;\n    let numPassingTests = 0;\n    testResults.forEach(testResult => {\n      if (testResult.failureMessages.length > 0) {\n        numFailingTests++;\n      } else {\n        numPassingTests++;\n      }\n    });\n    this._resolve({numFailingTests, numPassingTests, testResults});\n  }\n\n  getResults() {\n    return this._resultsPromise;\n  }\n\n  _extractSuiteResults(container, ancestorTitles, suite) {\n    ancestorTitles = ancestorTitles.concat([suite.description]);\n    suite.specs().forEach(\n      this._extractSpecResults.bind(this, container, ancestorTitles)\n    );\n    suite.suites().forEach(\n      this._extractSuiteResults.bind(this, container, ancestorTitles)\n    );\n  }\n\n  _extractSpecResults(container, ancestorTitles, spec) {\n    const results = {\n      title: 'it ' + spec.description,\n      ancestorTitles: ancestorTitles,\n      failureMessages: [],\n      numPassingAsserts: 0,\n    };\n\n    spec.results().getItems().forEach(result => {\n      switch (result.type) {\n        case 'expect':\n          if (result.passed()) {\n            results.numPassingAsserts++;\n          } else if (!result.matcherName && result.trace.stack) {\n            results.failureMessages.push(\n              this._formatter.formatException(result.trace.stack)\n            );\n          } else {\n            results.failureMessages.push(\n              this._formatter.formatMatchFailure(result)\n            );\n          }\n          break;\n        default:\n          throw new Error('Unexpected jasmine spec result type: ', result.type);\n      }\n    });\n\n    container.push(results);\n  }\n}\n\nmodule.exports = JasmineReporter;\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/JasmineReporter.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/JasmineFormatter.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst diff = require('diff');\nconst chalk = require('chalk');\nconst utils = require('../../lib/utils');\n\nconst ERROR_TITLE_COLOR = chalk.bold.underline.red;\nconst DIFFABLE_MATCHERS = Object.assign(Object.create(null), {\n  toBe: true,\n  toNotBe: true,\n  toEqual: true,\n  toNotEqual: true,\n});\n\nconst LINEBREAK_REGEX = /[\\r\\n]/;\n\nclass JasmineFormatter {\n\n  constructor(jasmine, config) {\n    this._config = config;\n    this._jasmine = jasmine;\n  }\n\n  formatDiffable(matcherName, isNot, actual, expected) {\n    const ppActual = this.prettyPrint(actual);\n    const ppExpected = this.prettyPrint(expected);\n    const colorDiff = this.highlightDifferences(ppActual, ppExpected);\n    matcherName = (isNot ? 'NOT ' : '') + matcherName;\n\n    return (\n      ERROR_TITLE_COLOR('Expected:') + ' ' + colorDiff.a + ' ' +\n      ERROR_TITLE_COLOR(matcherName + ':') + ' ' + colorDiff.b\n    );\n  }\n\n  formatMatchFailure(result) {\n    let message;\n    if (DIFFABLE_MATCHERS[result.matcherName]) {\n      const isNot =\n        'isNot' in result ? result.isNot : /not to /.test(result.message);\n      message = this.formatDiffable(\n        result.matcherName,\n        isNot,\n        result.actual,\n        result.expected\n      );\n    } else {\n      message = ERROR_TITLE_COLOR(result.message);\n    }\n\n    // error message & stack live on 'trace' field in jasmine 1.3\n    const error = result.trace ? result.trace : result;\n    if (error.stack) {\n      message = this.formatStackTrace(error.stack, error.message, message);\n    }\n    return message;\n  }\n\n\n  formatException(stackTrace) {\n    // jasmine doesn't give us access to the actual Error object, so we\n    // have to regexp out the message from the stack string in order to\n    // colorize the `message` value\n    return utils.cleanStackTrace(stackTrace.replace(\n      /(^(.|\\n)*?(?=\\n\\s*at\\s))/,\n      ERROR_TITLE_COLOR('$1')\n    ));\n  }\n\n  highlightDifferences(a, b) {\n    let differ;\n    if (a.match(LINEBREAK_REGEX) || b.match(LINEBREAK_REGEX)) {\n      // `diff` uses the Myers LCS diff algorithm which runs in O(n+d^2) time\n      // (where \"d\" is the edit distance) and can get very slow for large edit\n      // distances. Mitigate the cost by switching to a lower-resolution diff\n      // whenever linebreaks are involved.\n      differ = diff.diffLines;\n    } else {\n      differ = diff.diffChars;\n    }\n    const changes = differ(a, b);\n    const ret = {a: '', b: ''};\n    for (let i = 0, il = changes.length; i < il; i++) {\n      const change = changes[i];\n      if (change.added) {\n        ret.b += chalk.bgRed(change.value);\n      } else if (change.removed) {\n        ret.a += chalk.bgRed(change.value);\n      } else {\n        ret.a += change.value;\n        ret.b += change.value;\n      }\n    }\n    return ret;\n  }\n\n  prettyPrint(obj, indent, cycleWeakMap) {\n    if (!indent) {\n      indent = '';\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      if (this._jasmine.isDomNode(obj)) {\n        let attrStr = '';\n        Array.prototype.forEach.call(obj.attributes, attr => {\n          const attrName = attr.name.trim();\n          const attrValue = attr.value.trim();\n          attrStr += ' ' + attrName + '=\"' + attrValue + '\"';\n        });\n        return (\n          'HTMLNode(<' + obj.tagName + attrStr + '>{...}</' + obj.tagName + '>)'\n        );\n      }\n\n      if (!cycleWeakMap) {\n        cycleWeakMap = new WeakMap();\n      }\n\n      if (cycleWeakMap.get(obj) === true) {\n        return '<circular reference>';\n      }\n      cycleWeakMap.set(obj, true);\n\n      const orderedKeys = Object.keys(obj).sort();\n      let value;\n      const keysOutput = [];\n      const keyIndent = chalk.gray('|') + ' ';\n      for (let i = 0; i < orderedKeys.length; i++) {\n        value = obj[orderedKeys[i]];\n        keysOutput.push(\n          indent + keyIndent + orderedKeys[i] + ': ' +\n          this.prettyPrint(value, indent + keyIndent, cycleWeakMap)\n        );\n      }\n      return '{\\n' + keysOutput.join(',\\n') + '\\n' + indent + '}';\n    } else {\n      return this._jasmine.pp(obj);\n    }\n  }\n\n  formatStackTrace(stackTrace, originalMessage, formattedMessage) {\n    return utils.cleanStackTrace(\n      stackTrace\n        .replace(originalMessage, formattedMessage)\n        .replace(/^.*Error:\\s*/, '')\n    );\n  }\n}\n\nmodule.exports = JasmineFormatter;\n","dependencies":["diff","chalk","../../lib/utils"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst diff = require('diff');\nconst chalk = require('chalk');\nconst utils = require('../../lib/utils');\n\nconst ERROR_TITLE_COLOR = chalk.bold.underline.red;\nconst DIFFABLE_MATCHERS = Object.assign(Object.create(null), {\n  toBe: true,\n  toNotBe: true,\n  toEqual: true,\n  toNotEqual: true,\n});\n\nconst LINEBREAK_REGEX = /[\\r\\n]/;\n\nclass JasmineFormatter {\n\n  constructor(jasmine, config) {\n    this._config = config;\n    this._jasmine = jasmine;\n  }\n\n  formatDiffable(matcherName, isNot, actual, expected) {\n    const ppActual = this.prettyPrint(actual);\n    const ppExpected = this.prettyPrint(expected);\n    const colorDiff = this.highlightDifferences(ppActual, ppExpected);\n    matcherName = (isNot ? 'NOT ' : '') + matcherName;\n\n    return (\n      ERROR_TITLE_COLOR('Expected:') + ' ' + colorDiff.a + ' ' +\n      ERROR_TITLE_COLOR(matcherName + ':') + ' ' + colorDiff.b\n    );\n  }\n\n  formatMatchFailure(result) {\n    let message;\n    if (DIFFABLE_MATCHERS[result.matcherName]) {\n      const isNot =\n        'isNot' in result ? result.isNot : /not to /.test(result.message);\n      message = this.formatDiffable(\n        result.matcherName,\n        isNot,\n        result.actual,\n        result.expected\n      );\n    } else {\n      message = ERROR_TITLE_COLOR(result.message);\n    }\n\n    // error message & stack live on 'trace' field in jasmine 1.3\n    const error = result.trace ? result.trace : result;\n    if (error.stack) {\n      message = this.formatStackTrace(error.stack, error.message, message);\n    }\n    return message;\n  }\n\n\n  formatException(stackTrace) {\n    // jasmine doesn't give us access to the actual Error object, so we\n    // have to regexp out the message from the stack string in order to\n    // colorize the `message` value\n    return utils.cleanStackTrace(stackTrace.replace(\n      /(^(.|\\n)*?(?=\\n\\s*at\\s))/,\n      ERROR_TITLE_COLOR('$1')\n    ));\n  }\n\n  highlightDifferences(a, b) {\n    let differ;\n    if (a.match(LINEBREAK_REGEX) || b.match(LINEBREAK_REGEX)) {\n      // `diff` uses the Myers LCS diff algorithm which runs in O(n+d^2) time\n      // (where \"d\" is the edit distance) and can get very slow for large edit\n      // distances. Mitigate the cost by switching to a lower-resolution diff\n      // whenever linebreaks are involved.\n      differ = diff.diffLines;\n    } else {\n      differ = diff.diffChars;\n    }\n    const changes = differ(a, b);\n    const ret = {a: '', b: ''};\n    for (let i = 0, il = changes.length; i < il; i++) {\n      const change = changes[i];\n      if (change.added) {\n        ret.b += chalk.bgRed(change.value);\n      } else if (change.removed) {\n        ret.a += chalk.bgRed(change.value);\n      } else {\n        ret.a += change.value;\n        ret.b += change.value;\n      }\n    }\n    return ret;\n  }\n\n  prettyPrint(obj, indent, cycleWeakMap) {\n    if (!indent) {\n      indent = '';\n    }\n\n    if (typeof obj === 'object' && obj !== null) {\n      if (this._jasmine.isDomNode(obj)) {\n        let attrStr = '';\n        Array.prototype.forEach.call(obj.attributes, attr => {\n          const attrName = attr.name.trim();\n          const attrValue = attr.value.trim();\n          attrStr += ' ' + attrName + '=\"' + attrValue + '\"';\n        });\n        return (\n          'HTMLNode(<' + obj.tagName + attrStr + '>{...}</' + obj.tagName + '>)'\n        );\n      }\n\n      if (!cycleWeakMap) {\n        cycleWeakMap = new WeakMap();\n      }\n\n      if (cycleWeakMap.get(obj) === true) {\n        return '<circular reference>';\n      }\n      cycleWeakMap.set(obj, true);\n\n      const orderedKeys = Object.keys(obj).sort();\n      let value;\n      const keysOutput = [];\n      const keyIndent = chalk.gray('|') + ' ';\n      for (let i = 0; i < orderedKeys.length; i++) {\n        value = obj[orderedKeys[i]];\n        keysOutput.push(\n          indent + keyIndent + orderedKeys[i] + ': ' +\n          this.prettyPrint(value, indent + keyIndent, cycleWeakMap)\n        );\n      }\n      return '{\\n' + keysOutput.join(',\\n') + '\\n' + indent + '}';\n    } else {\n      return this._jasmine.pp(obj);\n    }\n  }\n\n  formatStackTrace(stackTrace, originalMessage, formattedMessage) {\n    return utils.cleanStackTrace(\n      stackTrace\n        .replace(originalMessage, formattedMessage)\n        .replace(/^.*Error:\\s*/, '')\n    );\n  }\n}\n\nmodule.exports = JasmineFormatter;\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/JasmineFormatter.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/Jasmine2Reporter.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst jasmineRequire = require('../../../vendor/jasmine/jasmine-2.3.4.js');\nconst jasmine = jasmineRequire.core(jasmineRequire);\nconst JasmineFormatter = require('./JasmineFormatter');\n\nclass Jasmine2Reporter {\n\n  constructor(config) {\n    this._config = config || {};\n    this._formatter = new JasmineFormatter(jasmine, config);\n    this._testResults = [];\n    this._currentSuites = [];\n    this._resolve = null;\n    this._resultsPromise = new Promise(resolve => this._resolve = resolve);\n  }\n\n  specDone(result) {\n    this._testResults.push(\n      this._extractSpecResults(result, this._currentSuites.slice(0))\n    );\n  }\n\n  suiteStarted(suite) {\n    this._currentSuites.push(suite.description);\n  }\n\n  suiteDone() {\n    this._currentSuites.pop();\n  }\n\n  jasmineDone() {\n    let numFailingTests = 0;\n    let numPassingTests = 0;\n    const testResults = this._testResults;\n    testResults.forEach(testResult => {\n      if (testResult.failureMessages.length > 0) {\n        numFailingTests++;\n      } else {\n        numPassingTests++;\n      }\n    });\n    this._resolve({\n      numFailingTests,\n      numPassingTests,\n      testResults,\n    });\n  }\n\n  getResults() {\n    return this._resultsPromise;\n  }\n\n  _extractSpecResults(specResult, currentSuites) {\n    const results = {\n      title: 'it ' + specResult.description,\n      ancestorTitles: currentSuites,\n      failureMessages: [],\n      numPassingAsserts: 0, // Jasmine2 only returns an array of failed asserts.\n    };\n\n    specResult.failedExpectations.forEach(failed => {\n      let message;\n      if (!failed.matcherName) {\n        message = this._formatter.formatException(failed.stack);\n      } else {\n        message = this._formatter.formatMatchFailure(failed);\n      }\n      results.failureMessages.push(message);\n    });\n\n    return results;\n  }\n}\n\nmodule.exports = Jasmine2Reporter;\n","dependencies":["../../../vendor/jasmine/jasmine-2.3.4.js","./JasmineFormatter"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst jasmineRequire = require('../../../vendor/jasmine/jasmine-2.3.4.js');\nconst jasmine = jasmineRequire.core(jasmineRequire);\nconst JasmineFormatter = require('./JasmineFormatter');\n\nclass Jasmine2Reporter {\n\n  constructor(config) {\n    this._config = config || {};\n    this._formatter = new JasmineFormatter(jasmine, config);\n    this._testResults = [];\n    this._currentSuites = [];\n    this._resolve = null;\n    this._resultsPromise = new Promise(resolve => this._resolve = resolve);\n  }\n\n  specDone(result) {\n    this._testResults.push(\n      this._extractSpecResults(result, this._currentSuites.slice(0))\n    );\n  }\n\n  suiteStarted(suite) {\n    this._currentSuites.push(suite.description);\n  }\n\n  suiteDone() {\n    this._currentSuites.pop();\n  }\n\n  jasmineDone() {\n    let numFailingTests = 0;\n    let numPassingTests = 0;\n    const testResults = this._testResults;\n    testResults.forEach(testResult => {\n      if (testResult.failureMessages.length > 0) {\n        numFailingTests++;\n      } else {\n        numPassingTests++;\n      }\n    });\n    this._resolve({\n      numFailingTests,\n      numPassingTests,\n      testResults,\n    });\n  }\n\n  getResults() {\n    return this._resultsPromise;\n  }\n\n  _extractSpecResults(specResult, currentSuites) {\n    const results = {\n      title: 'it ' + specResult.description,\n      ancestorTitles: currentSuites,\n      failureMessages: [],\n      numPassingAsserts: 0, // Jasmine2 only returns an array of failed asserts.\n    };\n\n    specResult.failedExpectations.forEach(failed => {\n      let message;\n      if (!failed.matcherName) {\n        message = this._formatter.formatException(failed.stack);\n      } else {\n        message = this._formatter.formatMatchFailure(failed);\n      }\n      results.failureMessages.push(message);\n    });\n\n    return results;\n  }\n}\n\nmodule.exports = Jasmine2Reporter;\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/Jasmine2Reporter.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/jasmine2.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst VENDOR_PATH = '../../../vendor/';\nconst JASMINE_PATH = require.resolve(VENDOR_PATH + '/jasmine/jasmine-2.3.4.js');\n\nconst fs = require('graceful-fs');\nconst jasminePit = require(VENDOR_PATH + '/jasmine-pit/jasmine-pit');\nconst JasmineReporter = require('./Jasmine2Reporter');\nconst path = require('path');\n\nconst jasmineFileContent =\n  fs.readFileSync(require.resolve(JASMINE_PATH), 'utf8');\n\nfunction jasmine2(config, environment, moduleLoader, testPath) {\n  let env;\n  let jasmine;\n\n  // Jasmine does stuff with timers that affect running the tests. However, we\n  // also mock out all the timer APIs (to make them test-controllable).\n  // To account for this conflict, we set up jasmine in an environment with real\n  // timers (instead of mock timers).\n  environment.fakeTimers.runWithRealTimers(() => {\n    environment.runSourceText(jasmineFileContent, JASMINE_PATH);\n\n    const requireJasmine = environment.global.jasmineRequire;\n    jasmine = requireJasmine.core(requireJasmine);\n    env = jasmine.getEnv();\n    const jasmineInterface = requireJasmine.interface(jasmine, env);\n    Object.assign(environment.global, jasmineInterface);\n    env.addReporter(jasmineInterface.jsApiReporter);\n\n    jasminePit.install(environment.global);\n\n    if (config.setupTestFrameworkScriptFile) {\n      moduleLoader.requireModule(null, config.setupTestFrameworkScriptFile);\n    }\n  });\n\n  env.beforeEach(() => {\n    jasmine.addMatchers({\n      toBeCalled: (/* util, customEqualityTesters */) => {\n        return {\n          compare: (actual/*, expected */) => {\n            if (actual.mock === undefined) {\n              throw Error('toBeCalled() should be used on a mock function');\n            }\n            return {\n              pass: actual.mock.calls.length !== 0,\n            };\n          },\n        };\n      },\n\n      lastCalledWith: (util/*, customEqualityTesters */) => {\n        return {\n          compare: function(actual) {\n            if (actual.mock === undefined) {\n              throw Error('lastCalledWith() should be used on a mock function');\n            }\n            const calls = actual.mock.calls;\n            const args = Array.prototype.slice.call(arguments, 1);\n            return {\n              pass: util.equals(calls[calls.length - 1], args),\n            };\n\n          },\n        };\n      },\n\n      toBeCalledWith: (util/*, customEqualityTesters */) => {\n        return {\n          compare: function(actual) {\n            if (actual.mock === undefined) {\n              throw Error('toBeCalledWith() should be used on a mock function');\n            }\n            const calls = actual.mock.calls;\n            const args = Array.prototype.slice.call(arguments, 1);\n            const pass = calls.some(call => util.equals(call, args));\n            return {pass};\n          },\n        };\n      },\n    });\n\n    if (!config.persistModuleRegistryBetweenSpecs) {\n      moduleLoader.resetModuleRegistry();\n    }\n  });\n\n  const reporter = new JasmineReporter({\n    noHighlight: config.noHighlight,\n    noStackTrace: config.noStackTrace,\n  });\n  env.addReporter(reporter);\n  // Run the test by require()ing it\n  moduleLoader.requireModule(testPath, './' + path.basename(testPath));\n  env.execute();\n  return reporter.getResults();\n}\n\nmodule.exports = jasmine2;\n","dependencies":["graceful-fs","./Jasmine2Reporter","path"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst VENDOR_PATH = '../../../vendor/';\nconst JASMINE_PATH = require.resolve(VENDOR_PATH + '/jasmine/jasmine-2.3.4.js');\n\nconst fs = require('graceful-fs');\nconst jasminePit = require(VENDOR_PATH + '/jasmine-pit/jasmine-pit');\nconst JasmineReporter = require('./Jasmine2Reporter');\nconst path = require('path');\n\nconst jasmineFileContent =\n  fs.readFileSync(require.resolve(JASMINE_PATH), 'utf8');\n\nfunction jasmine2(config, environment, moduleLoader, testPath) {\n  let env;\n  let jasmine;\n\n  // Jasmine does stuff with timers that affect running the tests. However, we\n  // also mock out all the timer APIs (to make them test-controllable).\n  // To account for this conflict, we set up jasmine in an environment with real\n  // timers (instead of mock timers).\n  environment.fakeTimers.runWithRealTimers(() => {\n    environment.runSourceText(jasmineFileContent, JASMINE_PATH);\n\n    const requireJasmine = environment.global.jasmineRequire;\n    jasmine = requireJasmine.core(requireJasmine);\n    env = jasmine.getEnv();\n    const jasmineInterface = requireJasmine.interface(jasmine, env);\n    Object.assign(environment.global, jasmineInterface);\n    env.addReporter(jasmineInterface.jsApiReporter);\n\n    jasminePit.install(environment.global);\n\n    if (config.setupTestFrameworkScriptFile) {\n      moduleLoader.requireModule(null, config.setupTestFrameworkScriptFile);\n    }\n  });\n\n  env.beforeEach(() => {\n    jasmine.addMatchers({\n      toBeCalled: (/* util, customEqualityTesters */) => {\n        return {\n          compare: (actual/*, expected */) => {\n            if (actual.mock === undefined) {\n              throw Error('toBeCalled() should be used on a mock function');\n            }\n            return {\n              pass: actual.mock.calls.length !== 0,\n            };\n          },\n        };\n      },\n\n      lastCalledWith: (util/*, customEqualityTesters */) => {\n        return {\n          compare: function(actual) {\n            if (actual.mock === undefined) {\n              throw Error('lastCalledWith() should be used on a mock function');\n            }\n            const calls = actual.mock.calls;\n            const args = Array.prototype.slice.call(arguments, 1);\n            return {\n              pass: util.equals(calls[calls.length - 1], args),\n            };\n\n          },\n        };\n      },\n\n      toBeCalledWith: (util/*, customEqualityTesters */) => {\n        return {\n          compare: function(actual) {\n            if (actual.mock === undefined) {\n              throw Error('toBeCalledWith() should be used on a mock function');\n            }\n            const calls = actual.mock.calls;\n            const args = Array.prototype.slice.call(arguments, 1);\n            const pass = calls.some(call => util.equals(call, args));\n            return {pass};\n          },\n        };\n      },\n    });\n\n    if (!config.persistModuleRegistryBetweenSpecs) {\n      moduleLoader.resetModuleRegistry();\n    }\n  });\n\n  const reporter = new JasmineReporter({\n    noHighlight: config.noHighlight,\n    noStackTrace: config.noStackTrace,\n  });\n  env.addReporter(reporter);\n  // Run the test by require()ing it\n  moduleLoader.requireModule(testPath, './' + path.basename(testPath));\n  env.execute();\n  return reporter.getResults();\n}\n\nmodule.exports = jasmine2;\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/jasmine2.js"}},"/Users/cpojer/Projects/jest/src/testRunners/jasmine/jasmine1.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst VENDOR_PATH = '../../../vendor/';\nconst JASMINE_PATH = require.resolve(VENDOR_PATH + '/jasmine/jasmine-1.3.0');\nconst JASMINE_ONLY_PATH =\n  require.resolve(VENDOR_PATH + '/jasmine-only/jasmine-only.js');\n\nconst fs = require('graceful-fs');\nconst jasminePit = require(VENDOR_PATH + '/jasmine-pit/jasmine-pit');\nconst JasmineReporter = require('./JasmineReporter');\nconst path = require('path');\n\nconst jasmineFileContent = fs.readFileSync(JASMINE_PATH, 'utf8');\nconst jasmineOnlyContent = fs.readFileSync(JASMINE_ONLY_PATH, 'utf8');\n\nfunction jasmine1(config, environment, moduleLoader, testPath) {\n  const hasKey = (obj, keyName) => (\n    obj !== null\n    && obj !== undefined\n    && obj[keyName] !== environment.global.jasmine.undefined\n  );\n\n  const checkMissingExpectedKeys =\n    (actual, expected, property, mismatchKeys) => {\n      if (!hasKey(expected, property) && hasKey(actual, property)) {\n        mismatchKeys.push(\n          'expected missing key \\'' + property + '\\', but present in ' +\n          'actual.'\n        );\n      }\n    };\n\n  const checkMissingActualKeys =\n    (actual, expected, property, mismatchKeys) => {\n      if (!hasKey(actual, property) && hasKey(expected, property)) {\n        mismatchKeys.push(\n          'expected has key \\'' + property + '\\', but missing from actual.'\n        );\n      }\n    };\n\n  const checkMismatchedValues = function(\n    a,\n    b,\n    property,\n    mismatchKeys,\n    mismatchValues\n  ) {\n    // The only different implementation from the original jasmine\n    const areEqual = this.equals_(\n      a[property],\n      b[property],\n      mismatchKeys,\n      mismatchValues\n    );\n    if (!areEqual) {\n      let aprop;\n      let bprop;\n      if (!a[property]) {\n        aprop = a[property];\n      } else if (a[property].toString) {\n        aprop = environment.global.jasmine.util.htmlEscape(\n          a[property].toString()\n        );\n      } else {\n        aprop = Object.prototype.toString.call(a[property]);\n      }\n\n      if (!b[property]) {\n        bprop = b[property];\n      } else if (b[property].toString) {\n        bprop = environment.global.jasmine.util.htmlEscape(\n          b[property].toString()\n        );\n      } else {\n        bprop = Object.prototype.toString.call(b[property]);\n      }\n\n      mismatchValues.push(\n        '\\'' + property + '\\' was \\'' + bprop +\n        '\\' in expected, but was \\'' + aprop +\n        '\\' in actual.'\n      );\n    }\n  };\n\n  // Jasmine does stuff with timers that affect running the tests. However, we\n  // also mock out all the timer APIs (to make them test-controllable).\n  // To account for this conflict, we set up jasmine in an environment with real\n  // timers (instead of mock timers).\n  environment.fakeTimers.runWithRealTimers(() => {\n    environment.runSourceText(jasmineFileContent, JASMINE_PATH);\n    jasminePit.install(environment.global);\n    environment.runSourceText(jasmineOnlyContent);\n\n    const _comparedObjects = new WeakMap();\n    environment.global.jasmine.Env.prototype.compareObjects_ =\n      function(a, b, mismatchKeys, mismatchValues) {\n        if (_comparedObjects.get(a) === b && _comparedObjects.get(b) === a) {\n          return true;\n        }\n        const areArrays =\n          environment.global.jasmine.isArray_(a)\n          && environment.global.jasmine.isArray_(b);\n\n        _comparedObjects.set(a, b);\n        _comparedObjects.set(b, a);\n\n        let property;\n        let index;\n        if (areArrays) {\n          const largerLength = Math.max(a.length, b.length);\n          for (index = 0; index < largerLength; index++) {\n            // check that all expected keys match actual keys\n            if (index < b.length && typeof b[index] !== 'function') {\n              checkMissingActualKeys(a, b, index, mismatchKeys);\n            }\n            // check that all actual keys match expected keys\n            if (index < a.length && typeof a[index] !== 'function') {\n              checkMissingExpectedKeys(a, b, index, mismatchKeys);\n            }\n\n            // check that every expected value matches each actual value\n            if (typeof a[index] !== 'function' &&\n                typeof b[index] !== 'function') {\n              checkMismatchedValues.call(\n                this,\n                a,\n                b,\n                index,\n                mismatchKeys,\n                mismatchValues\n              );\n            }\n          }\n        } else {\n          for (property in b) {\n            // check that all actual keys match expected keys\n            checkMissingActualKeys(a, b, property, mismatchKeys);\n\n            // check that every expected value matches each actual value\n            checkMismatchedValues.call(\n              this,\n              a,\n              b,\n              property,\n              mismatchKeys,\n              mismatchValues\n            );\n          }\n          for (property in a) {\n            // check that all of b's keys match a's\n            checkMissingExpectedKeys(a, b, property, mismatchKeys);\n          }\n        }\n\n\n        if (areArrays && a.length !== b.length) {\n          mismatchValues.push('arrays were not the same length');\n        }\n\n        _comparedObjects.delete(a);\n        _comparedObjects.delete(b);\n        return (mismatchKeys.length === 0 && mismatchValues.length === 0);\n      };\n\n    if (config.setupTestFrameworkScriptFile) {\n      moduleLoader.requireModule(null, config.setupTestFrameworkScriptFile);\n    }\n  });\n\n  const jasmine = environment.global.jasmine;\n\n  jasmine.getEnv().beforeEach(function() {\n    this.addMatchers({\n      toBeCalled: function() {\n        if (this.actual.mock === undefined) {\n          throw Error('toBeCalled() should be used on a mock function');\n        }\n        return this.actual.mock.calls.length !== 0;\n      },\n\n      lastCalledWith: function() {\n        if (this.actual.mock === undefined) {\n          throw Error('lastCalledWith() should be used on a mock function');\n        }\n        const calls = this.actual.mock.calls;\n        const args = Array.prototype.slice.call(arguments);\n        this.env.currentSpec.expect(calls[calls.length - 1]).toEqual(args);\n        return true;\n      },\n\n      toBeCalledWith: function() {\n        if (this.actual.mock === undefined) {\n          throw Error('toBeCalledWith() should be used on a mock function');\n        }\n        const calls = this.actual.mock.calls;\n        const args = Array.prototype.slice.call(arguments);\n\n        // Often toBeCalledWith is called on a mock that only has one call, so\n        // we can give a better error message in this case.\n        if (calls.length === 1) {\n          let expect = this.env.currentSpec.expect(calls[0]);\n          if (this.isNot) {\n            expect = expect.not;\n          }\n          expect.toEqual(args);\n          return !this.isNot;\n        }\n\n        return calls.some(call => this.env.equals_(call, args));\n      },\n    });\n\n    if (!config.persistModuleRegistryBetweenSpecs) {\n      moduleLoader.resetModuleRegistry();\n    }\n  });\n\n  const reporter = new JasmineReporter({\n    noHighlight: config.noHighlight,\n    noStackTrace: config.noStackTrace,\n  });\n  jasmine.getEnv().addReporter(reporter);\n  // Run the test by require()ing it\n  moduleLoader.requireModule(testPath, './' + path.basename(testPath));\n  jasmine.getEnv().execute();\n  return reporter.getResults();\n}\n\nmodule.exports = jasmine1;\n","dependencies":["graceful-fs","./JasmineReporter","path"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst VENDOR_PATH = '../../../vendor/';\nconst JASMINE_PATH = require.resolve(VENDOR_PATH + '/jasmine/jasmine-1.3.0');\nconst JASMINE_ONLY_PATH =\n  require.resolve(VENDOR_PATH + '/jasmine-only/jasmine-only.js');\n\nconst fs = require('graceful-fs');\nconst jasminePit = require(VENDOR_PATH + '/jasmine-pit/jasmine-pit');\nconst JasmineReporter = require('./JasmineReporter');\nconst path = require('path');\n\nconst jasmineFileContent = fs.readFileSync(JASMINE_PATH, 'utf8');\nconst jasmineOnlyContent = fs.readFileSync(JASMINE_ONLY_PATH, 'utf8');\n\nfunction jasmine1(config, environment, moduleLoader, testPath) {\n  const hasKey = (obj, keyName) => (\n    obj !== null\n    && obj !== undefined\n    && obj[keyName] !== environment.global.jasmine.undefined\n  );\n\n  const checkMissingExpectedKeys =\n    (actual, expected, property, mismatchKeys) => {\n      if (!hasKey(expected, property) && hasKey(actual, property)) {\n        mismatchKeys.push(\n          'expected missing key \\'' + property + '\\', but present in ' +\n          'actual.'\n        );\n      }\n    };\n\n  const checkMissingActualKeys =\n    (actual, expected, property, mismatchKeys) => {\n      if (!hasKey(actual, property) && hasKey(expected, property)) {\n        mismatchKeys.push(\n          'expected has key \\'' + property + '\\', but missing from actual.'\n        );\n      }\n    };\n\n  const checkMismatchedValues = function(\n    a,\n    b,\n    property,\n    mismatchKeys,\n    mismatchValues\n  ) {\n    // The only different implementation from the original jasmine\n    const areEqual = this.equals_(\n      a[property],\n      b[property],\n      mismatchKeys,\n      mismatchValues\n    );\n    if (!areEqual) {\n      let aprop;\n      let bprop;\n      if (!a[property]) {\n        aprop = a[property];\n      } else if (a[property].toString) {\n        aprop = environment.global.jasmine.util.htmlEscape(\n          a[property].toString()\n        );\n      } else {\n        aprop = Object.prototype.toString.call(a[property]);\n      }\n\n      if (!b[property]) {\n        bprop = b[property];\n      } else if (b[property].toString) {\n        bprop = environment.global.jasmine.util.htmlEscape(\n          b[property].toString()\n        );\n      } else {\n        bprop = Object.prototype.toString.call(b[property]);\n      }\n\n      mismatchValues.push(\n        '\\'' + property + '\\' was \\'' + bprop +\n        '\\' in expected, but was \\'' + aprop +\n        '\\' in actual.'\n      );\n    }\n  };\n\n  // Jasmine does stuff with timers that affect running the tests. However, we\n  // also mock out all the timer APIs (to make them test-controllable).\n  // To account for this conflict, we set up jasmine in an environment with real\n  // timers (instead of mock timers).\n  environment.fakeTimers.runWithRealTimers(() => {\n    environment.runSourceText(jasmineFileContent, JASMINE_PATH);\n    jasminePit.install(environment.global);\n    environment.runSourceText(jasmineOnlyContent);\n\n    const _comparedObjects = new WeakMap();\n    environment.global.jasmine.Env.prototype.compareObjects_ =\n      function(a, b, mismatchKeys, mismatchValues) {\n        if (_comparedObjects.get(a) === b && _comparedObjects.get(b) === a) {\n          return true;\n        }\n        const areArrays =\n          environment.global.jasmine.isArray_(a)\n          && environment.global.jasmine.isArray_(b);\n\n        _comparedObjects.set(a, b);\n        _comparedObjects.set(b, a);\n\n        let property;\n        let index;\n        if (areArrays) {\n          const largerLength = Math.max(a.length, b.length);\n          for (index = 0; index < largerLength; index++) {\n            // check that all expected keys match actual keys\n            if (index < b.length && typeof b[index] !== 'function') {\n              checkMissingActualKeys(a, b, index, mismatchKeys);\n            }\n            // check that all actual keys match expected keys\n            if (index < a.length && typeof a[index] !== 'function') {\n              checkMissingExpectedKeys(a, b, index, mismatchKeys);\n            }\n\n            // check that every expected value matches each actual value\n            if (typeof a[index] !== 'function' &&\n                typeof b[index] !== 'function') {\n              checkMismatchedValues.call(\n                this,\n                a,\n                b,\n                index,\n                mismatchKeys,\n                mismatchValues\n              );\n            }\n          }\n        } else {\n          for (property in b) {\n            // check that all actual keys match expected keys\n            checkMissingActualKeys(a, b, property, mismatchKeys);\n\n            // check that every expected value matches each actual value\n            checkMismatchedValues.call(\n              this,\n              a,\n              b,\n              property,\n              mismatchKeys,\n              mismatchValues\n            );\n          }\n          for (property in a) {\n            // check that all of b's keys match a's\n            checkMissingExpectedKeys(a, b, property, mismatchKeys);\n          }\n        }\n\n\n        if (areArrays && a.length !== b.length) {\n          mismatchValues.push('arrays were not the same length');\n        }\n\n        _comparedObjects.delete(a);\n        _comparedObjects.delete(b);\n        return (mismatchKeys.length === 0 && mismatchValues.length === 0);\n      };\n\n    if (config.setupTestFrameworkScriptFile) {\n      moduleLoader.requireModule(null, config.setupTestFrameworkScriptFile);\n    }\n  });\n\n  const jasmine = environment.global.jasmine;\n\n  jasmine.getEnv().beforeEach(function() {\n    this.addMatchers({\n      toBeCalled: function() {\n        if (this.actual.mock === undefined) {\n          throw Error('toBeCalled() should be used on a mock function');\n        }\n        return this.actual.mock.calls.length !== 0;\n      },\n\n      lastCalledWith: function() {\n        if (this.actual.mock === undefined) {\n          throw Error('lastCalledWith() should be used on a mock function');\n        }\n        const calls = this.actual.mock.calls;\n        const args = Array.prototype.slice.call(arguments);\n        this.env.currentSpec.expect(calls[calls.length - 1]).toEqual(args);\n        return true;\n      },\n\n      toBeCalledWith: function() {\n        if (this.actual.mock === undefined) {\n          throw Error('toBeCalledWith() should be used on a mock function');\n        }\n        const calls = this.actual.mock.calls;\n        const args = Array.prototype.slice.call(arguments);\n\n        // Often toBeCalledWith is called on a mock that only has one call, so\n        // we can give a better error message in this case.\n        if (calls.length === 1) {\n          let expect = this.env.currentSpec.expect(calls[0]);\n          if (this.isNot) {\n            expect = expect.not;\n          }\n          expect.toEqual(args);\n          return !this.isNot;\n        }\n\n        return calls.some(call => this.env.equals_(call, args));\n      },\n    });\n\n    if (!config.persistModuleRegistryBetweenSpecs) {\n      moduleLoader.resetModuleRegistry();\n    }\n  });\n\n  const reporter = new JasmineReporter({\n    noHighlight: config.noHighlight,\n    noStackTrace: config.noStackTrace,\n  });\n  jasmine.getEnv().addReporter(reporter);\n  // Run the test by require()ing it\n  moduleLoader.requireModule(testPath, './' + path.basename(testPath));\n  jasmine.getEnv().execute();\n  return reporter.getResults();\n}\n\nmodule.exports = jasmine1;\n"},"name":"/Users/cpojer/Projects/jest/src/testRunners/jasmine/jasmine1.js"}},"/Users/cpojer/Projects/jest/src/reporters/__tests__/VerboseLogger-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2016-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed in the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('VerboseLogger', () => {\n  let groupTestsBySuites;\n\n  beforeEach(() => {\n    groupTestsBySuites = require('../VerboseLogger').groupTestsBySuites;\n  });\n\n  describe('groupTestsBySuites', () => {\n\n    it('should handle empty results', () => {\n      expect(groupTestsBySuites([])).toEqual([]);\n    });\n\n    it('should group A1 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group A1 in A; B1 in B', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'B1',\n        ancestorTitles: ['B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }, {\n        title: 'B',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['B'],\n          title: 'B1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group A1, A2 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A2',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }, {\n          ancestorTitles: ['A'],\n          title: 'A2',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group A1, A2 in A; B1, B2 in B', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A2',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'B1',\n        ancestorTitles: ['B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'B2',\n        ancestorTitles: ['B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }, {\n          ancestorTitles: ['A'],\n          title: 'A2',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }, {\n        title: 'B',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['B'],\n          title: 'B1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }, {\n          ancestorTitles: ['B'],\n          title: 'B2',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group AB1 in AB', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }]);\n    });\n\n    it('should group AB1, AB2 in AB', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'AB2',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }, {\n            ancestorTitles: ['A', 'B'],\n            title: 'AB2',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }]);\n    });\n\n    it('should group A1 in A; AB1 in AB', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group AB1 in AB; A1 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group AB1 in AB; CD1 in CD', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'CD1',\n        ancestorTitles: ['C', 'D'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }, {\n        title: 'C',\n        suites: [{\n          title: 'D',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['C', 'D'],\n            title: 'CD1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }]);\n    });\n\n    it('should group ABC1 in ABC; BC1 in BC; D1 in D; A1 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'ABC1',\n        ancestorTitles: ['A', 'B', 'C'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'BC1',\n        ancestorTitles: ['B', 'C'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'D1',\n        ancestorTitles: ['D'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [{\n            title: 'C',\n            suites: [],\n            tests: [{\n              ancestorTitles: ['A', 'B', 'C'],\n              title: 'ABC1',\n              failureMessages: [],\n              numPassingAsserts: 1,\n            }],\n          }],\n          tests: [],\n        }],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }, {\n        title: 'B',\n        suites: [{\n          title: 'C',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['B', 'C'],\n            title: 'BC1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }, {\n        title: 'D',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['D'],\n          title: 'D1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n  });\n});\n","dependencies":["../VerboseLogger"],"source":"/**\n * Copyright (c) 2016-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed in the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('VerboseLogger', () => {\n  let groupTestsBySuites;\n\n  beforeEach(() => {\n    groupTestsBySuites = require('../VerboseLogger').groupTestsBySuites;\n  });\n\n  describe('groupTestsBySuites', () => {\n\n    it('should handle empty results', () => {\n      expect(groupTestsBySuites([])).toEqual([]);\n    });\n\n    it('should group A1 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group A1 in A; B1 in B', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'B1',\n        ancestorTitles: ['B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }, {\n        title: 'B',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['B'],\n          title: 'B1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group A1, A2 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A2',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }, {\n          ancestorTitles: ['A'],\n          title: 'A2',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group A1, A2 in A; B1, B2 in B', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A2',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'B1',\n        ancestorTitles: ['B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'B2',\n        ancestorTitles: ['B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }, {\n          ancestorTitles: ['A'],\n          title: 'A2',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }, {\n        title: 'B',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['B'],\n          title: 'B1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }, {\n          ancestorTitles: ['B'],\n          title: 'B2',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group AB1 in AB', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }]);\n    });\n\n    it('should group AB1, AB2 in AB', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'AB2',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }, {\n            ancestorTitles: ['A', 'B'],\n            title: 'AB2',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }]);\n    });\n\n    it('should group A1 in A; AB1 in AB', () => {\n      expect(groupTestsBySuites([{\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group AB1 in AB; A1 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n    it('should group AB1 in AB; CD1 in CD', () => {\n      expect(groupTestsBySuites([{\n        title: 'AB1',\n        ancestorTitles: ['A', 'B'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'CD1',\n        ancestorTitles: ['C', 'D'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['A', 'B'],\n            title: 'AB1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }, {\n        title: 'C',\n        suites: [{\n          title: 'D',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['C', 'D'],\n            title: 'CD1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }]);\n    });\n\n    it('should group ABC1 in ABC; BC1 in BC; D1 in D; A1 in A', () => {\n      expect(groupTestsBySuites([{\n        title: 'ABC1',\n        ancestorTitles: ['A', 'B', 'C'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'BC1',\n        ancestorTitles: ['B', 'C'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'D1',\n        ancestorTitles: ['D'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }, {\n        title: 'A1',\n        ancestorTitles: ['A'],\n        failureMessages: [],\n        numPassingAsserts: 1,\n      }])).toEqual([{\n        title: 'A',\n        suites: [{\n          title: 'B',\n          suites: [{\n            title: 'C',\n            suites: [],\n            tests: [{\n              ancestorTitles: ['A', 'B', 'C'],\n              title: 'ABC1',\n              failureMessages: [],\n              numPassingAsserts: 1,\n            }],\n          }],\n          tests: [],\n        }],\n        tests: [{\n          ancestorTitles: ['A'],\n          title: 'A1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }, {\n        title: 'B',\n        suites: [{\n          title: 'C',\n          suites: [],\n          tests: [{\n            ancestorTitles: ['B', 'C'],\n            title: 'BC1',\n            failureMessages: [],\n            numPassingAsserts: 1,\n          }],\n        }],\n        tests: [],\n      }, {\n        title: 'D',\n        suites: [],\n        tests: [{\n          ancestorTitles: ['D'],\n          title: 'D1',\n          failureMessages: [],\n          numPassingAsserts: 1,\n        }],\n      }]);\n    });\n\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/reporters/__tests__/VerboseLogger-test.js"}},"/Users/cpojer/Projects/jest/src/reporters/__tests__/DefaultTestReporter-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\njest.autoMockOff().mock('fs');\n\ndescribe('DefaultTestReporter', function() {\n  let DefaultTestReporter;\n\n  beforeEach(function() {\n    DefaultTestReporter = require('../DefaultTestReporter');\n  });\n\n  describe('onTestResult', function() {\n\n    let testReporter;\n    let fakeProcess;\n\n    beforeEach(function() {\n      fakeProcess = {\n        exit: jest.genMockFunction(),\n        stdout: {\n          write: jest.genMockFunction(),\n        },\n      };\n      testReporter = new DefaultTestReporter(fakeProcess);\n    });\n\n    it('Exits with proper error code on bail.', function() {\n      const mockAggResults = {\n        success: false,\n        startTime: 0,\n        numTotalTestSuites: 1,\n        numPassedTestSuites: 0,\n        numFailedTestSuites: 1,\n        numRuntimeErrorTestSuites: 0,\n        numTotalTests: 1,\n        numPassedTests: 0,\n        numFailedTests: 1,\n        testResults: [],\n        postSuiteHeaders: [],\n        testFilePath: 'foo',\n      };\n      testReporter.onRunStart({\n        bail: true,\n        noHighlight: false,\n      }, mockAggResults);\n      testReporter.onTestResult({\n        bail: true,\n        rootDir: 'foo',\n      }, mockAggResults, mockAggResults);\n      expect(fakeProcess.exit).lastCalledWith(1);\n    });\n\n  });\n});\n\n\n","dependencies":["../DefaultTestReporter"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\njest.autoMockOff().mock('fs');\n\ndescribe('DefaultTestReporter', function() {\n  let DefaultTestReporter;\n\n  beforeEach(function() {\n    DefaultTestReporter = require('../DefaultTestReporter');\n  });\n\n  describe('onTestResult', function() {\n\n    let testReporter;\n    let fakeProcess;\n\n    beforeEach(function() {\n      fakeProcess = {\n        exit: jest.genMockFunction(),\n        stdout: {\n          write: jest.genMockFunction(),\n        },\n      };\n      testReporter = new DefaultTestReporter(fakeProcess);\n    });\n\n    it('Exits with proper error code on bail.', function() {\n      const mockAggResults = {\n        success: false,\n        startTime: 0,\n        numTotalTestSuites: 1,\n        numPassedTestSuites: 0,\n        numFailedTestSuites: 1,\n        numRuntimeErrorTestSuites: 0,\n        numTotalTests: 1,\n        numPassedTests: 0,\n        numFailedTests: 1,\n        testResults: [],\n        postSuiteHeaders: [],\n        testFilePath: 'foo',\n      };\n      testReporter.onRunStart({\n        bail: true,\n        noHighlight: false,\n      }, mockAggResults);\n      testReporter.onTestResult({\n        bail: true,\n        rootDir: 'foo',\n      }, mockAggResults, mockAggResults);\n      expect(fakeProcess.exit).lastCalledWith(1);\n    });\n\n  });\n});\n\n\n"},"name":"/Users/cpojer/Projects/jest/src/reporters/__tests__/DefaultTestReporter-test.js"}},"/Users/cpojer/Projects/jest/src/lib/__tests__/promisify-test.js":{"metadata":{"mtime":1457041710000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.unmock('../promisify');\n\ndescribe('promisify', () => {\n  var promisify;\n\n  beforeEach(() => {\n    promisify = require('../promisify');\n  });\n\n  pit('should resolve', () => {\n    var foo = promisify(callback => {\n      callback(null, 1);\n    });\n\n    return foo().then(res => {\n      expect(res).toBe(1);\n    });\n  });\n\n  pit('should resolve with args', () => {\n    var foo = promisify((a, b, callback) => {\n      callback(null, a + b);\n    });\n\n    return foo(3, 5).then(res => {\n      expect(res).toBe(8);\n    });\n  });\n\n  pit('should reject with args', () => {\n    var foo = promisify((a, b, callback) => {\n      callback(new Error('lol'));\n    });\n\n    return foo(3, 5).catch(err => {\n      expect(err.message).toBe('lol');\n    });\n  });\n});\n","dependencies":["../promisify"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.unmock('../promisify');\n\ndescribe('promisify', () => {\n  var promisify;\n\n  beforeEach(() => {\n    promisify = require('../promisify');\n  });\n\n  pit('should resolve', () => {\n    var foo = promisify(callback => {\n      callback(null, 1);\n    });\n\n    return foo().then(res => {\n      expect(res).toBe(1);\n    });\n  });\n\n  pit('should resolve with args', () => {\n    var foo = promisify((a, b, callback) => {\n      callback(null, a + b);\n    });\n\n    return foo(3, 5).then(res => {\n      expect(res).toBe(8);\n    });\n  });\n\n  pit('should reject with args', () => {\n    var foo = promisify((a, b, callback) => {\n      callback(new Error('lol'));\n    });\n\n    return foo(3, 5).catch(err => {\n      expect(err.message).toBe('lol');\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/lib/__tests__/promisify-test.js"}},"/Users/cpojer/Projects/jest/src/lib/__tests__/moduleMocker-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('moduleMocker', () => {\n  let moduleMocker;\n\n  beforeEach(() => {\n    moduleMocker = require('../moduleMocker');\n  });\n\n  describe('getMetadata', () => {\n    it('returns the function `name` property', () => {\n      function x() {}\n      const metadata = moduleMocker.getMetadata(x);\n      expect(x.name).toBe('x');\n      expect(metadata.name).toBe('x');\n    });\n\n    it('mocks constant values', () => {\n      expect(moduleMocker.getMetadata('banana').value).toEqual('banana');\n      expect(moduleMocker.getMetadata(27).value).toEqual(27);\n      expect(moduleMocker.getMetadata(false).value).toEqual(false);\n    });\n  });\n\n  describe('generateFromMetadata', () => {\n    it('forwards the function name property', () => {\n      function foo() {}\n      const fooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo)\n      );\n      expect(fooMock.name).toBe('foo');\n    });\n\n    it('wont interfere with previous mocks on a shared prototype', () => {\n      const ClassFoo = function() {};\n      ClassFoo.prototype.x = () => {};\n      const ClassFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassFoo)\n      );\n      const foo = new ClassFooMock();\n      const bar = new ClassFooMock();\n\n      foo.x.mockImplementation(() => {\n        return 'Foo';\n      });\n      bar.x.mockImplementation(() => {\n        return 'Bar';\n      });\n\n      expect(foo.x()).toBe('Foo');\n      expect(bar.x()).toBe('Bar');\n    });\n\n    it('does not mock non-enumerable getters', () => {\n      const foo = Object.defineProperties({}, {\n        nonEnumMethod: {\n          value: () => {},\n        },\n        nonEnumGetter: {\n          get: () => { throw new Error(); },\n        },\n      });\n      const fooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo)\n      );\n\n      expect(typeof foo.nonEnumMethod).toBe('function');\n\n      expect(fooMock.nonEnumMethod.mock).not.toBeUndefined();\n      expect(fooMock.nonEnumGetter).toBeUndefined();\n    });\n\n    it('mocks ES2015 non-enumerable methods', () => {\n      class ClassFoo {\n        foo() {}\n        toString() {\n          return 'Foo';\n        }\n      }\n\n      const ClassFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassFoo)\n      );\n      const foo = new ClassFooMock();\n\n      const instanceFoo = new ClassFoo();\n      const instanceFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(instanceFoo)\n      );\n\n      expect(typeof foo.foo).toBe('function');\n      expect(typeof instanceFooMock.foo).toBe('function');\n      expect(instanceFooMock.foo.mock).not.toBeUndefined();\n\n      expect(instanceFooMock.toString.mock).not.toBeUndefined();\n    });\n\n    it('mocks methods that are bound multiple times', () => {\n      const func = function func() {};\n      const multipleBoundFunc = func.bind(null).bind(null);\n\n      const multipleBoundFuncMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(multipleBoundFunc)\n      );\n\n      expect(typeof multipleBoundFuncMock).toBe('function');\n    });\n\n    it('mocks regexp instances', () => {\n      expect(\n        () => moduleMocker.generateFromMetadata(moduleMocker.getMetadata(/a/))\n      ).not.toThrow();\n    });\n  });\n});\n","dependencies":["../moduleMocker"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('moduleMocker', () => {\n  let moduleMocker;\n\n  beforeEach(() => {\n    moduleMocker = require('../moduleMocker');\n  });\n\n  describe('getMetadata', () => {\n    it('returns the function `name` property', () => {\n      function x() {}\n      const metadata = moduleMocker.getMetadata(x);\n      expect(x.name).toBe('x');\n      expect(metadata.name).toBe('x');\n    });\n\n    it('mocks constant values', () => {\n      expect(moduleMocker.getMetadata('banana').value).toEqual('banana');\n      expect(moduleMocker.getMetadata(27).value).toEqual(27);\n      expect(moduleMocker.getMetadata(false).value).toEqual(false);\n    });\n  });\n\n  describe('generateFromMetadata', () => {\n    it('forwards the function name property', () => {\n      function foo() {}\n      const fooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo)\n      );\n      expect(fooMock.name).toBe('foo');\n    });\n\n    it('wont interfere with previous mocks on a shared prototype', () => {\n      const ClassFoo = function() {};\n      ClassFoo.prototype.x = () => {};\n      const ClassFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassFoo)\n      );\n      const foo = new ClassFooMock();\n      const bar = new ClassFooMock();\n\n      foo.x.mockImplementation(() => {\n        return 'Foo';\n      });\n      bar.x.mockImplementation(() => {\n        return 'Bar';\n      });\n\n      expect(foo.x()).toBe('Foo');\n      expect(bar.x()).toBe('Bar');\n    });\n\n    it('does not mock non-enumerable getters', () => {\n      const foo = Object.defineProperties({}, {\n        nonEnumMethod: {\n          value: () => {},\n        },\n        nonEnumGetter: {\n          get: () => { throw new Error(); },\n        },\n      });\n      const fooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo)\n      );\n\n      expect(typeof foo.nonEnumMethod).toBe('function');\n\n      expect(fooMock.nonEnumMethod.mock).not.toBeUndefined();\n      expect(fooMock.nonEnumGetter).toBeUndefined();\n    });\n\n    it('mocks ES2015 non-enumerable methods', () => {\n      class ClassFoo {\n        foo() {}\n        toString() {\n          return 'Foo';\n        }\n      }\n\n      const ClassFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassFoo)\n      );\n      const foo = new ClassFooMock();\n\n      const instanceFoo = new ClassFoo();\n      const instanceFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(instanceFoo)\n      );\n\n      expect(typeof foo.foo).toBe('function');\n      expect(typeof instanceFooMock.foo).toBe('function');\n      expect(instanceFooMock.foo.mock).not.toBeUndefined();\n\n      expect(instanceFooMock.toString.mock).not.toBeUndefined();\n    });\n\n    it('mocks methods that are bound multiple times', () => {\n      const func = function func() {};\n      const multipleBoundFunc = func.bind(null).bind(null);\n\n      const multipleBoundFuncMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(multipleBoundFunc)\n      );\n\n      expect(typeof multipleBoundFuncMock).toBe('function');\n    });\n\n    it('mocks regexp instances', () => {\n      expect(\n        () => moduleMocker.generateFromMetadata(moduleMocker.getMetadata(/a/))\n      ).not.toThrow();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/lib/__tests__/moduleMocker-test.js"}},"/Users/cpojer/Projects/jest/src/lib/__tests__/FakeTimers-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('FakeTimers', function() {\n  var FakeTimers;\n\n  beforeEach(function() {\n    FakeTimers = require('../FakeTimers');\n  });\n\n  describe('construction', function() {\n    /* eslint-disable no-new */\n    it('installs setTimeout mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.setTimeout).not.toBe(undefined);\n    });\n\n    it('installs clearTimeout mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.clearTimeout).not.toBe(undefined);\n    });\n\n    it('installs setInterval mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.setInterval).not.toBe(undefined);\n    });\n\n    it('installs clearInterval mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.clearInterval).not.toBe(undefined);\n    });\n\n    it('mocks process.nextTick if on exists on global', function() {\n      var origNextTick = function() {};\n      var global = {\n        process: {\n          nextTick: origNextTick,\n        },\n      };\n      new FakeTimers(global);\n      expect(global.process.nextTick).not.toBe(origNextTick);\n    });\n\n    it('doesn\\'t mock process.nextTick if real impl isnt present', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.process).toBe(undefined);\n    });\n\n    it('mocks setImmediate if it exists on global', function() {\n      var origSetImmediate = function() {};\n      var global = {\n        setImmediate: origSetImmediate,\n      };\n      new FakeTimers(global);\n      expect(global.setImmediate).not.toBe(origSetImmediate);\n    });\n\n    it('mocks clearImmediate if setImmediate is on global', function() {\n      var origSetImmediate = function() {};\n      var origClearImmediate = function() {};\n      var global = {\n        setImmediate: origSetImmediate,\n        clearImmediate: origClearImmediate,\n      };\n      new FakeTimers(global);\n      expect(global.clearImmediate).not.toBe(origClearImmediate);\n    });\n\n    it('doesn\\'t mock setImmediate if real impl isnt present', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.setImmediate).toBe(undefined);\n    });\n\n    it('doesnt mock clearImmediate if real immediate isnt present', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.clearImmediate).toBe(undefined);\n    });\n  });\n\n  describe('runAllTicks', function() {\n    it('runs all ticks, in order', function() {\n      var global = {\n        process: {\n          nextTick: function() {},\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n      var mock1 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock1');\n      });\n      var mock2 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock2');\n      });\n\n      global.process.nextTick(mock1);\n      global.process.nextTick(mock2);\n\n      expect(mock1.mock.calls.length).toBe(0);\n      expect(mock2.mock.calls.length).toBe(0);\n\n      fakeTimers.runAllTicks();\n\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(mock2.mock.calls.length).toBe(1);\n      expect(runOrder).toEqual(['mock1', 'mock2']);\n    });\n\n    it('does nothing when no ticks have been scheduled', function() {\n      var nextTick = jest.genMockFn();\n      var global = {\n        process: {\n          nextTick: nextTick,\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.runAllTicks();\n\n      expect(nextTick.mock.calls.length).toBe(0);\n    });\n\n    it('only runs a scheduled callback once', function() {\n      var global = {\n        process: {\n          nextTick: function() {},\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n      expect(mock1.mock.calls.length).toBe(0);\n\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('cancels a callback even from native nextTick', function() {\n      var nativeNextTick = jest.genMockFn();\n\n      var global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(nativeNextTick.mock.calls.length).toBe(1);\n\n      // Now imagine we fast forward to the next real tick. We need to be sure\n      // that native nextTick doesn't try to run the callback again\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('cancels a callback even from native setImmediate', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setImmediate(mock1);\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(nativeSetImmediate.mock.calls.length).toBe(1);\n\n      // ensure that native setImmediate doesn't try to run the callback again\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('doesnt run a tick callback if native nextTick already did', function() {\n      var nativeNextTick = jest.genMockFn();\n\n      var global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n\n      // Emulate native nextTick running...\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('doesnt run immediate if native setImmediate already did', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setImmediate(mock1);\n\n      // Emulate native setImmediate running...\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('native doesnt run immediate if fake already did', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setImmediate(mock1);\n\n      //run all immediates now\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      // Emulate native setImmediate running ensuring it doesn't re-run\n      nativeSetImmediate.mock.calls[0][0]();\n\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('throws before allowing infinite recursion', function() {\n      var global = {\n        process: {\n          nextTick: function() {},\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global, 100);\n\n      global.process.nextTick(function infinitelyRecursingCallback() {\n        global.process.nextTick(infinitelyRecursingCallback);\n      });\n\n      expect(function() {\n        fakeTimers.runAllTicks();\n      }).toThrow(new Error(\n        'Ran 100 ticks, and there are still more! Assuming we\\'ve hit an ' +\n        'infinite recursion and bailing out...'\n      ));\n    });\n  });\n\n  describe('runAllTimers', function() {\n    it('runs all timers in order', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n      var mock1 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock1');\n      });\n      var mock2 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock2');\n      });\n      var mock3 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock3');\n      });\n      var mock4 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock4');\n      });\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      var intervalHandler = global.setInterval(function() {\n        mock4();\n        global.clearInterval(intervalHandler);\n      }, 200);\n\n      fakeTimers.runAllTimers();\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n    });\n\n    it('does nothing when no timers have been scheduled', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var global = {\n        setTimeout: nativeSetTimeout,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.runAllTimers();\n    });\n\n    it('only runs a setTimeout callback once (ever)', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var fn = jest.genMockFn();\n      global.setTimeout(fn, 0);\n      expect(fn.mock.calls.length).toBe(0);\n\n      fakeTimers.runAllTimers();\n      expect(fn.mock.calls.length).toBe(1);\n\n      fakeTimers.runAllTimers();\n      expect(fn.mock.calls.length).toBe(1);\n    });\n\n    it('runs callbacks with arguments after the interval', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var fn = jest.genMockFn();\n      global.setTimeout(fn, 0, 'mockArg1', 'mockArg2');\n\n      fakeTimers.runAllTimers();\n      expect(fn.mock.calls).toEqual([\n        ['mockArg1', 'mockArg2'],\n      ]);\n    });\n\n    it('doesnt pass the callback to native setTimeout', function() {\n      var nativeSetTimeout = jest.genMockFn();\n\n      var global = {\n        setTimeout: nativeSetTimeout,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setTimeout(mock1, 0);\n\n      fakeTimers.runAllTimers();\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(nativeSetTimeout.mock.calls.length).toBe(0);\n    });\n\n    it('throws before allowing infinite recursion', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global, 100);\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(function() {\n        fakeTimers.runAllTimers();\n      }).toThrow(new Error(\n        'Ran 100 timers, and there are still more! Assuming we\\'ve hit an ' +\n        'infinite recursion and bailing out...'\n      ));\n    });\n  });\n\n  describe('runTimersToTime', function() {\n    it('runs timers in order', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n      var mock1 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock1');\n      });\n      var mock2 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock2');\n      });\n      var mock3 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock3');\n      });\n      var mock4 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock4');\n      });\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(function() {\n        mock4();\n      }, 200);\n\n      // Move forward to t=50\n      fakeTimers.runTimersToTime(50);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=60\n      fakeTimers.runTimersToTime(10);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=100\n      fakeTimers.runTimersToTime(40);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      // Move forward to t=200\n      fakeTimers.runTimersToTime(100);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n\n      // Move forward to t=400\n      fakeTimers.runTimersToTime(200);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4', 'mock4']);\n    });\n\n    it('does nothing when no timers have been scheduled', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      fakeTimers.runTimersToTime(100);\n    });\n\n    it('throws before allowing infinite recursion', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global, 100);\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(function() {\n        fakeTimers.runTimersToTime(50);\n      }).toThrow(new Error(\n        'Ran 100 timers, and there are still more! Assuming we\\'ve hit an ' +\n        'infinite recursion and bailing out...'\n      ));\n    });\n  });\n\n  describe('reset', function() {\n    it('resets all pending setTimeouts', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setTimeout(mock1, 100);\n\n      fakeTimers.reset();\n      fakeTimers.runAllTimers();\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n\n    it('resets all pending setIntervals', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setInterval(mock1, 200);\n\n      fakeTimers.reset();\n      fakeTimers.runAllTimers();\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n\n    it('resets all pending ticks callbacks & immediates', function() {\n      var global = {\n        setImmediate: function() {},\n        process: {\n          nextTick: function() {},\n        },\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n      global.setImmediate(mock1);\n\n      fakeTimers.reset();\n      fakeTimers.runAllTicks();\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n\n    it('resets current runTimersToTime time cursor', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setTimeout(mock1, 100);\n      fakeTimers.runTimersToTime(50);\n\n      fakeTimers.reset();\n      global.setTimeout(mock1, 100);\n\n      fakeTimers.runTimersToTime(50);\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n  });\n\n  describe('runOnlyPendingTimers', function() {\n    it('runs all timers in order', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock1');\n        global.setTimeout(cb, 100);\n      }, 100);\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock2');\n        global.setTimeout(cb, 0);\n      }, 0);\n\n      global.setInterval(function() {\n        runOrder.push('mock3');\n      }, 200);\n\n      global.setImmediate(function() {\n        runOrder.push('mock4');\n      });\n\n      fakeTimers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock2',\n        'mock1',\n        'mock3',\n      ]);\n\n      fakeTimers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock2',\n        'mock1',\n        'mock3',\n\n        'mock2',\n        'mock1',\n        'mock3',\n      ]);\n    });\n\n    it('does not run timers that were cleared in another timer', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var fn = jest.genMockFn();\n      var timer = global.setTimeout(fn, 10);\n      global.setTimeout(function() {\n        global.clearTimeout(timer);\n      }, 0);\n\n      fakeTimers.runOnlyPendingTimers();\n      expect(fn).not.toBeCalled();\n    });\n  });\n\n  describe('runWithRealTimers', function() {\n    it('executes callback with native timers', function() {\n      var nativeClearInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeSetTimeout = jest.genMockFn();\n\n      var global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // clearInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearInterval();\n      });\n      expect(nativeClearInterval.mock.calls.length).toBe(1);\n      expect(global.clearInterval.mock.calls.length).toBe(0);\n\n      // clearTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearTimeout();\n      });\n      expect(nativeClearTimeout.mock.calls.length).toBe(1);\n      expect(global.clearTimeout.mock.calls.length).toBe(0);\n\n      // setInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.setInterval();\n      });\n      expect(nativeSetInterval.mock.calls.length).toBe(1);\n      expect(global.setInterval.mock.calls.length).toBe(0);\n\n      // setTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.setTimeout();\n      });\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(0);\n    });\n\n    it('resets mock timers after executing callback', function() {\n      var nativeClearInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeSetTimeout = jest.genMockFn();\n\n\n      var global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // clearInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearInterval();\n      });\n      expect(nativeClearInterval.mock.calls.length).toBe(1);\n      expect(global.clearInterval.mock.calls.length).toBe(0);\n\n      global.clearInterval();\n      expect(nativeClearInterval.mock.calls.length).toBe(1);\n      expect(global.clearInterval.mock.calls.length).toBe(1);\n\n      // clearTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearTimeout();\n      });\n      expect(nativeClearTimeout.mock.calls.length).toBe(1);\n      expect(global.clearTimeout.mock.calls.length).toBe(0);\n\n      global.clearTimeout();\n      expect(nativeClearTimeout.mock.calls.length).toBe(1);\n      expect(global.clearTimeout.mock.calls.length).toBe(1);\n\n      // setInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.setInterval();\n      });\n      expect(nativeSetInterval.mock.calls.length).toBe(1);\n      expect(global.setInterval.mock.calls.length).toBe(0);\n\n      global.setInterval();\n      expect(nativeSetInterval.mock.calls.length).toBe(1);\n      expect(global.setInterval.mock.calls.length).toBe(1);\n\n      // setTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.setTimeout();\n      });\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(0);\n\n      global.setTimeout();\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(1);\n    });\n\n    it('resets mock timer functions even if callback throws', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var global = {setTimeout: nativeSetTimeout};\n      var fakeTimers = new FakeTimers(global);\n\n      expect(function() {\n        fakeTimers.runWithRealTimers(function() {\n          global.setTimeout();\n          throw new Error('test');\n        });\n      }).toThrow(new Error('test'));\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(0);\n\n      global.setTimeout();\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(1);\n    });\n  });\n\n  describe('useRealTimers', function() {\n    it('resets native timer APIs', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeClearInterval = jest.genMockFn();\n\n      var global = {\n        setTimeout: nativeSetTimeout,\n        setInterval: nativeSetInterval,\n        clearTimeout: nativeClearTimeout,\n        clearInterval: nativeClearInterval,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // Ensure that fakeTimers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n\n      fakeTimers.useRealTimers();\n\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n    });\n\n    it('resets native process.nextTick when present', function() {\n      var nativeProcessNextTick = jest.genMockFn();\n\n      var global = {\n        process: {nextTick: nativeProcessNextTick},\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // Ensure that fakeTimers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n\n      fakeTimers.useRealTimers();\n\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n    });\n\n    it('resets native setImmediate when present', function() {\n      var nativeSetImmediate = jest.genMockFn();\n      var nativeClearImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n        clearImmediate: nativeClearImmediate,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // Ensure that fakeTimers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n\n      fakeTimers.useRealTimers();\n\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n    });\n  });\n\n  describe('useFakeTimers', function() {\n    it('resets mock timer APIs', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeClearInterval = jest.genMockFn();\n\n      var global = {\n        setTimeout: nativeSetTimeout,\n        setInterval: nativeSetInterval,\n        clearTimeout: nativeClearTimeout,\n        clearInterval: nativeClearInterval,\n      };\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n    });\n\n    it('resets mock process.nextTick when present', function() {\n      var nativeProcessNextTick = jest.genMockFn();\n\n      var global = {\n        process: {nextTick: nativeProcessNextTick},\n      };\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n    });\n\n    it('resets mock setImmediate when present', function() {\n      var nativeSetImmediate = jest.genMockFn();\n      var nativeClearImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n        clearImmediate: nativeClearImmediate,\n      };\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n    });\n  });\n});\n","dependencies":["../FakeTimers"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\ndescribe('FakeTimers', function() {\n  var FakeTimers;\n\n  beforeEach(function() {\n    FakeTimers = require('../FakeTimers');\n  });\n\n  describe('construction', function() {\n    /* eslint-disable no-new */\n    it('installs setTimeout mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.setTimeout).not.toBe(undefined);\n    });\n\n    it('installs clearTimeout mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.clearTimeout).not.toBe(undefined);\n    });\n\n    it('installs setInterval mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.setInterval).not.toBe(undefined);\n    });\n\n    it('installs clearInterval mock', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.clearInterval).not.toBe(undefined);\n    });\n\n    it('mocks process.nextTick if on exists on global', function() {\n      var origNextTick = function() {};\n      var global = {\n        process: {\n          nextTick: origNextTick,\n        },\n      };\n      new FakeTimers(global);\n      expect(global.process.nextTick).not.toBe(origNextTick);\n    });\n\n    it('doesn\\'t mock process.nextTick if real impl isnt present', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.process).toBe(undefined);\n    });\n\n    it('mocks setImmediate if it exists on global', function() {\n      var origSetImmediate = function() {};\n      var global = {\n        setImmediate: origSetImmediate,\n      };\n      new FakeTimers(global);\n      expect(global.setImmediate).not.toBe(origSetImmediate);\n    });\n\n    it('mocks clearImmediate if setImmediate is on global', function() {\n      var origSetImmediate = function() {};\n      var origClearImmediate = function() {};\n      var global = {\n        setImmediate: origSetImmediate,\n        clearImmediate: origClearImmediate,\n      };\n      new FakeTimers(global);\n      expect(global.clearImmediate).not.toBe(origClearImmediate);\n    });\n\n    it('doesn\\'t mock setImmediate if real impl isnt present', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.setImmediate).toBe(undefined);\n    });\n\n    it('doesnt mock clearImmediate if real immediate isnt present', function() {\n      var global = {};\n      new FakeTimers(global);\n      expect(global.clearImmediate).toBe(undefined);\n    });\n  });\n\n  describe('runAllTicks', function() {\n    it('runs all ticks, in order', function() {\n      var global = {\n        process: {\n          nextTick: function() {},\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n      var mock1 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock1');\n      });\n      var mock2 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock2');\n      });\n\n      global.process.nextTick(mock1);\n      global.process.nextTick(mock2);\n\n      expect(mock1.mock.calls.length).toBe(0);\n      expect(mock2.mock.calls.length).toBe(0);\n\n      fakeTimers.runAllTicks();\n\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(mock2.mock.calls.length).toBe(1);\n      expect(runOrder).toEqual(['mock1', 'mock2']);\n    });\n\n    it('does nothing when no ticks have been scheduled', function() {\n      var nextTick = jest.genMockFn();\n      var global = {\n        process: {\n          nextTick: nextTick,\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.runAllTicks();\n\n      expect(nextTick.mock.calls.length).toBe(0);\n    });\n\n    it('only runs a scheduled callback once', function() {\n      var global = {\n        process: {\n          nextTick: function() {},\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n      expect(mock1.mock.calls.length).toBe(0);\n\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('cancels a callback even from native nextTick', function() {\n      var nativeNextTick = jest.genMockFn();\n\n      var global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(nativeNextTick.mock.calls.length).toBe(1);\n\n      // Now imagine we fast forward to the next real tick. We need to be sure\n      // that native nextTick doesn't try to run the callback again\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('cancels a callback even from native setImmediate', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setImmediate(mock1);\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(nativeSetImmediate.mock.calls.length).toBe(1);\n\n      // ensure that native setImmediate doesn't try to run the callback again\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('doesnt run a tick callback if native nextTick already did', function() {\n      var nativeNextTick = jest.genMockFn();\n\n      var global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n\n      // Emulate native nextTick running...\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      fakeTimers.runAllTicks();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('doesnt run immediate if native setImmediate already did', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setImmediate(mock1);\n\n      // Emulate native setImmediate running...\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('native doesnt run immediate if fake already did', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setImmediate(mock1);\n\n      //run all immediates now\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(1);\n\n      // Emulate native setImmediate running ensuring it doesn't re-run\n      nativeSetImmediate.mock.calls[0][0]();\n\n      expect(mock1.mock.calls.length).toBe(1);\n    });\n\n    it('throws before allowing infinite recursion', function() {\n      var global = {\n        process: {\n          nextTick: function() {},\n        },\n      };\n\n      var fakeTimers = new FakeTimers(global, 100);\n\n      global.process.nextTick(function infinitelyRecursingCallback() {\n        global.process.nextTick(infinitelyRecursingCallback);\n      });\n\n      expect(function() {\n        fakeTimers.runAllTicks();\n      }).toThrow(new Error(\n        'Ran 100 ticks, and there are still more! Assuming we\\'ve hit an ' +\n        'infinite recursion and bailing out...'\n      ));\n    });\n  });\n\n  describe('runAllTimers', function() {\n    it('runs all timers in order', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n      var mock1 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock1');\n      });\n      var mock2 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock2');\n      });\n      var mock3 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock3');\n      });\n      var mock4 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock4');\n      });\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      var intervalHandler = global.setInterval(function() {\n        mock4();\n        global.clearInterval(intervalHandler);\n      }, 200);\n\n      fakeTimers.runAllTimers();\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n    });\n\n    it('does nothing when no timers have been scheduled', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var global = {\n        setTimeout: nativeSetTimeout,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.runAllTimers();\n    });\n\n    it('only runs a setTimeout callback once (ever)', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var fn = jest.genMockFn();\n      global.setTimeout(fn, 0);\n      expect(fn.mock.calls.length).toBe(0);\n\n      fakeTimers.runAllTimers();\n      expect(fn.mock.calls.length).toBe(1);\n\n      fakeTimers.runAllTimers();\n      expect(fn.mock.calls.length).toBe(1);\n    });\n\n    it('runs callbacks with arguments after the interval', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var fn = jest.genMockFn();\n      global.setTimeout(fn, 0, 'mockArg1', 'mockArg2');\n\n      fakeTimers.runAllTimers();\n      expect(fn.mock.calls).toEqual([\n        ['mockArg1', 'mockArg2'],\n      ]);\n    });\n\n    it('doesnt pass the callback to native setTimeout', function() {\n      var nativeSetTimeout = jest.genMockFn();\n\n      var global = {\n        setTimeout: nativeSetTimeout,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setTimeout(mock1, 0);\n\n      fakeTimers.runAllTimers();\n      expect(mock1.mock.calls.length).toBe(1);\n      expect(nativeSetTimeout.mock.calls.length).toBe(0);\n    });\n\n    it('throws before allowing infinite recursion', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global, 100);\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(function() {\n        fakeTimers.runAllTimers();\n      }).toThrow(new Error(\n        'Ran 100 timers, and there are still more! Assuming we\\'ve hit an ' +\n        'infinite recursion and bailing out...'\n      ));\n    });\n  });\n\n  describe('runTimersToTime', function() {\n    it('runs timers in order', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n      var mock1 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock1');\n      });\n      var mock2 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock2');\n      });\n      var mock3 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock3');\n      });\n      var mock4 = jest.genMockFn().mockImpl(function() {\n        runOrder.push('mock4');\n      });\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(function() {\n        mock4();\n      }, 200);\n\n      // Move forward to t=50\n      fakeTimers.runTimersToTime(50);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=60\n      fakeTimers.runTimersToTime(10);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=100\n      fakeTimers.runTimersToTime(40);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      // Move forward to t=200\n      fakeTimers.runTimersToTime(100);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n\n      // Move forward to t=400\n      fakeTimers.runTimersToTime(200);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4', 'mock4']);\n    });\n\n    it('does nothing when no timers have been scheduled', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      fakeTimers.runTimersToTime(100);\n    });\n\n    it('throws before allowing infinite recursion', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global, 100);\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(function() {\n        fakeTimers.runTimersToTime(50);\n      }).toThrow(new Error(\n        'Ran 100 timers, and there are still more! Assuming we\\'ve hit an ' +\n        'infinite recursion and bailing out...'\n      ));\n    });\n  });\n\n  describe('reset', function() {\n    it('resets all pending setTimeouts', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setTimeout(mock1, 100);\n\n      fakeTimers.reset();\n      fakeTimers.runAllTimers();\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n\n    it('resets all pending setIntervals', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setInterval(mock1, 200);\n\n      fakeTimers.reset();\n      fakeTimers.runAllTimers();\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n\n    it('resets all pending ticks callbacks & immediates', function() {\n      var global = {\n        setImmediate: function() {},\n        process: {\n          nextTick: function() {},\n        },\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.process.nextTick(mock1);\n      global.setImmediate(mock1);\n\n      fakeTimers.reset();\n      fakeTimers.runAllTicks();\n      fakeTimers.runAllImmediates();\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n\n    it('resets current runTimersToTime time cursor', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var mock1 = jest.genMockFn();\n      global.setTimeout(mock1, 100);\n      fakeTimers.runTimersToTime(50);\n\n      fakeTimers.reset();\n      global.setTimeout(mock1, 100);\n\n      fakeTimers.runTimersToTime(50);\n      expect(mock1.mock.calls.length).toBe(0);\n    });\n  });\n\n  describe('runOnlyPendingTimers', function() {\n    it('runs all timers in order', function() {\n      var nativeSetImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n      };\n\n      var fakeTimers = new FakeTimers(global);\n\n      var runOrder = [];\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock1');\n        global.setTimeout(cb, 100);\n      }, 100);\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock2');\n        global.setTimeout(cb, 0);\n      }, 0);\n\n      global.setInterval(function() {\n        runOrder.push('mock3');\n      }, 200);\n\n      global.setImmediate(function() {\n        runOrder.push('mock4');\n      });\n\n      fakeTimers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock2',\n        'mock1',\n        'mock3',\n      ]);\n\n      fakeTimers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock2',\n        'mock1',\n        'mock3',\n\n        'mock2',\n        'mock1',\n        'mock3',\n      ]);\n    });\n\n    it('does not run timers that were cleared in another timer', function() {\n      var global = {};\n      var fakeTimers = new FakeTimers(global);\n\n      var fn = jest.genMockFn();\n      var timer = global.setTimeout(fn, 10);\n      global.setTimeout(function() {\n        global.clearTimeout(timer);\n      }, 0);\n\n      fakeTimers.runOnlyPendingTimers();\n      expect(fn).not.toBeCalled();\n    });\n  });\n\n  describe('runWithRealTimers', function() {\n    it('executes callback with native timers', function() {\n      var nativeClearInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeSetTimeout = jest.genMockFn();\n\n      var global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // clearInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearInterval();\n      });\n      expect(nativeClearInterval.mock.calls.length).toBe(1);\n      expect(global.clearInterval.mock.calls.length).toBe(0);\n\n      // clearTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearTimeout();\n      });\n      expect(nativeClearTimeout.mock.calls.length).toBe(1);\n      expect(global.clearTimeout.mock.calls.length).toBe(0);\n\n      // setInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.setInterval();\n      });\n      expect(nativeSetInterval.mock.calls.length).toBe(1);\n      expect(global.setInterval.mock.calls.length).toBe(0);\n\n      // setTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.setTimeout();\n      });\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(0);\n    });\n\n    it('resets mock timers after executing callback', function() {\n      var nativeClearInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeSetTimeout = jest.genMockFn();\n\n\n      var global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // clearInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearInterval();\n      });\n      expect(nativeClearInterval.mock.calls.length).toBe(1);\n      expect(global.clearInterval.mock.calls.length).toBe(0);\n\n      global.clearInterval();\n      expect(nativeClearInterval.mock.calls.length).toBe(1);\n      expect(global.clearInterval.mock.calls.length).toBe(1);\n\n      // clearTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.clearTimeout();\n      });\n      expect(nativeClearTimeout.mock.calls.length).toBe(1);\n      expect(global.clearTimeout.mock.calls.length).toBe(0);\n\n      global.clearTimeout();\n      expect(nativeClearTimeout.mock.calls.length).toBe(1);\n      expect(global.clearTimeout.mock.calls.length).toBe(1);\n\n      // setInterval()\n      fakeTimers.runWithRealTimers(function() {\n        global.setInterval();\n      });\n      expect(nativeSetInterval.mock.calls.length).toBe(1);\n      expect(global.setInterval.mock.calls.length).toBe(0);\n\n      global.setInterval();\n      expect(nativeSetInterval.mock.calls.length).toBe(1);\n      expect(global.setInterval.mock.calls.length).toBe(1);\n\n      // setTimeout()\n      fakeTimers.runWithRealTimers(function() {\n        global.setTimeout();\n      });\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(0);\n\n      global.setTimeout();\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(1);\n    });\n\n    it('resets mock timer functions even if callback throws', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var global = {setTimeout: nativeSetTimeout};\n      var fakeTimers = new FakeTimers(global);\n\n      expect(function() {\n        fakeTimers.runWithRealTimers(function() {\n          global.setTimeout();\n          throw new Error('test');\n        });\n      }).toThrow(new Error('test'));\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(0);\n\n      global.setTimeout();\n      expect(nativeSetTimeout.mock.calls.length).toBe(1);\n      expect(global.setTimeout.mock.calls.length).toBe(1);\n    });\n  });\n\n  describe('useRealTimers', function() {\n    it('resets native timer APIs', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeClearInterval = jest.genMockFn();\n\n      var global = {\n        setTimeout: nativeSetTimeout,\n        setInterval: nativeSetInterval,\n        clearTimeout: nativeClearTimeout,\n        clearInterval: nativeClearInterval,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // Ensure that fakeTimers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n\n      fakeTimers.useRealTimers();\n\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n    });\n\n    it('resets native process.nextTick when present', function() {\n      var nativeProcessNextTick = jest.genMockFn();\n\n      var global = {\n        process: {nextTick: nativeProcessNextTick},\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // Ensure that fakeTimers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n\n      fakeTimers.useRealTimers();\n\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n    });\n\n    it('resets native setImmediate when present', function() {\n      var nativeSetImmediate = jest.genMockFn();\n      var nativeClearImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n        clearImmediate: nativeClearImmediate,\n      };\n      var fakeTimers = new FakeTimers(global);\n\n      // Ensure that fakeTimers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n\n      fakeTimers.useRealTimers();\n\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n    });\n  });\n\n  describe('useFakeTimers', function() {\n    it('resets mock timer APIs', function() {\n      var nativeSetTimeout = jest.genMockFn();\n      var nativeSetInterval = jest.genMockFn();\n      var nativeClearTimeout = jest.genMockFn();\n      var nativeClearInterval = jest.genMockFn();\n\n      var global = {\n        setTimeout: nativeSetTimeout,\n        setInterval: nativeSetInterval,\n        clearTimeout: nativeClearTimeout,\n        clearInterval: nativeClearInterval,\n      };\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n    });\n\n    it('resets mock process.nextTick when present', function() {\n      var nativeProcessNextTick = jest.genMockFn();\n\n      var global = {\n        process: {nextTick: nativeProcessNextTick},\n      };\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n    });\n\n    it('resets mock setImmediate when present', function() {\n      var nativeSetImmediate = jest.genMockFn();\n      var nativeClearImmediate = jest.genMockFn();\n\n      var global = {\n        setImmediate: nativeSetImmediate,\n        clearImmediate: nativeClearImmediate,\n      };\n      var fakeTimers = new FakeTimers(global);\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/lib/__tests__/FakeTimers-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-requireModuleOrMock-test.js":{"metadata":{"mtime":1456971424000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const baseConfig = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-requireModuleOrMock-tests',\n    rootDir,\n    moduleNameMapper: {\n      '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',\n      '^[./a-zA-Z0-9$_-]+\\.png$': 'RelativeImageStub',\n    },\n  });\n\n  function buildLoader(config) {\n    config = Object.assign({}, baseConfig, config);\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireModuleOrMock', function() {\n    pit('mocks modules by default', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.setModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit(`doesn't mock modules when explicitly unmocked`, function() {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootDir, rootPath);\n        root.jest.unmock('RegularModule');\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit(`doesn't mock modules when explicitly unmocked via a different denormalized module name`, () => {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootDir, rootPath);\n        root.jest.unmock('./RegularModule');\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit(`doesn't mock modules when autoMockOff() has been called`, function() {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootDir, rootPath);\n        root.jest.autoMockOff();\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('uses manual mock when automocking on and mock is avail', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModuleOrMock(rootPath, 'ManuallyMocked');\n        expect(exports.isManualMockModule).toBe(true);\n      });\n    });\n\n    pit(\n      'does not use manual mock when automocking is off and a real module is ' +\n      'available',\n      function() {\n        return buildLoader().then(function(loader) {\n          const root = loader.requireModule(rootDir, rootPath);\n          root.jest.autoMockOff();\n          const exports = loader.requireModuleOrMock(\n            rootPath,\n            'ManuallyMocked'\n          );\n          expect(exports.isManualMockModule).toBe(false);\n        });\n      }\n    );\n\n    pit('resolves mapped module names and unmocks them by default', function() {\n      return buildLoader().then(function(loader) {\n        let exports =\n          loader.requireModuleOrMock(rootPath, 'image!not-really-a-module');\n        expect(exports.isGlobalImageStub).toBe(true);\n\n        exports = loader.requireModuleOrMock(rootPath, 'cat.png');\n        expect(exports.isRelativeImageStub).toBe(true);\n\n        exports = loader.requireModuleOrMock(rootPath, 'dog.png');\n        expect(exports.isRelativeImageStub).toBe(true);\n      });\n    });\n\n    describe('automocking behavior', () => {\n      it('can be disabled by default', () => {\n        return buildLoader({\n          automock: false,\n        }).then(loader => {\n          const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n          expect(exports.setModuleStateValue._isMockFunction).toBe(undefined);\n        });\n      });\n    });\n\n    describe('transitive dependencies', () => {\n      const expectUnmocked = nodeModule => {\n        const moduleData = nodeModule();\n        expect(moduleData.isUnmocked()).toBe(true);\n        expect(moduleData.transitiveNPM3Dep).toEqual('npm3-transitive-dep');\n        expect(moduleData.internalImplementation())\n          .toEqual('internal-module-code');\n      };\n\n      pit('unmocks transitive dependencies in node_modules by default', () => {\n        return buildLoader({\n          unmockedModulePathPatterns: ['npm3-main-dep'],\n        }).then(loader => {\n          const root = loader.requireModule(rootPath, './root.js');\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Test twice to make sure HasteModuleLoader caching works properly\n          root.jest.resetModuleRegistry();\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Directly requiring the transitive dependency will mock it\n          const transitiveDep =\n            loader.requireModuleOrMock(rootPath, 'npm3-transitive-dep');\n          expect(transitiveDep()).toEqual(undefined);\n        });\n      });\n\n      pit('unmocks transitive dependencies in node_modules when using unmock', () => {\n        return buildLoader().then(loader => {\n          const root = loader.requireModule(rootPath, './root.js');\n          root.jest.unmock('npm3-main-dep');\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Test twice to make sure HasteModuleLoader caching works properly\n          root.jest.resetModuleRegistry();\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Directly requiring the transitive dependency will mock it\n          const transitiveDep =\n            loader.requireModuleOrMock(rootPath, 'npm3-transitive-dep');\n          expect(transitiveDep()).toEqual(undefined);\n        });\n      });\n\n      pit('unmocks transitive dependencies in node_modules by default when using both patterns and unmock', () => {\n        return buildLoader({\n          unmockedModulePathPatterns: ['banana-module'],\n        }).then(loader => {\n          const root = loader.requireModule(rootPath, './root.js');\n          root.jest.unmock('npm3-main-dep');\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Test twice to make sure HasteModuleLoader caching works properly\n          root.jest.resetModuleRegistry();\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Directly requiring the transitive dependency will mock it\n          const transitiveDep =\n            loader.requireModuleOrMock(rootPath, 'npm3-transitive-dep');\n          expect(transitiveDep()).toEqual(undefined);\n        });\n      });\n    });\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const baseConfig = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-requireModuleOrMock-tests',\n    rootDir,\n    moduleNameMapper: {\n      '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',\n      '^[./a-zA-Z0-9$_-]+\\.png$': 'RelativeImageStub',\n    },\n  });\n\n  function buildLoader(config) {\n    config = Object.assign({}, baseConfig, config);\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireModuleOrMock', function() {\n    pit('mocks modules by default', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.setModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit(`doesn't mock modules when explicitly unmocked`, function() {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootDir, rootPath);\n        root.jest.unmock('RegularModule');\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit(`doesn't mock modules when explicitly unmocked via a different denormalized module name`, () => {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootDir, rootPath);\n        root.jest.unmock('./RegularModule');\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit(`doesn't mock modules when autoMockOff() has been called`, function() {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootDir, rootPath);\n        root.jest.autoMockOff();\n        const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('uses manual mock when automocking on and mock is avail', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModuleOrMock(rootPath, 'ManuallyMocked');\n        expect(exports.isManualMockModule).toBe(true);\n      });\n    });\n\n    pit(\n      'does not use manual mock when automocking is off and a real module is ' +\n      'available',\n      function() {\n        return buildLoader().then(function(loader) {\n          const root = loader.requireModule(rootDir, rootPath);\n          root.jest.autoMockOff();\n          const exports = loader.requireModuleOrMock(\n            rootPath,\n            'ManuallyMocked'\n          );\n          expect(exports.isManualMockModule).toBe(false);\n        });\n      }\n    );\n\n    pit('resolves mapped module names and unmocks them by default', function() {\n      return buildLoader().then(function(loader) {\n        let exports =\n          loader.requireModuleOrMock(rootPath, 'image!not-really-a-module');\n        expect(exports.isGlobalImageStub).toBe(true);\n\n        exports = loader.requireModuleOrMock(rootPath, 'cat.png');\n        expect(exports.isRelativeImageStub).toBe(true);\n\n        exports = loader.requireModuleOrMock(rootPath, 'dog.png');\n        expect(exports.isRelativeImageStub).toBe(true);\n      });\n    });\n\n    describe('automocking behavior', () => {\n      it('can be disabled by default', () => {\n        return buildLoader({\n          automock: false,\n        }).then(loader => {\n          const exports = loader.requireModuleOrMock(rootPath, 'RegularModule');\n          expect(exports.setModuleStateValue._isMockFunction).toBe(undefined);\n        });\n      });\n    });\n\n    describe('transitive dependencies', () => {\n      const expectUnmocked = nodeModule => {\n        const moduleData = nodeModule();\n        expect(moduleData.isUnmocked()).toBe(true);\n        expect(moduleData.transitiveNPM3Dep).toEqual('npm3-transitive-dep');\n        expect(moduleData.internalImplementation())\n          .toEqual('internal-module-code');\n      };\n\n      pit('unmocks transitive dependencies in node_modules by default', () => {\n        return buildLoader({\n          unmockedModulePathPatterns: ['npm3-main-dep'],\n        }).then(loader => {\n          const root = loader.requireModule(rootPath, './root.js');\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Test twice to make sure HasteModuleLoader caching works properly\n          root.jest.resetModuleRegistry();\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Directly requiring the transitive dependency will mock it\n          const transitiveDep =\n            loader.requireModuleOrMock(rootPath, 'npm3-transitive-dep');\n          expect(transitiveDep()).toEqual(undefined);\n        });\n      });\n\n      pit('unmocks transitive dependencies in node_modules when using unmock', () => {\n        return buildLoader().then(loader => {\n          const root = loader.requireModule(rootPath, './root.js');\n          root.jest.unmock('npm3-main-dep');\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Test twice to make sure HasteModuleLoader caching works properly\n          root.jest.resetModuleRegistry();\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Directly requiring the transitive dependency will mock it\n          const transitiveDep =\n            loader.requireModuleOrMock(rootPath, 'npm3-transitive-dep');\n          expect(transitiveDep()).toEqual(undefined);\n        });\n      });\n\n      pit('unmocks transitive dependencies in node_modules by default when using both patterns and unmock', () => {\n        return buildLoader({\n          unmockedModulePathPatterns: ['banana-module'],\n        }).then(loader => {\n          const root = loader.requireModule(rootPath, './root.js');\n          root.jest.unmock('npm3-main-dep');\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Test twice to make sure HasteModuleLoader caching works properly\n          root.jest.resetModuleRegistry();\n          expectUnmocked(loader.requireModuleOrMock(rootPath, 'npm3-main-dep'));\n\n          // Directly requiring the transitive dependency will mock it\n          const transitiveDep =\n            loader.requireModuleOrMock(rootPath, 'npm3-transitive-dep');\n          expect(transitiveDep()).toEqual(undefined);\n        });\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-requireModuleOrMock-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-requireModule-test.js":{"metadata":{"mtime":1456948247000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-requireModule-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireModule', function() {\n    pit('finds @providesModule modules', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('provides `module.parent` to modules', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(rootPath, 'RegularModule');\n        expect(exports.parent).toEqual({\n          id: 'mockParent',\n          exports: {},\n        });\n      });\n    });\n\n    pit('throws on non-existant @providesModule modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireModule(rootPath, 'DoesntExist');\n        }).toThrow(\n          new Error('Cannot find module \\'DoesntExist\\' from \\'root.js\\'')\n        );\n      });\n    });\n\n    pit('finds relative-path modules without file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          './RegularModule'\n        );\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('finds relative-path modules with file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          './RegularModule.js'\n        );\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('throws on non-existant relative-path modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireModule(rootPath, './DoesntExist');\n        }).toThrow(\n          new Error('Cannot find module \\'./DoesntExist\\' from \\'root.js\\'')\n        );\n      });\n    });\n\n    pit('finds node core built-in modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireModule(rootPath, 'fs');\n        }).not.toThrow();\n      });\n    });\n\n    pit('finds and loads JSON files without file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(rootPath, './JSONFile');\n        expect(exports.isJSONModule).toBe(true);\n      });\n    });\n\n    pit('finds and loads JSON files with file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          './JSONFile.json'\n        );\n        expect(exports.isJSONModule).toBe(true);\n      });\n    });\n\n    pit('requires a JSON file twice successfully', function() {\n      return buildLoader().then(function(loader) {\n        const exports1 = loader.requireModule(\n          rootPath,\n          './JSONFile.json'\n        );\n        const exports2 = loader.requireModule(\n          rootPath,\n          './JSONFile.json'\n        );\n        expect(exports1.isJSONModule).toBe(true);\n        expect(exports2.isJSONModule).toBe(true);\n        expect(exports1).toBe(exports2);\n      });\n    });\n\n    pit('provides manual mock when real module doesnt exist', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          'ExclusivelyManualMock'\n        );\n        expect(exports.isExclusivelyManualMockModule).toBe(true);\n      });\n    });\n\n    pit(`doesn't override real modules with manual mocks when explicitly marked with .unmock()`, () => {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootPath, './root.js');\n        root.jest.resetModuleRegistry();\n        root.jest.unmock('ManuallyMocked');\n        const exports = loader.requireModule(rootPath, 'ManuallyMocked');\n        expect(exports.isManualMockModule).toBe(false);\n      });\n    });\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-requireModule-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireModule', function() {\n    pit('finds @providesModule modules', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(rootPath, 'RegularModule');\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('provides `module.parent` to modules', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(rootPath, 'RegularModule');\n        expect(exports.parent).toEqual({\n          id: 'mockParent',\n          exports: {},\n        });\n      });\n    });\n\n    pit('throws on non-existant @providesModule modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireModule(rootPath, 'DoesntExist');\n        }).toThrow(\n          new Error('Cannot find module \\'DoesntExist\\' from \\'root.js\\'')\n        );\n      });\n    });\n\n    pit('finds relative-path modules without file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          './RegularModule'\n        );\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('finds relative-path modules with file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          './RegularModule.js'\n        );\n        expect(exports.isRealModule).toBe(true);\n      });\n    });\n\n    pit('throws on non-existant relative-path modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireModule(rootPath, './DoesntExist');\n        }).toThrow(\n          new Error('Cannot find module \\'./DoesntExist\\' from \\'root.js\\'')\n        );\n      });\n    });\n\n    pit('finds node core built-in modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireModule(rootPath, 'fs');\n        }).not.toThrow();\n      });\n    });\n\n    pit('finds and loads JSON files without file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(rootPath, './JSONFile');\n        expect(exports.isJSONModule).toBe(true);\n      });\n    });\n\n    pit('finds and loads JSON files with file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          './JSONFile.json'\n        );\n        expect(exports.isJSONModule).toBe(true);\n      });\n    });\n\n    pit('requires a JSON file twice successfully', function() {\n      return buildLoader().then(function(loader) {\n        const exports1 = loader.requireModule(\n          rootPath,\n          './JSONFile.json'\n        );\n        const exports2 = loader.requireModule(\n          rootPath,\n          './JSONFile.json'\n        );\n        expect(exports1.isJSONModule).toBe(true);\n        expect(exports2.isJSONModule).toBe(true);\n        expect(exports1).toBe(exports2);\n      });\n    });\n\n    pit('provides manual mock when real module doesnt exist', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireModule(\n          rootPath,\n          'ExclusivelyManualMock'\n        );\n        expect(exports.isExclusivelyManualMockModule).toBe(true);\n      });\n    });\n\n    pit(`doesn't override real modules with manual mocks when explicitly marked with .unmock()`, () => {\n      return buildLoader().then(function(loader) {\n        const root = loader.requireModule(rootPath, './root.js');\n        root.jest.resetModuleRegistry();\n        root.jest.unmock('ManuallyMocked');\n        const exports = loader.requireModule(rootPath, 'ManuallyMocked');\n        expect(exports.isManualMockModule).toBe(false);\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-requireModule-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-requireMock-test.js":{"metadata":{"mtime":1456988657000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-requireMock-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireMock', function() {\n    pit('uses manual mocks before attempting to automock', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        expect(exports.isManualMockModule).toBe(true);\n      });\n    });\n\n    pit('can resolve modules that are only referenced from mocks', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        expect(\n          exports.onlyRequiredFromMockModuleValue\n        ).toBe('banana banana banana');\n      });\n    });\n\n    pit('stores and re-uses manual mock exports', function() {\n      return buildLoader().then(function(loader) {\n        let exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        exports.setModuleStateValue('test value');\n        exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        expect(exports.getModuleStateValue()).toBe('test value');\n      });\n    });\n\n    pit('automocks @providesModule modules without a manual mock', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(rootPath, 'RegularModule');\n        expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit('automocks relative-path modules without a file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule'\n        );\n        expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit('automocks relative-path modules with a file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule.js'\n        );\n        expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit('just falls back when loading a native module', function() {\n      return buildLoader().then(function(loader) {\n        let error;\n        // Okay so this is a really WAT way to test this, but we\n        // are going to require an empty .node file which should\n        // throw an error letting us know that the file is too\n        // short. If it does not (it gives another error) then we\n        // are not correctly falling back to 'native' require.\n        try {\n          loader.requireMock(\n            __filename,\n            './test_root/NativeModule.node'\n          );\n        } catch (e) {\n          error = e;\n        } finally {\n          expect(error.message).toMatch(\n            /NativeModule.node\\: file too short|not a valid Win\\d+ application/\n          );\n        }\n      });\n    });\n\n    pit('stores and re-uses automocked @providesModule exports', function() {\n      return buildLoader().then(function(loader) {\n        let exports = loader.requireMock(rootPath, 'RegularModule');\n        exports.externalMutation = 'test value';\n        exports = loader.requireMock(rootPath, 'RegularModule');\n        expect(exports.externalMutation).toBe('test value');\n      });\n    });\n\n    pit('stores and re-uses automocked relative-path modules', function() {\n      return buildLoader().then(function(loader) {\n        let exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule'\n        );\n        exports.externalMutation = 'test value';\n        exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule'\n        );\n        expect(exports.externalMutation).toBe('test value');\n      });\n    });\n\n    pit('multiple node core modules returns correct module', function() {\n      return buildLoader().then(function(loader) {\n        loader.requireMock(rootPath, 'fs');\n        expect(loader.requireMock(rootPath, 'events').EventEmitter).toBeDefined();\n      });\n    });\n\n    pit('throws on non-existant @providesModule modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireMock(rootPath, 'DoesntExist');\n        }).toThrow();\n      });\n    });\n\n    pit('uses the closest manual mock when duplicates exist', function() {\n      return buildLoader().then(function(loader) {\n        const exports1 = loader.requireMock(\n          __dirname,\n          path.resolve(__dirname, './test_root/subdir1/MyModule')\n        );\n        expect(exports1.modulePath).toEqual(\n          'subdir1/__mocks__/MyModule.js'\n        );\n\n        const exports2 = loader.requireMock(\n          __dirname,\n          path.resolve(__dirname, './test_root/subdir2/MyModule')\n        );\n        expect(exports2.modulePath).toEqual(\n          'subdir2/__mocks__/MyModule.js'\n        );\n      });\n    });\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-requireMock-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireMock', function() {\n    pit('uses manual mocks before attempting to automock', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        expect(exports.isManualMockModule).toBe(true);\n      });\n    });\n\n    pit('can resolve modules that are only referenced from mocks', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        expect(\n          exports.onlyRequiredFromMockModuleValue\n        ).toBe('banana banana banana');\n      });\n    });\n\n    pit('stores and re-uses manual mock exports', function() {\n      return buildLoader().then(function(loader) {\n        let exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        exports.setModuleStateValue('test value');\n        exports = loader.requireMock(rootPath, 'ManuallyMocked');\n        expect(exports.getModuleStateValue()).toBe('test value');\n      });\n    });\n\n    pit('automocks @providesModule modules without a manual mock', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(rootPath, 'RegularModule');\n        expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit('automocks relative-path modules without a file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule'\n        );\n        expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit('automocks relative-path modules with a file extension', function() {\n      return buildLoader().then(function(loader) {\n        const exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule.js'\n        );\n        expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n      });\n    });\n\n    pit('just falls back when loading a native module', function() {\n      return buildLoader().then(function(loader) {\n        let error;\n        // Okay so this is a really WAT way to test this, but we\n        // are going to require an empty .node file which should\n        // throw an error letting us know that the file is too\n        // short. If it does not (it gives another error) then we\n        // are not correctly falling back to 'native' require.\n        try {\n          loader.requireMock(\n            __filename,\n            './test_root/NativeModule.node'\n          );\n        } catch (e) {\n          error = e;\n        } finally {\n          expect(error.message).toMatch(\n            /NativeModule.node\\: file too short|not a valid Win\\d+ application/\n          );\n        }\n      });\n    });\n\n    pit('stores and re-uses automocked @providesModule exports', function() {\n      return buildLoader().then(function(loader) {\n        let exports = loader.requireMock(rootPath, 'RegularModule');\n        exports.externalMutation = 'test value';\n        exports = loader.requireMock(rootPath, 'RegularModule');\n        expect(exports.externalMutation).toBe('test value');\n      });\n    });\n\n    pit('stores and re-uses automocked relative-path modules', function() {\n      return buildLoader().then(function(loader) {\n        let exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule'\n        );\n        exports.externalMutation = 'test value';\n        exports = loader.requireMock(\n          __filename,\n          './test_root/RegularModule'\n        );\n        expect(exports.externalMutation).toBe('test value');\n      });\n    });\n\n    pit('multiple node core modules returns correct module', function() {\n      return buildLoader().then(function(loader) {\n        loader.requireMock(rootPath, 'fs');\n        expect(loader.requireMock(rootPath, 'events').EventEmitter).toBeDefined();\n      });\n    });\n\n    pit('throws on non-existant @providesModule modules', function() {\n      return buildLoader().then(function(loader) {\n        expect(function() {\n          loader.requireMock(rootPath, 'DoesntExist');\n        }).toThrow();\n      });\n    });\n\n    pit('uses the closest manual mock when duplicates exist', function() {\n      return buildLoader().then(function(loader) {\n        const exports1 = loader.requireMock(\n          __dirname,\n          path.resolve(__dirname, './test_root/subdir1/MyModule')\n        );\n        expect(exports1.modulePath).toEqual(\n          'subdir1/__mocks__/MyModule.js'\n        );\n\n        const exports2 = loader.requireMock(\n          __dirname,\n          path.resolve(__dirname, './test_root/subdir2/MyModule')\n        );\n        expect(exports2.modulePath).toEqual(\n          'subdir2/__mocks__/MyModule.js'\n        );\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-requireMock-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-NODE_PATH-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-NODE_PATH-tests',\n    rootDir: path.resolve(__dirname, 'test_root'),\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  function initHasteModuleLoader(nodePath) {\n    process.env.NODE_PATH = nodePath;\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  }\n\n  pit('uses NODE_PATH to find modules', function() {\n    const nodePath = __dirname + '/NODE_PATH_dir';\n    initHasteModuleLoader(nodePath);\n    return buildLoader().then(function(loader) {\n      const exports =\n        loader.requireModuleOrMock(rootPath, 'RegularModuleInNodePath');\n      expect(exports).toBeDefined();\n    });\n  });\n\n  pit('finds modules in NODE_PATH containing multiple paths', function() {\n    const cwd = process.cwd();\n    const nodePath = cwd + '/some/other/path' + path.delimiter + __dirname +\n      '/NODE_PATH_dir';\n    initHasteModuleLoader(nodePath);\n    return buildLoader().then(function(loader) {\n      const exports =\n        loader.requireModuleOrMock(rootPath, 'RegularModuleInNodePath');\n      expect(exports).toBeDefined();\n    });\n  });\n\n  pit('doesnt find modules if NODE_PATH is relative', function() {\n    const nodePath = process.cwd().substr(path.sep.length) +\n      'src/HasteModuleLoader/__tests__/NODE_PATH_dir';\n    initHasteModuleLoader(nodePath);\n    return buildLoader().then(function(loader) {\n      expect(() => {\n        loader.requireModuleOrMock(\n          rootPath,\n          'RegularModuleInNodePath'\n        );\n      }).toThrow(\n        new Error(`Cannot find module 'RegularModuleInNodePath' from 'root.js'`)\n      );\n    });\n  });\n\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-NODE_PATH-tests',\n    rootDir: path.resolve(__dirname, 'test_root'),\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  function initHasteModuleLoader(nodePath) {\n    process.env.NODE_PATH = nodePath;\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  }\n\n  pit('uses NODE_PATH to find modules', function() {\n    const nodePath = __dirname + '/NODE_PATH_dir';\n    initHasteModuleLoader(nodePath);\n    return buildLoader().then(function(loader) {\n      const exports =\n        loader.requireModuleOrMock(rootPath, 'RegularModuleInNodePath');\n      expect(exports).toBeDefined();\n    });\n  });\n\n  pit('finds modules in NODE_PATH containing multiple paths', function() {\n    const cwd = process.cwd();\n    const nodePath = cwd + '/some/other/path' + path.delimiter + __dirname +\n      '/NODE_PATH_dir';\n    initHasteModuleLoader(nodePath);\n    return buildLoader().then(function(loader) {\n      const exports =\n        loader.requireModuleOrMock(rootPath, 'RegularModuleInNodePath');\n      expect(exports).toBeDefined();\n    });\n  });\n\n  pit('doesnt find modules if NODE_PATH is relative', function() {\n    const nodePath = process.cwd().substr(path.sep.length) +\n      'src/HasteModuleLoader/__tests__/NODE_PATH_dir';\n    initHasteModuleLoader(nodePath);\n    return buildLoader().then(function(loader) {\n      expect(() => {\n        loader.requireModuleOrMock(\n          rootPath,\n          'RegularModuleInNodePath'\n        );\n      }).toThrow(\n        new Error(`Cannot find module 'RegularModuleInNodePath' from 'root.js'`)\n      );\n    });\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-NODE_PATH-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-jsdom-env-test.js":{"metadata":{"mtime":1456549025000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-jsdom-env-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireModule', function() {\n    pit('emulates a node stack trace during module load', function() {\n      return buildLoader().then(function(loader) {\n        let hasThrown = false;\n        try {\n          loader.requireModule(\n            __filename,\n            './test_root/throwing.js'\n          );\n        } catch (err) {\n          hasThrown = true;\n          expect(err.stack).toMatch(/^Error: throwing\\s+at Object.<anonymous>/);\n        }\n        expect(hasThrown).toBe(true);\n      });\n    });\n\n    pit('emulates a node stack trace during function execution', function() {\n      return buildLoader().then(function(loader) {\n        let hasThrown = false;\n        const sum = loader.requireModule(\n          __filename,\n          './test_root/throwing-fn.js'\n        );\n\n        try {\n          sum();\n        } catch (err) {\n          hasThrown = true;\n\n          if (process.platform === 'win32') {\n            expect(err.stack).toMatch(/^Error: throwing fn\\s+at sum.+HasteModuleLoader\\\\__tests__\\\\test_root\\\\throwing-fn.js:12:9/);\n          } else {\n            expect(err.stack).toMatch(/^Error: throwing fn\\s+at sum.+HasteModuleLoader\\/__tests__\\/test_root\\/throwing-fn.js:12:9/);\n          }\n        }\n        expect(hasThrown).toBe(true);\n      });\n    });\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-jsdom-env-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('requireModule', function() {\n    pit('emulates a node stack trace during module load', function() {\n      return buildLoader().then(function(loader) {\n        let hasThrown = false;\n        try {\n          loader.requireModule(\n            __filename,\n            './test_root/throwing.js'\n          );\n        } catch (err) {\n          hasThrown = true;\n          expect(err.stack).toMatch(/^Error: throwing\\s+at Object.<anonymous>/);\n        }\n        expect(hasThrown).toBe(true);\n      });\n    });\n\n    pit('emulates a node stack trace during function execution', function() {\n      return buildLoader().then(function(loader) {\n        let hasThrown = false;\n        const sum = loader.requireModule(\n          __filename,\n          './test_root/throwing-fn.js'\n        );\n\n        try {\n          sum();\n        } catch (err) {\n          hasThrown = true;\n\n          if (process.platform === 'win32') {\n            expect(err.stack).toMatch(/^Error: throwing fn\\s+at sum.+HasteModuleLoader\\\\__tests__\\\\test_root\\\\throwing-fn.js:12:9/);\n          } else {\n            expect(err.stack).toMatch(/^Error: throwing fn\\s+at sum.+HasteModuleLoader\\/__tests__\\/test_root\\/throwing-fn.js:12:9/);\n          }\n        }\n        expect(hasThrown).toBe(true);\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-jsdom-env-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-getTestEnvData-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-getTestEnvData-tests',\n    rootDir,\n    testEnvData: {someTestData: 42},\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  pit('passes config data through to jest.envData', function() {\n    return buildLoader().then(function(loader) {\n      const root = loader.requireModule(rootDir, rootPath);\n      const envData = root.jest.getTestEnvData();\n      expect(envData).toEqual(config.testEnvData);\n    });\n  });\n\n  pit('freezes jest.envData object', function() {\n    return buildLoader().then(function(loader) {\n      const root = loader.requireModule(rootDir, rootPath);\n      const envData = root.jest.getTestEnvData();\n      expect(Object.isFrozen(envData)).toBe(true);\n    });\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('HasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.join(__dirname, 'test_root');\n  const rootPath = path.join(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'HasteModuleLoader-getTestEnvData-tests',\n    rootDir,\n    testEnvData: {someTestData: 42},\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  pit('passes config data through to jest.envData', function() {\n    return buildLoader().then(function(loader) {\n      const root = loader.requireModule(rootDir, rootPath);\n      const envData = root.jest.getTestEnvData();\n      expect(envData).toEqual(config.testEnvData);\n    });\n  });\n\n  pit('freezes jest.envData object', function() {\n    return buildLoader().then(function(loader) {\n      const root = loader.requireModule(rootDir, rootPath);\n      const envData = root.jest.getTestEnvData();\n      expect(Object.isFrozen(envData)).toBe(true);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-getTestEnvData-test.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-genMockFromModule-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('nodeHasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.resolve(__dirname, 'test_root');\n  const rootPath = path.resolve(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'nodeHasteModuleLoader-genMockFromModule-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('genMockFromModule', function() {\n    pit(\n      'does not cause side effects in the rest of the module system when ' +\n      'generating a mock',\n      function() {\n        return buildLoader().then(loader => {\n          const testRequire = loader.requireModule.bind(loader, rootPath);\n\n          const regularModule = testRequire('RegularModule');\n          const origModuleStateValue = regularModule.getModuleStateValue();\n\n          expect(origModuleStateValue).toBe('default');\n\n          // Generate a mock for a module with side effects\n          const mock = regularModule.jest.genMockFromModule('ModuleWithSideEffects');\n\n          // Make sure we get a mock.\n          expect(mock.fn()).toBe(undefined);\n\n          expect(regularModule.getModuleStateValue()).toBe(\n            origModuleStateValue\n          );\n        });\n      }\n    );\n  });\n});\n","dependencies":["path","../../lib/utils","../HasteModuleLoader","../../resolvers/HasteResolver","../../environments/JSDOMEnvironment","ModuleWithSideEffects"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\njest.mock('../../environments/JSDOMEnvironment');\n\nconst path = require('path');\nconst utils = require('../../lib/utils');\n\ndescribe('nodeHasteModuleLoader', function() {\n  let HasteModuleLoader;\n  let HasteResolver;\n  let JSDOMEnvironment;\n\n  const rootDir = path.resolve(__dirname, 'test_root');\n  const rootPath = path.resolve(rootDir, 'root.js');\n  const config = utils.normalizeConfig({\n    cacheDirectory: global.CACHE_DIRECTORY,\n    name: 'nodeHasteModuleLoader-genMockFromModule-tests',\n    rootDir,\n  });\n\n  function buildLoader() {\n    const environment = new JSDOMEnvironment(config);\n    const resolver = new HasteResolver(config, {resetCache: false});\n    return resolver.getHasteMap().then(\n      response => resolver.end().then(() =>\n        new HasteModuleLoader(config, environment, response)\n      )\n    );\n  }\n\n  beforeEach(function() {\n    HasteModuleLoader = require('../HasteModuleLoader');\n    HasteResolver = require('../../resolvers/HasteResolver');\n    JSDOMEnvironment = require('../../environments/JSDOMEnvironment');\n  });\n\n  describe('genMockFromModule', function() {\n    pit(\n      'does not cause side effects in the rest of the module system when ' +\n      'generating a mock',\n      function() {\n        return buildLoader().then(loader => {\n          const testRequire = loader.requireModule.bind(loader, rootPath);\n\n          const regularModule = testRequire('RegularModule');\n          const origModuleStateValue = regularModule.getModuleStateValue();\n\n          expect(origModuleStateValue).toBe('default');\n\n          // Generate a mock for a module with side effects\n          const mock = regularModule.jest.genMockFromModule('ModuleWithSideEffects');\n\n          // Make sure we get a mock.\n          expect(mock.fn()).toBe(undefined);\n\n          expect(regularModule.getModuleStateValue()).toBe(\n            origModuleStateValue\n          );\n        });\n      }\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-genMockFromModule-test.js"}},"/Users/cpojer/Projects/jest/src/environments/__mocks__/JSDOMEnvironment.js":{"metadata":{"mtime":1451997768000},"data":{"isHaste":false,"moduleData":{"code":"// Copyright 2004-present Facebook. All Rights Reserved.\n\n'use strict';\n\nconst utils = require.requireActual('../../lib/utils');\nconst vm = require.requireActual('vm');\n\nconst JSDOMEnvironment = jest.genMockFromModule('../JSDOMEnvironment');\n\nJSDOMEnvironment.mockImplementation(function(config) {\n  this.global = {\n    console: {},\n    mockClearTimers: jest.genMockFn(),\n    JSON,\n  };\n\n  const globalValues = utils.deepCopy(config.globals);\n  for (const customGlobalKey in globalValues) {\n    this.global[customGlobalKey] = globalValues[customGlobalKey];\n  }\n});\n\nJSDOMEnvironment.prototype.runSourceText.mockImplementation(\n  function(sourceText, filename) {\n    return vm.runInNewContext(sourceText, this.global, {\n      filename,\n      displayErrors: false,\n    });\n  }\n);\n\nmodule.exports = JSDOMEnvironment;\n","dependencies":["../../lib/utils","vm","../JSDOMEnvironment"],"source":"// Copyright 2004-present Facebook. All Rights Reserved.\n\n'use strict';\n\nconst utils = require.requireActual('../../lib/utils');\nconst vm = require.requireActual('vm');\n\nconst JSDOMEnvironment = jest.genMockFromModule('../JSDOMEnvironment');\n\nJSDOMEnvironment.mockImplementation(function(config) {\n  this.global = {\n    console: {},\n    mockClearTimers: jest.genMockFn(),\n    JSON,\n  };\n\n  const globalValues = utils.deepCopy(config.globals);\n  for (const customGlobalKey in globalValues) {\n    this.global[customGlobalKey] = globalValues[customGlobalKey];\n  }\n});\n\nJSDOMEnvironment.prototype.runSourceText.mockImplementation(\n  function(sourceText, filename) {\n    return vm.runInNewContext(sourceText, this.global, {\n      filename,\n      displayErrors: false,\n    });\n  }\n);\n\nmodule.exports = JSDOMEnvironment;\n"},"name":"/Users/cpojer/Projects/jest/src/environments/__mocks__/JSDOMEnvironment.js"}},"/Users/cpojer/Projects/jest/src/environments/__tests__/NodeEnvironment-test.js":{"metadata":{"mtime":1453950894000},"data":{"isHaste":false,"moduleData":{"code":"// Copyright 2004-present Facebook. All Rights Reserved.\n\n'use strict';\n\njest.autoMockOff();\n\nconst NodeEnvironment = require.requireActual('../NodeEnvironment');\n\ndescribe('NodeEnvironment', () => {\n\n  it('uses a copy of the process object', () => {\n    const env1 = new NodeEnvironment({});\n    const env2 = new NodeEnvironment({});\n\n    expect(env1.global.process).not.toBe(env2.global.process);\n  });\n\n  it('exposes process.on', () => {\n    const env1 = new NodeEnvironment({});\n\n    expect(env1.global.process.on).not.toBe(null);\n  });\n\n});\n","dependencies":["../NodeEnvironment"],"source":"// Copyright 2004-present Facebook. All Rights Reserved.\n\n'use strict';\n\njest.autoMockOff();\n\nconst NodeEnvironment = require.requireActual('../NodeEnvironment');\n\ndescribe('NodeEnvironment', () => {\n\n  it('uses a copy of the process object', () => {\n    const env1 = new NodeEnvironment({});\n    const env2 = new NodeEnvironment({});\n\n    expect(env1.global.process).not.toBe(env2.global.process);\n  });\n\n  it('exposes process.on', () => {\n    const env1 = new NodeEnvironment({});\n\n    expect(env1.global.process.on).not.toBe(null);\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/jest/src/environments/__tests__/NodeEnvironment-test.js"}},"/Users/cpojer/Projects/jest/src/__tests__/TestRunner-fs-test.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst utils = require('../lib/utils');\nconst TestRunner = require('../TestRunner');\n\nconst name = 'TestRunner-fs';\n\ndescribe('TestRunner-fs', function() {\n\n  describe('testPathsMatching', function() {\n\n    pit('finds tests with default file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths).toEqual([path.normalize('__testtests__/test.js')]);\n        return runner._resolver.end();\n      });\n    });\n\n    pit('finds tests with similar but custom file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n        testFileExtensions: ['jsx'],\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths).toEqual([path.normalize('__testtests__/test.jsx')]);\n        return runner._resolver.end();\n      });\n    });\n\n    pit('finds tests with totally custom foobar file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n        testFileExtensions: ['foobar'],\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths).toEqual([path.normalize('__testtests__/test.foobar')]);\n        return runner._resolver.end();\n      });\n    });\n\n    pit('finds tests with many kinds of file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n        testFileExtensions: ['js', 'jsx'],\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths.sort()).toEqual([\n          path.normalize('__testtests__/test.js'),\n          path.normalize('__testtests__/test.jsx'),\n        ]);\n        return runner._resolver.end();\n      });\n    });\n\n  });\n\n});\n","dependencies":["path","../lib/utils","../TestRunner"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst utils = require('../lib/utils');\nconst TestRunner = require('../TestRunner');\n\nconst name = 'TestRunner-fs';\n\ndescribe('TestRunner-fs', function() {\n\n  describe('testPathsMatching', function() {\n\n    pit('finds tests with default file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths).toEqual([path.normalize('__testtests__/test.js')]);\n        return runner._resolver.end();\n      });\n    });\n\n    pit('finds tests with similar but custom file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n        testFileExtensions: ['jsx'],\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths).toEqual([path.normalize('__testtests__/test.jsx')]);\n        return runner._resolver.end();\n      });\n    });\n\n    pit('finds tests with totally custom foobar file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n        testFileExtensions: ['foobar'],\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths).toEqual([path.normalize('__testtests__/test.foobar')]);\n        return runner._resolver.end();\n      });\n    });\n\n    pit('finds tests with many kinds of file extensions', function() {\n      const rootDir = path.resolve(__dirname, 'test_root');\n      const runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir,\n        testDirectoryName: '__testtests__',\n        testFileExtensions: ['js', 'jsx'],\n      }));\n      return runner.promiseTestPathsMatching(/.*/).then(function(paths) {\n        const relPaths = paths.map(function(absPath) {\n          return path.relative(rootDir, absPath);\n        });\n        expect(relPaths.sort()).toEqual([\n          path.normalize('__testtests__/test.js'),\n          path.normalize('__testtests__/test.jsx'),\n        ]);\n        return runner._resolver.end();\n      });\n    });\n\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/jest/src/__tests__/TestRunner-fs-test.js"}},"/Users/cpojer/Projects/jest/src/environments/NodeEnvironment.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst FakeTimers = require('../lib/FakeTimers');\nconst installCommonGlobals = require('./installCommonGlobals');\nconst vm = require('vm');\n\nclass NodeEnvironment {\n\n  constructor(config) {\n    this.global = {};\n    vm.createContext(this.global);\n    this.global.setTimeout = setTimeout;\n    this.global.clearTimeout = clearTimeout;\n    this.global.setInterval = setInterval;\n    this.global.clearInterval = clearInterval;\n    this.global.Promise = Promise;\n    this.global.JSON = JSON;\n    installCommonGlobals(this.global, config.globals);\n    this.fakeTimers = new FakeTimers(this.global);\n  }\n\n  dispose() {\n    this.global = null;\n    this.fakeTimers = null;\n  }\n\n  runSourceText(sourceText, filename) {\n    return vm.runInContext(sourceText, this.global, {\n      filename,\n      displayErrors: false,\n    });\n  }\n\n  runWithRealTimers(callback) {\n    if (this.global) {\n      this.fakeTimers.runWithRealTimers(callback);\n    }\n  }\n\n}\n\nmodule.exports = NodeEnvironment;\n","dependencies":["../lib/FakeTimers","./installCommonGlobals","vm"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst FakeTimers = require('../lib/FakeTimers');\nconst installCommonGlobals = require('./installCommonGlobals');\nconst vm = require('vm');\n\nclass NodeEnvironment {\n\n  constructor(config) {\n    this.global = {};\n    vm.createContext(this.global);\n    this.global.setTimeout = setTimeout;\n    this.global.clearTimeout = clearTimeout;\n    this.global.setInterval = setInterval;\n    this.global.clearInterval = clearInterval;\n    this.global.Promise = Promise;\n    this.global.JSON = JSON;\n    installCommonGlobals(this.global, config.globals);\n    this.fakeTimers = new FakeTimers(this.global);\n  }\n\n  dispose() {\n    this.global = null;\n    this.fakeTimers = null;\n  }\n\n  runSourceText(sourceText, filename) {\n    return vm.runInContext(sourceText, this.global, {\n      filename,\n      displayErrors: false,\n    });\n  }\n\n  runWithRealTimers(callback) {\n    if (this.global) {\n      this.fakeTimers.runWithRealTimers(callback);\n    }\n  }\n\n}\n\nmodule.exports = NodeEnvironment;\n"},"name":"/Users/cpojer/Projects/jest/src/environments/NodeEnvironment.js"}},"/Users/cpojer/Projects/jest/src/environments/installCommonGlobals.js":{"metadata":{"mtime":1456381445000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst utils = require('../lib/utils');\n\nmodule.exports = (global, globals) => {\n  // Forward some APIs\n  global.Buffer = Buffer;\n  // `global.process` is mutated by FakeTimers. Make a copy of the\n  // object for the jsdom environment to prevent memory leaks.\n  global.process                    = Object.assign({}, process);\n\n  // Correctly bind all EventEmitter functions\n  global.process.setMaxListeners    = process.setMaxListeners.bind(process);\n  global.process.getMaxListeners    = process.getMaxListeners.bind(process);\n  global.process.emit               = process.emit.bind(process);\n  global.process.addListener        = process.addListener.bind(process);\n  global.process.on                 = process.on.bind(process);\n  global.process.once               = process.once.bind(process);\n  global.process.removeListener     = process.removeListener.bind(process);\n  global.process.removeAllListeners = process.removeAllListeners.bind(process);\n  global.process.listeners          = process.listeners.bind(process);\n  global.process.listenerCount      = process.listenerCount.bind(process);\n\n  global.setImmediate               = setImmediate;\n  global.clearImmediate             = clearImmediate;\n\n  Object.assign(global, utils.deepCopy(globals));\n};\n","dependencies":["../lib/utils"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst utils = require('../lib/utils');\n\nmodule.exports = (global, globals) => {\n  // Forward some APIs\n  global.Buffer = Buffer;\n  // `global.process` is mutated by FakeTimers. Make a copy of the\n  // object for the jsdom environment to prevent memory leaks.\n  global.process                    = Object.assign({}, process);\n\n  // Correctly bind all EventEmitter functions\n  global.process.setMaxListeners    = process.setMaxListeners.bind(process);\n  global.process.getMaxListeners    = process.getMaxListeners.bind(process);\n  global.process.emit               = process.emit.bind(process);\n  global.process.addListener        = process.addListener.bind(process);\n  global.process.on                 = process.on.bind(process);\n  global.process.once               = process.once.bind(process);\n  global.process.removeListener     = process.removeListener.bind(process);\n  global.process.removeAllListeners = process.removeAllListeners.bind(process);\n  global.process.listeners          = process.listeners.bind(process);\n  global.process.listenerCount      = process.listenerCount.bind(process);\n\n  global.setImmediate               = setImmediate;\n  global.clearImmediate             = clearImmediate;\n\n  Object.assign(global, utils.deepCopy(globals));\n};\n"},"name":"/Users/cpojer/Projects/jest/src/environments/installCommonGlobals.js"}},"/Users/cpojer/Projects/jest/src/lib/promisify.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nmodule.exports = function promisify(fn) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n    return new Promise((resolve, reject) => {\n      args.push((err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(this, args);\n    });\n  };\n};\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nmodule.exports = function promisify(fn) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n    return new Promise((resolve, reject) => {\n      args.push((err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(this, args);\n    });\n  };\n};\n"},"name":"/Users/cpojer/Projects/jest/src/lib/promisify.js"}},"/Users/cpojer/Projects/jest/src/lib/moduleMocker.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst RESERVED_KEYWORDS = [\n  'do',\n  'if',\n  'in',\n  'for',\n  'let',\n  'new',\n  'try',\n  'var',\n  'case',\n  'else',\n  'enum',\n  'eval',\n  'null',\n  'this',\n  'true',\n  'void',\n  'with',\n  'await',\n  'break',\n  'catch',\n  'class',\n  'const',\n  'false',\n  'super',\n  'throw',\n  'while',\n  'yield',\n  'delete',\n  'export',\n  'import',\n  'public',\n  'return',\n  'static',\n  'switch',\n  'typeof',\n  'default',\n  'extends',\n  'finally',\n  'package',\n  'private',\n  'continue',\n  'debugger',\n  'function',\n  'arguments',\n  'interface',\n  'protected',\n  'implements',\n  'instanceof',\n];\n\nfunction isA(typeName, value) {\n  return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n}\n\nfunction getType(ref) {\n  if (isA('Function', ref)) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (isA('Object', ref)) {\n    return 'object';\n  } else if (isA('Number', ref) || isA('String', ref) || isA('Boolean', ref)) {\n    return 'constant';\n  } else if (isA('Map', ref) || isA('WeakMap', ref) || isA('Set', ref)) {\n    return 'collection';\n  } else if (isA('RegExp', ref)) {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  return (\n    (\n      (\n        prop === 'arguments' ||\n        prop === 'caller' ||\n        prop === 'callee' ||\n        prop === 'name' ||\n        prop === 'length'\n      ) &&\n      isA('Function', object)\n    ) ||\n    (\n      (\n        prop === 'source' ||\n        prop === 'global' ||\n        prop === 'ignoreCase' ||\n        prop === 'multiline'\n      ) &&\n      isA('RegExp', object)\n    )\n  );\n}\n\nfunction getSlots(object) {\n  const slots = {};\n  if (!object) {\n    return [];\n  }\n\n  let parent = Object.getPrototypeOf(object);\n  do {\n    if (object === Function.prototype) {\n      break;\n    }\n    const ownNames = Object.getOwnPropertyNames(object);\n    for (let i = 0; i < ownNames.length; i++) {\n      const prop = ownNames[i];\n      if (!isReadonlyProp(object, prop)) {\n        const propDesc = Object.getOwnPropertyDescriptor(object, prop);\n        if (!propDesc.get) {\n          slots[prop] = true;\n        }\n      }\n    }\n    object = parent;\n  } while (object && (parent = Object.getPrototypeOf(object)) !== null);\n  return Object.keys(slots);\n}\n\nfunction createMockFunction(metadata, mockConstructor) {\n  let name = metadata.name;\n  if (!name) {\n    return mockConstructor;\n  }\n\n  // Preserve `name` property of mocked function.\n  const boundFunctionPrefix = 'bound ';\n  let bindCall = '';\n  // if-do-while for perf reasons. The common case is for the if to fail.\n  if (name && name.startsWith(boundFunctionPrefix)) {\n    do {\n      name = name.substring(boundFunctionPrefix.length);\n      // Call bind() just to alter the function name.\n      bindCall = '.bind(null)';\n    } while (name && name.startsWith(boundFunctionPrefix));\n  }\n\n  // It's a syntax error to define functions with a reserved keyword\n  // as name.\n  if (RESERVED_KEYWORDS.indexOf(name) !== -1) {\n    name = '$' + name;\n  }\n\n  /* eslint-disable no-new-func */\n  return new Function(\n    'mockConstructor',\n    'return function ' + name + '() {' +\n      'return mockConstructor.apply(this,arguments);' +\n    '}' + bindCall\n  )(mockConstructor);\n  /* eslint-enable no-new-func */\n}\n\nfunction makeComponent(metadata) {\n  if (metadata.type === 'object') {\n    return {};\n  } else if (metadata.type === 'array') {\n    return [];\n  } else if (metadata.type === 'regexp') {\n    return new RegExp();\n  } else if (\n    metadata.type === 'constant' ||\n    metadata.type === 'collection' ||\n    metadata.type === 'null' ||\n    metadata.type === 'undefined'\n  ) {\n    return metadata.value;\n  } else if (metadata.type === 'function') {\n    let isReturnValueLastSet = false;\n    let defaultReturnValue;\n    let mockImpl;\n    let f;\n    const specificReturnValues = [];\n    const calls = [];\n    const instances = [];\n    const prototype = (\n      metadata.members &&\n      metadata.members.prototype &&\n      metadata.members.prototype.members\n    ) || {};\n    const prototypeSlots = getSlots(prototype);\n    const mockConstructor = function() {\n      instances.push(this);\n      calls.push(Array.prototype.slice.call(arguments));\n      if (this instanceof f) {\n        // This is probably being called as a constructor\n        prototypeSlots.forEach(slot => {\n          // Copy prototype methods to the instance to make\n          // it easier to interact with mock instance call and\n          // return values\n          if (prototype[slot].type === 'function') {\n            const protoImpl = this[slot];\n            this[slot] = generateFromMetadata(prototype[slot]);\n            this[slot]._protoImpl = protoImpl;\n          }\n        });\n\n        // Run the mock constructor implementation\n        return mockImpl && mockImpl.apply(this, arguments);\n      }\n\n      let returnValue;\n      // If return value is last set, either specific or default, i.e.\n      // mockReturnValueOnce()/mockReturnValue() is called and no\n      // mockImplementation() is called after that.\n      // use the set return value.\n      if (isReturnValueLastSet) {\n        returnValue = specificReturnValues.shift();\n        if (returnValue === undefined) {\n          returnValue = defaultReturnValue;\n        }\n      }\n\n      // If mockImplementation() is last set, or specific return values\n      // are used up, use the mock implementation.\n      if (mockImpl && returnValue === undefined) {\n        return mockImpl.apply(this, arguments);\n      }\n\n      // Otherwise use prototype implementation\n      if (returnValue === undefined && f._protoImpl) {\n        return f._protoImpl.apply(this, arguments);\n      }\n\n      return returnValue;\n    };\n\n    f = createMockFunction(metadata, mockConstructor);\n    f._isMockFunction = true;\n    f._getMockImplementation = () => mockImpl;\n    f.mock = {calls, instances};\n\n    f.mockClear = () => {\n      calls.length = 0;\n      instances.length = 0;\n    };\n\n    f.mockReturnValueOnce = value => {\n      // next function call will return this value or default return value\n      isReturnValueLastSet = true;\n      specificReturnValues.push(value);\n      return f;\n    };\n\n    f.mockReturnValue = value => {\n      // next function call will return specified return value or this one\n      isReturnValueLastSet = true;\n      defaultReturnValue = value;\n      return f;\n    };\n\n    f.mockImplementation = f.mockImpl = fn => {\n      // next function call will use mock implementation return value\n      isReturnValueLastSet = false;\n      mockImpl = fn;\n      return f;\n    };\n\n    f.mockReturnThis = () =>\n      f.mockImplementation(function() {\n        return this;\n      });\n\n    if (metadata.mockImpl) {\n      f.mockImplementation(metadata.mockImpl);\n    }\n\n    return f;\n  } else {\n    throw new Error('Unrecognized type ' + metadata.type);\n  }\n}\n\nfunction generateMock(metadata, callbacks, refs) {\n  const mock = makeComponent(metadata);\n  if (metadata.refID != null) {\n    refs[metadata.refID] = mock;\n  }\n\n  getSlots(metadata.members).forEach(slot => {\n    const slotMetadata = metadata.members[slot];\n    if (slotMetadata.ref != null) {\n      callbacks.push(() => mock[slot] = refs[slotMetadata.ref]);\n    } else {\n      mock[slot] = generateMock(slotMetadata, callbacks, refs);\n    }\n  });\n\n  if (\n    metadata.type !== 'undefined' &&\n    metadata.type !== 'null' &&\n    mock.prototype\n  ) {\n    mock.prototype.constructor = mock;\n  }\n\n  return mock;\n}\n\nfunction generateFromMetadata(_metadata) {\n  const callbacks = [];\n  const refs = {};\n  const mock = generateMock(_metadata, callbacks, refs);\n  callbacks.forEach(setter => setter());\n  return mock;\n}\n\nfunction getMetadata(component, _refs) {\n  const refs = _refs || new Map();\n  const ref = refs.get(component);\n  if (ref != null) {\n    return {ref};\n  }\n\n  const type = getType(component);\n  if (!type) {\n    return null;\n  }\n\n  const metadata = {type: type};\n  if (\n    type === 'constant' ||\n    type === 'collection' ||\n    type === 'undefined' ||\n    type === 'null'\n  ) {\n    metadata.value = component;\n    return metadata;\n  } else if (type === 'function') {\n    metadata.name = component.name;\n    if (component._isMockFunction) {\n      metadata.mockImpl = component._getMockImplementation();\n    }\n  }\n\n  metadata.refID = refs.size;\n  refs.set(component, metadata.refID);\n\n  let members = null;\n  // Leave arrays alone\n  if (type !== 'array') {\n    if (type !== 'undefined') {\n      getSlots(component).forEach(slot => {\n        if (\n          type === 'function' &&\n          component._isMockFunction &&\n          slot.match(/^mock/)\n        ) {\n          return;\n        }\n\n        if (\n          (!component.hasOwnProperty && component[slot] !== undefined) ||\n          (component.hasOwnProperty && component.hasOwnProperty(slot)) ||\n          (type === 'object' && component[slot] != Object.prototype[slot])\n        ) {\n          const slotMetadata = getMetadata(component[slot], refs);\n          if (slotMetadata) {\n            if (!members) {\n              members = {};\n            }\n            members[slot] = slotMetadata;\n          }\n        }\n      });\n    }\n\n    // If component is native code function, prototype might be undefined\n    if (type === 'function' && component.prototype) {\n      const prototype = getMetadata(component.prototype, refs);\n      if (prototype && prototype.members) {\n        if (!members) {\n          members = {};\n        }\n        members.prototype = prototype;\n      }\n    }\n  }\n\n  if (members) {\n    metadata.members = members;\n  }\n\n  return metadata;\n}\n\nmodule.exports = {\n  /**\n   * Generates a mock based on the given metadata. Mocks treat functions\n   * specially, and all mock functions have additional members, described in the\n   * documentation for getMockFunction in this module.\n   *\n   * One important note: function prototoypes are handled specially by this\n   * mocking framework. For functions with prototypes, when called as a\n   * constructor, the mock will install mocked function members on the instance.\n   * This allows different instances of the same constructor to have different\n   * values for its mocks member and its return values.\n   *\n   * @param metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   *\n   */\n  generateFromMetadata,\n\n  /**\n   * Inspects the argument and returns its schema in the following recursive\n   * format:\n   * {\n   *  type: ...\n   *  members : {}\n   * }\n   *\n   * Where type is one of 'array', 'object', 'function', or 'ref', and members\n   * is an optional dictionary where the keys are member names and the values\n   * are metadata objects. Function prototypes are defined simply by defining\n   * metadata for the member.prototype of the function. The type of a function\n   * prototype should always be \"object\". For instance, a simple class might be\n   * defined like this:\n   *\n   * {\n   *  type: 'function',\n   *  members: {\n   *    staticMethod: {type: 'function'},\n   *    prototype: {\n   *      type: 'object',\n   *      members: {\n   *        instanceMethod: {type: 'function'}\n   *      }\n   *    }\n   *  }\n   * }\n   *\n   * Metadata may also contain references to other objects defined within the\n   * same metadata object. The metadata for the referent must be marked with\n   * 'refID' key and an arbitrary value. The referer must be marked with a\n   * 'ref' key that has the same value as object with refID that it refers to.\n   * For instance, this metadata blob:\n   * {\n   *  type: 'object',\n   *  refID: 1,\n   *  members: {\n   *    self: {ref: 1}\n   *  }\n   * }\n   *\n   * defines an object with a slot named 'self' that refers back to the object.\n   *\n   * @param component The component for which to retrieve metadata.\n   */\n  getMetadata(component) {\n    return getMetadata(component);\n  },\n\n  /**\n   * Generates a stand-alone function with members that help drive unit tests or\n   * confirm expectations. Specifically, functions returned by this method have\n   * the following members:\n   *\n   * .mock:\n   * An object with two members, \"calls\", and \"instances\", which are both\n   * lists. The items in the \"calls\" list are the arguments with which the\n   * function was called. The \"instances\" list stores the value of 'this' for\n   * each call to the function. This is useful for retrieving instances from a\n   * constructor.\n   *\n   * .mockReturnValueOnce(value)\n   * Pushes the given value onto a FIFO queue of return values for the\n   * function.\n   *\n   * .mockReturnValue(value)\n   * Sets the default return value for the function.\n   *\n   * .mockImplementation(function)\n   * Sets a mock implementation for the function.\n   *\n   * .mockReturnThis()\n   * Syntactic sugar for .mockImplementation(function() {return this;})\n   *\n   * In case both mockImplementation() and\n   * mockReturnValueOnce()/mockReturnValue() are called. The priority of\n   * which to use is based on what is the last call:\n   * - if the last call is mockReturnValueOnce() or mockReturnValue(),\n   *   use the specific return specific return value or default return value.\n   *   If specific return values are used up or no default return value is set,\n   *   fall back to try mockImplementation();\n   * - if the last call is mockImplementation(), run the given implementation\n   *   and return the result.\n   */\n  getMockFunction() {\n    return makeComponent({type: 'function'});\n  },\n\n  // Just a short-hand alias\n  getMockFn() {\n    return this.getMockFunction();\n  },\n};\n","dependencies":[],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst RESERVED_KEYWORDS = [\n  'do',\n  'if',\n  'in',\n  'for',\n  'let',\n  'new',\n  'try',\n  'var',\n  'case',\n  'else',\n  'enum',\n  'eval',\n  'null',\n  'this',\n  'true',\n  'void',\n  'with',\n  'await',\n  'break',\n  'catch',\n  'class',\n  'const',\n  'false',\n  'super',\n  'throw',\n  'while',\n  'yield',\n  'delete',\n  'export',\n  'import',\n  'public',\n  'return',\n  'static',\n  'switch',\n  'typeof',\n  'default',\n  'extends',\n  'finally',\n  'package',\n  'private',\n  'continue',\n  'debugger',\n  'function',\n  'arguments',\n  'interface',\n  'protected',\n  'implements',\n  'instanceof',\n];\n\nfunction isA(typeName, value) {\n  return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n}\n\nfunction getType(ref) {\n  if (isA('Function', ref)) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (isA('Object', ref)) {\n    return 'object';\n  } else if (isA('Number', ref) || isA('String', ref) || isA('Boolean', ref)) {\n    return 'constant';\n  } else if (isA('Map', ref) || isA('WeakMap', ref) || isA('Set', ref)) {\n    return 'collection';\n  } else if (isA('RegExp', ref)) {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  return (\n    (\n      (\n        prop === 'arguments' ||\n        prop === 'caller' ||\n        prop === 'callee' ||\n        prop === 'name' ||\n        prop === 'length'\n      ) &&\n      isA('Function', object)\n    ) ||\n    (\n      (\n        prop === 'source' ||\n        prop === 'global' ||\n        prop === 'ignoreCase' ||\n        prop === 'multiline'\n      ) &&\n      isA('RegExp', object)\n    )\n  );\n}\n\nfunction getSlots(object) {\n  const slots = {};\n  if (!object) {\n    return [];\n  }\n\n  let parent = Object.getPrototypeOf(object);\n  do {\n    if (object === Function.prototype) {\n      break;\n    }\n    const ownNames = Object.getOwnPropertyNames(object);\n    for (let i = 0; i < ownNames.length; i++) {\n      const prop = ownNames[i];\n      if (!isReadonlyProp(object, prop)) {\n        const propDesc = Object.getOwnPropertyDescriptor(object, prop);\n        if (!propDesc.get) {\n          slots[prop] = true;\n        }\n      }\n    }\n    object = parent;\n  } while (object && (parent = Object.getPrototypeOf(object)) !== null);\n  return Object.keys(slots);\n}\n\nfunction createMockFunction(metadata, mockConstructor) {\n  let name = metadata.name;\n  if (!name) {\n    return mockConstructor;\n  }\n\n  // Preserve `name` property of mocked function.\n  const boundFunctionPrefix = 'bound ';\n  let bindCall = '';\n  // if-do-while for perf reasons. The common case is for the if to fail.\n  if (name && name.startsWith(boundFunctionPrefix)) {\n    do {\n      name = name.substring(boundFunctionPrefix.length);\n      // Call bind() just to alter the function name.\n      bindCall = '.bind(null)';\n    } while (name && name.startsWith(boundFunctionPrefix));\n  }\n\n  // It's a syntax error to define functions with a reserved keyword\n  // as name.\n  if (RESERVED_KEYWORDS.indexOf(name) !== -1) {\n    name = '$' + name;\n  }\n\n  /* eslint-disable no-new-func */\n  return new Function(\n    'mockConstructor',\n    'return function ' + name + '() {' +\n      'return mockConstructor.apply(this,arguments);' +\n    '}' + bindCall\n  )(mockConstructor);\n  /* eslint-enable no-new-func */\n}\n\nfunction makeComponent(metadata) {\n  if (metadata.type === 'object') {\n    return {};\n  } else if (metadata.type === 'array') {\n    return [];\n  } else if (metadata.type === 'regexp') {\n    return new RegExp();\n  } else if (\n    metadata.type === 'constant' ||\n    metadata.type === 'collection' ||\n    metadata.type === 'null' ||\n    metadata.type === 'undefined'\n  ) {\n    return metadata.value;\n  } else if (metadata.type === 'function') {\n    let isReturnValueLastSet = false;\n    let defaultReturnValue;\n    let mockImpl;\n    let f;\n    const specificReturnValues = [];\n    const calls = [];\n    const instances = [];\n    const prototype = (\n      metadata.members &&\n      metadata.members.prototype &&\n      metadata.members.prototype.members\n    ) || {};\n    const prototypeSlots = getSlots(prototype);\n    const mockConstructor = function() {\n      instances.push(this);\n      calls.push(Array.prototype.slice.call(arguments));\n      if (this instanceof f) {\n        // This is probably being called as a constructor\n        prototypeSlots.forEach(slot => {\n          // Copy prototype methods to the instance to make\n          // it easier to interact with mock instance call and\n          // return values\n          if (prototype[slot].type === 'function') {\n            const protoImpl = this[slot];\n            this[slot] = generateFromMetadata(prototype[slot]);\n            this[slot]._protoImpl = protoImpl;\n          }\n        });\n\n        // Run the mock constructor implementation\n        return mockImpl && mockImpl.apply(this, arguments);\n      }\n\n      let returnValue;\n      // If return value is last set, either specific or default, i.e.\n      // mockReturnValueOnce()/mockReturnValue() is called and no\n      // mockImplementation() is called after that.\n      // use the set return value.\n      if (isReturnValueLastSet) {\n        returnValue = specificReturnValues.shift();\n        if (returnValue === undefined) {\n          returnValue = defaultReturnValue;\n        }\n      }\n\n      // If mockImplementation() is last set, or specific return values\n      // are used up, use the mock implementation.\n      if (mockImpl && returnValue === undefined) {\n        return mockImpl.apply(this, arguments);\n      }\n\n      // Otherwise use prototype implementation\n      if (returnValue === undefined && f._protoImpl) {\n        return f._protoImpl.apply(this, arguments);\n      }\n\n      return returnValue;\n    };\n\n    f = createMockFunction(metadata, mockConstructor);\n    f._isMockFunction = true;\n    f._getMockImplementation = () => mockImpl;\n    f.mock = {calls, instances};\n\n    f.mockClear = () => {\n      calls.length = 0;\n      instances.length = 0;\n    };\n\n    f.mockReturnValueOnce = value => {\n      // next function call will return this value or default return value\n      isReturnValueLastSet = true;\n      specificReturnValues.push(value);\n      return f;\n    };\n\n    f.mockReturnValue = value => {\n      // next function call will return specified return value or this one\n      isReturnValueLastSet = true;\n      defaultReturnValue = value;\n      return f;\n    };\n\n    f.mockImplementation = f.mockImpl = fn => {\n      // next function call will use mock implementation return value\n      isReturnValueLastSet = false;\n      mockImpl = fn;\n      return f;\n    };\n\n    f.mockReturnThis = () =>\n      f.mockImplementation(function() {\n        return this;\n      });\n\n    if (metadata.mockImpl) {\n      f.mockImplementation(metadata.mockImpl);\n    }\n\n    return f;\n  } else {\n    throw new Error('Unrecognized type ' + metadata.type);\n  }\n}\n\nfunction generateMock(metadata, callbacks, refs) {\n  const mock = makeComponent(metadata);\n  if (metadata.refID != null) {\n    refs[metadata.refID] = mock;\n  }\n\n  getSlots(metadata.members).forEach(slot => {\n    const slotMetadata = metadata.members[slot];\n    if (slotMetadata.ref != null) {\n      callbacks.push(() => mock[slot] = refs[slotMetadata.ref]);\n    } else {\n      mock[slot] = generateMock(slotMetadata, callbacks, refs);\n    }\n  });\n\n  if (\n    metadata.type !== 'undefined' &&\n    metadata.type !== 'null' &&\n    mock.prototype\n  ) {\n    mock.prototype.constructor = mock;\n  }\n\n  return mock;\n}\n\nfunction generateFromMetadata(_metadata) {\n  const callbacks = [];\n  const refs = {};\n  const mock = generateMock(_metadata, callbacks, refs);\n  callbacks.forEach(setter => setter());\n  return mock;\n}\n\nfunction getMetadata(component, _refs) {\n  const refs = _refs || new Map();\n  const ref = refs.get(component);\n  if (ref != null) {\n    return {ref};\n  }\n\n  const type = getType(component);\n  if (!type) {\n    return null;\n  }\n\n  const metadata = {type: type};\n  if (\n    type === 'constant' ||\n    type === 'collection' ||\n    type === 'undefined' ||\n    type === 'null'\n  ) {\n    metadata.value = component;\n    return metadata;\n  } else if (type === 'function') {\n    metadata.name = component.name;\n    if (component._isMockFunction) {\n      metadata.mockImpl = component._getMockImplementation();\n    }\n  }\n\n  metadata.refID = refs.size;\n  refs.set(component, metadata.refID);\n\n  let members = null;\n  // Leave arrays alone\n  if (type !== 'array') {\n    if (type !== 'undefined') {\n      getSlots(component).forEach(slot => {\n        if (\n          type === 'function' &&\n          component._isMockFunction &&\n          slot.match(/^mock/)\n        ) {\n          return;\n        }\n\n        if (\n          (!component.hasOwnProperty && component[slot] !== undefined) ||\n          (component.hasOwnProperty && component.hasOwnProperty(slot)) ||\n          (type === 'object' && component[slot] != Object.prototype[slot])\n        ) {\n          const slotMetadata = getMetadata(component[slot], refs);\n          if (slotMetadata) {\n            if (!members) {\n              members = {};\n            }\n            members[slot] = slotMetadata;\n          }\n        }\n      });\n    }\n\n    // If component is native code function, prototype might be undefined\n    if (type === 'function' && component.prototype) {\n      const prototype = getMetadata(component.prototype, refs);\n      if (prototype && prototype.members) {\n        if (!members) {\n          members = {};\n        }\n        members.prototype = prototype;\n      }\n    }\n  }\n\n  if (members) {\n    metadata.members = members;\n  }\n\n  return metadata;\n}\n\nmodule.exports = {\n  /**\n   * Generates a mock based on the given metadata. Mocks treat functions\n   * specially, and all mock functions have additional members, described in the\n   * documentation for getMockFunction in this module.\n   *\n   * One important note: function prototoypes are handled specially by this\n   * mocking framework. For functions with prototypes, when called as a\n   * constructor, the mock will install mocked function members on the instance.\n   * This allows different instances of the same constructor to have different\n   * values for its mocks member and its return values.\n   *\n   * @param metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   *\n   */\n  generateFromMetadata,\n\n  /**\n   * Inspects the argument and returns its schema in the following recursive\n   * format:\n   * {\n   *  type: ...\n   *  members : {}\n   * }\n   *\n   * Where type is one of 'array', 'object', 'function', or 'ref', and members\n   * is an optional dictionary where the keys are member names and the values\n   * are metadata objects. Function prototypes are defined simply by defining\n   * metadata for the member.prototype of the function. The type of a function\n   * prototype should always be \"object\". For instance, a simple class might be\n   * defined like this:\n   *\n   * {\n   *  type: 'function',\n   *  members: {\n   *    staticMethod: {type: 'function'},\n   *    prototype: {\n   *      type: 'object',\n   *      members: {\n   *        instanceMethod: {type: 'function'}\n   *      }\n   *    }\n   *  }\n   * }\n   *\n   * Metadata may also contain references to other objects defined within the\n   * same metadata object. The metadata for the referent must be marked with\n   * 'refID' key and an arbitrary value. The referer must be marked with a\n   * 'ref' key that has the same value as object with refID that it refers to.\n   * For instance, this metadata blob:\n   * {\n   *  type: 'object',\n   *  refID: 1,\n   *  members: {\n   *    self: {ref: 1}\n   *  }\n   * }\n   *\n   * defines an object with a slot named 'self' that refers back to the object.\n   *\n   * @param component The component for which to retrieve metadata.\n   */\n  getMetadata(component) {\n    return getMetadata(component);\n  },\n\n  /**\n   * Generates a stand-alone function with members that help drive unit tests or\n   * confirm expectations. Specifically, functions returned by this method have\n   * the following members:\n   *\n   * .mock:\n   * An object with two members, \"calls\", and \"instances\", which are both\n   * lists. The items in the \"calls\" list are the arguments with which the\n   * function was called. The \"instances\" list stores the value of 'this' for\n   * each call to the function. This is useful for retrieving instances from a\n   * constructor.\n   *\n   * .mockReturnValueOnce(value)\n   * Pushes the given value onto a FIFO queue of return values for the\n   * function.\n   *\n   * .mockReturnValue(value)\n   * Sets the default return value for the function.\n   *\n   * .mockImplementation(function)\n   * Sets a mock implementation for the function.\n   *\n   * .mockReturnThis()\n   * Syntactic sugar for .mockImplementation(function() {return this;})\n   *\n   * In case both mockImplementation() and\n   * mockReturnValueOnce()/mockReturnValue() are called. The priority of\n   * which to use is based on what is the last call:\n   * - if the last call is mockReturnValueOnce() or mockReturnValue(),\n   *   use the specific return specific return value or default return value.\n   *   If specific return values are used up or no default return value is set,\n   *   fall back to try mockImplementation();\n   * - if the last call is mockImplementation(), run the given implementation\n   *   and return the result.\n   */\n  getMockFunction() {\n    return makeComponent({type: 'function'});\n  },\n\n  // Just a short-hand alias\n  getMockFn() {\n    return this.getMockFunction();\n  },\n};\n"},"name":"/Users/cpojer/Projects/jest/src/lib/moduleMocker.js"}},"/Users/cpojer/Projects/jest/src/lib/getCacheKey.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst version = require('../../package').version;\n\nmodule.exports = function(name, config) {\n  return [\n    name,\n    version,\n    config.name,\n    config.testPathDirs.join(';'),\n    config.cacheDirectory,\n    config.modulePathIgnorePatterns.toString(),\n    config.moduleFileExtensions.toString(),\n    config.testFileExtensions.toString(),\n  ].join('$');\n};\n","dependencies":["../../package"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst version = require('../../package').version;\n\nmodule.exports = function(name, config) {\n  return [\n    name,\n    version,\n    config.name,\n    config.testPathDirs.join(';'),\n    config.cacheDirectory,\n    config.modulePathIgnorePatterns.toString(),\n    config.moduleFileExtensions.toString(),\n    config.testFileExtensions.toString(),\n  ].join('$');\n};\n"},"name":"/Users/cpojer/Projects/jest/src/lib/getCacheKey.js"}},"/Users/cpojer/Projects/jest/src/lib/formatTestResults.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst utils = require('./utils');\n\nconst formatResult = (testResult, codeCoverageFormatter, reporter) => {\n  const output = {\n    name: testResult.testFilePath,\n    summary: '', // TODO\n    message: '',\n  };\n\n  if (testResult.testExecError) {\n    const currTime = Date.now();\n    output.status = 'failed';\n    output.message = testResult.testExecError;\n    output.startTime = currTime;\n    output.endTime = currTime;\n    output.coverage = {};\n  } else {\n    const allTestsPassed = testResult.numFailingTests === 0;\n    output.status = allTestsPassed ? 'passed' : 'failed';\n    output.startTime = testResult.perfStats.start;\n    output.endTime = testResult.perfStats.end;\n    output.coverage = codeCoverageFormatter(testResult.coverage, reporter);\n\n    if (!allTestsPassed) {\n      output.message = utils.formatFailureMessage(testResult, {\n        rootPath: '',\n        useColor: false,\n      });\n    }\n  }\n\n  return output;\n};\n\n/**\n * @callback codeCoverageFormatter\n * @param {*} results\n * @param {*} reporter - an instance of the testReporter\n */\n\n/**\n * Formats the test results.\n * @param {*} results - a results hash determined by the reporter\n * @param {codeCoverageFormatter} codeCoverageFormatter\n * @param {*} reporter - an instance of the testReporter\n * @returns {{success: *, startTime: (*|number|Number),\n *  numTotalTests: *,\n *  numTotalTestSuites: *,\n *  numRuntimeErrorTestSuites: *,\n *  numPassedTests: *,\n *  numFailedTests: *,\n *  testResults: (*|{}|Array),\n *  postSuiteHeaders: *}}\n */\n\nfunction formatTestResults(results, codeCoverageFormatter, reporter) {\n  if (!codeCoverageFormatter) {\n    codeCoverageFormatter = coverage => coverage;\n  }\n\n  const testResults = results.testResults.map(\n    testResult => formatResult(testResult, codeCoverageFormatter, reporter)\n  );\n\n  return {\n    success: results.success,\n    startTime: results.startTime,\n    numTotalTests: results.numTotalTests,\n    numTotalTestSuites: results.numTotalTestSuites,\n    numRuntimeErrorTestSuites: results.numRuntimeErrorTestSuites,\n    numPassedTests: results.numPassedTests,\n    numFailedTests: results.numFailedTests,\n    testResults,\n    postSuiteHeaders: results.postSuiteHeaders,\n  };\n}\n\nmodule.exports = formatTestResults;\n","dependencies":["./utils"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst utils = require('./utils');\n\nconst formatResult = (testResult, codeCoverageFormatter, reporter) => {\n  const output = {\n    name: testResult.testFilePath,\n    summary: '', // TODO\n    message: '',\n  };\n\n  if (testResult.testExecError) {\n    const currTime = Date.now();\n    output.status = 'failed';\n    output.message = testResult.testExecError;\n    output.startTime = currTime;\n    output.endTime = currTime;\n    output.coverage = {};\n  } else {\n    const allTestsPassed = testResult.numFailingTests === 0;\n    output.status = allTestsPassed ? 'passed' : 'failed';\n    output.startTime = testResult.perfStats.start;\n    output.endTime = testResult.perfStats.end;\n    output.coverage = codeCoverageFormatter(testResult.coverage, reporter);\n\n    if (!allTestsPassed) {\n      output.message = utils.formatFailureMessage(testResult, {\n        rootPath: '',\n        useColor: false,\n      });\n    }\n  }\n\n  return output;\n};\n\n/**\n * @callback codeCoverageFormatter\n * @param {*} results\n * @param {*} reporter - an instance of the testReporter\n */\n\n/**\n * Formats the test results.\n * @param {*} results - a results hash determined by the reporter\n * @param {codeCoverageFormatter} codeCoverageFormatter\n * @param {*} reporter - an instance of the testReporter\n * @returns {{success: *, startTime: (*|number|Number),\n *  numTotalTests: *,\n *  numTotalTestSuites: *,\n *  numRuntimeErrorTestSuites: *,\n *  numPassedTests: *,\n *  numFailedTests: *,\n *  testResults: (*|{}|Array),\n *  postSuiteHeaders: *}}\n */\n\nfunction formatTestResults(results, codeCoverageFormatter, reporter) {\n  if (!codeCoverageFormatter) {\n    codeCoverageFormatter = coverage => coverage;\n  }\n\n  const testResults = results.testResults.map(\n    testResult => formatResult(testResult, codeCoverageFormatter, reporter)\n  );\n\n  return {\n    success: results.success,\n    startTime: results.startTime,\n    numTotalTests: results.numTotalTests,\n    numTotalTestSuites: results.numTotalTestSuites,\n    numRuntimeErrorTestSuites: results.numRuntimeErrorTestSuites,\n    numPassedTests: results.numPassedTests,\n    numFailedTests: results.numFailedTests,\n    testResults,\n    postSuiteHeaders: results.postSuiteHeaders,\n  };\n}\n\nmodule.exports = formatTestResults;\n"},"name":"/Users/cpojer/Projects/jest/src/lib/formatTestResults.js"}},"/Users/cpojer/Projects/jest/src/lib/FakeTimers.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst mocks = require('./moduleMocker');\n\nconst MS_IN_A_YEAR = 31536000000;\n\nclass FakeTimers {\n\n  constructor(global, maxLoops) {\n    this._global = global;\n    this._uuidCounter = 1;\n    this._maxLoops = maxLoops || 100000;\n\n    this.reset();\n\n    // Store original timer APIs for future reference\n    this._originalTimerAPIs = {\n      setTimeout: global.setTimeout,\n      clearTimeout: global.clearTimeout,\n      setInterval: global.setInterval,\n      clearInterval: global.clearInterval,\n    };\n\n    this._fakeTimerAPIs = {\n      setTimeout: mocks.getMockFn().mockImpl(\n        this._fakeSetTimeout.bind(this)\n      ),\n      clearTimeout: mocks.getMockFn().mockImpl(\n        this._fakeClearTimer.bind(this)\n      ),\n      setInterval: mocks.getMockFn().mockImpl(\n        this._fakeSetInterval.bind(this)\n      ),\n      clearInterval: mocks.getMockFn().mockImpl(\n        this._fakeClearTimer.bind(this)\n      ),\n    };\n\n    // If there's a process.nextTick on the global, mock it out\n    // (only applicable to node/node-emulating environments)\n    if (typeof global.process === 'object'\n        && typeof global.process.nextTick === 'function') {\n      this._originalTimerAPIs.nextTick = global.process.nextTick;\n      this._fakeTimerAPIs.nextTick = mocks.getMockFn().mockImpl(\n        this._fakeNextTick.bind(this)\n      );\n    }\n\n    // If there's a global.setImmediate, mock it out\n    if (typeof global.setImmediate === 'function') {\n      this._originalTimerAPIs.setImmediate = global.setImmediate;\n      this._fakeTimerAPIs.setImmediate = mocks.getMockFn().mockImpl(\n          this._fakeSetImmediate.bind(this)\n      );\n      this._originalTimerAPIs.clearImmediate = global.clearImmediate;\n      this._fakeTimerAPIs.clearImmediate = mocks.getMockFn().mockImpl(\n        this._fakeClearImmediate.bind(this)\n      );\n    }\n\n    this.useFakeTimers();\n\n    // These globally-accessible function are now deprecated!\n    // They will go away very soon, so do not use them!\n    // Instead, use the versions available on the `jest` object\n    global.mockRunTicksRepeatedly = this.runAllTicks.bind(this);\n    global.mockRunTimersOnce = this.runOnlyPendingTimers.bind(this);\n    global.mockRunTimersToTime = this.runTimersToTime.bind(this);\n    global.mockRunTimersRepeatedly = this.runAllTimers.bind(this);\n    global.mockClearTimers = this.clearAllTimers.bind(this);\n    global.mockGetTimersCount = () => Object.keys(this._timers).length;\n  }\n\n  clearAllTimers() {\n    this._immediates.forEach(function(immediate) {\n      this._fakeClearImmediate(immediate.uuid);\n    }, this);\n    for (const uuid in this._timers) {\n      delete this._timers[uuid];\n    }\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._cancelledImmediates = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = {};\n  }\n\n  // Used to be called runTicksRepeatedly\n  runAllTicks() {\n    // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops + ' ticks, and there are still more! ' +\n        'Assuming we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  runAllImmediates() {\n    // Only run a generous number of immediates and then bail.\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n      if (immediate === undefined) {\n        break;\n      }\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops +\n        ' immediates, and there are still more! Assuming ' +\n        'we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  _runImmediate(immediate) {\n    if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n      // Callback may throw, so update the map prior calling.\n      this._cancelledImmediates[immediate.uuid] = true;\n      immediate.callback();\n    }\n  }\n\n  // Used to be called runTimersRepeatedly\n  runAllTimers() {\n    this.runAllTicks();\n    this.runAllImmediates();\n\n    // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle();\n\n      // If there are no more timer handles, stop!\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle);\n\n      // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops + ' timers, and there are still more! ' +\n        'Assuming we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  // Used to be called runTimersOnce\n  runOnlyPendingTimers() {\n    this._immediates.forEach(this._runImmediate, this);\n    const timers = this._timers;\n    Object.keys(timers)\n      .sort(function(left, right) {\n        return timers[left].expiry - timers[right].expiry;\n      })\n      .forEach(this._runTimerHandle, this);\n  }\n\n  // Use to be runTimersToTime\n  runTimersToTime(msToRun) {\n    // Only run a generous number of timers and then bail.\n    // This is jsut to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle();\n\n      // If there are no more timer handles, stop!\n      if (timerHandle === null) {\n        break;\n      }\n\n      const nextTimerExpiry = this._timers[timerHandle].expiry;\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= (nextTimerExpiry - this._now);\n        this._now = nextTimerExpiry;\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops + ' timers, and there are still more! ' +\n        'Assuming we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const hasNextTick =\n      typeof this._global.process === 'object'\n      && typeof this._global.process.nextTick === 'function';\n\n    const hasSetImmediate = typeof this._global.setImmediate === 'function';\n\n    const prevSetTimeout = this._global.setTimeout;\n    const prevSetInterval = this._global.setInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevClearInterval = this._global.clearInterval;\n\n    let prevNextTick;\n    let prevSetImmediate;\n    let prevClearImmediate;\n\n    if (hasNextTick) {\n      prevNextTick = this._global.process.nextTick;\n    }\n    if (hasSetImmediate) {\n      prevSetImmediate = this._global.setImmediate;\n      prevClearImmediate = this._global.clearImmediate;\n    }\n\n    this.useRealTimers();\n\n    let cbErr = null;\n    let errThrown = false;\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.setTimeout = prevSetTimeout;\n    this._global.setInterval = prevSetInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.clearInterval = prevClearInterval;\n    if (hasNextTick) {\n      this._global.process.nextTick = prevNextTick;\n    }\n    if (hasSetImmediate) {\n      this._global.setImmediate = prevSetImmediate;\n      this._global.clearImmediate = prevClearImmediate;\n    }\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const hasNextTick =\n      typeof this._global.process === 'object'\n      && typeof this._global.process.nextTick === 'function';\n\n    const hasSetImmediate = typeof this._global.setImmediate === 'function';\n\n    this._global.setTimeout = this._originalTimerAPIs.setTimeout;\n    this._global.setInterval = this._originalTimerAPIs.setInterval;\n    this._global.clearTimeout = this._originalTimerAPIs.clearTimeout;\n    this._global.clearInterval = this._originalTimerAPIs.clearInterval;\n    if (hasNextTick) {\n      this._global.process.nextTick = this._originalTimerAPIs.nextTick;\n    }\n    if (hasSetImmediate) {\n      this._global.setImmediate = this._originalTimerAPIs.setImmediate;\n      this._global.clearImmediate = this._originalTimerAPIs.clearImmediate;\n    }\n  }\n\n  useFakeTimers() {\n    const hasNextTick =\n      typeof this._global.process === 'object'\n      && typeof this._global.process.nextTick === 'function';\n\n    const hasSetImmediate = typeof this._global.setImmediate === 'function';\n\n    this._global.setTimeout = this._fakeTimerAPIs.setTimeout;\n    this._global.setInterval = this._fakeTimerAPIs.setInterval;\n    this._global.clearTimeout = this._fakeTimerAPIs.clearTimeout;\n    this._global.clearInterval = this._fakeTimerAPIs.clearInterval;\n    if (hasNextTick) {\n      this._global.process.nextTick = this._fakeTimerAPIs.nextTick;\n    }\n    if (hasSetImmediate) {\n      this._global.setImmediate = this._fakeTimerAPIs.setImmediate;\n      this._global.clearImmediate = this._fakeTimerAPIs.clearImmediate;\n    }\n  }\n\n  _fakeClearTimer(uuid) {\n    if (this._timers.hasOwnProperty(uuid)) {\n      delete this._timers[uuid];\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._cancelledImmediates[uuid] = true;\n  }\n\n  _fakeNextTick(callback) {\n    const args = [];\n    for (let ii = 1, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._ticks.push({\n      uuid,\n      callback: function() {\n        return callback.apply(null, args);\n      },\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n    this._originalTimerAPIs.nextTick(function() {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback) {\n    const args = [];\n    for (let ii = 1, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._immediates.push({\n      uuid,\n      callback: function() {\n        return callback.apply(null, args);\n      },\n    });\n\n    const cancelledImmediates = this._cancelledImmediates;\n    this._originalTimerAPIs.setImmediate(function() {\n      if (!cancelledImmediates.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledImmediates[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay) {\n    if (intervalDelay === undefined || intervalDelay === null) {\n      intervalDelay = 0;\n    }\n\n    const args = [];\n    for (let ii = 2, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers[uuid] = {\n      type: 'interval',\n      callback: function() {\n        return callback.apply(null, args);\n      },\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n    };\n\n    return uuid;\n  }\n\n  _fakeSetTimeout(callback, delay)  {\n    if (delay === undefined || delay === null) {\n      delay = 0;\n    }\n\n    const args = [];\n    for (let ii = 2, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers[uuid] = {\n      type: 'timeout',\n      callback: function() {\n        return callback.apply(null, args);\n      },\n      expiry: this._now + delay,\n      interval: null,\n    };\n\n    return uuid;\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let uuid;\n    let soonestTime = MS_IN_A_YEAR;\n    let timer;\n    for (uuid in this._timers) {\n      timer = this._timers[uuid];\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    }\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers[timerHandle];\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n        delete this._timers[timerHandle];\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + timer.interval;\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n\n}\n\nmodule.exports = FakeTimers;\n","dependencies":["./moduleMocker"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst mocks = require('./moduleMocker');\n\nconst MS_IN_A_YEAR = 31536000000;\n\nclass FakeTimers {\n\n  constructor(global, maxLoops) {\n    this._global = global;\n    this._uuidCounter = 1;\n    this._maxLoops = maxLoops || 100000;\n\n    this.reset();\n\n    // Store original timer APIs for future reference\n    this._originalTimerAPIs = {\n      setTimeout: global.setTimeout,\n      clearTimeout: global.clearTimeout,\n      setInterval: global.setInterval,\n      clearInterval: global.clearInterval,\n    };\n\n    this._fakeTimerAPIs = {\n      setTimeout: mocks.getMockFn().mockImpl(\n        this._fakeSetTimeout.bind(this)\n      ),\n      clearTimeout: mocks.getMockFn().mockImpl(\n        this._fakeClearTimer.bind(this)\n      ),\n      setInterval: mocks.getMockFn().mockImpl(\n        this._fakeSetInterval.bind(this)\n      ),\n      clearInterval: mocks.getMockFn().mockImpl(\n        this._fakeClearTimer.bind(this)\n      ),\n    };\n\n    // If there's a process.nextTick on the global, mock it out\n    // (only applicable to node/node-emulating environments)\n    if (typeof global.process === 'object'\n        && typeof global.process.nextTick === 'function') {\n      this._originalTimerAPIs.nextTick = global.process.nextTick;\n      this._fakeTimerAPIs.nextTick = mocks.getMockFn().mockImpl(\n        this._fakeNextTick.bind(this)\n      );\n    }\n\n    // If there's a global.setImmediate, mock it out\n    if (typeof global.setImmediate === 'function') {\n      this._originalTimerAPIs.setImmediate = global.setImmediate;\n      this._fakeTimerAPIs.setImmediate = mocks.getMockFn().mockImpl(\n          this._fakeSetImmediate.bind(this)\n      );\n      this._originalTimerAPIs.clearImmediate = global.clearImmediate;\n      this._fakeTimerAPIs.clearImmediate = mocks.getMockFn().mockImpl(\n        this._fakeClearImmediate.bind(this)\n      );\n    }\n\n    this.useFakeTimers();\n\n    // These globally-accessible function are now deprecated!\n    // They will go away very soon, so do not use them!\n    // Instead, use the versions available on the `jest` object\n    global.mockRunTicksRepeatedly = this.runAllTicks.bind(this);\n    global.mockRunTimersOnce = this.runOnlyPendingTimers.bind(this);\n    global.mockRunTimersToTime = this.runTimersToTime.bind(this);\n    global.mockRunTimersRepeatedly = this.runAllTimers.bind(this);\n    global.mockClearTimers = this.clearAllTimers.bind(this);\n    global.mockGetTimersCount = () => Object.keys(this._timers).length;\n  }\n\n  clearAllTimers() {\n    this._immediates.forEach(function(immediate) {\n      this._fakeClearImmediate(immediate.uuid);\n    }, this);\n    for (const uuid in this._timers) {\n      delete this._timers[uuid];\n    }\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._cancelledImmediates = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = {};\n  }\n\n  // Used to be called runTicksRepeatedly\n  runAllTicks() {\n    // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops + ' ticks, and there are still more! ' +\n        'Assuming we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  runAllImmediates() {\n    // Only run a generous number of immediates and then bail.\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n      if (immediate === undefined) {\n        break;\n      }\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops +\n        ' immediates, and there are still more! Assuming ' +\n        'we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  _runImmediate(immediate) {\n    if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {\n      // Callback may throw, so update the map prior calling.\n      this._cancelledImmediates[immediate.uuid] = true;\n      immediate.callback();\n    }\n  }\n\n  // Used to be called runTimersRepeatedly\n  runAllTimers() {\n    this.runAllTicks();\n    this.runAllImmediates();\n\n    // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle();\n\n      // If there are no more timer handles, stop!\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle);\n\n      // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops + ' timers, and there are still more! ' +\n        'Assuming we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  // Used to be called runTimersOnce\n  runOnlyPendingTimers() {\n    this._immediates.forEach(this._runImmediate, this);\n    const timers = this._timers;\n    Object.keys(timers)\n      .sort(function(left, right) {\n        return timers[left].expiry - timers[right].expiry;\n      })\n      .forEach(this._runTimerHandle, this);\n  }\n\n  // Use to be runTimersToTime\n  runTimersToTime(msToRun) {\n    // Only run a generous number of timers and then bail.\n    // This is jsut to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle();\n\n      // If there are no more timer handles, stop!\n      if (timerHandle === null) {\n        break;\n      }\n\n      const nextTimerExpiry = this._timers[timerHandle].expiry;\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= (nextTimerExpiry - this._now);\n        this._now = nextTimerExpiry;\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' + this._maxLoops + ' timers, and there are still more! ' +\n        'Assuming we\\'ve hit an infinite recursion and bailing out...'\n      );\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const hasNextTick =\n      typeof this._global.process === 'object'\n      && typeof this._global.process.nextTick === 'function';\n\n    const hasSetImmediate = typeof this._global.setImmediate === 'function';\n\n    const prevSetTimeout = this._global.setTimeout;\n    const prevSetInterval = this._global.setInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevClearInterval = this._global.clearInterval;\n\n    let prevNextTick;\n    let prevSetImmediate;\n    let prevClearImmediate;\n\n    if (hasNextTick) {\n      prevNextTick = this._global.process.nextTick;\n    }\n    if (hasSetImmediate) {\n      prevSetImmediate = this._global.setImmediate;\n      prevClearImmediate = this._global.clearImmediate;\n    }\n\n    this.useRealTimers();\n\n    let cbErr = null;\n    let errThrown = false;\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.setTimeout = prevSetTimeout;\n    this._global.setInterval = prevSetInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.clearInterval = prevClearInterval;\n    if (hasNextTick) {\n      this._global.process.nextTick = prevNextTick;\n    }\n    if (hasSetImmediate) {\n      this._global.setImmediate = prevSetImmediate;\n      this._global.clearImmediate = prevClearImmediate;\n    }\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const hasNextTick =\n      typeof this._global.process === 'object'\n      && typeof this._global.process.nextTick === 'function';\n\n    const hasSetImmediate = typeof this._global.setImmediate === 'function';\n\n    this._global.setTimeout = this._originalTimerAPIs.setTimeout;\n    this._global.setInterval = this._originalTimerAPIs.setInterval;\n    this._global.clearTimeout = this._originalTimerAPIs.clearTimeout;\n    this._global.clearInterval = this._originalTimerAPIs.clearInterval;\n    if (hasNextTick) {\n      this._global.process.nextTick = this._originalTimerAPIs.nextTick;\n    }\n    if (hasSetImmediate) {\n      this._global.setImmediate = this._originalTimerAPIs.setImmediate;\n      this._global.clearImmediate = this._originalTimerAPIs.clearImmediate;\n    }\n  }\n\n  useFakeTimers() {\n    const hasNextTick =\n      typeof this._global.process === 'object'\n      && typeof this._global.process.nextTick === 'function';\n\n    const hasSetImmediate = typeof this._global.setImmediate === 'function';\n\n    this._global.setTimeout = this._fakeTimerAPIs.setTimeout;\n    this._global.setInterval = this._fakeTimerAPIs.setInterval;\n    this._global.clearTimeout = this._fakeTimerAPIs.clearTimeout;\n    this._global.clearInterval = this._fakeTimerAPIs.clearInterval;\n    if (hasNextTick) {\n      this._global.process.nextTick = this._fakeTimerAPIs.nextTick;\n    }\n    if (hasSetImmediate) {\n      this._global.setImmediate = this._fakeTimerAPIs.setImmediate;\n      this._global.clearImmediate = this._fakeTimerAPIs.clearImmediate;\n    }\n  }\n\n  _fakeClearTimer(uuid) {\n    if (this._timers.hasOwnProperty(uuid)) {\n      delete this._timers[uuid];\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._cancelledImmediates[uuid] = true;\n  }\n\n  _fakeNextTick(callback) {\n    const args = [];\n    for (let ii = 1, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._ticks.push({\n      uuid,\n      callback: function() {\n        return callback.apply(null, args);\n      },\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n    this._originalTimerAPIs.nextTick(function() {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback) {\n    const args = [];\n    for (let ii = 1, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._immediates.push({\n      uuid,\n      callback: function() {\n        return callback.apply(null, args);\n      },\n    });\n\n    const cancelledImmediates = this._cancelledImmediates;\n    this._originalTimerAPIs.setImmediate(function() {\n      if (!cancelledImmediates.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledImmediates[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay) {\n    if (intervalDelay === undefined || intervalDelay === null) {\n      intervalDelay = 0;\n    }\n\n    const args = [];\n    for (let ii = 2, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers[uuid] = {\n      type: 'interval',\n      callback: function() {\n        return callback.apply(null, args);\n      },\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n    };\n\n    return uuid;\n  }\n\n  _fakeSetTimeout(callback, delay)  {\n    if (delay === undefined || delay === null) {\n      delay = 0;\n    }\n\n    const args = [];\n    for (let ii = 2, ll = arguments.length; ii < ll; ii++) {\n      args.push(arguments[ii]);\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers[uuid] = {\n      type: 'timeout',\n      callback: function() {\n        return callback.apply(null, args);\n      },\n      expiry: this._now + delay,\n      interval: null,\n    };\n\n    return uuid;\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let uuid;\n    let soonestTime = MS_IN_A_YEAR;\n    let timer;\n    for (uuid in this._timers) {\n      timer = this._timers[uuid];\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    }\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers[timerHandle];\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n        delete this._timers[timerHandle];\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + timer.interval;\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n\n}\n\nmodule.exports = FakeTimers;\n"},"name":"/Users/cpojer/Projects/jest/src/lib/FakeTimers.js"}},"/Users/cpojer/Projects/jest/src/reporters/VerboseLogger.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst chalk = require('chalk');\n\nclass VerboseLogger {\n  constructor(customProcess) {\n    this._process = customProcess || process;\n  }\n\n  logTestResults(testResults) {\n    groupTestsBySuites(testResults).forEach(suite =>\n      this._logSuite(suite, 0)\n    );\n\n    this._logLine();\n  }\n\n  _logSuite(suite, indentLevel) {\n    this._logLine(suite.title, indentLevel);\n\n    suite.tests.forEach(test =>\n      this._logTest(test, indentLevel + 1)\n    );\n\n    suite.suites.forEach(childSuite =>\n      this._logSuite(childSuite, indentLevel + 1)\n    );\n  }\n\n  _logTest(test, indentLevel) {\n    const status = test.failureMessages.length > 0 ?\n      chalk.red('\\u2715') :\n      chalk.green('\\u2713');\n\n    this._logLine(`${status} ${chalk.gray(test.title)}`, indentLevel);\n  }\n\n  _logLine(str, indentLevel) {\n    str = str || '';\n    indentLevel = indentLevel || 0;\n\n    const indentation = '  '.repeat(indentLevel);\n    this._process.stdout.write(`${indentation}${str}\\n`);\n  }\n}\n\nfunction groupTestsBySuites(testResults) {\n  const root = { suites: [] };\n\n  testResults.forEach(testResult => {\n    let targetSuite = root;\n\n    // Find the target suite for this test,\n    // creating nested suites as necessary.\n    for (const title of testResult.ancestorTitles) {\n      let matchingSuite = targetSuite.suites.find(s => s.title === title);\n      if (!matchingSuite) {\n        matchingSuite = { title, suites: [], tests: [] };\n        targetSuite.suites.push(matchingSuite);\n      }\n      targetSuite = matchingSuite;\n    }\n\n    targetSuite.tests.push(testResult);\n  });\n\n  return root.suites;\n}\n\nVerboseLogger.groupTestsBySuites = groupTestsBySuites;\nmodule.exports = VerboseLogger;\n","dependencies":["chalk"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst chalk = require('chalk');\n\nclass VerboseLogger {\n  constructor(customProcess) {\n    this._process = customProcess || process;\n  }\n\n  logTestResults(testResults) {\n    groupTestsBySuites(testResults).forEach(suite =>\n      this._logSuite(suite, 0)\n    );\n\n    this._logLine();\n  }\n\n  _logSuite(suite, indentLevel) {\n    this._logLine(suite.title, indentLevel);\n\n    suite.tests.forEach(test =>\n      this._logTest(test, indentLevel + 1)\n    );\n\n    suite.suites.forEach(childSuite =>\n      this._logSuite(childSuite, indentLevel + 1)\n    );\n  }\n\n  _logTest(test, indentLevel) {\n    const status = test.failureMessages.length > 0 ?\n      chalk.red('\\u2715') :\n      chalk.green('\\u2713');\n\n    this._logLine(`${status} ${chalk.gray(test.title)}`, indentLevel);\n  }\n\n  _logLine(str, indentLevel) {\n    str = str || '';\n    indentLevel = indentLevel || 0;\n\n    const indentation = '  '.repeat(indentLevel);\n    this._process.stdout.write(`${indentation}${str}\\n`);\n  }\n}\n\nfunction groupTestsBySuites(testResults) {\n  const root = { suites: [] };\n\n  testResults.forEach(testResult => {\n    let targetSuite = root;\n\n    // Find the target suite for this test,\n    // creating nested suites as necessary.\n    for (const title of testResult.ancestorTitles) {\n      let matchingSuite = targetSuite.suites.find(s => s.title === title);\n      if (!matchingSuite) {\n        matchingSuite = { title, suites: [], tests: [] };\n        targetSuite.suites.push(matchingSuite);\n      }\n      targetSuite = matchingSuite;\n    }\n\n    targetSuite.tests.push(testResult);\n  });\n\n  return root.suites;\n}\n\nVerboseLogger.groupTestsBySuites = groupTestsBySuites;\nmodule.exports = VerboseLogger;\n"},"name":"/Users/cpojer/Projects/jest/src/reporters/VerboseLogger.js"}},"/Users/cpojer/Projects/jest/src/reporters/IstanbulTestReporter.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n* Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n*\n* This source code is licensed under the BSD-style license found in the\n* LICENSE file in the root directory of this source tree. An additional grant\n* of patent rights can be found in the PATENTS file in the same directory.\n*/\n'use strict';\n\nconst DefaultTestReporter = require('./DefaultTestReporter');\nconst istanbul = require('istanbul');\nconst collector = new istanbul.Collector();\nconst testCollectors = Object.create(null);\nconst reporter = new istanbul.Reporter();\n\nclass IstanbulTestReporter extends DefaultTestReporter {\n  onTestResult(config, testResult, aggregatedResults) {\n    super.onTestResult(config, testResult, aggregatedResults);\n\n    if (config.collectCoverage && testResult.coverage) {\n      collector.add(testResult.coverage);\n      if (!testCollectors[testResult.testFilePath]) {\n        testCollectors[testResult.testFilePath] = new istanbul.Collector();\n      }\n      testCollectors[testResult.testFilePath].add(testResult.coverage);\n    }\n  }\n\n  onRunComplete(config, aggregatedResults) {\n    super.onRunComplete(config, aggregatedResults);\n\n    if (config.collectCoverage) {\n      try {\n        reporter.addAll(config.coverageReporters);\n        reporter.write(collector, true, () => {});\n      } catch (e) {}\n    }\n  }\n\n  static getReporter() {\n    return reporter;\n  }\n\n  static getCollector() {\n    return collector;\n  }\n\n  static getTestCollectors() {\n    return testCollectors;\n  }\n}\n\nmodule.exports = IstanbulTestReporter;\n","dependencies":["./DefaultTestReporter","istanbul"],"source":"/**\n* Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n*\n* This source code is licensed under the BSD-style license found in the\n* LICENSE file in the root directory of this source tree. An additional grant\n* of patent rights can be found in the PATENTS file in the same directory.\n*/\n'use strict';\n\nconst DefaultTestReporter = require('./DefaultTestReporter');\nconst istanbul = require('istanbul');\nconst collector = new istanbul.Collector();\nconst testCollectors = Object.create(null);\nconst reporter = new istanbul.Reporter();\n\nclass IstanbulTestReporter extends DefaultTestReporter {\n  onTestResult(config, testResult, aggregatedResults) {\n    super.onTestResult(config, testResult, aggregatedResults);\n\n    if (config.collectCoverage && testResult.coverage) {\n      collector.add(testResult.coverage);\n      if (!testCollectors[testResult.testFilePath]) {\n        testCollectors[testResult.testFilePath] = new istanbul.Collector();\n      }\n      testCollectors[testResult.testFilePath].add(testResult.coverage);\n    }\n  }\n\n  onRunComplete(config, aggregatedResults) {\n    super.onRunComplete(config, aggregatedResults);\n\n    if (config.collectCoverage) {\n      try {\n        reporter.addAll(config.coverageReporters);\n        reporter.write(collector, true, () => {});\n      } catch (e) {}\n    }\n  }\n\n  static getReporter() {\n    return reporter;\n  }\n\n  static getCollector() {\n    return collector;\n  }\n\n  static getTestCollectors() {\n    return testCollectors;\n  }\n}\n\nmodule.exports = IstanbulTestReporter;\n"},"name":"/Users/cpojer/Projects/jest/src/reporters/IstanbulTestReporter.js"}},"/Users/cpojer/Projects/jest/src/reporters/DefaultTestReporter.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst chalk = require('chalk');\nconst formatFailureMessage = require('../lib/utils').formatFailureMessage;\nconst path = require('path');\nconst VerboseLogger = require('./VerboseLogger');\n\n// Explicitly reset for these messages since they can get written out in the\n// middle of error logging (should have listened to Spengler and not crossed the\n// streams).\nconst FAIL = chalk.reset.bold.bgRed(' FAIL ');\nconst PASS = chalk.reset.bold.bgGreen(' PASS ');\n\nconst FAIL_COLOR = chalk.bold.red;\nconst PASS_COLOR = chalk.bold.green;\nconst RUNNING_TEST_COLOR = chalk.bold.gray;\nconst TEST_NAME_COLOR = chalk.bold;\nconst LONG_TEST_COLOR = chalk.reset.bold.bgRed;\n\nconst print = (word, count) => `${count} ${word}${count === 1 ? '' : 's'}`;\n\nclass DefaultTestReporter {\n\n  constructor(customProcess) {\n    this._process = customProcess || process;\n  }\n\n  log(str) {\n    this._process.stdout.write(str + '\\n');\n  }\n\n  onRunStart(config, results) {\n    this._config = config;\n    this._printWaitingOn(results);\n    if (this._config.verbose) {\n      this.verboseLogger = new VerboseLogger(this._process);\n    }\n  }\n\n  onTestResult(config, testResult, results) {\n    this._clearWaitingOn();\n\n    const pathStr =\n      config.rootDir\n      ? path.relative(config.rootDir, testResult.testFilePath)\n      : testResult.testFilePath;\n    const allTestsPassed = testResult.numFailingTests === 0;\n    const runTime =\n      testResult.perfStats\n      ? (testResult.perfStats.end - testResult.perfStats.start) / 1000\n      : null;\n\n    const testDetail = [];\n    if (runTime !== null) {\n      testDetail.push(\n        runTime > 2.5 ? LONG_TEST_COLOR(runTime + 's') : runTime + 's'\n      );\n    }\n\n    if (testResult.memoryUsage) {\n      const toMB = bytes => Math.floor(bytes / 1024 / 1024);\n      testDetail.push(`${toMB(testResult.memoryUsage)} MB heap size`);\n    }\n\n    const resultHeader =\n       `${allTestsPassed ? PASS : FAIL} ${TEST_NAME_COLOR(pathStr)}` +\n       (testDetail.length ? ` (${testDetail.join(', ')})` : '');\n\n    /*\n    if (config.collectCoverage) {\n      // TODO: Find a nice pretty way to print this out\n    }\n    */\n\n    this.log(resultHeader);\n    if (config.verbose) {\n      this.verboseLogger.logTestResults(testResult.testResults);\n    }\n\n    if (!allTestsPassed) {\n      const failureMessage = formatFailureMessage(testResult, {\n        rootPath: config.rootDir,\n        useColor: !config.noHighlight,\n      });\n      if (config.verbose) {\n        results.postSuiteHeaders.push(resultHeader, failureMessage);\n      } else {\n        // If we write more than one character at a time it is possible that\n        // node exits in the middle of printing the result.\n        // If you are reading this and you are from the future, this might not\n        // be true any more.\n        for (let i = 0; i < failureMessage.length; i++) {\n          this._process.stdout.write(failureMessage.charAt(i));\n        }\n        this._process.stdout.write('\\n');\n      }\n\n      if (config.bail) {\n        this.onRunComplete(config, results);\n        this._process.exit(1);\n      }\n    }\n\n    this._printWaitingOn(results);\n  }\n\n  onRunComplete(config, aggregatedResults) {\n    const totalTestSuites = aggregatedResults.numTotalTestSuites;\n    const failedTests = aggregatedResults.numFailedTests;\n    const passedTests = aggregatedResults.numPassedTests;\n    const totalTests = aggregatedResults.numTotalTests;\n    const totalErrors = aggregatedResults.numRuntimeErrorTestSuites;\n    const runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n\n    if (totalTests === 0) {\n      return;\n    }\n\n    if (config.verbose && aggregatedResults.postSuiteHeaders.length > 0) {\n      this.log(aggregatedResults.postSuiteHeaders.join('\\n'));\n    }\n\n    let results = '';\n    if (failedTests) {\n      results +=\n        `${FAIL_COLOR(`${print('test', failedTests)} failed`)}, `;\n    }\n\n    if (totalErrors) {\n      results +=\n        `${FAIL_COLOR(`${print('test suite', totalErrors)} failed`)}, `;\n    }\n\n    results +=\n      `${PASS_COLOR(`${print('test', passedTests)} passed`)} ` +\n      `(${totalTests} total in ${print('test suite', totalTestSuites)}, ` +\n      `run time ${runTime}s)`;\n\n    this.log(results);\n  }\n\n  _clearWaitingOn() {\n    this._process.stdout.write(this._config.noHighlight ? '' : '\\r\\x1B[K');\n  }\n\n  _printWaitingOn(results) {\n    const remaining = results.numTotalTestSuites -\n      results.numPassedTestSuites -\n      results.numFailedTestSuites -\n      results.numRuntimeErrorTestSuites;\n    if (!this._config.noHighlight && remaining > 0) {\n      this._process.stdout.write(RUNNING_TEST_COLOR(\n        `Running ${print('test suite', remaining)}...`\n      ));\n    }\n  }\n\n}\n\nmodule.exports = DefaultTestReporter;\n","dependencies":["chalk","../lib/utils","path","./VerboseLogger"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst chalk = require('chalk');\nconst formatFailureMessage = require('../lib/utils').formatFailureMessage;\nconst path = require('path');\nconst VerboseLogger = require('./VerboseLogger');\n\n// Explicitly reset for these messages since they can get written out in the\n// middle of error logging (should have listened to Spengler and not crossed the\n// streams).\nconst FAIL = chalk.reset.bold.bgRed(' FAIL ');\nconst PASS = chalk.reset.bold.bgGreen(' PASS ');\n\nconst FAIL_COLOR = chalk.bold.red;\nconst PASS_COLOR = chalk.bold.green;\nconst RUNNING_TEST_COLOR = chalk.bold.gray;\nconst TEST_NAME_COLOR = chalk.bold;\nconst LONG_TEST_COLOR = chalk.reset.bold.bgRed;\n\nconst print = (word, count) => `${count} ${word}${count === 1 ? '' : 's'}`;\n\nclass DefaultTestReporter {\n\n  constructor(customProcess) {\n    this._process = customProcess || process;\n  }\n\n  log(str) {\n    this._process.stdout.write(str + '\\n');\n  }\n\n  onRunStart(config, results) {\n    this._config = config;\n    this._printWaitingOn(results);\n    if (this._config.verbose) {\n      this.verboseLogger = new VerboseLogger(this._process);\n    }\n  }\n\n  onTestResult(config, testResult, results) {\n    this._clearWaitingOn();\n\n    const pathStr =\n      config.rootDir\n      ? path.relative(config.rootDir, testResult.testFilePath)\n      : testResult.testFilePath;\n    const allTestsPassed = testResult.numFailingTests === 0;\n    const runTime =\n      testResult.perfStats\n      ? (testResult.perfStats.end - testResult.perfStats.start) / 1000\n      : null;\n\n    const testDetail = [];\n    if (runTime !== null) {\n      testDetail.push(\n        runTime > 2.5 ? LONG_TEST_COLOR(runTime + 's') : runTime + 's'\n      );\n    }\n\n    if (testResult.memoryUsage) {\n      const toMB = bytes => Math.floor(bytes / 1024 / 1024);\n      testDetail.push(`${toMB(testResult.memoryUsage)} MB heap size`);\n    }\n\n    const resultHeader =\n       `${allTestsPassed ? PASS : FAIL} ${TEST_NAME_COLOR(pathStr)}` +\n       (testDetail.length ? ` (${testDetail.join(', ')})` : '');\n\n    /*\n    if (config.collectCoverage) {\n      // TODO: Find a nice pretty way to print this out\n    }\n    */\n\n    this.log(resultHeader);\n    if (config.verbose) {\n      this.verboseLogger.logTestResults(testResult.testResults);\n    }\n\n    if (!allTestsPassed) {\n      const failureMessage = formatFailureMessage(testResult, {\n        rootPath: config.rootDir,\n        useColor: !config.noHighlight,\n      });\n      if (config.verbose) {\n        results.postSuiteHeaders.push(resultHeader, failureMessage);\n      } else {\n        // If we write more than one character at a time it is possible that\n        // node exits in the middle of printing the result.\n        // If you are reading this and you are from the future, this might not\n        // be true any more.\n        for (let i = 0; i < failureMessage.length; i++) {\n          this._process.stdout.write(failureMessage.charAt(i));\n        }\n        this._process.stdout.write('\\n');\n      }\n\n      if (config.bail) {\n        this.onRunComplete(config, results);\n        this._process.exit(1);\n      }\n    }\n\n    this._printWaitingOn(results);\n  }\n\n  onRunComplete(config, aggregatedResults) {\n    const totalTestSuites = aggregatedResults.numTotalTestSuites;\n    const failedTests = aggregatedResults.numFailedTests;\n    const passedTests = aggregatedResults.numPassedTests;\n    const totalTests = aggregatedResults.numTotalTests;\n    const totalErrors = aggregatedResults.numRuntimeErrorTestSuites;\n    const runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n\n    if (totalTests === 0) {\n      return;\n    }\n\n    if (config.verbose && aggregatedResults.postSuiteHeaders.length > 0) {\n      this.log(aggregatedResults.postSuiteHeaders.join('\\n'));\n    }\n\n    let results = '';\n    if (failedTests) {\n      results +=\n        `${FAIL_COLOR(`${print('test', failedTests)} failed`)}, `;\n    }\n\n    if (totalErrors) {\n      results +=\n        `${FAIL_COLOR(`${print('test suite', totalErrors)} failed`)}, `;\n    }\n\n    results +=\n      `${PASS_COLOR(`${print('test', passedTests)} passed`)} ` +\n      `(${totalTests} total in ${print('test suite', totalTestSuites)}, ` +\n      `run time ${runTime}s)`;\n\n    this.log(results);\n  }\n\n  _clearWaitingOn() {\n    this._process.stdout.write(this._config.noHighlight ? '' : '\\r\\x1B[K');\n  }\n\n  _printWaitingOn(results) {\n    const remaining = results.numTotalTestSuites -\n      results.numPassedTestSuites -\n      results.numFailedTestSuites -\n      results.numRuntimeErrorTestSuites;\n    if (!this._config.noHighlight && remaining > 0) {\n      this._process.stdout.write(RUNNING_TEST_COLOR(\n        `Running ${print('test suite', remaining)}...`\n      ));\n    }\n  }\n\n}\n\nmodule.exports = DefaultTestReporter;\n"},"name":"/Users/cpojer/Projects/jest/src/reporters/DefaultTestReporter.js"}},"/Users/cpojer/Projects/jest/src/TestWorker.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\n// Make sure uncaught errors are logged before we exit.\nprocess.on('uncaughtException', err => {\n  console.error(err.stack);\n  process.exit(1);\n});\n\nconst Test = require('./Test');\n\nconst fs = require('graceful-fs');\nconst getCacheFilePath = require('node-haste').Cache.getCacheFilePath;\nconst getCacheKey = require('./lib/getCacheKey');\n\nconst formatError = error => {\n  if (typeof error === 'string') {\n    return {\n      stack: null,\n      message: error,\n      type: 'Error',\n    };\n  }\n\n  return {\n    stack: error.stack,\n    message: error.message,\n    type: error.type,\n  };\n};\n\nlet moduleMap;\n\nmodule.exports = (data, callback) => {\n  try {\n    if (!moduleMap) {\n      const cacheFile = getCacheFilePath(\n        data.config.cacheDirectory,\n        getCacheKey('jest-module-map', data.config)\n      );\n      moduleMap = JSON.parse(fs.readFileSync(cacheFile));\n    }\n\n    new Test(data.path, data.config, moduleMap)\n      .run()\n      .then(\n        result => callback(null, result),\n        err => callback(formatError(err))\n      );\n  } catch (err) {\n    callback(formatError(err));\n  }\n};\n","dependencies":["./Test","graceful-fs","node-haste","./lib/getCacheKey"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\n// Make sure uncaught errors are logged before we exit.\nprocess.on('uncaughtException', err => {\n  console.error(err.stack);\n  process.exit(1);\n});\n\nconst Test = require('./Test');\n\nconst fs = require('graceful-fs');\nconst getCacheFilePath = require('node-haste').Cache.getCacheFilePath;\nconst getCacheKey = require('./lib/getCacheKey');\n\nconst formatError = error => {\n  if (typeof error === 'string') {\n    return {\n      stack: null,\n      message: error,\n      type: 'Error',\n    };\n  }\n\n  return {\n    stack: error.stack,\n    message: error.message,\n    type: error.type,\n  };\n};\n\nlet moduleMap;\n\nmodule.exports = (data, callback) => {\n  try {\n    if (!moduleMap) {\n      const cacheFile = getCacheFilePath(\n        data.config.cacheDirectory,\n        getCacheKey('jest-module-map', data.config)\n      );\n      moduleMap = JSON.parse(fs.readFileSync(cacheFile));\n    }\n\n    new Test(data.path, data.config, moduleMap)\n      .run()\n      .then(\n        result => callback(null, result),\n        err => callback(formatError(err))\n      );\n  } catch (err) {\n    callback(formatError(err));\n  }\n};\n"},"name":"/Users/cpojer/Projects/jest/src/TestWorker.js"}},"/Users/cpojer/Projects/jest/src/Test.js":{"metadata":{"mtime":1456879629000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst Console = require('./Console');\n\nclass Test {\n\n  constructor(path, config, moduleMap) {\n    this._path = path;\n    this._config = config;\n    this._moduleMap = moduleMap;\n  }\n\n  run() {\n    const path = this._path;\n    const config = this._config;\n    const moduleMap = this._moduleMap;\n    const TestEnvironment = require(config.testEnvironment);\n    const TestRunner = require(config.testRunner);\n    const ModuleLoader = require(config.moduleLoader);\n\n    const env = new TestEnvironment(config);\n    env.global.console = new Console(\n      config.useStderr ? process.stderr : process.stdout,\n      process.stderr\n    );\n    env.testFilePath = path;\n    const moduleLoader = new ModuleLoader(config, env, moduleMap);\n    if (config.setupFiles.length) {\n      for (let i = 0; i < config.setupFiles.length; i++) {\n        moduleLoader.requireModule(null, config.setupFiles[i]);\n      }\n    }\n\n    const start = Date.now();\n    return TestRunner(config, env, moduleLoader, path)\n      .then(result => {\n        result.perfStats = {start, end: Date.now()};\n        result.testFilePath = path;\n        result.coverage = moduleLoader.getAllCoverageInfo();\n        return result;\n      })\n      .then(\n        result => Promise.resolve().then(() => {\n          env.dispose();\n          if (config.logHeapUsage) {\n            if (global.gc) {\n              global.gc();\n            }\n            result.memoryUsage = process.memoryUsage().heapUsed;\n          }\n          return result;\n        }),\n        err => Promise.resolve().then(() => {\n          env.dispose();\n          throw err;\n        })\n      );\n  }\n\n}\n\nmodule.exports = Test;\n","dependencies":["./Console"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst Console = require('./Console');\n\nclass Test {\n\n  constructor(path, config, moduleMap) {\n    this._path = path;\n    this._config = config;\n    this._moduleMap = moduleMap;\n  }\n\n  run() {\n    const path = this._path;\n    const config = this._config;\n    const moduleMap = this._moduleMap;\n    const TestEnvironment = require(config.testEnvironment);\n    const TestRunner = require(config.testRunner);\n    const ModuleLoader = require(config.moduleLoader);\n\n    const env = new TestEnvironment(config);\n    env.global.console = new Console(\n      config.useStderr ? process.stderr : process.stdout,\n      process.stderr\n    );\n    env.testFilePath = path;\n    const moduleLoader = new ModuleLoader(config, env, moduleMap);\n    if (config.setupFiles.length) {\n      for (let i = 0; i < config.setupFiles.length; i++) {\n        moduleLoader.requireModule(null, config.setupFiles[i]);\n      }\n    }\n\n    const start = Date.now();\n    return TestRunner(config, env, moduleLoader, path)\n      .then(result => {\n        result.perfStats = {start, end: Date.now()};\n        result.testFilePath = path;\n        result.coverage = moduleLoader.getAllCoverageInfo();\n        return result;\n      })\n      .then(\n        result => Promise.resolve().then(() => {\n          env.dispose();\n          if (config.logHeapUsage) {\n            if (global.gc) {\n              global.gc();\n            }\n            result.memoryUsage = process.memoryUsage().heapUsed;\n          }\n          return result;\n        }),\n        err => Promise.resolve().then(() => {\n          env.dispose();\n          throw err;\n        })\n      );\n  }\n\n}\n\nmodule.exports = Test;\n"},"name":"/Users/cpojer/Projects/jest/src/Test.js"}},"/Users/cpojer/Projects/jest/src/IstanbulCollector.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n* Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n*\n* This source code is licensed under the BSD-style license found in the\n* LICENSE file in the root directory of this source tree. An additional grant\n* of patent rights can be found in the PATENTS file in the same directory.\n*/\n'use strict';\n\nconst istanbul = require('istanbul');\n\nclass IstanbulCollector {\n\n  constructor(sourceText, filename) {\n    const instr = new istanbul.Instrumenter();\n    this._coverageDataStore = {};\n    this._instrumentor = instr;\n    this._origSourceText = sourceText;\n    this._instrumentedSourceText = instr.instrumentSync(sourceText, filename);\n  }\n\n  getCoverageDataStore() {\n    return this._coverageDataStore;\n  }\n\n  getInstrumentedSource(storageVarName) {\n    return this._instrumentedSourceText + storageVarName + '.coverState=' +\n           this._instrumentor.currentState.trackerVar + ';';\n  }\n\n  extractRuntimeCoverageInfo() {\n    return this._coverageDataStore.coverState;\n  }\n\n}\n\nmodule.exports = IstanbulCollector;\n","dependencies":["istanbul"],"source":"/**\n* Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n*\n* This source code is licensed under the BSD-style license found in the\n* LICENSE file in the root directory of this source tree. An additional grant\n* of patent rights can be found in the PATENTS file in the same directory.\n*/\n'use strict';\n\nconst istanbul = require('istanbul');\n\nclass IstanbulCollector {\n\n  constructor(sourceText, filename) {\n    const instr = new istanbul.Instrumenter();\n    this._coverageDataStore = {};\n    this._instrumentor = instr;\n    this._origSourceText = sourceText;\n    this._instrumentedSourceText = instr.instrumentSync(sourceText, filename);\n  }\n\n  getCoverageDataStore() {\n    return this._coverageDataStore;\n  }\n\n  getInstrumentedSource(storageVarName) {\n    return this._instrumentedSourceText + storageVarName + '.coverState=' +\n           this._instrumentor.currentState.trackerVar + ';';\n  }\n\n  extractRuntimeCoverageInfo() {\n    return this._coverageDataStore.coverState;\n  }\n\n}\n\nmodule.exports = IstanbulCollector;\n"},"name":"/Users/cpojer/Projects/jest/src/IstanbulCollector.js"}},"/Users/cpojer/Projects/jest/src/CoverageCollector.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst CoverageInstrumentor = require('cover/instrument').Instrumentor;\nconst fs = require('graceful-fs');\nconst path = require('path');\n\nconst COVERAGE_TEMPLATE_PATH = path.join(__dirname, 'coverage.template');\n\nlet _memoizedCoverageTemplate = null;\n\nfunction _getCoverageTemplate() {\n  if (_memoizedCoverageTemplate === null) {\n    _memoizedCoverageTemplate = require('lodash.template')(\n      fs.readFileSync(COVERAGE_TEMPLATE_PATH, 'utf8')\n    );\n  }\n  return _memoizedCoverageTemplate;\n}\n\nclass CoverageCollector {\n\n  constructor(sourceText) {\n    this._coverageDataStore = {};\n    this._instrumentedSourceText = null;\n    this._instrumentor = new CoverageInstrumentor();\n    this._origSourceText = sourceText;\n  }\n\n  getCoverageDataStore() {\n    return this._coverageDataStore;\n  }\n\n  getInstrumentedSource(storageVarName) {\n    if (this._instrumentedSourceText === null) {\n      this._instrumentedSourceText = _getCoverageTemplate()({\n        instrumented: this._instrumentor,\n        coverageStorageVar: storageVarName,\n        source: this._instrumentor.instrument(this._origSourceText),\n      });\n    }\n    return this._instrumentedSourceText;\n  }\n\n  extractRuntimeCoverageInfo() {\n    const instrumentationInfo = this._instrumentor.objectify();\n    const coverageInfo = {\n      coveredSpans: [],\n      uncoveredSpans: [],\n      sourceText: this._origSourceText,\n    };\n\n    let nodeIndex;\n\n    // Find all covered spans\n    for (nodeIndex in this._coverageDataStore.nodes) {\n      coverageInfo.coveredSpans.push(instrumentationInfo.nodes[nodeIndex].loc);\n    }\n\n    // Find all definitely uncovered spans\n    for (nodeIndex in instrumentationInfo.nodes) {\n      if (!this._coverageDataStore.nodes.hasOwnProperty(nodeIndex)) {\n        coverageInfo.uncoveredSpans.push(\n          instrumentationInfo.nodes[nodeIndex].loc\n        );\n      }\n    }\n\n    return coverageInfo;\n  }\n\n}\n\nmodule.exports = CoverageCollector;\n","dependencies":["cover/instrument","graceful-fs","path","lodash.template"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst CoverageInstrumentor = require('cover/instrument').Instrumentor;\nconst fs = require('graceful-fs');\nconst path = require('path');\n\nconst COVERAGE_TEMPLATE_PATH = path.join(__dirname, 'coverage.template');\n\nlet _memoizedCoverageTemplate = null;\n\nfunction _getCoverageTemplate() {\n  if (_memoizedCoverageTemplate === null) {\n    _memoizedCoverageTemplate = require('lodash.template')(\n      fs.readFileSync(COVERAGE_TEMPLATE_PATH, 'utf8')\n    );\n  }\n  return _memoizedCoverageTemplate;\n}\n\nclass CoverageCollector {\n\n  constructor(sourceText) {\n    this._coverageDataStore = {};\n    this._instrumentedSourceText = null;\n    this._instrumentor = new CoverageInstrumentor();\n    this._origSourceText = sourceText;\n  }\n\n  getCoverageDataStore() {\n    return this._coverageDataStore;\n  }\n\n  getInstrumentedSource(storageVarName) {\n    if (this._instrumentedSourceText === null) {\n      this._instrumentedSourceText = _getCoverageTemplate()({\n        instrumented: this._instrumentor,\n        coverageStorageVar: storageVarName,\n        source: this._instrumentor.instrument(this._origSourceText),\n      });\n    }\n    return this._instrumentedSourceText;\n  }\n\n  extractRuntimeCoverageInfo() {\n    const instrumentationInfo = this._instrumentor.objectify();\n    const coverageInfo = {\n      coveredSpans: [],\n      uncoveredSpans: [],\n      sourceText: this._origSourceText,\n    };\n\n    let nodeIndex;\n\n    // Find all covered spans\n    for (nodeIndex in this._coverageDataStore.nodes) {\n      coverageInfo.coveredSpans.push(instrumentationInfo.nodes[nodeIndex].loc);\n    }\n\n    // Find all definitely uncovered spans\n    for (nodeIndex in instrumentationInfo.nodes) {\n      if (!this._coverageDataStore.nodes.hasOwnProperty(nodeIndex)) {\n        coverageInfo.uncoveredSpans.push(\n          instrumentationInfo.nodes[nodeIndex].loc\n        );\n      }\n    }\n\n    return coverageInfo;\n  }\n\n}\n\nmodule.exports = CoverageCollector;\n"},"name":"/Users/cpojer/Projects/jest/src/CoverageCollector.js"}},"/Users/cpojer/Projects/jest/src/Console.js":{"metadata":{"mtime":1456289197000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst Console = require('console').Console;\nconst chalk = require('chalk');\n\nclass CustomConsole extends Console {\n  warn() {\n    return super.warn(\n      chalk.yellow(util.format.apply(this, arguments))\n    );\n  }\n\n  error() {\n    return super.error(\n      chalk.red(util.format.apply(this, arguments))\n    );\n  }\n}\n\nmodule.exports = CustomConsole;\n","dependencies":["util","console","chalk"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst Console = require('console').Console;\nconst chalk = require('chalk');\n\nclass CustomConsole extends Console {\n  warn() {\n    return super.warn(\n      chalk.yellow(util.format.apply(this, arguments))\n    );\n  }\n\n  error() {\n    return super.error(\n      chalk.red(util.format.apply(this, arguments))\n    );\n  }\n}\n\nmodule.exports = CustomConsole;\n"},"name":"/Users/cpojer/Projects/jest/src/Console.js"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/JSONFile.json":{"metadata":{"mtime":1447743521000},"data":{"isHaste":false,"moduleData":{"code":"{\"isJSONModule\": true}\n","dependencies":[],"source":"{\"isJSONModule\": true}\n"},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/JSONFile.json"}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/NativeModule.node":{"metadata":{"mtime":1447743522000},"data":{"isHaste":false,"moduleData":{"code":"","dependencies":[],"source":""},"name":"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/test_root/NativeModule.node"}},"/Users/cpojer/Projects/jest/src/TestRunner.js":{"metadata":{"mtime":1457386193000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n /* eslint-disable fb-www/object-create-only-one-param */\n'use strict';\n\nconst Test = require('./Test');\n\nconst fs = require('graceful-fs');\nconst getCacheFilePath = require('node-haste').Cache.getCacheFilePath;\nconst getCacheKey = require('./lib/getCacheKey');\nconst mkdirp = require('mkdirp');\nconst os = require('os');\nconst path = require('path');\nconst promisify = require('./lib/promisify');\nconst utils = require('./lib/utils');\nconst workerFarm = require('worker-farm');\n\nconst TEST_WORKER_PATH = require.resolve('./TestWorker');\n\nconst DEFAULT_OPTIONS = {\n\n  /**\n   * When true, runs all tests serially in the current process, rather than\n   * creating a worker pool of child processes.\n   *\n   * This can be useful for debugging, or when the environment limits to a\n   * single process.\n   */\n  runInBand: false,\n\n  /**\n   * The maximum number of workers to run tests concurrently with.\n   *\n   * It's probably good to keep this at something close to the number of cores\n   * on the machine that's running the test.\n   */\n  maxWorkers: Math.max(os.cpus().length, 1),\n\n  /**\n   * The path to the executable node binary.\n   *\n   * This is used in the process of booting each of the workers.\n   */\n  nodePath: process.execPath,\n\n  /**\n   * The args to be passed to the node binary executable.\n   *\n   * This is used in the process of booting each of the workers.\n   * Passing --debug off to child processes can screw with socket connections\n   * of the parent process.\n   */\n  nodeArgv: process.execArgv.filter(arg => arg.indexOf('--debug') == -1),\n};\n\nconst HIDDEN_FILE_RE = /\\/\\.[^\\/]*$/;\nfunction optionPathToRegex(p) {\n  return utils.escapeStrForRegex(p.replace(/\\//g, path.sep));\n}\n\nclass TestRunner {\n\n  constructor(config, options) {\n    this._opts = Object.assign({}, DEFAULT_OPTIONS, options);\n    this._config = Object.freeze(config);\n\n    try {\n      mkdirp.sync(this._config.cacheDirectory, '777');\n    } catch (e) {\n      if (e.code !== 'EEXIST') {\n        throw e;\n      }\n    }\n\n    const Resolver = require(config.moduleResolver);\n    this._resolver = new Resolver(config, {\n      resetCache: !config.cache,\n    });\n\n    this._testPathDirsRegExp = new RegExp(\n      config.testPathDirs\n        .map(dir => optionPathToRegex(dir))\n        .join('|')\n    );\n\n    this._nodeHasteTestRegExp = new RegExp(\n      optionPathToRegex(path.sep + config.testDirectoryName + path.sep) +\n      '.*\\\\.(' +\n        config.testFileExtensions\n          .map(ext => utils.escapeStrForRegex(ext))\n          .join('|') +\n      ')$'\n    );\n\n    // Map from testFilePath -> time it takes to run the test. Used to\n    // optimally schedule bigger test runs.\n    this._testPerformanceCache = null;\n  }\n\n  _getAllTestPaths() {\n    return this._resolver\n      .matchFilesByPattern(this._config.testDirectoryName)\n      .then(paths => paths.filter(path => this._isTestFilePath(path)));\n  }\n\n  _isTestFilePath(path) {\n    const testPathIgnorePattern =\n      this._config.testPathIgnorePatterns.length\n      ? new RegExp(this._config.testPathIgnorePatterns.join('|'))\n      : null;\n\n    return (\n      this._nodeHasteTestRegExp.test(path)\n      && !HIDDEN_FILE_RE.test(path)\n      && (!testPathIgnorePattern || !testPathIgnorePattern.test(path))\n      && this._testPathDirsRegExp.test(path)\n    );\n  }\n\n  collectChangedModules(relatedPaths, moduleMap, changed) {\n    const visitedModules = new Set();\n    while (changed.size) {\n      changed = new Set(moduleMap.filter(module => (\n        !visitedModules.has(module.path) &&\n        module.dependencies.some(dep => dep && changed.has(dep))\n      )).map(module => {\n        const path = module.path;\n        if (this._isTestFilePath(path)) {\n          relatedPaths.add(path);\n        }\n        visitedModules.add(path);\n        return module.name;\n      }));\n    }\n    return relatedPaths;\n  }\n\n  promiseTestPathsRelatedTo(changedPaths) {\n    const relatedPaths = new Set();\n    return this._resolver.getAllModules().then(allModules => {\n      const changed = new Set();\n      for (const path of changedPaths) {\n        if (this._resolver.getFS().fileExists(path)) {\n          const module = this._resolver.getModuleForPath(path);\n          if (module) {\n            changed.add(module.path);\n            if (this._isTestFilePath(module.path)) {\n              relatedPaths.add(module.path);\n            }\n          }\n        }\n      }\n      return Promise.all(Object.keys(allModules).map(path =>\n        this._resolver.getShallowDependencies(path)\n          .then(response => ({\n            name: path,\n            path,\n            dependencies: response.dependencies.map(dep => dep.path),\n          }))\n      )).then(moduleMap => Array.from(this.collectChangedModules(\n        relatedPaths,\n        moduleMap,\n        changed\n      )));\n    });\n  }\n\n  promiseHasteTestPathsRelatedTo(changedPaths) {\n    return Promise.all([\n      this._getAllTestPaths(),\n      this._resolver.getHasteMap(),\n    ]).then(response => {\n      const testPaths = response[0];\n      const hasteMap = response[1];\n      const relatedPaths = new Set();\n      const changed = new Set();\n      const moduleMap = testPaths.map(path => ({\n        name: path,\n        path,\n        dependencies: null,\n      }));\n      const collectModules = list => {\n        for (const name in list) {\n          const path = list[name];\n          if (changedPaths.has(path)) {\n            changed.add(name);\n            if (this._isTestFilePath(path)) {\n              relatedPaths.add(path);\n            }\n          }\n          moduleMap.push({name, path, dependencies: null});\n        }\n      };\n      collectModules(hasteMap.modules);\n      collectModules(hasteMap.mocks);\n\n      const deferreds = moduleMap.map(() => {\n        let resolve;\n        const promise = new Promise(_resolve => resolve = _resolve);\n        return {resolve, promise};\n      });\n      let i = 0;\n      const nextResolution = () => {\n        if (i >= moduleMap.length) {\n          return;\n        }\n\n        const currentIndex = i;\n        const module = moduleMap[currentIndex];\n        const deferred = deferreds[currentIndex];\n        i++;\n        this._resolver.getModuleForPath(module.path).getDependencies()\n          .then(dependencies => {\n            nextResolution();\n            moduleMap[currentIndex].dependencies = dependencies;\n          })\n          .then(() => deferred.resolve());\n      };\n\n      for (let i = 0; i < 20; i++) {\n        nextResolution();\n      }\n      return Promise.all(deferreds.map(deferred => deferred.promise))\n        .then(() => Array.from(this.collectChangedModules(\n          relatedPaths,\n          moduleMap,\n          changed\n        )));\n    });\n  }\n\n  promiseTestPathsMatching(pathPattern) {\n    return this._getAllTestPaths()\n      .then(paths => paths.filter(path => pathPattern.test(path)));\n  }\n\n  _getTestPerformanceCachePath() {\n    const config = this._config;\n    return path.join(config.cacheDirectory, 'perf-cache-' + config.name);\n  }\n\n  _sortTests(testPaths) {\n    // When running more tests than we have workers available, sort the tests\n    // by size - big test files usually take longer to complete, so we run\n    // them first in an effort to minimize worker idle time at the end of a\n    // long test run.\n    //\n    // After a test run we store the time it took to run a test and on\n    // subsequent runs we use that to run the slowest tests first, yielding the\n    // fastest results.\n    try {\n      this._testPerformanceCache = JSON.parse(fs.readFileSync(\n        this._getTestPerformanceCachePath()\n      ));\n    } catch (e) {}\n\n    const testPerformanceCache = this._testPerformanceCache;\n    if (testPaths.length > this._opts.maxWorkers) {\n      testPaths = testPaths\n        .map(path => [path, fs.statSync(path).size])\n        .sort((a, b) => {\n          const cacheA = testPerformanceCache && testPerformanceCache[a[0]];\n          const cacheB = testPerformanceCache && testPerformanceCache[b[0]];\n          if (cacheA !== null && cacheB !== null) {\n            return cacheA < cacheB ? 1 : -1;\n          }\n          return a[1] < b[1] ? 1 : -1;\n        })\n        .map(p => p[0]);\n    }\n\n    return testPaths;\n  }\n\n  _cacheTestResults(aggregatedResults) {\n    const cacheFile = this._getTestPerformanceCachePath();\n    let cache = this._testPerformanceCache;\n    if (!cache) {\n      cache = this._testPerformanceCache = {};\n    }\n    aggregatedResults.testResults.forEach(test => {\n      const perf = test && test.perfStats;\n      if (perf && perf.end && perf.start) {\n        cache[test.testFilePath] = perf.end - perf.start;\n      }\n    });\n    return promisify(fs.writeFile)(cacheFile, JSON.stringify(cache));\n  }\n\n  runTests(testPaths, reporter) {\n    const config = this._config;\n    if (!reporter) {\n      const TestReporter = require(config.testReporter);\n      if (config.useStderr) {\n        reporter = new TestReporter(Object.create(\n          process,\n          {stdout: {value: process.stderr}}\n        ));\n      } else {\n        reporter = new TestReporter();\n      }\n    }\n\n    testPaths = this._sortTests(testPaths);\n\n    const aggregatedResults = {\n      success: null,\n      startTime: null,\n      numTotalTestSuites: testPaths.length,\n      numPassedTestSuites: 0,\n      numFailedTestSuites: 0,\n      numRuntimeErrorTestSuites: 0,\n      numTotalTests: 0,\n      numPassedTests: 0,\n      numFailedTests: 0,\n      testResults: [],\n      postSuiteHeaders: [],\n    };\n\n    reporter.onRunStart && reporter.onRunStart(config, aggregatedResults);\n\n    const onTestResult = (testPath, testResult) => {\n      aggregatedResults.testResults.push(testResult);\n      aggregatedResults.numTotalTests +=\n        testResult.numPassingTests +\n        testResult.numFailingTests;\n      aggregatedResults.numFailedTests += testResult.numFailingTests;\n      aggregatedResults.numPassedTests += testResult.numPassingTests;\n      if (testResult.numFailingTests > 0) {\n        aggregatedResults.numFailedTestSuites++;\n      } else {\n        aggregatedResults.numPassedTestSuites++;\n      }\n      reporter.onTestResult && reporter.onTestResult(\n        config,\n        testResult,\n        aggregatedResults\n      );\n    };\n\n    const onRunFailure = (testPath, err) => {\n      const testResult = {\n        testFilePath: testPath,\n        testExecError: err,\n        testResults: [],\n      };\n      aggregatedResults.testResults.push(testResult);\n      aggregatedResults.numRuntimeErrorTestSuites++;\n      if (reporter.onTestResult) {\n        reporter.onTestResult(config, testResult, aggregatedResults);\n      }\n    };\n\n    aggregatedResults.startTime = Date.now();\n    const testRun = this._createTestRun(testPaths, onTestResult, onRunFailure);\n\n    return testRun\n      .then(() => {\n        aggregatedResults.success =\n          aggregatedResults.numFailedTests === 0 &&\n          aggregatedResults.numRuntimeErrorTestSuites === 0;\n        if (reporter.onRunComplete) {\n          reporter.onRunComplete(config, aggregatedResults);\n        }\n        return aggregatedResults;\n      })\n      .then(results => Promise.all([\n        this._cacheTestResults(results),\n        this.end(),\n      ]).then(() => results));\n  }\n\n  end() {\n    return this._resolver.end();\n  }\n\n  _createTestRun(testPaths, onTestResult, onRunFailure) {\n    if (this._opts.runInBand || testPaths.length <= 1) {\n      return this._createInBandTestRun(testPaths, onTestResult, onRunFailure);\n    } else {\n      return this._createParallelTestRun(testPaths, onTestResult, onRunFailure);\n    }\n  }\n\n  _createInBandTestRun(testPaths, onTestResult, onRunFailure) {\n    return testPaths.reduce((promise, path) =>\n      promise\n        .then(() => this._resolver.getHasteMap())\n        .then(moduleMap => new Test(path, this._config, moduleMap).run())\n        .then(result => onTestResult(path, result))\n        .catch(err => onRunFailure(path, err)),\n      Promise.resolve()\n    );\n  }\n\n  _persistModuleMap(moduleMap) {\n    const cacheFile = getCacheFilePath(\n      this._config.cacheDirectory,\n      getCacheKey('jest-module-map', this._config)\n    );\n    return promisify(fs.writeFile)(cacheFile, JSON.stringify(moduleMap));\n  }\n\n  _createParallelTestRun(testPaths, onTestResult, onRunFailure) {\n    const config = this._config;\n    return this._resolver.getHasteMap()\n      .then(moduleMap => this._persistModuleMap(moduleMap))\n      .then(() => {\n        const farm = workerFarm({\n          autoStart: true,\n          maxConcurrentCallsPerWorker: 1,\n          maxRetries: 2, // Allow for a couple of transient errors.\n          maxConcurrentWorkers: this._opts.maxWorkers,\n        }, TEST_WORKER_PATH);\n        const runTest = promisify(farm);\n        return Promise.all(testPaths.map(\n          path => runTest({path, config})\n            .then(testResult => onTestResult(path, testResult))\n            .catch(err => {\n              onRunFailure(path, err);\n              if (err.type === 'ProcessTerminatedError') {\n                console.error(\n                  'A worker process has quit unexpectedly! ' +\n                  'Most likely this an initialization error.'\n                );\n                process.exit(1);\n              }\n            }))\n        )\n        .then(() => workerFarm.end(farm));\n      });\n  }\n\n}\n\nmodule.exports = TestRunner;\n","dependencies":["./Test","graceful-fs","node-haste","./lib/getCacheKey","mkdirp","os","path","./lib/promisify","./lib/utils","worker-farm"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n /* eslint-disable fb-www/object-create-only-one-param */\n'use strict';\n\nconst Test = require('./Test');\n\nconst fs = require('graceful-fs');\nconst getCacheFilePath = require('node-haste').Cache.getCacheFilePath;\nconst getCacheKey = require('./lib/getCacheKey');\nconst mkdirp = require('mkdirp');\nconst os = require('os');\nconst path = require('path');\nconst promisify = require('./lib/promisify');\nconst utils = require('./lib/utils');\nconst workerFarm = require('worker-farm');\n\nconst TEST_WORKER_PATH = require.resolve('./TestWorker');\n\nconst DEFAULT_OPTIONS = {\n\n  /**\n   * When true, runs all tests serially in the current process, rather than\n   * creating a worker pool of child processes.\n   *\n   * This can be useful for debugging, or when the environment limits to a\n   * single process.\n   */\n  runInBand: false,\n\n  /**\n   * The maximum number of workers to run tests concurrently with.\n   *\n   * It's probably good to keep this at something close to the number of cores\n   * on the machine that's running the test.\n   */\n  maxWorkers: Math.max(os.cpus().length, 1),\n\n  /**\n   * The path to the executable node binary.\n   *\n   * This is used in the process of booting each of the workers.\n   */\n  nodePath: process.execPath,\n\n  /**\n   * The args to be passed to the node binary executable.\n   *\n   * This is used in the process of booting each of the workers.\n   * Passing --debug off to child processes can screw with socket connections\n   * of the parent process.\n   */\n  nodeArgv: process.execArgv.filter(arg => arg.indexOf('--debug') == -1),\n};\n\nconst HIDDEN_FILE_RE = /\\/\\.[^\\/]*$/;\nfunction optionPathToRegex(p) {\n  return utils.escapeStrForRegex(p.replace(/\\//g, path.sep));\n}\n\nclass TestRunner {\n\n  constructor(config, options) {\n    this._opts = Object.assign({}, DEFAULT_OPTIONS, options);\n    this._config = Object.freeze(config);\n\n    try {\n      mkdirp.sync(this._config.cacheDirectory, '777');\n    } catch (e) {\n      if (e.code !== 'EEXIST') {\n        throw e;\n      }\n    }\n\n    const Resolver = require(config.moduleResolver);\n    this._resolver = new Resolver(config, {\n      resetCache: !config.cache,\n    });\n\n    this._testPathDirsRegExp = new RegExp(\n      config.testPathDirs\n        .map(dir => optionPathToRegex(dir))\n        .join('|')\n    );\n\n    this._nodeHasteTestRegExp = new RegExp(\n      optionPathToRegex(path.sep + config.testDirectoryName + path.sep) +\n      '.*\\\\.(' +\n        config.testFileExtensions\n          .map(ext => utils.escapeStrForRegex(ext))\n          .join('|') +\n      ')$'\n    );\n\n    // Map from testFilePath -> time it takes to run the test. Used to\n    // optimally schedule bigger test runs.\n    this._testPerformanceCache = null;\n  }\n\n  _getAllTestPaths() {\n    return this._resolver\n      .matchFilesByPattern(this._config.testDirectoryName)\n      .then(paths => paths.filter(path => this._isTestFilePath(path)));\n  }\n\n  _isTestFilePath(path) {\n    const testPathIgnorePattern =\n      this._config.testPathIgnorePatterns.length\n      ? new RegExp(this._config.testPathIgnorePatterns.join('|'))\n      : null;\n\n    return (\n      this._nodeHasteTestRegExp.test(path)\n      && !HIDDEN_FILE_RE.test(path)\n      && (!testPathIgnorePattern || !testPathIgnorePattern.test(path))\n      && this._testPathDirsRegExp.test(path)\n    );\n  }\n\n  collectChangedModules(relatedPaths, moduleMap, changed) {\n    const visitedModules = new Set();\n    while (changed.size) {\n      changed = new Set(moduleMap.filter(module => (\n        !visitedModules.has(module.path) &&\n        module.dependencies.some(dep => dep && changed.has(dep))\n      )).map(module => {\n        const path = module.path;\n        if (this._isTestFilePath(path)) {\n          relatedPaths.add(path);\n        }\n        visitedModules.add(path);\n        return module.name;\n      }));\n    }\n    return relatedPaths;\n  }\n\n  promiseTestPathsRelatedTo(changedPaths) {\n    const relatedPaths = new Set();\n    return this._resolver.getAllModules().then(allModules => {\n      const changed = new Set();\n      for (const path of changedPaths) {\n        if (this._resolver.getFS().fileExists(path)) {\n          const module = this._resolver.getModuleForPath(path);\n          if (module) {\n            changed.add(module.path);\n            if (this._isTestFilePath(module.path)) {\n              relatedPaths.add(module.path);\n            }\n          }\n        }\n      }\n      return Promise.all(Object.keys(allModules).map(path =>\n        this._resolver.getShallowDependencies(path)\n          .then(response => ({\n            name: path,\n            path,\n            dependencies: response.dependencies.map(dep => dep.path),\n          }))\n      )).then(moduleMap => Array.from(this.collectChangedModules(\n        relatedPaths,\n        moduleMap,\n        changed\n      )));\n    });\n  }\n\n  promiseHasteTestPathsRelatedTo(changedPaths) {\n    return Promise.all([\n      this._getAllTestPaths(),\n      this._resolver.getHasteMap(),\n    ]).then(response => {\n      const testPaths = response[0];\n      const hasteMap = response[1];\n      const relatedPaths = new Set();\n      const changed = new Set();\n      const moduleMap = testPaths.map(path => ({\n        name: path,\n        path,\n        dependencies: null,\n      }));\n      const collectModules = list => {\n        for (const name in list) {\n          const path = list[name];\n          if (changedPaths.has(path)) {\n            changed.add(name);\n            if (this._isTestFilePath(path)) {\n              relatedPaths.add(path);\n            }\n          }\n          moduleMap.push({name, path, dependencies: null});\n        }\n      };\n      collectModules(hasteMap.modules);\n      collectModules(hasteMap.mocks);\n\n      const deferreds = moduleMap.map(() => {\n        let resolve;\n        const promise = new Promise(_resolve => resolve = _resolve);\n        return {resolve, promise};\n      });\n      let i = 0;\n      const nextResolution = () => {\n        if (i >= moduleMap.length) {\n          return;\n        }\n\n        const currentIndex = i;\n        const module = moduleMap[currentIndex];\n        const deferred = deferreds[currentIndex];\n        i++;\n        this._resolver.getModuleForPath(module.path).getDependencies()\n          .then(dependencies => {\n            nextResolution();\n            moduleMap[currentIndex].dependencies = dependencies;\n          })\n          .then(() => deferred.resolve());\n      };\n\n      for (let i = 0; i < 20; i++) {\n        nextResolution();\n      }\n      return Promise.all(deferreds.map(deferred => deferred.promise))\n        .then(() => Array.from(this.collectChangedModules(\n          relatedPaths,\n          moduleMap,\n          changed\n        )));\n    });\n  }\n\n  promiseTestPathsMatching(pathPattern) {\n    return this._getAllTestPaths()\n      .then(paths => paths.filter(path => pathPattern.test(path)));\n  }\n\n  _getTestPerformanceCachePath() {\n    const config = this._config;\n    return path.join(config.cacheDirectory, 'perf-cache-' + config.name);\n  }\n\n  _sortTests(testPaths) {\n    // When running more tests than we have workers available, sort the tests\n    // by size - big test files usually take longer to complete, so we run\n    // them first in an effort to minimize worker idle time at the end of a\n    // long test run.\n    //\n    // After a test run we store the time it took to run a test and on\n    // subsequent runs we use that to run the slowest tests first, yielding the\n    // fastest results.\n    try {\n      this._testPerformanceCache = JSON.parse(fs.readFileSync(\n        this._getTestPerformanceCachePath()\n      ));\n    } catch (e) {}\n\n    const testPerformanceCache = this._testPerformanceCache;\n    if (testPaths.length > this._opts.maxWorkers) {\n      testPaths = testPaths\n        .map(path => [path, fs.statSync(path).size])\n        .sort((a, b) => {\n          const cacheA = testPerformanceCache && testPerformanceCache[a[0]];\n          const cacheB = testPerformanceCache && testPerformanceCache[b[0]];\n          if (cacheA !== null && cacheB !== null) {\n            return cacheA < cacheB ? 1 : -1;\n          }\n          return a[1] < b[1] ? 1 : -1;\n        })\n        .map(p => p[0]);\n    }\n\n    return testPaths;\n  }\n\n  _cacheTestResults(aggregatedResults) {\n    const cacheFile = this._getTestPerformanceCachePath();\n    let cache = this._testPerformanceCache;\n    if (!cache) {\n      cache = this._testPerformanceCache = {};\n    }\n    aggregatedResults.testResults.forEach(test => {\n      const perf = test && test.perfStats;\n      if (perf && perf.end && perf.start) {\n        cache[test.testFilePath] = perf.end - perf.start;\n      }\n    });\n    return promisify(fs.writeFile)(cacheFile, JSON.stringify(cache));\n  }\n\n  runTests(testPaths, reporter) {\n    const config = this._config;\n    if (!reporter) {\n      const TestReporter = require(config.testReporter);\n      if (config.useStderr) {\n        reporter = new TestReporter(Object.create(\n          process,\n          {stdout: {value: process.stderr}}\n        ));\n      } else {\n        reporter = new TestReporter();\n      }\n    }\n\n    testPaths = this._sortTests(testPaths);\n\n    const aggregatedResults = {\n      success: null,\n      startTime: null,\n      numTotalTestSuites: testPaths.length,\n      numPassedTestSuites: 0,\n      numFailedTestSuites: 0,\n      numRuntimeErrorTestSuites: 0,\n      numTotalTests: 0,\n      numPassedTests: 0,\n      numFailedTests: 0,\n      testResults: [],\n      postSuiteHeaders: [],\n    };\n\n    reporter.onRunStart && reporter.onRunStart(config, aggregatedResults);\n\n    const onTestResult = (testPath, testResult) => {\n      aggregatedResults.testResults.push(testResult);\n      aggregatedResults.numTotalTests +=\n        testResult.numPassingTests +\n        testResult.numFailingTests;\n      aggregatedResults.numFailedTests += testResult.numFailingTests;\n      aggregatedResults.numPassedTests += testResult.numPassingTests;\n      if (testResult.numFailingTests > 0) {\n        aggregatedResults.numFailedTestSuites++;\n      } else {\n        aggregatedResults.numPassedTestSuites++;\n      }\n      reporter.onTestResult && reporter.onTestResult(\n        config,\n        testResult,\n        aggregatedResults\n      );\n    };\n\n    const onRunFailure = (testPath, err) => {\n      const testResult = {\n        testFilePath: testPath,\n        testExecError: err,\n        testResults: [],\n      };\n      aggregatedResults.testResults.push(testResult);\n      aggregatedResults.numRuntimeErrorTestSuites++;\n      if (reporter.onTestResult) {\n        reporter.onTestResult(config, testResult, aggregatedResults);\n      }\n    };\n\n    aggregatedResults.startTime = Date.now();\n    const testRun = this._createTestRun(testPaths, onTestResult, onRunFailure);\n\n    return testRun\n      .then(() => {\n        aggregatedResults.success =\n          aggregatedResults.numFailedTests === 0 &&\n          aggregatedResults.numRuntimeErrorTestSuites === 0;\n        if (reporter.onRunComplete) {\n          reporter.onRunComplete(config, aggregatedResults);\n        }\n        return aggregatedResults;\n      })\n      .then(results => Promise.all([\n        this._cacheTestResults(results),\n        this.end(),\n      ]).then(() => results));\n  }\n\n  end() {\n    return this._resolver.end();\n  }\n\n  _createTestRun(testPaths, onTestResult, onRunFailure) {\n    if (this._opts.runInBand || testPaths.length <= 1) {\n      return this._createInBandTestRun(testPaths, onTestResult, onRunFailure);\n    } else {\n      return this._createParallelTestRun(testPaths, onTestResult, onRunFailure);\n    }\n  }\n\n  _createInBandTestRun(testPaths, onTestResult, onRunFailure) {\n    return testPaths.reduce((promise, path) =>\n      promise\n        .then(() => this._resolver.getHasteMap())\n        .then(moduleMap => new Test(path, this._config, moduleMap).run())\n        .then(result => onTestResult(path, result))\n        .catch(err => onRunFailure(path, err)),\n      Promise.resolve()\n    );\n  }\n\n  _persistModuleMap(moduleMap) {\n    const cacheFile = getCacheFilePath(\n      this._config.cacheDirectory,\n      getCacheKey('jest-module-map', this._config)\n    );\n    return promisify(fs.writeFile)(cacheFile, JSON.stringify(moduleMap));\n  }\n\n  _createParallelTestRun(testPaths, onTestResult, onRunFailure) {\n    const config = this._config;\n    return this._resolver.getHasteMap()\n      .then(moduleMap => this._persistModuleMap(moduleMap))\n      .then(() => {\n        const farm = workerFarm({\n          autoStart: true,\n          maxConcurrentCallsPerWorker: 1,\n          maxRetries: 2, // Allow for a couple of transient errors.\n          maxConcurrentWorkers: this._opts.maxWorkers,\n        }, TEST_WORKER_PATH);\n        const runTest = promisify(farm);\n        return Promise.all(testPaths.map(\n          path => runTest({path, config})\n            .then(testResult => onTestResult(path, testResult))\n            .catch(err => {\n              onRunFailure(path, err);\n              if (err.type === 'ProcessTerminatedError') {\n                console.error(\n                  'A worker process has quit unexpectedly! ' +\n                  'Most likely this an initialization error.'\n                );\n                process.exit(1);\n              }\n            }))\n        )\n        .then(() => workerFarm.end(farm));\n      });\n  }\n\n}\n\nmodule.exports = TestRunner;\n"},"name":"/Users/cpojer/Projects/jest/src/TestRunner.js"}},"/Users/cpojer/Projects/jest/src/__tests__/TestRunner-test.js":{"metadata":{"mtime":1457398779000},"data":{"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst utils = require('../lib/utils');\n\ndescribe('TestRunner', () => {\n  const name = 'TestRunner';\n  let TestRunner;\n  let runner;\n\n  beforeEach(() => {\n    TestRunner = require('../TestRunner');\n  });\n\n  describe('_isTestFilePath', () => {\n\n    beforeEach(() => {\n      const utils = require('../lib/utils');\n      jest.mock('../resolvers/HasteResolver');\n      runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir: '.',\n        testPathDirs: [],\n      }));\n    });\n\n    it('supports ../ paths and unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/foo/bar/baz/../../../test.js';\n        expect(runner._isTestFilePath(path)).toEqual(true);\n      }\n    });\n\n    it('supports unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/test.js';\n        expect(runner._isTestFilePath(path)).toEqual(true);\n      }\n    });\n\n    it('supports win32 separators', () => {\n      if (process.platform === 'win32') {\n        const path = '\\\\path\\\\to\\\\__tests__\\\\test.js';\n        expect(runner._isTestFilePath(path)).toEqual(true);\n      }\n    });\n  });\n\n  describe('promiseTestPathsRelatedTo', () => {\n    const rootDir = path.join(\n      __dirname,\n      '..',\n      'HasteModuleLoader',\n      '__tests__',\n      'test_root'\n    );\n    const rootPath = path.join(rootDir, 'root.js');\n    const config = utils.normalizeConfig({\n      cacheDirectory: global.CACHE_DIRECTORY,\n      name: 'TestRunner-promiseTestPathsRelatedTo-tests',\n      rootDir,\n      // In order to test the reverse-dependency-resolution we assume\n      // every file is a test file in the test directory.\n      testPathPattern: '',\n    });\n\n    beforeEach(() => {\n      jest.dontMock('../resolvers/HasteResolver');\n      runner = new TestRunner(config);\n    });\n\n    pit('makes sure a file is related to itself', () => {\n      const path = rootPath;\n\n      return runner.promiseTestPathsRelatedTo(new Set([path]))\n        .then(relatedTests => {\n          expect(relatedTests).toEqual([rootPath]);\n        })\n        .then(() => runner.end());\n    });\n\n    pit('finds tests that depend directly on the path', () => {\n      const filePath = path.join(rootDir, 'RegularModule.js');\n      const parentDep = path.join(rootDir, 'ModuleWithSideEffects.js');\n      return runner.promiseTestPathsRelatedTo(new Set([filePath]))\n        .then(relatedTests => {\n          expect(relatedTests.sort()).toEqual([\n            parentDep,\n            filePath,\n            rootPath,\n          ]);\n        })\n        .then(() => runner.end());\n    });\n  });\n});\n","dependencies":["path","../lib/utils","../TestRunner"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+jsinfra\n */\n'use strict';\n\njest.autoMockOff();\n\nconst path = require('path');\nconst utils = require('../lib/utils');\n\ndescribe('TestRunner', () => {\n  const name = 'TestRunner';\n  let TestRunner;\n  let runner;\n\n  beforeEach(() => {\n    TestRunner = require('../TestRunner');\n  });\n\n  describe('_isTestFilePath', () => {\n\n    beforeEach(() => {\n      const utils = require('../lib/utils');\n      jest.mock('../resolvers/HasteResolver');\n      runner = new TestRunner(utils.normalizeConfig({\n        cacheDirectory: global.CACHE_DIRECTORY,\n        name,\n        rootDir: '.',\n        testPathDirs: [],\n      }));\n    });\n\n    it('supports ../ paths and unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/foo/bar/baz/../../../test.js';\n        expect(runner._isTestFilePath(path)).toEqual(true);\n      }\n    });\n\n    it('supports unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/test.js';\n        expect(runner._isTestFilePath(path)).toEqual(true);\n      }\n    });\n\n    it('supports win32 separators', () => {\n      if (process.platform === 'win32') {\n        const path = '\\\\path\\\\to\\\\__tests__\\\\test.js';\n        expect(runner._isTestFilePath(path)).toEqual(true);\n      }\n    });\n  });\n\n  describe('promiseTestPathsRelatedTo', () => {\n    const rootDir = path.join(\n      __dirname,\n      '..',\n      'HasteModuleLoader',\n      '__tests__',\n      'test_root'\n    );\n    const rootPath = path.join(rootDir, 'root.js');\n    const config = utils.normalizeConfig({\n      cacheDirectory: global.CACHE_DIRECTORY,\n      name: 'TestRunner-promiseTestPathsRelatedTo-tests',\n      rootDir,\n      // In order to test the reverse-dependency-resolution we assume\n      // every file is a test file in the test directory.\n      testPathPattern: '',\n    });\n\n    beforeEach(() => {\n      jest.dontMock('../resolvers/HasteResolver');\n      runner = new TestRunner(config);\n    });\n\n    pit('makes sure a file is related to itself', () => {\n      const path = rootPath;\n\n      return runner.promiseTestPathsRelatedTo(new Set([path]))\n        .then(relatedTests => {\n          expect(relatedTests).toEqual([rootPath]);\n        })\n        .then(() => runner.end());\n    });\n\n    pit('finds tests that depend directly on the path', () => {\n      const filePath = path.join(rootDir, 'RegularModule.js');\n      const parentDep = path.join(rootDir, 'ModuleWithSideEffects.js');\n      return runner.promiseTestPathsRelatedTo(new Set([filePath]))\n        .then(relatedTests => {\n          expect(relatedTests.sort()).toEqual([\n            parentDep,\n            filePath,\n            rootPath,\n          ]);\n        })\n        .then(() => runner.end());\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/jest/src/__tests__/TestRunner-test.js","isHaste":false}},"/Users/cpojer/Projects/jest/src/lib/transform.js":{"metadata":{"mtime":1457476277000},"data":{"moduleData":{"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst stableStringify = require('json-stable-stringify');\nconst mkdirp = require('mkdirp');\n\nconst cache = new Map();\nconst configToJsonMap = new Map();\nconst preprocessorRegExpCache = new WeakMap();\n\nconst removeFile = path => {\n  try {\n    fs.unlinkSync(path);\n  } catch (e) {}\n};\n\nconst createDirectory = path => {\n  try {\n    mkdirp.sync(path, '777');\n  } catch (e) {\n    if (e.code !== 'EEXIST') {\n      throw e;\n    }\n  }\n};\n\nconst getCacheKey = (preprocessor, fileData, filePath, config) => {\n  let configStr = configToJsonMap.get(config);\n  if (!configStr) {\n    configStr = stableStringify(config);\n    configToJsonMap.set(config, configStr);\n  }\n  if (typeof preprocessor.getCacheKey === 'function') {\n    return preprocessor.getCacheKey(fileData, filePath, configStr);\n  } else {\n    return crypto.createHash('md5')\n      .update(fileData)\n      .update(configStr)\n      .digest('hex');\n  }\n};\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    fs.writeFileSync(cachePath, fileData);\n  } catch (e) {\n    e.message = 'jest: failed to cache preprocess results in: ' + cachePath;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n\nconst readCacheFile = (filePath, cachePath) => {\n  if (!fs.existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n  try {\n    fileData = fs.readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read preprocess cache file: ' + cachePath;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n  return fileData;\n};\n\nmodule.exports = (filePath, config) => {\n  const mtime = fs.statSync(filePath).mtime;\n  const mapCacheKey = filePath + '_' + mtime.getTime();\n  const shouldCache =\n    config.preprocessCachingDisabled === false && config.cache === true;\n\n  if (cache.has(mapCacheKey)) {\n    return cache.get(mapCacheKey);\n  }\n\n  let fileData = fs.readFileSync(filePath, 'utf8');\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (fileData.startsWith('#!')) {\n    fileData = fileData.replace(/^#!.*/, '');\n  }\n\n  if (!preprocessorRegExpCache.has(config)) {\n    preprocessorRegExpCache.set(\n      config,\n      new RegExp(config.preprocessorIgnorePatterns.join('|'))\n    );\n  }\n  const regex = preprocessorRegExpCache.get(config);\n  if (\n    config.scriptPreprocessor &&\n    (\n      !config.preprocessorIgnorePatterns.length || !regex.test(filePath)\n    )\n  ) {\n    const preprocessor = require(config.scriptPreprocessor);\n    if (typeof preprocessor.process !== 'function') {\n      throw new TypeError(\n        'Jest: a preprocessor must export a `process` function.'\n      );\n    }\n\n    if (shouldCache) {\n      const baseCacheDir = path.join(config.cacheDirectory, 'preprocess-cache');\n      const cacheKey = getCacheKey(preprocessor, fileData, filePath, config);\n      // Create sub folders based on the cacheKey to avoid creating one\n      // directory with many files.\n      const cacheDir = path.join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n      const cachePath = path.join(\n        cacheDir,\n        path.basename(filePath, path.extname(filePath)) + '_' + cacheKey\n      );\n      createDirectory(cacheDir);\n      const cachedData = readCacheFile(filePath, cachePath);\n      if (cachedData) {\n        fileData = cachedData;\n      } else {\n        fileData = preprocessor.process(fileData, filePath, config);\n        writeCacheFile(cachePath, fileData);\n      }\n    } else {\n      fileData = preprocessor.process(fileData, filePath, config);\n    }\n  }\n\n  cache.set(mapCacheKey, fileData);\n  return fileData;\n};\n","dependencies":["crypto","graceful-fs","path","json-stable-stringify","mkdirp"],"source":"/**\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst stableStringify = require('json-stable-stringify');\nconst mkdirp = require('mkdirp');\n\nconst cache = new Map();\nconst configToJsonMap = new Map();\nconst preprocessorRegExpCache = new WeakMap();\n\nconst removeFile = path => {\n  try {\n    fs.unlinkSync(path);\n  } catch (e) {}\n};\n\nconst createDirectory = path => {\n  try {\n    mkdirp.sync(path, '777');\n  } catch (e) {\n    if (e.code !== 'EEXIST') {\n      throw e;\n    }\n  }\n};\n\nconst getCacheKey = (preprocessor, fileData, filePath, config) => {\n  let configStr = configToJsonMap.get(config);\n  if (!configStr) {\n    configStr = stableStringify(config);\n    configToJsonMap.set(config, configStr);\n  }\n  if (typeof preprocessor.getCacheKey === 'function') {\n    return preprocessor.getCacheKey(fileData, filePath, configStr);\n  } else {\n    return crypto.createHash('md5')\n      .update(fileData)\n      .update(configStr)\n      .digest('hex');\n  }\n};\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    fs.writeFileSync(cachePath, fileData);\n  } catch (e) {\n    e.message = 'jest: failed to cache preprocess results in: ' + cachePath;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n\nconst readCacheFile = (filePath, cachePath) => {\n  if (!fs.existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n  try {\n    fileData = fs.readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read preprocess cache file: ' + cachePath;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n  return fileData;\n};\n\nmodule.exports = (filePath, config) => {\n  const mtime = fs.statSync(filePath).mtime;\n  const mapCacheKey = filePath + '_' + mtime.getTime();\n  const shouldCache =\n    config.preprocessCachingDisabled === false && config.cache === true;\n\n  if (cache.has(mapCacheKey)) {\n    return cache.get(mapCacheKey);\n  }\n\n  let fileData = fs.readFileSync(filePath, 'utf8');\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (fileData.startsWith('#!')) {\n    fileData = fileData.replace(/^#!.*/, '');\n  }\n\n  if (!preprocessorRegExpCache.has(config)) {\n    preprocessorRegExpCache.set(\n      config,\n      new RegExp(config.preprocessorIgnorePatterns.join('|'))\n    );\n  }\n  const regex = preprocessorRegExpCache.get(config);\n  if (\n    config.scriptPreprocessor &&\n    (\n      !config.preprocessorIgnorePatterns.length || !regex.test(filePath)\n    )\n  ) {\n    const preprocessor = require(config.scriptPreprocessor);\n    if (typeof preprocessor.process !== 'function') {\n      throw new TypeError(\n        'Jest: a preprocessor must export a `process` function.'\n      );\n    }\n\n    if (shouldCache) {\n      const baseCacheDir = path.join(config.cacheDirectory, 'preprocess-cache');\n      const cacheKey = getCacheKey(preprocessor, fileData, filePath, config);\n      // Create sub folders based on the cacheKey to avoid creating one\n      // directory with many files.\n      const cacheDir = path.join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n      const cachePath = path.join(\n        cacheDir,\n        path.basename(filePath, path.extname(filePath)) + '_' + cacheKey\n      );\n      createDirectory(cacheDir);\n      const cachedData = readCacheFile(filePath, cachePath);\n      if (cachedData) {\n        fileData = cachedData;\n      } else {\n        fileData = preprocessor.process(fileData, filePath, config);\n        writeCacheFile(cachePath, fileData);\n      }\n    } else {\n      fileData = preprocessor.process(fileData, filePath, config);\n    }\n  }\n\n  cache.set(mapCacheKey, fileData);\n  return fileData;\n};\n"},"name":"/Users/cpojer/Projects/jest/src/lib/transform.js","isHaste":false}},"/Users/cpojer/Projects/jest/src/lib/resolveNodeModule.js":{"metadata":{"mtime":1457483261000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/lib/__tests__/utils-normalizeConfig-test.js":{"metadata":{"mtime":1457481216000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/environments/JSDOMEnvironment.js":{"metadata":{"mtime":1457482562000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/HasteModuleLoader.js":{"metadata":{"mtime":1457483452000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/lib/utils.js":{"metadata":{"mtime":1457483478000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/jest.js":{"metadata":{"mtime":1457482241000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/resolvers/HasteResolver.js":{"metadata":{"mtime":1457491403000},"data":{"isHaste":false}},"/Users/cpojer/Projects/jest/src/HasteModuleLoader/__tests__/HasteModuleLoader-currentTestPath-test.js":{"metadata":{"mtime":1457630564000},"data":{}}}