/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};function _toArray(arr) {return Array.isArray(arr) ? arr : Array.from(arr);}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError('Cannot call a class as a function');}}function _inherits(subClass, superClass) {if (typeof superClass !== 'function' && superClass !== null) {throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;}



/**
 * Utility methods (eg. for unmocking Relay internals) and custom Jasmine
 * matchers.
 */
var RelayTestUtils = { 
  /**
   * Returns true if `query` contains a node that equals the `target` node
   */
  containsNode: function (query, target) {
    function find(node) {
      if (node.equals(target)) {
        return true;}

      var children = node.getChildren();
      return children.length > 0 && children.some(find);}

    return find(query);}, 


  createRenderer: function (container) {
    var React = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react');
    var ReactDOM = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react-dom');
    var RelayContext = require('RelayContext');
    var RelayPropTypes = require('RelayPropTypes');
    var RelayRoute = require('RelayRoute');
    var invariant = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant');var 

    ContextSetter = (function (_React$Component) {_inherits(ContextSetter, _React$Component);function ContextSetter() {_classCallCheck(this, ContextSetter);_React$Component.apply(this, arguments);}ContextSetter.prototype.
      getChildContext = function getChildContext() {
        return this.props.context;};ContextSetter.prototype.

      render = function render() {
        return this.props.render();};return ContextSetter;})(React.Component);


    ContextSetter.childContextTypes = { 
      relay: RelayPropTypes.Context, 
      route: RelayPropTypes.QueryConfig.isRequired };var 


    MockPointer = 
    function MockPointer(dataID) {_classCallCheck(this, MockPointer);
      this.dataID = dataID;};



    container = container || document.createElement('div');

    return { 
      render: function (render, relay, route) {
        invariant(
        relay == null || relay instanceof RelayContext, 
        'render(): Expected an instance of `RelayContext`.');

        relay = relay || new RelayContext();
        route = route || RelayRoute.genMockInstance();

        var result;
        function ref(component) {
          result = component;}

        ReactDOM.render(
        React.createElement(ContextSetter, { 
          context: { relay: relay, route: route }, 
          render: function () {
            var element = render(function (dataID) {return new MockPointer(dataID);});
            var pointers = {};
            for (var propName in element.props) {
              var propValue = element.props[propName];
              if (propValue instanceof MockPointer) {
                var fragmentReference = element.type.getFragment(propName);
                if (fragmentReference == null) {
                  throw new Error(
                  'Query not found, `' + element.type.displayName + '.' + 
                  propName + '`.');}


                pointers[propName] = RelayTestUtils.getPointer(
                propValue.dataID, 
                RelayTestUtils.getNode(fragmentReference.getFragment({})));}}



            return React.cloneElement(element, _extends({}, pointers, { ref: ref }));} }), 


        container);

        return result;} };}, 




  conditionOnType: function (fragment) {
    var QueryBuilder = require('QueryBuilder');
    var RelayFragmentReference = require('RelayFragmentReference');
    var invariant = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant');

    invariant(
    !!QueryBuilder.getFragment(fragment), 
    'conditionOnType(): Argument must be a GraphQL.QueryFragment.');

    var reference = new RelayFragmentReference(
    function () {return fragment;}, 
    {});

    reference.conditionOnType();
    return reference;}, 


  createCall: function (name, value) {
    var QueryBuilder = require('QueryBuilder');

    if (Array.isArray(value)) {
      value = value.map(QueryBuilder.createCallValue);} else 
    if (value != null) {
      value = QueryBuilder.createCallValue(value);}

    return QueryBuilder.createCall(name, value);}, 


  createContainerFragment: function (fragment) {
    var RelayFragmentReference = require('RelayFragmentReference');
    return RelayFragmentReference.createForContainer(
    function () {return fragment;}, 
    {});}, 



  defer: function (fragment) {
    var QueryBuilder = require('QueryBuilder');
    var RelayFragmentReference = require('RelayFragmentReference');
    var invariant = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant');

    invariant(
    !!QueryBuilder.getFragment(fragment), 
    'defer(): Argument must be a GraphQL.QueryFragment.');

    var reference = new RelayFragmentReference(
    function () {return fragment;}, 
    {});

    reference.defer();
    return reference;}, 


  getNode: function (node, variables) {
    var RelayMetaRoute = require('RelayMetaRoute');
    var RelayQuery = require('RelayQuery');

    var route = RelayMetaRoute.get('$RelayTestUtils');
    return RelayQuery.Node.create(node, route, variables || {});}, 


  getPointer: function (dataID, fragment) {
    var RelayFragmentPointer = require('RelayFragmentPointer');
    var RelayQuery = require('RelayQuery');
    var invariant = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant');

    invariant(
    fragment instanceof RelayQuery.Fragment, 
    'getPointer(): expected a `RelayQueryFragment`, got `%s`.', 
    fragment.constructor.name);


    return RelayFragmentPointer.create(dataID, fragment);}, 


  /**
   * Convenience method for turning `node` into a properly formed ref query. We
   * can't produce one of these solely with `Relay.QL`, so we use a node from
   * `Relay.QL` as a basis and attach the appropriate args and ref params.
   */
  getRefNode: function (node, refParam) {
    var QueryBuilder = require('QueryBuilder');
    var RelayQuery = require('RelayQuery');
    var RelayMetaRoute = require('RelayMetaRoute');

    var invariant = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant');

    invariant(
    node.fieldName === 'nodes', 
    'getRefNode(): Ref queries require `nodes()` roots.');

    var callValue = Array.isArray(node.calls[0].value) ? 
    node.calls[0].value[0] : 
    node.calls[0].value;
    invariant(
    !!QueryBuilder.getCallVariable(callValue), 
    'getRefNode(): Expected a batch call variable, got `%s`.', 
    JSON.stringify(callValue));

    var name = callValue.callVariableName;
    var match = name.match(/^ref_(q\d+)$/);
    invariant(
    match, 
    'getRefNode(): Expected call variable of the form `<ref_q\\d+>`.');

    // e.g. `q0`
    var id = match[1];
    // e.g. `{ref_q0: '<ref_q0>'}`
    var variables = _defineProperty({}, name, '<' + callValue.callVariableName + '>');

    return RelayQuery.Root.create(_extends({}, 

    node, { 
      calls: [QueryBuilder.createCall(
      'id', 
      QueryBuilder.createBatchCallVariable(id, refParam.path))], 

      isDeferred: true }), 

    RelayMetaRoute.get('$RelayTestUtils'), 
    variables);}, 



  getVerbatimNode: function (node, variables) {
    return RelayTestUtils.filterGeneratedFields(
    RelayTestUtils.getNode(node, variables));}, 



  filterGeneratedFields: function (query) {
    var RelayQuery = require('RelayQuery');
    var filterRelayQuery = require('filterRelayQuery');

    return filterRelayQuery(
    query, 
    function (node) {return !(node instanceof RelayQuery.Field && node.isGenerated());});}, 



  matchers: { 

    /**
     * Checks if a RelayQuery.Root is `===` to another.
     */
    toBeQueryRoot: function () {
      return { 
        compare: function (actual, expected) {
          var RelayQuery = require('RelayQuery');
          var queryType = checkQueryType(actual, expected, RelayQuery.Root);
          if (!queryType.pass) {
            return queryType;}

          return checkQueryEquality(actual, expected, true);} };}, 




    /**
     * Checks that `warning` was invoked with a falsey condition with expected
     * arguments the supplied number of times. Example usage:
     *
     *   warning(false, "format", "x", "y");
     *   warning(false, "format", "x", "z");
     *
     *   expect(["format", "x", "y"]).toBeWarnedNTimes(1);
     *   expect(["format", "x", "z"]).toBeWarnedNTimes(1);
     *   expect(["format", "x"]).toBeWarnedNTimes(2);
     *
     *   warning(false, "format", "y");
     *
     *   expect(["format", "y"]).toBeWarnedNTimes(1);
     *
     *   warning(true, "format", "z");
     *
     *   expect(["format", "z"]).toBeWarnedNTimes(0);
     *
     *   expect(["format"]).toBeWarnedNTimes(3);
     *
     */
    toBeWarnedNTimes: function () {
      return { 
        compare: function (actual, expectedCount) {
          var warning = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning');
          if (!warning.mock) {
            throw new Error(
            'expect(...).toBeWarnedNTimes(): Requires ' + 
            '`jest.mock(\'warning\');`.');}


          var expectedArgs = actual;
          if (!Array.isArray(expectedArgs)) {
            throw new Error(
            'expect(...).toBeWarnedNTimes(): Requires an array of ' + 
            'warning args.');}var _expectedArgs = _toArray(


          expectedArgs);var format = _expectedArgs[0];var values = _expectedArgs.slice(1);
          if (!format) {
            throw new Error(
            'expect(...).toBeWarnedNTimes(): Requires a format string.');}



          var callsWithExpectedFormatButArgs = [];
          var callsWithExpectedArgs = warning.mock.calls.filter(function (args) {
            if (args[0] || 
            args[1] !== format) {
              return false;}

            if (values.some(function (value, ii) {return value !== args[ii + 2];})) {
              callsWithExpectedFormatButArgs.push(args.slice(1));
              return false;}

            return true;});


          var message = 
          'Expected to warn ' + expectedCount + ' time' + (
          expectedCount === 1 ? '' : 's') + ' with arguments: ' + 
          JSON.stringify(expectedArgs) + '.';
          var unexpectedCount = callsWithExpectedFormatButArgs.length;
          if (unexpectedCount) {
            message += ' Instead, called ' + unexpectedCount + 
            ' time' + (unexpectedCount === 1 ? '' : 's') + ' with arguments: ' + 
            JSON.stringify(callsWithExpectedFormatButArgs) + '.';}


          return { 
            pass: callsWithExpectedArgs.length === expectedCount, 
            message: message };} };}, 





    /**
     * Checks if a query node contains a node that `equals()` another.
     */
    toContainQueryNode: function () {
      return { 
        compare: function (actual, expected) {
          if (!RelayTestUtils.containsNode(actual, expected)) {
            return { 
              pass: false, 
              message: printQueryComparison(
              actual, 
              expected, 
              'to contain query node') };}



          return { 
            pass: true };} };}, 





    toEqualPrintedQuery: function () {
      return { 
        compare: function (actual, expected) {
          var minifiedActual = RelayTestUtils.minifyQueryText(actual);
          var minifiedExpected = RelayTestUtils.minifyQueryText(expected);

          if (minifiedActual !== minifiedExpected) {
            return { 
              pass: false, 
              message: [
              minifiedActual, 
              'to equal', 
              minifiedExpected].
              join('\n') };}


          return { 
            pass: true };} };}, 





    /**
     * Checks if a RelayQuery.Node is `equals()` to another.
     */
    toEqualQueryNode: function () {
      return { 
        compare: function (actual, expected) {
          var RelayQuery = require('RelayQuery');
          var queryType = checkQueryType(actual, expected, RelayQuery.Node);
          if (!queryType.pass) {
            return queryType;}

          return checkQueryEquality(actual, expected, false);} };}, 




    /**
     * Checks if a RelayQuery.Root is `equals()` to another.
     */
    toEqualQueryRoot: function () {
      return { 
        compare: function (actual, expected) {
          var RelayQuery = require('RelayQuery');
          var queryType = checkQueryType(actual, expected, RelayQuery.Root);
          if (!queryType.pass) {
            return queryType;}

          return checkQueryEquality(actual, expected, false);} };}, 




    toFailInvariant: function () {
      return { 
        compare: function (actual, expected) {
          expect(actual).toThrowError(expected);
          return { 
            pass: true };} };}, 





    /**
     * Compares a query path with another path. Succeeds when the paths are of
     * the same length have equivalent (shallow-equal) roots and fields.
     */
    toMatchPath: function () {
      return { 
        compare: function (actual, expected) {
          var QueryBuilder = require('QueryBuilder');
          var RelayMetaRoute = require('RelayMetaRoute');
          var RelayNodeInterface = require('RelayNodeInterface');
          var RelayQuery = require('RelayQuery');
          var RelayQueryPath = require('RelayQueryPath');

          var invariant = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant');
          var printRelayQuery = require('printRelayQuery');

          invariant(
          expected && expected instanceof RelayQueryPath, 
          'expect(...).toMatchPath(): Argument must be a RelayQueryPath.');

          if (!(actual instanceof RelayQueryPath)) {
            var name = actual ? actual.constructor.name : actual;
            return { 
              pass: false, 
              message: 'expected instance of RelayQueryPath but got [' + name + ']' };}


          var fragment = RelayQuery.Fragment.create(
          QueryBuilder.createFragment({ 
            children: [QueryBuilder.createField({ 
              fieldName: '__test__' })], 

            name: 'Test', 
            type: 'Node' }), 

          RelayMetaRoute.get('$RelayTestUtils'), 
          {});

          var mockStore = { 
            getDataID: function (fieldName, id) {
              invariant(
              fieldName === RelayNodeInterface.NODE, 
              'RelayTestUtils: Cannot `getDataID` for non-node root call ' + 
              '`%s`.', 
              fieldName);

              return id;}, 

            getType: function () {
              return 'RelayTestUtils';} };



          var actualQuery = actual.getQuery(mockStore, fragment);
          var expectedQuery = expected.getQuery(mockStore, fragment);

          if (!actualQuery.equals(expectedQuery)) {
            return { 
              pass: false, 
              message: [
              'Expected:', 
              '  ' + printRelayQuery(actualQuery).text, 
              '\ntoMatchPath:', 
              '  ' + printRelayQuery(expectedQuery).text].
              filter(function (token) {return token;}).join('\n') };}


          return { 
            pass: true };} };} }, 






  /**
   * Returns a version of the query text with extraneous whitespace removed.
   */
  minifyQueryText: function (queryText) {
    return queryText.
    replace(/\n+/g, ' ').
    replace(/\s+/g, ' ').
    replace(/\s*([\{\}\(\):,])\s*/g, '$1').
    trim();}, 


  /**
   * Helper to write the result payload of a (root) query into a store,
   * returning created/updated ID sets. The payload is transformed before
   * writing; property keys are rewritten from application names into
   * serialization keys matching the fields in the query.
   */
  writePayload: function (store, writer, query, payload, tracker, options) {
    var transformRelayQueryPayload = require('transformRelayQueryPayload');

    return RelayTestUtils.writeVerbatimPayload(
    store, 
    writer, 
    query, 
    transformRelayQueryPayload(query, payload), 
    tracker, 
    options);}, 



  /**
   * Helper to write the result payload into a store. Unlike `writePayload`,
   * the payload is not transformed first.
   */
  writeVerbatimPayload: function (store, writer, query, payload, tracker, options) {
    var RelayChangeTracker = require('RelayChangeTracker');
    var RelayQueryTracker = require('RelayQueryTracker');
    var RelayQueryWriter = require('RelayQueryWriter');
    var writeRelayQueryPayload = require('writeRelayQueryPayload');

    tracker = tracker || new RelayQueryTracker();
    options = options || {};
    var changeTracker = new RelayChangeTracker();
    var queryWriter = new RelayQueryWriter(
    store, 
    writer, 
    tracker, 
    changeTracker, 
    options);

    writeRelayQueryPayload(
    queryWriter, 
    query, 
    payload);

    return changeTracker.getChangeSet();} };



/**
 * @private
 */
function checkQueryType(actual, expected, ExpectedClass) {
  var expectedType = ExpectedClass.name;
  if (!(expected && expected instanceof ExpectedClass)) {
    throw new Error('expect(...): Requires a `' + expectedType + '`.');}

  if (!(actual instanceof ExpectedClass)) {
    var actualType = actual;
    if (actual && actual.constructor) {
      actualType = actual.constructor.name;}

    return { 
      pass: false, 
      message: 'Expected a `' + expectedType + '`, got `' + actualType + '`.' };}


  return { 
    pass: true };}



/**
 * @private
 */
function checkQueryEquality(actual, expected, toBe) {
  var flatActual = sortRelayQuery(actual);
  var flatExpected = sortRelayQuery(expected);

  if (toBe ? actual !== expected : !flatActual.equals(flatExpected)) {
    return { 
      pass: false, 
      message: printQueryComparison(
      actual, 
      expected, 
      toBe ? 'to be query' : 'to equal query') };}




  return { 
    pass: true };}



/**
 * @private
 */
function printQueryComparison(actual, expected, message) {
  var printRelayQuery = require('printRelayQuery');

  var formatRefParam = function (node) {return node.hasRefParam && node.hasRefParam() ? 
    '  [ref param: ' + JSON.stringify(node.getRefParam()) + ']' : 
    null;};

  return [
  'Expected:', 
  '  ' + printRelayQuery(actual).text, 
  formatRefParam(actual), 
  message + ':', 
  '  ' + printRelayQuery(expected).text, 
  formatRefParam(expected)].
  filter(function (line) {return !!line;}).join('\n');}


/**
 * @private
 *
 * Simulates sort key that existed when `getConcreteFragmentID` used to exist.
 */
var concreteFragmentSortKeys = new (require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/Map'))();
function createFragmentSortKey(node) {
  var stableStringify = require('stableStringify');
  var concreteNode = node.__concreteNode__;
  if (!concreteFragmentSortKeys.has(concreteNode)) {
    concreteFragmentSortKeys.set(concreteNode, concreteFragmentSortKeys.size);}

  return [
  concreteFragmentSortKeys.get(concreteNode), 
  node.getRoute().name, 
  stableStringify(node.getVariables())].
  join('.');}


/**
 * @private
 */
function sortRelayQuery(node) {
  var RelayQuery = require('RelayQuery');

  function getSortableKey(node) {
    return node instanceof RelayQuery.Fragment ? 
    createFragmentSortKey(node) : 
    node.getShallowHash();}

  function compare(a, b) {
    if (a === b) {
      return 0;} else 
    if (a < b) {
      return -1;} else 
    {
      return 1;}}



  return node.clone(node.getChildren().sort(function (a, b) {
    var aKey = getSortableKey(a);
    var bKey = getSortableKey(b);
    return compare(aKey, bKey);}).
  map(sortRelayQuery));}


module.exports = RelayTestUtils;