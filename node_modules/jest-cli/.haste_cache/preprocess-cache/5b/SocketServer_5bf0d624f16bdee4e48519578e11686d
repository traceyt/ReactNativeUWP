'use strict';












var debug=require('debug')('ReactNativePackager:SocketServer');



var MAX_IDLE_TIME=30*1000;
var MAX_STARTUP_TIME=5*60*1000;var 

SocketServer=function(){
function SocketServer(sockPath,options){var _this=this;babelHelpers.classCallCheck(this,SocketServer);
this._server=require('net').createServer();
this._server.listen(sockPath);
this._ready=new (require('promise'))(function(resolve,reject){
_this._server.once('error',function(e){return reject(e);});
_this._server.once('listening',function(){

_this._server.removeAllListeners('error');
_this._server.on(
'close',
function(){return debug('server closed');});


debug(
'Process %d listening on socket path %s '+
'for server with options %j',
process.pid,
sockPath,
options);

resolve(_this);
process.on('exit',function(code){
debug('exit code:',code);
require('fs').unlinkSync(sockPath);});});});




process.on('uncaughtException',function(error){
debug('uncaught error',error.stack);
setImmediate(function(){return process.exit(1);});});


this._server.on('connection',function(sock){return _this._handleConnection(sock);});


options.nonPersistent=true;
this._packagerServer=new (require('../Server'))(options);
this._dieEventually(MAX_STARTUP_TIME);}babelHelpers.createClass(SocketServer,[{key:'onReady',value:function onReady()


{
return this._ready;}},{key:'_handleConnection',value:function _handleConnection(


sock){var _this2=this;
debug('connection to server',process.pid);

var bunser=new (require('bser').BunserBuf)();
sock.on('data',function(buf){return bunser.append(buf);});
bunser.on('value',function(m){return _this2._handleMessage(sock,m);});
bunser.on('error',function(e){
e.message='Unhandled error from the bser buffer. '+
'Either error on encoding or message handling: \n'+
e.message;
throw e;});}},{key:'_handleMessage',value:function _handleMessage(



sock,m){var _this3=this;
if(!m||!m.id||!m.data){
console.error('SocketServer recieved a malformed message: %j',m);
return;}


debug('got request',m);


this._dieEventually();

var handleError=function(error){
debug('request error',error);
_this3._reply(sock,m.id,'error',error.stack);


if(error.type==='ProcessTerminatedError'){
setImmediate(function(){return process.exit(1);});}};



switch(m.type){
case 'getDependencies':
this._packagerServer.getDependencies(m.data).then(
function(_ref){var dependencies=_ref.dependencies;return _this3._reply(sock,m.id,'result',dependencies);},
handleError);

break;

case 'buildBundle':
this._packagerServer.buildBundle(m.data).then(
function(result){return _this3._reply(sock,m.id,'result',result);},
handleError);

break;

case 'buildPrepackBundle':
this._packagerServer.buildPrepackBundle(m.data).then(
function(result){return _this3._reply(sock,m.id,'result',result);},
handleError);

break;

case 'getOrderedDependencyPaths':
this._packagerServer.getOrderedDependencyPaths(m.data).then(
function(dependencies){return _this3._reply(sock,m.id,'result',dependencies);},
handleError);

break;

default:
this._reply(sock,m.id,'error','Unknown message type: '+m.type);}}},{key:'_reply',value:function _reply(



sock,id,type,data){
debug('request finished',type);

data=toJSON(data);

sock.write(require('bser').dumpToBuffer({
id:id,
type:type,
data:data}));




this._dieEventually();}},{key:'_dieEventually',value:function _dieEventually()


{var _this4=this;var delay=arguments.length<=0||arguments[0]===undefined?MAX_IDLE_TIME:arguments[0];
clearTimeout(this._deathTimer);
this._deathTimer=setTimeout(function(){
_this4._server.getConnections(function(error,numConnections){

if(error||numConnections<=0){
debug('server dying',process.pid);
process.exit();}

_this4._dieEventually();});},

delay);}}],[{key:'listenOnServerIPCMessages',value:function listenOnServerIPCMessages()


{
process.on('message',function(message){
if(!(message&&message.type&&message.type==='createSocketServer')){
return;}


debug('server got ipc message',message);var _message$data=

message.data;var options=_message$data.options;var sockPath=_message$data.sockPath;

options.blacklistRE=new RegExp(options.blacklistRE.source);

new SocketServer(sockPath,options).onReady().then(
function(){
debug('succesfully created server');
process.send({type:'createdServer'});},

function(error){
if(error.code==='EADDRINUSE'||error.code==='EEXIST'){


process.send({type:'createdServer'});



debug('server already started');
setImmediate(function(){return process.exit();});}else 
{
debug('error creating server',error.code);
throw error;}}).


done();});}}]);return SocketServer;}();





function toJSON(object){
if(!(object&&typeof object==='object')){
return object;}


if(object.toJSON){
return object.toJSON();}


for(var p in object){
object[p]=toJSON(object[p]);}


return object;}


module.exports=SocketServer;