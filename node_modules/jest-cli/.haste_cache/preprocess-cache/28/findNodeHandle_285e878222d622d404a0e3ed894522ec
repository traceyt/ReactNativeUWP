'use strict';


















































function findNodeHandle(componentOrHandle){
if(__DEV__){
var owner=require('ReactCurrentOwner').current;
if(owner!==null){
require('fbjs/lib/warning')(
owner._warnedAboutRefsInRender,
'%s is accessing findNodeHandle inside its render(). '+
'render() should be a pure function of props and state. It should '+
'never access something that requires stale data from the previous '+
'render, such as refs. Move this logic to componentDidMount and '+
'componentDidUpdate instead.',
owner.getName()||'A component');

owner._warnedAboutRefsInRender=true;}}


if(componentOrHandle==null){
return null;}

if(typeof componentOrHandle==='number'){

return componentOrHandle;}


var component=componentOrHandle;



var internalInstance=require('ReactInstanceMap').get(component);
if(internalInstance){
return require('ReactNativeTagHandles').rootNodeIDToTag[internalInstance._rootNodeID];}else 
{
var rootNodeID=component._rootNodeID;
if(rootNodeID){
return require('ReactNativeTagHandles').rootNodeIDToTag[rootNodeID];}else 
{
!(


typeof component==='object'&&
'_rootNodeID' in component||


component.render!=null&&
typeof component.render==='function')?require('fbjs/lib/invariant')(0,

'findNodeHandle(...): Argument is not a component '+
'(type: %s, keys: %s)',
typeof component,
Object.keys(component)):undefined;

!
false?require('fbjs/lib/invariant')(0,
'findNodeHandle(...): Unable to find node handle for unmounted '+
'component.'):undefined;}}}





module.exports=findNodeHandle;