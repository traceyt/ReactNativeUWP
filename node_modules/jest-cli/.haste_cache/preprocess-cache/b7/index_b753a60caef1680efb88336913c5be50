'use strict';














var validOptions={
project:true,
author:true};





var extraOptions;




var defaultOptions;




var Variation={
number:0,
gender:1};





var phrases;

module.exports=function fbt(){
return {
visitor:{




Program:function(path,state){
state.opts.fbtSentinel=state.opts.fbtSentinel||'__FBT__';
initExtraOptions(state);
initDefaultOptions(state);
phrases=[];},





JSXElement:function(path,state){
if(!isFbtElement(path.node)){
return;}


var children=filterWhiteSpaceNodes(path.node.children).
map(transformNamespacedFbtElement);

var text=children.length>1?
createConcatFromExpressions(children):
children[0];

var args=[
text,
getDescAttributeValue(path.node)];



if(path.node.openingElement.attributes.length>1){
args.push(
getOptionsFromAttributes(path.node.openingElement.attributes));}



var callNode=require('babel-types').callExpression(
require('babel-types').identifier('fbt'),
args);


callNode.loc=path.node.loc;
path.replaceWith(callNode);


path.parentPath.visit();},
















CallExpression:function(path,state){
if(!isFbtCall(path.node)){
return;}


if(path.node.arguments.length<2){
throw new Error(
'Expected fbt calls to have at least two arguments. Only '+
path.node.arguments.length+' was given.');}




var dataCollection=[];
var variations={};

var methodsState={
dataCollection:dataCollection,
variations:variations,
hasEnums:false};


path.traverse(fbtMethodCallVistors,methodsState);

var isTable=Object.keys(variations).length>0||methodsState.hasEnums;

var texts=isTable?
normalizeTableTexts(
extractTableTexts(path.node.arguments[0],variations)):
[normalizeSpaces(
expandStringConcat(path.node.arguments[0]).value).trim()];

var desc=normalizeSpaces(
expandStringConcat(path.node.arguments[1]).value).
trim();

var phrase={
type:isTable?'table':'text',
texts:texts,
desc:desc};


appendOptions(path.node,phrase);

if(state.opts.collectFbt){
addPhrase(path.node,phrase,state);}


var args=[
require('babel-types').stringLiteral(
state.opts.fbtSentinel+
JSON.stringify({
type:phrase.type,
texts:phrase.texts,
desc:phrase.desc,
incl_hash:state.opts.incl_hash,
project:phrase.project})+

state.opts.fbtSentinel)];



if(dataCollection.length>0){
args.push(require('babel-types').arrayExpression(dataCollection));}


path.replaceWith(require('babel-types').callExpression(
require('babel-types').memberExpression(
require('babel-types').identifier('fbt'),
require('babel-types').identifier('_')),

args));}}};};







function initExtraOptions(state){
extraOptions=state.opts.extraOptions||{};}


function initDefaultOptions(state){
defaultOptions={};
var fbtDocblockOptions=require('../util/docblock').getFromState(state).fbt;
if(fbtDocblockOptions){
try{
defaultOptions=JSON.parse(fbtDocblockOptions);}
catch(e){}
Object.keys(defaultOptions).forEach(checkOption);}

if(!defaultOptions.project){
defaultOptions.project='';}}



function getDescAttributeValue(node){
var descAttr=getAttributeByName(node.openingElement.attributes,'desc');
if(!descAttr){
throw new Error('<fbt> requires a "desc" attribute');}

if(descAttr.value.type==='JSXExpressionContainer'){
return descAttr.value.expression;}

return descAttr.value;}





function getOptionsFromAttributes(attributesNode){
var options=[];

attributesNode.forEach(function(node){
var option=node.name.name;



if(option==='desc'){
return;}


var value=node.value;
if(node.value.type==='JSXExpressionContainer'){
value=value.expression;}


options.push(require('babel-types').objectProperty(
require('babel-types').stringLiteral(checkOption(option)),
value));});



return require('babel-types').objectExpression(options);}


function checkOptions(optionsNode){
optionsNode.forEach(function(node){
checkOption(node.key.name||node.key.value);});

return optionsNode;}


function checkOption(option){
if(!validOptions.hasOwnProperty(option)&&
!extraOptions.hasOwnProperty(option)){
throw new Error('Invalid option "'+option+'". '+
'Only allowed: '+Object.keys(validOptions).join(', ')+' '+
Object.keys(extraOptions).join(', '));}


return option;}


function getVariationValue(variationName,variationInfo){

if(variationName==='number'&&variationInfo.value.type==='BooleanLiteral'){
if(variationInfo.value.value!==true){
throw new Error(
"fbt.param's number option should be an expression or 'true'");}



return null;}


return variationInfo.value;}


function extractEnumValues(node){
var values={};
node.properties.forEach(function(prop){
values[prop.key.name||prop.key.value]=prop.value.value;});

return values;}






function appendOptions(node,fbtArg){
var options=node.arguments[2];
require('util')._extend(fbtArg,defaultOptions);
if(options){
if(options.type!=='ObjectExpression'){
throw new Error(
'fbt(...) expects an ObjectExpression as its 3rd argument');}


checkOptions(options.properties).forEach(function(option){
var value=option.value.expression||option.value;
var name=option.key.name||option.key.value;


if(validOptions.hasOwnProperty(name)){
fbtArg[name]=normalizeSpaces(expandStringConcat(value,'').value);}});}}











var fbtMethodCallVistors={
CallExpression:{
enter:function(path,state){
var node=path.node;
var dataCollection=state.dataCollection;
var variations=state.variations;

var callee=node.callee;

if(!isFbtMember(callee)){
return;}


if(callee.property.type!=='Identifier'){
throw new Error(
'Expected fbt method to be an identifier, but got '+
callee.property.type);}



if(callee.property.name==='param'||
callee.property.name==='sameParam'){
if(node.arguments[0].type!=='StringLiteral'){
throw new Error(
'Expected first argument to fbt.param to be a string, but got '+
node.arguments[0].type);}




if(callee.property.name==='param'){
dataCollection.push(node);}





if(node.arguments.length===3){
var paramName=node.arguments[0].value;
var variationInfo=node.arguments[2].properties[0];
var variationName=variationInfo.key.name;
variations[paramName]={
type:variationName,
token:paramName};

var variationValues=[
require('babel-types').numericLiteral(Variation[variationName])];

var variationValue=getVariationValue(variationName,variationInfo);
if(variationValue){
variationValues.push(variationValue);}



node.arguments[2]=require('babel-types').arrayExpression(variationValues);
return;}




path.replaceWith(require('babel-types').stringLiteral('{'+node.arguments[0].value+'}'));}else 
if(callee.property.name==='enum'){
state.hasEnums=true;

node.callee.computed=true;
node.callee.property=require('babel-types').stringLiteral('enum');

var valuesArg=node.arguments[1];
var props;
if(valuesArg.type==='ArrayExpression'){
props=valuesArg.elements.map(function(val){
return require('babel-types').objectProperty(val,val);});}else 

if(valuesArg.type==='ObjectExpression'){
props=valuesArg.properties.map(function(prop){
if(prop.key.type==='Identifier'){
return require('babel-types').objectProperty(require('babel-types').stringLiteral(prop.key.name),prop.value);}else 
{
return prop;}});}else 


{
throw new Error(
'Expected an array or object as a second argument in `fbt.enum`');}


node.arguments[1]=require('babel-types').objectExpression(props);

dataCollection.push(node);
return;}else 
{
throw new Error('Unknown fbt method '+callee.property.name);}}}};






function isFbtElement(node){
var nameNode=node.openingElement.name;
return nameNode.type==='JSXIdentifier'&&isFbtName(nameNode.name);}


function isFbtCall(node){
return node.callee.type==='Identifier'&&isFbtName(node.callee.name);}


function isFbtMember(node){
return node.type==='MemberExpression'&&
isFbtName(node.object.name);}


function isFbtName(name){
return name==='fbt'||name==='Fbt';}





function filterWhiteSpaceNodes(nodes){
return nodes.filter(function(node){

return !(node.type==='JSXText'&&
node.value.match(/^\s+$/));});}







function transformNamespacedFbtElement(node){
switch(node.type){
case 'JSXElement':
return toFbtNamespacedCall(node);
case 'JSXText':
return require('babel-types').stringLiteral(normalizeSpaces(node.value));
case 'JSXExpressionContainer':
return require('babel-types').stringLiteral(
normalizeSpaces(expandStringConcat(node.expression).value));

default:
throw new Error('Unknown namespaced fbt type '+node.type);}}






var namespacedElementsArgsHandler={




param:function(node){
var attributes=node.openingElement.attributes;
var nameAttr=getAttributeByName(attributes,'name');
var children=filterWhiteSpaceNodes(node.children);

var paramChildren=children.filter(function(child){
return child.type==='JSXExpressionContainer'||
child.type==='JSXElement';});


if(paramChildren.length!==1){
throw new Error(
'fbt:param expects an {expression} or JSX element, and only one');}



var paramArgs=[
nameAttr.value,
paramChildren[0].expression||paramChildren[0]];


if(attributes.length>1){
var variations=this._getParamVariations(node);
if(variations.length>0){
paramArgs.push(require('babel-types').objectExpression(variations));}}



return paramArgs;},


_getParamVariations:function(node){
var variations=[];
var attributes=node.openingElement.attributes;
for(var i=0;i<attributes.length;i++){
var attr=attributes[i];
var attrName=attr.name.name;
if(attrName==='name'||attrName==='desc'){
continue;}

if(Variation.hasOwnProperty(attrName)){
variations.push(this._variationAttributeToOption(attr));}}


return variations;},


_variationAttributeToOption:function(attr){
var value;
if(attr.value.type==='StringLiteral'){
if(attr.value.value==='true'){
value=require('babel-types').booleanLiteral(true);}else 
if(attr.value.value==='false'){
value=require('babel-types').booleanLiteral(false);}else 
{
value=attr.value;}}else 

{
value=attr.value.expression;}

return require('babel-types').objectProperty(
require('babel-types').identifier(attr.name.name),
value);},






sameParam:function(node){
if(!node.openingElement.selfClosing){
throw new Error('Expected fbt same param to be selfClosing.');}


var nameAttr=getAttributeByName(node.openingElement.attributes,'name');

return [nameAttr.value];},





enum:function(node){
if(!node.openingElement.selfClosing){
throw new Error('Expected fbt enum to be selfClosing.');}


var rangeAttr=getAttributeByName(
node.openingElement.attributes,'enum-range');


if(rangeAttr.value.type!=='JSXExpressionContainer'){
throw new Error(
'Expected JSX Expression for enum-range attribute but got '+
rangeAttr.value.type);}



var valueAttr=getAttributeByName(
node.openingElement.attributes,'value');


if(valueAttr.value.type!=='JSXExpressionContainer'){
throw new Error(
'Expected value attribute of `<fbt:enum>` to be an expression '+
'but got '+valueAttr.value.type);}



return [valueAttr.value.expression,rangeAttr.value.expression];}};



function toFbtNamespacedCall(node){
var name=validateNamespacedFbtElement(node.openingElement.name);
return require('babel-types').callExpression(
require('babel-types').memberExpression(
require('babel-types').identifier('fbt'),
require('babel-types').identifier(name),
false),

namespacedElementsArgsHandler[name](node));}










function validateNamespacedFbtElement(node){
var valid=false;
var handlerName;


if(node.type==='JSXNamespacedName'){
handlerName=node.name.name;
valid=
node.namespace.type==='JSXIdentifier'&&
node.namespace.name==='fbt'&&(
handlerName==='param'||
handlerName==='same-param'||
handlerName==='enum');}else 



if(node.type==='JSXIdentifier'){
handlerName=node.name.substr(3).toLowerCase();
valid=node.name==='FbtParam'||
node.name==='FbtSameParam'||
node.name==='FbtEnum';}


if(!valid){
throw new Error('`<fbt>` cannot have arbitrary JSX children.');}


if(handlerName==='same-param'||handlerName==='sameparam'){
handlerName='sameParam';}


return handlerName;}


function normalizeSpaces(value){
return value.replace(/\s+/g,' ');}












function extractTableTexts(node,variations,texts){
texts||(texts=[]);
if(node.type==='BinaryExpression'){
if(node.operator!=='+'){
throw new Error(
'Expected concatination operator (+) but got '+node.operator);}


extractTableTexts(node.left,variations,texts);
extractTableTexts(node.right,variations,texts);}else 

if(node.type==='StringLiteral'){



var previousText=texts[texts.length-1];
if(typeof previousText==='string'){
texts[texts.length-1]=normalizeSpaces(previousText+node.value);}else 
{
texts.push(node.value);}}else 


if(node.type==='CallExpression'){
if(node.callee.property.name==='param'){
texts.push(variations[node.arguments[0].value]);}else 
if(node.callee.property.value==='enum'){
texts.push({
type:'enum',
values:extractEnumValues(node.arguments[1])});}}




return texts;}







function normalizeTableTexts(texts){
var firstText=texts[0];
if(firstText&&typeof firstText==='string'){
texts[0]=firstText.replace(/^\s+/,'');}

var lastText=texts[texts.length-1];
if(lastText&&typeof lastText==='string'){
texts[texts.length-1]=lastText.replace(/\s+$/,'');}

return texts;}





function getAttributeByName(attributes,name){
for(var i=0;i<attributes.length;i++){
var attr=attributes[i];
if(attr.type==='JSXAttribute'&&attr.name.name===name){
return attr;}}


throw new Error('Unable to find attribute `'+name+'`.');}






function createConcatFromExpressions(nodes){
if(nodes.length===0){
throw new Error('Cannot create an expression without nodes.');}

return nodes.reduceRight(function(rest,node){
return require('babel-types').binaryExpression('+',node,rest);});}







function expandStringConcat(node){
if(node.type==='BinaryExpression'){
if(node.operator!=='+'){
throw new Error(
'Expected concatination operator (+) but got '+node.operator);}


return require('babel-types').stringLiteral(
expandStringConcat(node.left).value+
expandStringConcat(node.right).value);}else 

if(node.type==='StringLiteral'){
return node;}else 
{
throw new Error(
'Expected string literal or concatenation, but got '+node.type);}}




function addPhrase(node,phrase,state){
var filepath=state.opts.filepath;
phrases.push(require('util')._extend({
filepath:filepath,
line_beg:node.loc.start.line,
col_beg:node.loc.start.column,
line_end:node.loc.end.line,
col_end:node.loc.end.column},
phrase));}


module.exports.getExtractedStrings=function(){
return phrases;};