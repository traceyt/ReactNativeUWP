/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');

jest.dontMock('recycleNodesInto');






describe('recycleNodesInto', function () {
  beforeEach(function () {
    jest.resetModuleRegistry();});


  describe('scalars', function () {
    it('ignores when `prevData` is null or undefined', function () {
      var nextData = {};
      expect(require('recycleNodesInto')(null, nextData)).toBe(nextData);
      expect(require('recycleNodesInto')(undefined, nextData)).toBe(nextData);});


    it('returns when `nextData` is null or undefined', function () {
      var prevData = {};
      expect(require('recycleNodesInto')(prevData, null)).toBe(null);
      expect(require('recycleNodesInto')(prevData, undefined)).toBe(undefined);});


    it('returns when `nextData` is a string or number', function () {
      expect(require('recycleNodesInto')(null, 'foo')).toBe('foo');
      expect(require('recycleNodesInto')(null, 1)).toBe(1);});


    it('ignores when `prevData` is not exactly the same', function () {
      expect(require('recycleNodesInto')(1, '1')).toBe('1');
      expect(require('recycleNodesInto')(null, '')).toBe('');});});



  describe('objects', function () {
    it('recycles equal leaf objects', function () {
      var prevData = { foo: 1 };
      var nextData = { foo: 1 };
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('recycles parent objects with equal leaf objects', function () {
      var prevData = { foo: { bar: 1 } };
      var nextData = { foo: { bar: 1 } };
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('does not recycle unequal leaf objects', function () {
      var prevData = { foo: 1 };
      var nextData = { foo: 100 };
      expect(require('recycleNodesInto')(prevData, nextData)).not.toBe(prevData);});


    it('does not recycle parent objects with unequal leaf objects', function () {
      var prevData = { foo: { bar: 1 } };
      var nextData = { foo: { bar: 100 } };
      expect(require('recycleNodesInto')(prevData, nextData)).not.toBe(prevData);});


    it('does not recycle object with fewer properties', function () {
      var prevData = { foo: 1 };
      var nextData = { foo: 1, bar: 2 };
      expect(require('recycleNodesInto')(prevData, nextData)).not.toBe(prevData);});


    it('does not recycle object with more properties', function () {
      var prevData = { foo: 1, bar: 2 };
      var nextData = { foo: 1 };
      expect(require('recycleNodesInto')(prevData, nextData)).toEqual({ foo: 1 });});


    it('recycles equal leaf objects with unequal parent objects', function () {
      var prevData = { foo: { bar: 1 }, baz: 2 };
      var nextData = { foo: { bar: 1 }, baz: 200 };
      var recycled = require('recycleNodesInto')(prevData, nextData);

      expect(recycled).not.toBe(prevData);
      expect(recycled.bar).toBe(prevData.bar);});


    it('does not recycle arrays as objects', function () {
      var prevData = [1, 2];
      var nextData = { 0: 1, 1: 2 };
      expect(require('recycleNodesInto')(prevData, nextData)).not.toBe(prevData);});});



  describe('arrays', function () {
    it('recycles arrays with equal scalars', function () {
      var prevData = [1, 2, 3];
      var nextData = [1, 2, 3];
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('does not recycle arrays with unequal scalars', function () {
      var prevData = [1, 2, 3];
      var nextData = [4, 5, 6];
      expect(require('recycleNodesInto')(prevData, nextData)).not.toBe(prevData);});


    it('recycles arrays with equal objects without mutating `prevData`', function () {
      var prevData = [{ foo: 1 }, { bar: 2 }];
      var nextData = [{ foo: 1 }, { bar: 2 }];
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('recycles arrays without mutating `prevData`', function () {
      var prevItem = { foo: 1 };
      var prevData = [prevItem];
      var nextData = [{ foo: 1 }];
      var recycled = require('recycleNodesInto')(prevData, nextData);

      expect(recycled).toBe(prevData);
      expect(recycled[0]).toBe(prevItem);});


    it('recycles arrays with equal objects but unequal parent objects', function () {
      var prevData = { foo: [{ foo: 1 }, { bar: 2 }], qux: 3 };
      var nextData = { foo: [{ foo: 1 }, { bar: 2 }], qux: 300 };
      var recycled = require('recycleNodesInto')(prevData, nextData);

      expect(recycled).not.toBe(prevData);
      expect(recycled.foo).toBe(prevData.foo);});


    it('recycles equal objects from an array with unequal siblings', function () {
      var prevData = [{ foo: 1 }, { bar: 2 }];
      var nextData = [{ foo: 1 }, { bar: 200 }];
      var recycled = require('recycleNodesInto')(prevData, nextData);

      expect(recycled).not.toBe(prevData);
      expect(recycled[0]).toBe(prevData[0]);
      expect(recycled[1]).not.toBe(prevData[1]);});


    it('recycles equal objects from an array with fewer siblings', function () {
      var prevData = [{ foo: 1 }];
      var nextData = [{ foo: 1 }, { bar: 2 }];
      var recycled = require('recycleNodesInto')(prevData, nextData);

      expect(recycled).not.toBe(prevData);
      expect(recycled[0]).toBe(prevData[0]);
      expect(recycled[1]).toEqual({ bar: 2 });});


    it('recycles equal objects from an array with more siblings', function () {
      var prevData = [{ foo: 1 }, { bar: 2 }];
      var nextData = [{ foo: 1 }];
      var recycled = require('recycleNodesInto')(prevData, nextData);

      expect(recycled).not.toBe(prevData);
      expect(recycled[0]).toBe(prevData[0]);
      expect(recycled.length).toBe(1);});


    it('does not recycle objects as arrays', function () {
      var prevData = Object.assign(Object.create({ length: 2 }), { 0: 1, 1: 2 });
      var nextData = [1, 2];
      expect(require('recycleNodesInto')(prevData, nextData)).not.toBe(prevData);});});



  describe('fragment pointers', function () {
    var getPointer;

    beforeEach(function () {var 
      getNode = require('RelayTestUtils').getNode;

      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'wMblg/9c+6ak:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RecycleNodesIntoRelayQL', type: 'Node' };})());
      getPointer = function (dataID) {
        return require('RelayTestUtils').getPointer(dataID, fragment);};});



    it('recycles equal fragment pointers', function () {
      var prevData = getPointer('A');
      var nextData = getPointer('A');
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('recycles parent objects with equal fragment pointers', function () {
      var prevData = { foo: getPointer('A') };
      var nextData = { foo: getPointer('A') };
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('recycles arrays with equal fragment pointers', function () {
      var prevData = [getPointer('A')];
      var nextData = [getPointer('A')];
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(prevData);});


    it('does not recycle unequal fragment pointers', function () {
      var prevData = getPointer('A');
      var nextData = getPointer('B');
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(nextData);});


    it('does not recycle parent objects with unequal fragment pointers', function () {
      var prevData = { foo: getPointer('A') };
      var nextData = { foo: getPointer('B') };
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(nextData);});


    it('does not recycle arrays with unequal fragment pointers', function () {
      var prevData = [getPointer('A')];
      var nextData = [getPointer('B')];
      expect(require('recycleNodesInto')(prevData, nextData)).toBe(nextData);});});});