/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');









describe('inferRelayFieldsFromData', function () {var 
  getVerbatimNode = require('RelayTestUtils').getVerbatimNode;var matchers = require('RelayTestUtils').matchers;
  var HAS_NEXT_PAGE = undefined, HAS_PREV_PAGE = undefined, PAGE_INFO = undefined;

  beforeEach(function () {
    jest.resetModuleRegistry();


    HAS_NEXT_PAGE = require('RelayConnectionInterface').HAS_NEXT_PAGE;
    HAS_PREV_PAGE = require('RelayConnectionInterface').HAS_PREV_PAGE;
    PAGE_INFO = require('RelayConnectionInterface').PAGE_INFO;


    jasmine.addMatchers(_extends({}, 
    require('RelayTestUtils').matchers, { 
      toEqualFields: function () {
        return { 
          compare: function (actual, expected) {
            expected = require('flattenRelayQuery')(getVerbatimNode(expected));
            actual = require('flattenRelayQuery')(expected.clone(actual));
            // NOTE: Generated fields might get in the way.
            return matchers.toEqualQueryNode().compare(actual, expected);} };} }));});






  it('generates metadata for fields', function () {
    var query = require('inferRelayFieldsFromData')({ 
      id: '123' });

    expect(query).toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'dg/zk2Wur+do:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());




    expect(query[0].isPlural()).toBe(false);});


  it('infers scalar fields from scalars', function () {
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      name: 'Alice' })).
    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: '4ldrtljGPPuj:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});







  it('infers nested fields from objects', function () {
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      address: { 
        city: 'Menlo Park' } })).

    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'yRGKZ7ChgwTW:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});









  it('infers unterminated fields from null', function () {
    var inferredFields = require('inferRelayFieldsFromData')({ 
      id: '123', 
      address: null });


    expect(inferredFields[0] instanceof require('RelayQuery').Field).toBe(true);
    expect(inferredFields[0].canHaveSubselections()).toBe(false);
    expect(inferredFields[0].getSchemaName()).toBe('id');

    expect(inferredFields[1] instanceof require('RelayQuery').Field).toBe(true);
    // Though this field can have subselections, there is no way we can infer
    // this from `address: null`. Defaults to false.
    expect(inferredFields[1].canHaveSubselections()).toBe(false);
    expect(inferredFields[1].getSchemaName()).toBe('address');});


  it('infers plural fields from arrays of scalars', function () {
    var fields = require('inferRelayFieldsFromData')({ 
      id: '123', 
      websites: [
      'facebook.com', 
      'google.com'] });


    expect(fields).toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'websites', kind: 'Field', metadata: { isPlural: true }, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'LD3JSmzNvUnl:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());





    expect(fields[1].isPlural()).toBe(true);});


  it('infers plural nested fields from arrays of objects', function () {
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      screennames: [
      { service: 'GTALK' }, 
      { service: 'TWITTER' }] })).

    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'service', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'screennames', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Screenname' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'ngvTYUrojxCV:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});









  it('infers unterminated fields from empty arrays', function () {
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      websites: [] })).
    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'websites', kind: 'Field', metadata: { isPlural: true }, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'lS1aSMCKmNQt:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});







  it('infers unterminated fields from null elements in arrays', function () {
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      websites: [null] })).
    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'websites', kind: 'Field', metadata: { isPlural: true }, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'zt1D8LDfdWo5:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});







  it('infers String field arguments from keys', function () {
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      'url(site: "www")': 'https://...' })).
    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'site', value: { kind: 'CallValue', callValue: 'www' } }], fieldName: 'url', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'y4PiDAV9G9UY:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});







  it('infers Boolean field arguments from keys', function () {
    expect(require('inferRelayFieldsFromData')({ 
      'url(relative: true)': '//...' })).
    toEqualFields((function () {return { children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'relative', value: { kind: 'CallValue', callValue: true } }], fieldName: 'url', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'KCPbQVxyr9iv:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});






  it('infers Int field arguments from keys', function () {
    expect(require('inferRelayFieldsFromData')({ 
      'comments(last: 10)': { 
        count: 20 } })).

    toEqualFields((function () {return { children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'last', value: { kind: 'CallValue', callValue: 10 } }], children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'comments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'CommentsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'HqiGGAVnXmEJ:0', kind: 'Fragment', metadata: {}, name: 'InferRelayFieldsFromDataRelayQL', type: 'Comment' };})());});








  it('throws for keys with invalid call encodings', function () {
    expect(function () {
      require('inferRelayFieldsFromData')({ 
        'url.site': 'https://...' });}).

    toFailInvariant(
    'inferRelayFieldsFromData(): Malformed data key, `url.site`.');


    expect(function () {
      require('inferRelayFieldsFromData')({ 
        'url(site)': 'https://...' });}).

    toFailInvariant(
    'inferRelayFieldsFromData(): Malformed or unsupported data key, ' + 
    '`url(site)`. Only booleans, strings, and numbers are currenly ' + 
    'supported, and commas are required. Parse failure reason was ' + 
    '`Unexpected token s`.');});



  it('infers `id` and `cursor` fields for `node` data', function () {var _PAGE_INFO;
    expect(require('inferRelayFieldsFromData')({ 
      id: '123', 
      'friends(first: "2")': _defineProperty({ 
        edges: [
        { node: { name: 'Alice' } }, 
        { node: { name: 'Bob' } }] }, 

      PAGE_INFO, (_PAGE_INFO = {}, _defineProperty(_PAGE_INFO, 
      HAS_NEXT_PAGE, true), _defineProperty(_PAGE_INFO, 
      HAS_PREV_PAGE, false), _PAGE_INFO)) })).


    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '2' } }], children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'URxzdbrB6HQ3:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Actor' };})());});



















  it('infers field for mutation field named `node`', function () {
    expect(require('inferRelayFieldsFromData')({ 
      node: { 
        id: '123', 
        name: 'name' } })).

    toEqualFields((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Node' }], id: 'SsqlhYQcQOyt:0', kind: 'Fragment', metadata: {}, name: 'InferRelayFieldsFromDataRelayQL', type: 'NodeSavedStateResponsePayload' };})());});









  it('ignores metadata fields', function () {
    expect(require('inferRelayFieldsFromData')({ 
      __dataID__: '123', 
      __range__: null, 
      __status__: 0, 
      id: '123', 
      name: 'Alice' })).
    toEqualFields((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'iRLw5AYTf/aG:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'InferRelayFieldsFromDataRelayQL', type: 'Node' };})());});});