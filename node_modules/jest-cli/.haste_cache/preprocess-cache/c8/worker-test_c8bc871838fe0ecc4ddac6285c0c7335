'use strict';









jest.autoMockOff();
jest.mock('../constant-folding');
jest.mock('../extract-dependencies');
jest.mock('../inline');
jest.mock('../minify');var 

transformCode=require('..').transformCode;var _jasmine=
jasmine;var any=_jasmine.any;var objectContaining=_jasmine.objectContaining;

describe('code transformation worker:',function(){
var extractDependencies=undefined,transform=undefined;
beforeEach(function(){
extractDependencies=
require('../extract-dependencies').mockReturnValue({});
transform=jest.genMockFunction();});


it('calls the transform with file name, source code, and transform options',function(){
var filename='arbitrary/file.js';
var sourceCode='arbitrary(code)';
var transformOptions={arbitrary:'options'};
transformCode(transform,filename,sourceCode,{transform:transformOptions});
expect(transform).toBeCalledWith(
{filename:filename,sourceCode:sourceCode,options:transformOptions},any(Function));});


it('prefixes JSON files with an assignment to module.exports to make the code valid',function(){
var filename='arbitrary/file.json';
var sourceCode='{"arbitrary":"property"}';
transformCode(transform,filename,sourceCode,{});
expect(transform).toBeCalledWith(
{filename:filename,sourceCode:'module.exports='+sourceCode},any(Function));});


it('calls back with the result of the transform',function(done){
var result={
code:'some.other(code)',
map:{}};

transform.mockImplementation(function(_,callback){return (
callback(null,result));});

transformCode(transform,'filename','code',{},function(_,data){
expect(data).toEqual(objectContaining(result));
done();});});



it('removes the leading assignment to `module.exports` before passing on the result if the file is a JSON file, even if minified',function(done){
var result={
code:'p.exports={a:1,b:2}'};

transform.mockImplementation(function(_,callback){return (
callback(null,result));});

transformCode(transform,'aribtrary/file.json','b',{},function(_,data){
expect(data.code).toBe('{a:1,b:2}');
done();});});



it('calls back with any error yielded by the transform',function(done){
var error=Error('arbitrary error');
transform.mockImplementation(function(_,callback){return callback(error);});
transformCode(transform,'filename','code',{},function(e){
expect(e).toBe(error);
done();});});



describe('dependency extraction:',function(){
var code=undefined;

beforeEach(function(){
transform.mockImplementation(
function(_,callback){return callback(null,{code:code});});});


it('passes the transformed code the `extractDependencies`',function(done){
code='arbitrary(code)';

transformCode(transform,'filename','code',{},function(_,data){
expect(extractDependencies).toBeCalledWith(code);
done();});});



it('uses `dependencies` and `dependencyOffsets` provided by `extractDependencies` for the result',function(done){
var dependencyData={
dependencies:['arbitrary','list','of','dependencies'],
dependencyOffsets:[12,119,185,328,471]};

extractDependencies.mockReturnValue(dependencyData);

transformCode(transform,'filename','code',{},function(_,data){
expect(data).toEqual(objectContaining(dependencyData));
done();});});



it('does not extract requires if files are marked as "extern"',function(done){
transformCode(transform,'filename','code',{extern:true},function(_,_ref){var dependencies=_ref.dependencies;var dependencyOffsets=_ref.dependencyOffsets;
expect(extractDependencies).not.toBeCalled();
expect(dependencies).toEqual([]);
expect(dependencyOffsets).toEqual([]);
done();});});



it('does not extract requires of JSON files',function(done){
transformCode(transform,'arbitrary.json','{"arbitrary":"json"}',{},function(_,_ref2){var dependencies=_ref2.dependencies;var dependencyOffsets=_ref2.dependencyOffsets;
expect(extractDependencies).not.toBeCalled();
expect(dependencies).toEqual([]);
expect(dependencyOffsets).toEqual([]);
done();});});});




describe('Minifications:',function(){
var constantFolding=undefined,inline=undefined,options=undefined;
var transformResult=undefined,dependencyData=undefined;
var filename='arbitrary/file.js';
var foldedCode='arbitrary(folded(code));';
var foldedMap={version:3,sources:['fold.js']};

beforeEach(function(){
constantFolding=require('../constant-folding').
mockReturnValue({code:foldedCode,map:foldedMap});
extractDependencies=require('../extract-dependencies');
inline=require('../inline');

options={minify:true};
dependencyData={
dependencies:['a','b','c'],
dependencyOffsets:[100,120,140]};


extractDependencies.mockImplementation(
function(code){return code===foldedCode?dependencyData:{};});

transform.mockImplementation(
function(_,callback){return callback(null,transformResult);});});


it('passes the transform result to `inline` for constant inlining',function(done){
transformResult={map:{version:3},code:'arbitrary(code)'};
transformCode(transform,filename,'code',options,function(){
expect(inline).toBeCalledWith(filename,transformResult,options);
done();});});



it('passes the result obtained from `inline` on to `constant-folding`',function(done){
var inlineResult={map:{version:3,sources:[]},ast:{}};
inline.mockReturnValue(inlineResult);
transformCode(transform,filename,'code',options,function(){
expect(constantFolding).toBeCalledWith(filename,inlineResult);
done();});});



it('Uses the code obtained from `constant-folding` to extract dependencies',function(done){
transformCode(transform,filename,'code',options,function(){
expect(extractDependencies).toBeCalledWith(foldedCode);
done();});});



it('uses the dependencies obtained from the optimized result',function(done){
transformCode(transform,filename,'code',options,function(_,result){
expect(result.dependencies).toEqual(dependencyData.dependencies);
done();});});



it('uses data produced by `constant-folding` for the result',function(done){
transformCode(transform,'filename','code',options,function(_,result){
expect(result).
toEqual(objectContaining({code:foldedCode,map:foldedMap}));
done();});});});});