/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');

jest.
dontMock('RelayPendingQueryTracker').
dontMock('RelayTaskQueue');










describe('RelayPendingQueryTracker', function () {
  var pendingQueryTracker;

  var addPending;var 

  getNode = require('RelayTestUtils').getNode;

  beforeEach(function () {
    jest.resetModuleRegistry();

    var storeData = new (require('RelayStoreData'))();
    pendingQueryTracker = storeData.getPendingQueryTracker();

    require('subtractRelayQuery').mockImplementation(function (query) {return query;});

    addPending = function (_ref) {var query = _ref.query;var fetchMode = _ref.fetchMode;
      fetchMode = fetchMode || require('RelayFetchMode').CLIENT;
      return pendingQueryTracker.add({ 
        query: query, 
        fetchMode: fetchMode, 
        forceIndex: null }).
      getResolvedPromise();};


    jasmine.addMatchers(require('RelayTestUtils').matchers);
    jasmine.addMatchers({ 
      toConsoleWarn: function () {
        return { 
          compare: function (callback, expected) {
            var consoleWarn = console.warn;
            var pass = false;
            console.warn = function () {for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
              if (args.length === expected.length && 
              args.every(function (arg, ii) {return arg === expected[ii];})) {
                pass = true;} else 
              {
                consoleWarn.apply(undefined, args);}};


            callback();
            console.warn = consoleWarn;
            return { pass: pass };} };} });});






  it('subtracts pending queries that share root call', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryB = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '4' } }], children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayPendingQueryTracker', type: 'Node' };})());




    var mockQueryC = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryD = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '4' } }], children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayPendingQueryTracker', type: 'Node' };})());





    addPending({ query: mockQueryA });
    jest.runAllTimers();

    expect(require('subtractRelayQuery')).not.toBeCalled();

    addPending({ query: mockQueryB });
    jest.runAllTimers();

    expect(require('subtractRelayQuery')).not.toBeCalled();

    addPending({ query: mockQueryC });
    jest.runAllTimers();

    expect(require('subtractRelayQuery').mock.calls).toEqual([
    [mockQueryC, mockQueryA]]);


    require('fetchRelayQuery').mock.requests[1].resolve({ node: { __typename: 'User' } });
    jest.runAllTimers();

    require('subtractRelayQuery').mockClear();
    addPending({ query: mockQueryD });
    jest.runAllTimers();

    expect(require('subtractRelayQuery')).not.toBeCalled();});


  it('subtracts pending queries until completely subtracted', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryB = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryC = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    addPending({ query: mockQueryA });
    jest.runAllTimers();

    require('subtractRelayQuery').mockImplementation(function () {return null;});

    addPending({ query: mockQueryB });
    addPending({ query: mockQueryC });
    jest.runAllTimers();

    expect(require('subtractRelayQuery').mock.calls).toEqual([
    [mockQueryB, mockQueryA], 
    [mockQueryC, mockQueryA]]);});



  it('does not fetch completely subtracted queries', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryB = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    addPending({ query: mockQueryA });
    jest.runAllTimers();

    require('subtractRelayQuery').mockImplementation(function (query, subQuery) {
      expect(query).toBe(mockQueryB);
      expect(subQuery).toBe(mockQueryA);
      return null;});


    addPending({ query: mockQueryB });
    jest.runAllTimers();

    expect(require('fetchRelayQuery').mock.calls.length).toBe(1);
    expect(require('fetchRelayQuery').mock.calls[0][0]).toEqualQueryRoot(mockQueryA);});


  it('calls `writeRelayQueryPayload` when receiving data', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    addPending({ query: mockQueryA });
    jest.runAllTimers();

    require('fetchRelayQuery').mock.requests[0].resolve({ viewer: {} });
    jest.runAllTimers();

    var writeCalls = require('writeRelayQueryPayload').mock.calls;
    expect(writeCalls.length).toBe(1);
    expect(writeCalls[0][1]).toEqualQueryRoot(mockQueryA);
    expect(writeCalls[0][2]).toEqual({ viewer: {} });});


  it('resolves after dependencies are ready', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryB = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryC = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    var pendingA = addPending({ query: mockQueryA });
    var mockSuccessA = jest.genMockFunction();
    pendingA.done(mockSuccessA);

    // Simulates: B - A = C
    require('subtractRelayQuery').mockImplementation(function (query, subQuery) {
      expect(query).toBe(mockQueryB);
      expect(subQuery).toBe(mockQueryA);
      return mockQueryC;});


    var pendingB = addPending({ query: mockQueryB });
    var mockSuccessB = jest.genMockFunction();
    pendingB.done(mockSuccessB);

    require('fetchRelayQuery').mock.requests[1].resolve({ viewer: {} });
    jest.runAllTimers();

    expect(mockSuccessA).not.toBeCalled();
    expect(mockSuccessB).not.toBeCalled();

    require('fetchRelayQuery').mock.requests[0].resolve({ viewer: {} });
    jest.runAllTimers();

    expect(mockSuccessA).toBeCalled();
    expect(mockSuccessB).toBeCalled();});


  it('fails direct dependents and not indirect ones', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryB = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryBPrime = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryC = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'firstName', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var mockQueryCPrime = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'firstName', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'day', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'birthdate', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Date' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    var pendingA = addPending({ query: mockQueryA });
    var mockFailureA = jest.genMockFunction();
    pendingA['catch'](mockFailureA);
    jest.runAllTimers();

    // Simulates: B - A = B'
    require('subtractRelayQuery').mockImplementation(function (query, subQuery) {
      expect(query).toBe(mockQueryB);
      expect(subQuery).toBe(mockQueryA);
      return mockQueryBPrime;});


    var pendingB = addPending({ query: mockQueryB });
    var mockFailureB = jest.genMockFunction();
    pendingB['catch'](mockFailureB);
    jest.runAllTimers();

    // Simulates: C - A = C, C - B' = C'
    require('subtractRelayQuery').mockImplementation(function (query, subQuery) {
      expect(query).toBe(mockQueryC);
      expect([mockQueryA, mockQueryBPrime]).toContain(subQuery);
      return subQuery === mockQueryA ? mockQueryC : mockQueryCPrime;});


    var pendingC = addPending({ query: mockQueryC });
    var mockSuccessC = jest.genMockFunction();
    pendingC.done(mockSuccessC);
    jest.runAllTimers();

    var mockFetchError = new Error('Expected `fetchRelayQuery` error.');
    require('fetchRelayQuery').mock.requests[1].resolve({ viewer: {} });
    require('fetchRelayQuery').mock.requests[0].reject(mockFetchError);
    require('fetchRelayQuery').mock.requests[2].resolve({ viewer: {} });

    expect(function () {
      jest.runAllTimers();}).
    toConsoleWarn([mockFetchError.message]);

    var writeCalls = require('writeRelayQueryPayload').mock.calls;
    expect(writeCalls.length).toBe(2);
    expect(writeCalls[0][1]).toEqualQueryRoot(mockQueryBPrime);
    expect(writeCalls[0][2]).toEqual({ viewer: {} });
    expect(writeCalls[1][1]).toEqualQueryRoot(mockQueryCPrime);
    expect(writeCalls[1][2]).toEqual({ viewer: {} });

    expect(mockFailureA).toBeCalled();
    expect(mockFailureB).toBeCalled();
    expect(mockSuccessC).toBeCalled();});


  it('fails if fetching throws an error', function () {
    var mockQuery = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var pendingA = addPending({ query: mockQuery });
    var mockFailureA = jest.genMockFunction();
    pendingA['catch'](mockFailureA);

    var mockError = new Error('Expected error.');
    require('fetchRelayQuery').mock.requests[0].reject(mockError);
    expect(function () {
      jest.runAllTimers();}).
    toConsoleWarn([mockError.message]);

    expect(mockFailureA).toBeCalledWith(mockError);});


  it('fails if `writeRelayQueryPayload` throws', function () {
    var mockQuery = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    var pendingA = addPending({ query: mockQuery });
    var mockFailureA = jest.genMockFunction();
    pendingA['catch'](mockFailureA);

    var mockError = new Error('Expected error.');
    require('fetchRelayQuery').mock.requests[0].resolve({ viewer: {} });
    require('writeRelayQueryPayload').mockImplementation(function () {
      throw mockError;});

    expect(function () {
      jest.runAllTimers();}).
    toConsoleWarn([mockError.message]);

    expect(mockFailureA).toBeCalledWith(mockError);});


  it('can resolve preload queries *after* they are added', function () {
    var mockQuery = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    addPending({ 
      query: mockQuery, 
      fetchMode: require('RelayFetchMode').PRELOAD });


    pendingQueryTracker.resolvePreloadQuery(
    mockQuery.getID(), 
    { response: { viewer: {} } });


    jest.runAllTimers();

    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();
    var writeCalls = require('writeRelayQueryPayload').mock.calls;
    expect(writeCalls.length).toBe(1);
    expect(writeCalls[0][1]).toEqualQueryRoot(mockQuery);
    expect(writeCalls[0][2]).toEqual({ viewer: {} });});


  it('can resolve preload queries *before* they are added', function () {
    var mockQuery = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    pendingQueryTracker.resolvePreloadQuery(
    mockQuery.getID(), 
    { response: { viewer: {} } });


    addPending({ 
      query: mockQuery, 
      fetchMode: require('RelayFetchMode').PRELOAD });


    jest.runAllTimers();

    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();
    var writeCalls = require('writeRelayQueryPayload').mock.calls;
    expect(writeCalls.length).toBe(1);
    expect(writeCalls[0][1]).toEqualQueryRoot(mockQuery);
    expect(writeCalls[0][2]).toEqual({ viewer: {} });});


  it('can reject preloaded pending queries by id', function () {
    var mockQuery = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());





    var mockPending = addPending({ 
      query: mockQuery, 
      fetchMode: require('RelayFetchMode').PRELOAD });

    var mockCallback = jest.genMockFunction();
    mockPending['catch'](mockCallback);

    var mockError = new Error('Expected error.');
    pendingQueryTracker.rejectPreloadQuery(
    mockQuery.getID(), 
    mockError);

    expect(function () {
      jest.runAllTimers();}).
    toConsoleWarn([mockError.message]);

    jest.runAllTimers();

    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();
    expect(mockCallback).toBeCalledWith(mockError);});


  it('has pending queries when not queries are all resolved', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    addPending({ query: mockQueryA });
    jest.runAllTimers();

    expect(pendingQueryTracker.hasPendingQueries()).toBeTruthy();});


  it('has no pending queries when queries are all resolved', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    addPending({ query: mockQueryA });
    jest.runAllTimers();

    require('fetchRelayQuery').mock.requests[0].resolve({ viewer: {} });
    jest.runAllTimers();

    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();});


  it('has no pending queries after being reset', function () {
    var mockQueryA = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayPendingQueryTracker', type: 'Viewer' };})());




    addPending({ query: mockQueryA });
    jest.runAllTimers();

    pendingQueryTracker.resetPending();

    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();});});