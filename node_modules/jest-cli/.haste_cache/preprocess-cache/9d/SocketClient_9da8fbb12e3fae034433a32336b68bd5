'use strict';













var debug=require('debug')('ReactNativePackager:SocketClient');



var tmpdir=require('os').tmpdir();

var LOG_PATH=require('path').join(tmpdir,'react-packager.log');var 

SocketClient=function(){babelHelpers.createClass(SocketClient,null,[{key:'create',value:function create(
sockPath){
return new SocketClient(sockPath).onReady();}}]);


function SocketClient(sockPath){var _this=this;babelHelpers.classCallCheck(this,SocketClient);
debug('connecting to',sockPath);

this._sock=require('net').connect(sockPath);
this._ready=new (require('promise'))(function(resolve,reject){
_this._sock.on('connect',function(){
_this._sock.removeAllListeners('error');
process.on('uncaughtException',function(error){
console.error('uncaught error',error.stack);
setImmediate(function(){return process.exit(1);});});

resolve(_this);});

_this._sock.on('error',function(e){
e.message='Error connecting to server on '+sockPath+' '+('with error: '+
e.message);
e.message+=getServerLogs();

reject(e);});});



this._resolvers=Object.create(null);
var bunser=new (require('bser').BunserBuf)();
this._sock.on('data',function(buf){return bunser.append(buf);});
bunser.on('value',function(message){return _this._handleMessage(message);});

this._sock.on('close',function(){
if(!_this._closing){(function(){
var terminate=function(result){
var sockPathExists=require('fs').existsSync(sockPath);
throw new Error(
'Server closed unexpectedly.\n'+
'Server ping connection attempt result: '+result+'\n'+
'Socket path: `'+sockPath+'` '+(
sockPathExists?' exists.':'doesn\'t exist')+'\n'+
getServerLogs());};




var socket=require('net').connect(sockPath);
socket.on('connect',function(){
socket.end();
terminate('OK');});

socket.on('error',function(error){return terminate(error);});})();}});}babelHelpers.createClass(SocketClient,[{key:'onReady',value:function onReady()




{
return this._ready;}},{key:'getDependencies',value:function getDependencies(


main){
return this._send({
type:'getDependencies',
data:main});}},{key:'getOrderedDependencyPaths',value:function getOrderedDependencyPaths(



main){
return this._send({
type:'getOrderedDependencyPaths',
data:main});}},{key:'buildBundle',value:function buildBundle(



options){
return this._send({
type:'buildBundle',
data:options}).
then(function(json){return require('../Bundler/Bundle').fromJSON(json);});}},{key:'buildPrepackBundle',value:function buildPrepackBundle(


options){
return this._send({
type:'buildPrepackBundle',
data:options}).
then(function(json){return require('../Bundler/PrepackBundle').fromJSON(json);});}},{key:'_send',value:function _send(


message){var _this2=this;
message.id=uid();
this._sock.write(require('bser').dumpToBuffer(message));
return new (require('promise'))(function(resolve,reject){
_this2._resolvers[message.id]={resolve:resolve,reject:reject};});}},{key:'_handleMessage',value:function _handleMessage(



message){
if(!(message&&message.id&&message.type)){
throw new Error(
'Malformed message from server '+JSON.stringify(message));}



debug('got message with type',message.type);

var resolver=this._resolvers[message.id];
if(!resolver){
throw new Error(
'Unrecognized message id ('+message.id+') '+
'message already resolved or never existed.');}



delete this._resolvers[message.id];

if(message.type==='error'){
var errorLog=
message.data&&message.data.indexOf('TimeoutError')===-1?
'See logs '+LOG_PATH:
getServerLogs();

resolver.reject(new Error(message.data+'\n'+errorLog));}else 
{
resolver.resolve(message.data);}}},{key:'close',value:function close()



{
debug('closing connection');
this._closing=true;
this._sock.end();}}]);return SocketClient;}();



module.exports=SocketClient;

function uid(len){
len=len||7;
return Math.random().toString(35).substr(2,len);}


function getServerLogs(){
if(require('fs').existsSync(LOG_PATH)){
return '\nServer logs:\n'+require('fs').readFileSync(LOG_PATH,'utf8');}


return '';}