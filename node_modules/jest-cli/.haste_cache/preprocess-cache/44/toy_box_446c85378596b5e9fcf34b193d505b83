'use strict';Object.defineProperty(exports, "__esModule", { value: true });exports.default = 
function () {
  var _container = [];

  var _globalSetters = [];

  var _functionName = '';

  return { 

    /**
     * Register the object under a given name.
     *
     * The name of the function is the id of which we store for later look up.
     * When you register a function to be stored in the container we create a new object
     * and push it on to the array. We will store the function name, so long as you have scope
     * of the current object being resistered.
     *
     * For example:
     *
     * const Foo = () => { return 'hello world.'; };
     *
     * const toyBox = ToyBox();
     * toyBox.register('foo', Foo);
     *
     * The method will return an instance of "this" so you can method chain other associated methods.
     *
     * @param String name
     * @param function fn
     * @return this
     */
    register: function register(name, fn) {
      _container.push({ name: name, fn: fn, args: [], setters: [] });
      _functionName = name;

      return this;}, 


    /**
     * Add an argument to the registered function.
     *
     * When chained on to the register method we can add or append arguments to the
     * argument container inside the registered objects container. For example:
     *
     * const Foo = (message) => { return message; };
     *
     * const toyBox = ToyBox();
     * toyBox.register('foo', Foo).addArgument('hello world');
     *
     * We will add this to the 'foo' container's arguments container. We can
     * chain addArgument to add multiple arguments.
     *
     * @param mixed arg
     * @return this
     */
    addArgument: function addArgument(arg) {
      var toy = _container.filter(function (container) {
        return container.name === _functionName;});


      toy[0].args.push(arg);

      return this;}, 


    /**
     * Add a reference to another function as a dependency.
     *
     */
    addReference: function addReference(reference) {
      if (typeof reference === 'function') {
        return this.addArgument(reference);}


      throw 'reference must be of type function';}, 


    /**
     * You can set up a setter on the object.
     *
     * If the object makes use of the set and get concept from ecma script 5
     * which would allow you to do fn.message = value and fn.message, then you can
     * use this to set up the setter.
     *
     * @param string setter - setter on the function that uses ecma script 5's set functionality.
     * @param mixed value
     */
    setUpSetter: function setUpSetter(setter, value) {
      var toy = _container.filter(function (container) {
        return container.name === _functionName;});


      toy[0].setters.push({ name: setter, value: value });

      return this;}, 


    /**
     * Called on the container it's self.
     *
     * This set up the global setters. Every time a container object is created
     * if it has a setter matching any of these then we will set that setters value
     * to the coresponding value.
     *
     * The paramters are either: setterName, setterValue or an array of arrays
     * each with the setterName and setterValue.
     */
    setupGlobalSetters: function setupGlobalSetters() {

      if (arguments.length === 2) {
        // setter, value
        _globalSetters.push([arguments[0], arguments[1]]);} else 
      if (arguments.length === 1) {
        // [[setter, value], ...]
        arguments[0].forEach(function (arg) {
          _globalSetters.push(arg);});}}, 






    /**
     * Fetch the stored stored object and return an instance of it.
     *
     * By passing in name of the container we can fetch the function or object thats
     * been registered. If there is any arguments in the aguments container we will pass those
     * in and return the object.
     *
     * An example:
     *
     * const Foo = (message) => { return message; };
     *
     * const toyBox = ToyBox();
     * toyBox.register('foo', Foo).addArgument('hello world');
     *
     * toyBox.fetch('foo') // => hello world
     *
     * We also have the concept of setters, that is, when a object is fetched from
     * the container we also set up the setters, these can be either global or individual.
     * individula will always over right the global setters.
     *
     * @param string name
     * @return mixed | null
     */
    fetch: function fetch(name) {var _this = this;
      var toy = _container.filter(function (container) {
        return container.name === name;});


      var obj = null;
      var args = [];

      if (toy.length === 0) {
        return name;}


      if (toy[0].args.length > 0) {
        toy[0].args.forEach(function (arg) {
          args.push(_this._determineTypeOfArgument(arg));});


        obj = toy[0].fn.apply(this, args);} else 
      {
        obj = toy[0].fn.call();}


      // set the global setters
      if (_globalSetters.length !== 0) {
        _globalSetters.forEach(function (setter) {
          if (obj[setter[0]] !== undefined) {
            obj = _this._setupObjectSetterFromGlobalSetter(obj, setter);}});}




      // over ride any setters with new values.
      if (toy[0].setters.length > 0) {
        toy[0].setters.forEach(function (setter) {
          obj = _this._setupObjectSetterFromSetters(obj, setter);});}



      return obj;}, 


    get container() {
      return _container;}, 


    get globalSetters() {
      return _globalSetters;}, 


    _setupObjectSetterFromGlobalSetter: function _setupObjectSetterFromGlobalSetter(obj, setter) {
      if (typeof setter[1] === 'function') {
        obj[setter[0]] = setter[1].call();} else 
      if (typeof setter[1] === 'string') {
        obj[setter[0]] = this.fetch(setter[1]);} else 
      {
        obj[setter[0]] = setter[1];}


      return obj;}, 


    _setupObjectSetterFromSetters: function _setupObjectSetterFromSetters(obj, setter) {
      if (typeof setter.value === 'function') {
        obj[setter.name] = setter.value.call();} else 
      if (typeof setter.value === 'string') {
        obj[setter.name] = this.fetch(setter.value);} else 
      {
        obj[setter.name] = setter.value;}


      return obj;}, 


    _determineTypeOfArgument: function _determineTypeOfArgument(arg) {
      if (typeof arg === 'function') {
        return arg.call();} else 
      if (typeof arg === 'string') {
        return this.fetch(arg);} else 
      {
        return arg;}} };};