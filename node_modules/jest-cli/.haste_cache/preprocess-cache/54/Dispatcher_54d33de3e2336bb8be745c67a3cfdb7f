'use strict';























var _prefix='ID_';var 
























































































Dispatcher=function(){
function Dispatcher(){babelHelpers.classCallCheck(this,Dispatcher);
this.$Dispatcher_lastID=1;
this.$Dispatcher_callbacks={};
this.$Dispatcher_isPending={};
this.$Dispatcher_isHandled={};
this.$Dispatcher_isDispatching=false;
this.$Dispatcher_pendingPayload=null;
this.$Dispatcher_postDispatchCallbacks={};}babelHelpers.createClass(Dispatcher,[{key:'register',value:function register(









callback){
var id=_prefix+this.$Dispatcher_lastID++;
this.$Dispatcher_callbacks[id]=callback;
return id;}},{key:'unregister',value:function unregister(







id){
!
this.$Dispatcher_callbacks[id]?require('invariant')(0,
'Dispatcher.unregister(...): `%s` does not map to a registered callback.',
id):undefined;

delete this.$Dispatcher_callbacks[id];}},{key:'waitFor',value:function waitFor(









ids){
!
this.$Dispatcher_isDispatching?require('invariant')(0,
'Dispatcher.waitFor(...): Must be invoked while dispatching.'):undefined;

for(var ii=0;ii<ids.length;ii++){
var id=ids[ii];
if(this.$Dispatcher_isPending[id]){
!
this.$Dispatcher_isHandled[id]?require('invariant')(0,
'Dispatcher.waitFor(...): Circular dependency detected while '+
'waiting for `%s`.',
id):undefined;

continue;}

!
this.$Dispatcher_callbacks[id]?require('invariant')(0,
'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',
id):undefined;

this.$Dispatcher_invokeCallback(id);}}},{key:'dispatch',value:function dispatch(








payload){
!
!this.$Dispatcher_isDispatching?require('invariant')(0,
'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'):undefined;

this.$Dispatcher_startDispatching(payload);
try{
for(var id in this.$Dispatcher_callbacks){
if(this.$Dispatcher_isPending[id]){
continue;}

this.$Dispatcher_invokeCallback(id);}}finally 

{
if(Object.keys(this.$Dispatcher_postDispatchCallbacks).length){
this.$Dispatcher_invokeCompletionCallbacks();}

this.$Dispatcher_stopDispatching();}}},{key:'isDispatching',value:function isDispatching()








{
return this.$Dispatcher_isDispatching;}},{key:'enqueueCompletionCallback',value:function enqueueCompletionCallback(

















id,callback){
!
this.$Dispatcher_isDispatching?require('invariant')(0,
'Dispatcher.enqueueCompletionCallback(...): '+
'Must be invoked while dispatching.'):undefined;

!
!this.$Dispatcher_postDispatchCallbacks[id]?require('invariant')(0,
'Post-dispatch callback already registered for supplied id: %s.',
id):undefined;

this.$Dispatcher_postDispatchCallbacks[id]=callback;}},{key:'$Dispatcher_invokeCallback',value:function $Dispatcher_invokeCallback(









id){
this.$Dispatcher_isPending[id]=true;
this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
this.$Dispatcher_isHandled[id]=true;}},{key:'$Dispatcher_startDispatching',value:function $Dispatcher_startDispatching(








payload){
for(var id in this.$Dispatcher_callbacks){
this.$Dispatcher_isPending[id]=false;
this.$Dispatcher_isHandled[id]=false;}

this.$Dispatcher_pendingPayload=payload;
this.$Dispatcher_isDispatching=true;}},{key:'$Dispatcher_invokeCompletionCallbacks',value:function $Dispatcher_invokeCompletionCallbacks()







{
for(var id in this.$Dispatcher_postDispatchCallbacks){
this.$Dispatcher_postDispatchCallbacks[id]();}

this.$Dispatcher_postDispatchCallbacks={};}},{key:'$Dispatcher_stopDispatching',value:function $Dispatcher_stopDispatching()







{
this.$Dispatcher_pendingPayload=null;
this.$Dispatcher_isDispatching=false;}}]);return Dispatcher;}();



module.exports=Dispatcher;