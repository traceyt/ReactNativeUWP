/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');

jest.
dontMock('GraphQLRange').
dontMock('GraphQLSegment');








describe('writePayload()', function () {
  var RelayRecordStore;
  var RelayRecordWriter;var 


  getNode = require('RelayTestUtils').getNode;var 
  getVerbatimNode = require('RelayTestUtils').getVerbatimNode;var 
  writeVerbatimPayload = require('RelayTestUtils').writeVerbatimPayload;var 
  writePayload = require('RelayTestUtils').writePayload;


  function getField(node) {for (var _len = arguments.length, fieldNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {fieldNames[_key - 1] = arguments[_key];}
    for (var ii = 0; ii < fieldNames.length; ii++) {
      node = node.getFieldByStorageKey(fieldNames[ii]);
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
      node, 
      'getField(): Expected node to have field named `%s`.', 
      fieldNames[ii]);}


    return node;}


  beforeEach(function () {
    jest.resetModuleRegistry();

    RelayRecordStore = require('RelayRecordStore');
    RelayRecordWriter = require('RelayRecordWriter');

    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  describe('paths', function () {
    it('writes path for id-less root records', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'WriteRelayQueryPayload_paths', type: 'Viewer' };})());








      var payload = { 
        viewer: { 
          actor: { 
            id: '123', 
            __typename: 'User' } } };



      var results = writePayload(store, writer, query, payload);
      expect(results).toEqual({ 
        created: { 
          'client:1': true, 
          '123': true }, 

        updated: {} });


      // viewer has a client id and must be refetched by the original root call
      var path = new (require('RelayQueryPath'))(query);
      expect(store.getRecordState('client:1')).toBe('EXISTENT');
      expect(store.getPathToRecord('client:1')).toMatchPath(path);

      // actor is refetchable by ID
      expect(store.getPathToRecord('123')).toBe(undefined);});


    it('does not write paths to refetchable root records', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());






      var payload = { 
        node: { 
          id: '123', 
          __typename: 'User' } };


      var results = writePayload(store, writer, query, payload);
      expect(results).toEqual({ 
        created: { 
          '123': true }, 

        updated: {} });


      expect(store.getRecordState('123')).toBe('EXISTENT');
      expect(store.getPathToRecord('123')).toBe(undefined);});


    it('writes paths to non-refetchable linked records', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { children: [{ children: [{ children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'WriteRelayQueryPayload_paths', type: 'Viewer' };})());










      var payload = { 
        viewer: { 
          actor: { 
            id: '123', 
            address: { 
              city: 'San Francisco' }, 

            __typename: 'User' } } };



      writePayload(store, writer, query, payload);

      // linked nodes use a minimal path from the nearest refetchable node
      var addressID = 'client:2'; // The generated id *after* viewer
      var pathQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());








      var path = new (require('RelayQueryPath'))(pathQuery).
      getPath(getField(pathQuery, 'address'), addressID);
      expect(store.getPathToRecord(addressID)).toMatchPath(path);});


    it('writes paths to plural linked fields', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var phone = { 
        isVerified: true, 
        phoneNumber: { 
          displayNumber: '1-800-555-1212', // directory assistance
          countryCode: '1' } };


      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ children: [{ fieldName: 'isVerified', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'displayNumber', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'countryCode', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'phoneNumber', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'PhoneNumber' }], fieldName: 'allPhones', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Phone' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());












      var payload = { 
        node: { 
          __typename: 'User', 
          id: '123', 
          allPhones: [phone] } };


      writePayload(store, writer, query, payload);

      // plural fields must be refetched through the parent
      // get linked records to verify the client id
      var allPhoneIDs = store.getLinkedRecordIDs('123', 'allPhones');
      expect(allPhoneIDs.length).toBe(1);
      var path = new (require('RelayQueryPath'))(query).
      getPath(getField(query, 'allPhones'), allPhoneIDs[0]);
      expect(store.getPathToRecord(allPhoneIDs[0])).toMatchPath(path);

      // plural items must be refetched through the parent plural field
      // get field to verify the client id is correct
      var phoneNoID = store.getLinkedRecordID(allPhoneIDs[0], 'phoneNumber');
      path = new (require('RelayQueryPath'))(query).
      getPath(getField(query, 'allPhones'), allPhoneIDs[0]).
      getPath(getField(query, 'allPhones', 'phoneNumber'), phoneNoID);
      expect(store.getPathToRecord(phoneNoID)).toMatchPath(path);});


    it('writes paths to connection records', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());















      var payload = { 
        node: { 
          __typename: 'User', 
          id: '123', 
          friends: { 
            edges: [
            { 
              cursor: 'cursor1', 
              node: { 
                id: 'node1', 
                address: { 
                  city: 'San Francisco' } } }] } } };







      writePayload(store, writer, query, payload);

      // connections and edges must be refetched through the parent
      var path = new (require('RelayQueryPath'))(query).
      getPath(getField(query, 'friends'), 'client:1');
      expect(store.getPathToRecord('client:1')).toMatchPath(path);
      path = new (require('RelayQueryPath'))(query).
      getPath(getField(query, 'friends'), 'client:1').
      getPath(getField(query, 'friends', 'edges'), 'client:client:1:node1');
      expect(store.getPathToRecord('client:client:1:node1')).toMatchPath(path);

      // connection nodes with an ID are refetchable
      expect(store.getPathToRecord('node1')).toBe(undefined);

      // linked nodes use a minimal path from the nearest refetchable node
      var pathQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: 'node1' } }], children: [{ children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());
      path = new (require('RelayQueryPath'))(pathQuery).
      getPath(getField(pathQuery, 'address'), 'client:2');
      expect(store.getField('client:2', 'city')).toBe('San Francisco');
      expect(store.getPathToRecord('client:2')).toMatchPath(path);});


    it('writes paths with fragments', function () {
      var records = {};
      var rootCallMap = {};
      var store = new RelayRecordStore({ records: records }, { rootCallMap: rootCallMap });
      var writer = new RelayRecordWriter(records, rootCallMap, false);
      var fragment = (function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], id: 'xiB4WWoBz/xR:0', kind: 'Fragment', metadata: {}, name: 'WriteRelayQueryPayload_pathsRelayQL', type: 'Viewer' };})();






      var query = getVerbatimNode((function (RQL_0) {return { children: [].concat.apply([], [require('Relay').QL.__frag(RQL_0)]), fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'WriteRelayQueryPayload_paths', type: 'Viewer' };})(


      fragment));



      var payload = { 
        viewer: { 
          actor: { 
            name: 'Joe', 
            __typename: 'User' } } };



      writePayload(store, writer, query, payload);

      var viewerID = store.getDataID('viewer');
      var actorID = store.getLinkedRecordID(viewerID, 'actor');

      var path = new (require('RelayQueryPath'))(query).
      getPath(getNode(fragment), viewerID).
      getPath(getNode(fragment).getChildren()[0], actorID);
      expect(store.getPathToRecord(actorID)).toMatchPath(path);});});



  describe('query tracking', function () {
    it('tracks new root records', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var tracker = new (require('RelayQueryTracker'))();
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());







      var payload = { 
        node: { 
          id: '123', 
          name: 'Joe', 
          __typename: 'User' } };


      writePayload(store, writer, query, payload, tracker);
      var trackedQueries = tracker.trackNodeForID.mock.calls;
      expect(trackedQueries.length).toBe(1);
      expect(trackedQueries[0][1]).toBe('123');
      expect(trackedQueries[0][0]).toEqualQueryRoot(query);});


    it('tracks new records in fragments', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var tracker = new (require('RelayQueryTracker'))();

      // `address` will be encountered twice, both occurrences must be tracked
      var fragment = (function () {return { children: [{ children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: '/zGNgT3MG1Bl:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'WriteRelayQueryPayload_pathsRelayQL', type: 'Node' };})();
      var query = getNode((function (RQL_0, RQL_1) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0), require('Relay').QL.__frag(RQL_1)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})(


      fragment, 
      fragment));



      var payload = { 
        node: { 
          id: '123', 
          address: { 
            city: 'San Francisco' }, 

          __typename: 'User' } };


      var addressID = 'client:1';
      var addressFragment = getNode(fragment).getChildren()[0];
      writePayload(store, writer, query, payload, tracker);
      var trackedQueries = tracker.trackNodeForID.mock.calls;
      expect(trackedQueries.length).toBe(3);
      expect(trackedQueries[1][1]).toBe(addressID);
      expect(trackedQueries[1][0]).toEqualQueryNode(addressFragment);
      expect(trackedQueries[2][1]).toBe(addressID);
      expect(trackedQueries[2][0]).toEqualQueryNode(addressFragment);});


    it('tracks new linked records', function () {
      var records = { 
        'client:1': { 
          __dataID__: 'client:1' } };


      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'WriteRelayQueryPayload_paths', type: 'Viewer' };})());








      var payload = { 
        viewer: { 
          actor: { 
            id: '123', 
            name: 'Joe', 
            __typename: 'User' } } };



      var tracker = new (require('RelayQueryTracker'))();
      writePayload(store, writer, query, payload, tracker);
      var trackedQueries = tracker.trackNodeForID.mock.calls;
      expect(trackedQueries.length).toBe(1);
      expect(trackedQueries[0][1]).toBe('123');
      expect(trackedQueries[0][0]).toEqualQueryNode(query.getChildren()[0]);});


    it('tracks new plural linked records', function () {
      var records = { 
        '123': { 
          __dataID__: '123', 
          id: '123' } };


      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ children: [{ fieldName: 'isVerified', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'displayNumber', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'countryCode', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'phoneNumber', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'PhoneNumber' }], fieldName: 'allPhones', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Phone' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());












      var phone = { 
        isVerified: true, 
        phoneNumber: { 
          displayNumber: '1-800-555-1212', // directory assistance
          countryCode: '1' } };


      var payload = { 
        node: { 
          __typename: 'User', 
          id: '123', 
          allPhones: [phone] } };


      var tracker = new (require('RelayQueryTracker'))();
      writePayload(store, writer, query, payload, tracker);
      var trackedQueries = tracker.trackNodeForID.mock.calls;
      // creates `allPhones` record and linked `phoneNumber` field
      expect(trackedQueries.length).toBe(2);
      expect(trackedQueries[0][1]).toBe('client:1');
      expect(trackedQueries[0][0]).toEqualQueryNode(
      getField(query, 'allPhones'));

      expect(trackedQueries[1][1]).toBe('client:2');
      expect(trackedQueries[1][0]).toEqualQueryNode(
      getField(query, 'allPhones', 'phoneNumber'));});



    it('tracks new connections', function () {
      var records = { 
        '123': { 
          __dataID__: '123', 
          id: '123' } };


      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());












      var payload = { 
        node: { 
          __typename: 'User', 
          id: '123', 
          friends: { 
            edges: [
            { 
              cursor: 'c1', 
              node: { 
                id: '456', 
                name: 'Greg' } }] } } };






      var tracker = new (require('RelayQueryTracker'))();
      writePayload(store, writer, query, payload, tracker);
      var trackedQueries = tracker.trackNodeForID.mock.calls;
      expect(trackedQueries.length).toBe(3);
      // track range node
      expect(trackedQueries[0][1]).toBe('client:1');
      expect(trackedQueries[0][0]).toEqualQueryNode(
      getField(query, 'friends'));

      // track first edge
      expect(trackedQueries[1][1]).toBe('client:client:1:456');
      expect(trackedQueries[1][0]).toEqualQueryNode(
      getField(query, 'friends', 'edges'));

      // track node
      expect(trackedQueries[2][1]).toBe('456');
      expect(trackedQueries[2][0]).toEqualQueryNode(
      getField(query, 'friends', 'edges', 'node'));});



    it('tracks edges and nodes added to an existing connection', function () {
      // write a range with first(1) edge
      var records = { 
        '123': { 
          __dataID__: '123', 
          id: '123' } };


      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());












      var payload = { 
        node: { 
          __typename: 'User', 
          id: '123', 
          friends: { 
            edges: [
            { 
              cursor: 'c1', 
              node: { 
                id: '456', 
                name: 'Greg' } }] } } };






      var tracker = new (require('RelayQueryTracker'))();
      writePayload(store, writer, query, payload, tracker);
      expect(tracker.trackNodeForID.mock.calls.length).toBe(3);

      // write an additional node and verify only the new edge and node are
      // tracked
      query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'after', value: { kind: 'CallValue', callValue: 'c1' } }, { kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());












      payload = { 
        node: { 
          id: '123', 
          friends: { 
            edges: [
            { 
              cursor: 'c2', 
              node: { 
                id: '789', 
                name: 'Jing' } }] } } };






      tracker = new (require('RelayQueryTracker'))();
      tracker.trackNodeForID.mockClear();
      writePayload(store, writer, query, payload, tracker);
      var trackedQueries = tracker.trackNodeForID.mock.calls;
      expect(trackedQueries.length).toBe(2);
      // track new edge
      expect(trackedQueries[0][1]).toBe('client:client:1:789');
      expect(trackedQueries[0][0]).toEqualQueryNode(
      getField(query, 'friends', 'edges'));

      // track node
      expect(trackedQueries[1][1]).toBe('789');
      expect(trackedQueries[1][0]).toEqualQueryNode(
      getField(query, 'friends', 'edges', 'node'));});



    it('re-tracks all nodes if `updateTrackedQueries` is enabled', function () {
      var records = {};
      var store = new RelayRecordStore({ records: records });
      var writer = new RelayRecordWriter(records, {}, false);
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ children: [{ fieldName: 'displayNumber', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'phoneNumber', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'PhoneNumber' }], fieldName: 'allPhones', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Phone' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());


















      var payload = { 
        node: { 
          id: '123', 
          name: 'Joe', 
          allPhones: [
          { 
            phoneNumber: { 
              displayNumber: '1-800-555-1212' } }], // directory assistance



          friends: { 
            edges: [
            { 
              cursor: 'c1', 
              node: { 
                id: '456', 
                name: 'Tim' } }] }, 




          __typename: 'User' } };


      // populate the store and record the original tracked queries
      var tracker = new (require('RelayQueryTracker'))();
      writePayload(store, writer, query, payload, tracker);
      var prevTracked = tracker.trackNodeForID.mock.calls.slice();
      expect(prevTracked.length).toBe(6);

      // rewriting the same payload by default does not track anything
      tracker = new (require('RelayQueryTracker'))();
      tracker.trackNodeForID.mockClear();
      writePayload(store, writer, query, payload, tracker);
      expect(tracker.trackNodeForID.mock.calls.length).toBe(0);

      // force-tracking should track the original nodes again
      tracker = new (require('RelayQueryTracker'))();
      tracker.trackNodeForID.mockClear();
      writePayload(store, writer, query, payload, tracker, { 
        updateTrackedQueries: true });

      var nextTracked = tracker.trackNodeForID.mock.calls;
      expect(nextTracked.length).toBe(prevTracked.length);
      nextTracked.forEach(function (tracked, ii) {
        expect(tracked[1]).toBe(prevTracked[ii][1]); // dataID
        expect(tracked[0]).toEqualQueryNode(prevTracked[ii][0]); // dataID
      });});});



  it('skips non-matching fragments', function () {
    var records = {};
    var store = new RelayRecordStore({ records: records });
    var writer = new RelayRecordWriter(records, {}, false);
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'eL+GxZlzLtG1:0', kind: 'Fragment', metadata: {}, name: 'User', type: 'User' }, { children: [{ children: [{ fieldName: 'text', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'body', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Text' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'eL+GxZlzLtG1:1', kind: 'Fragment', metadata: {}, name: 'Comment', type: 'Comment' }, { children: [{ fieldName: 'firstName', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'eL+GxZlzLtG1:2', kind: 'Fragment', metadata: { isAbstract: true }, name: 'Node', type: 'Node' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayQueryPayload_paths', type: 'Node' };})());
















    var payload = { 
      node: { 
        id: '123', 
        __typename: 'User', 
        firstName: 'Joe', 
        name: 'Joe', 
        body: { 
          text: 'Skipped!' } } };



    writeVerbatimPayload(store, writer, query, payload);
    expect(store.getField('123', 'firstName')).toBe('Joe');
    expect(store.getField('123', 'name')).toBe('Joe');
    // `body` only exists on `Comment` which does not match the record type
    expect(store.getLinkedRecordID('123', 'body')).toBe(undefined);});});