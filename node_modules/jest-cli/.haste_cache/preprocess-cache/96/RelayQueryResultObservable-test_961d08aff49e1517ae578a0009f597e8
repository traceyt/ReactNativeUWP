/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');

jest.
dontMock('RelayStoreData').
dontMock('GraphQLStoreChangeEmitter').
dontMock('GraphQLStoreQueryResolver');











describe('RelayQueryResultObservable', function () {
  var storeData;
  var changeEmitter;

  var query;
  var records;
  var results;
  var store;
  var writer;

  // helper functions
  var getNode = require('RelayTestUtils').getNode;

  function genMockSubscriber() {
    var onCompleted = jest.genMockFunction();
    var onError = jest.genMockFunction();
    var onNext = jest.genMockFunction();
    var mockClear = function () {
      [onCompleted, onError, onNext].forEach(function (fn) {return fn.mockClear();});};

    return { 
      onCompleted: onCompleted, 
      onError: onError, 
      onNext: onNext, 
      mockClear: mockClear };}



  function observeRelayQueryData(dataID) {
    return new (require('RelayQueryResultObservable'))(storeData, query, dataID);}


  beforeEach(function () {
    jest.resetModuleRegistry();

    query = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: '8LlrbSjy1g4n:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayQueryResultObservableRelayQL', type: 'Node' };})());
    records = { 
      '123': { 
        __dataID__: '123', 
        id: '123', 
        name: 'Joe', 
        firstName: 'Joe' } };


    results = { 
      __dataID__: '123', 
      id: '123', 
      name: 'Joe' };

    store = new (require('RelayRecordStore'))({ records: records });
    writer = new (require('RelayRecordWriter'))(records, {}, false);
    storeData = new (require('RelayStoreData'))();

    storeData.getQueuedStore = jest.genMockFunction().mockImplementation(function () {
      return store;});


    changeEmitter = storeData.getChangeEmitter();
    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  it('does not read data before the first subscriber is registered', function () {
    observeRelayQueryData('123');
    expect(require('readRelayQueryData')).not.toBeCalled();});


  it('cannot double-unsubscribe a subscription', function () {
    var observer = observeRelayQueryData('123');
    var subscriber = genMockSubscriber();
    var subscription = observer.subscribe(subscriber);
    subscription.dispose();
    expect(function () {return subscription.dispose();}).toFailInvariant(
    'RelayQueryResultObservable: Subscriptions may only be disposed once.');});



  it('immediately calls onNext of the first subscriber', function () {
    var observer = observeRelayQueryData('123');
    var subscriber = genMockSubscriber();
    observer.subscribe(subscriber);

    expect(require('readRelayQueryData')).toBeCalledWith(
    storeData, 
    query, 
    '123');

    expect(subscriber.onNext).toBeCalledWith(results);
    expect(subscriber.onError).not.toBeCalled();});


  it('immediately calls onNext of subsequent subscribers', function () {
    var observer = observeRelayQueryData('123');
    var firstSubscriber = genMockSubscriber();
    observer.subscribe(firstSubscriber);
    require('readRelayQueryData').mockClear();
    firstSubscriber.mockClear();

    var secondSubscriber = genMockSubscriber();
    observer.subscribe(secondSubscriber);
    expect(require('readRelayQueryData')).not.toBeCalled();
    expect(firstSubscriber.onNext).not.toBeCalled();
    expect(secondSubscriber.onNext).toBeCalledWith(results);
    expect(secondSubscriber.onError).not.toBeCalled();});


  it('updates all subscribers when data changes', function () {
    var observer = observeRelayQueryData('123');
    var subscribers = [
    genMockSubscriber(), 
    genMockSubscriber()];

    subscribers.forEach(function (subscriber) {
      observer.subscribe(subscriber);
      subscriber.mockClear();});


    writer.putField('123', 'name', 'Joseph');
    results.name = 'Joseph';
    changeEmitter.broadcastChangeForID('123');
    jest.runAllTimers();

    subscribers.forEach(function (subscriber) {
      expect(subscriber.onCompleted).not.toBeCalled();
      expect(subscriber.onError).not.toBeCalled();
      expect(subscriber.onNext).toBeCalledWith(results);});});



  it('does not call callbacks after a subscription is disposed', function () {
    var observer = observeRelayQueryData('123');
    var subscriber = genMockSubscriber();
    var subscription = observer.subscribe(subscriber);
    subscriber.mockClear();
    subscription.dispose();

    writer.putField('123', 'name', 'Joseph');
    results.name = 'Joseph';
    changeEmitter.broadcastChangeForID('123');
    jest.runAllTimers();

    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).not.toBeCalled();});


  it('calls onNext if the record is initially unfetched', function () {
    var observer = observeRelayQueryData('oops');
    var subscriber = genMockSubscriber();
    observer.subscribe(subscriber);

    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).toBeCalledWith(undefined);
    subscriber.mockClear();

    // fetching the record calls onNext
    writer.putRecord('oops');
    changeEmitter.broadcastChangeForID('oops');
    jest.runAllTimers();
    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).toBeCalledWith({ 
      __dataID__: 'oops' });});



  it('calls onNext if the record is deleted', function () {
    var observer = observeRelayQueryData('123');
    var subscriber = genMockSubscriber();
    observer.subscribe(subscriber);
    subscriber.mockClear();

    // deleting the record calls onNext
    writer.deleteRecord('123');
    changeEmitter.broadcastChangeForID('123');
    jest.runAllTimers();
    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).toBeCalledWith(null);
    subscriber.mockClear();

    // restoring the record calls onNext
    writer.putRecord('123');
    changeEmitter.broadcastChangeForID('123');
    jest.runAllTimers();
    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).toBeCalledWith({ 
      __dataID__: '123' });});



  it('calls onNext if the record is evicted from the store', function () {
    var observer = observeRelayQueryData('123');
    var subscriber = genMockSubscriber();
    observer.subscribe(subscriber);
    subscriber.mockClear();

    // evicting the record calls onNext
    store.removeRecord('123');
    changeEmitter.broadcastChangeForID('123');
    jest.runAllTimers();
    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).toBeCalledWith(undefined);
    subscriber.mockClear();

    // restoring the record calls onNext
    writer.putRecord('123');
    changeEmitter.broadcastChangeForID('123');
    jest.runAllTimers();
    expect(subscriber.onCompleted).not.toBeCalled();
    expect(subscriber.onError).not.toBeCalled();
    expect(subscriber.onNext).toBeCalledWith({ 
      __dataID__: '123' });});});