'use strict';var _RelayConnectionInter=require('RelayConnectionInterface');var 























CLIENT_MUTATION_ID=_RelayConnectionInter.CLIENT_MUTATION_ID;

var storeData=require('RelayStore').getStoreData();


var cachedData=storeData.getCachedData();
var changeEmitter=storeData.getChangeEmitter();
var nodeData=storeData.getNodeData();
var queuedData=storeData.getQueuedData();

var rootCallData=storeData.getRootCallData();




var GraphQLStore={
ERROR:'ERROR',




handleOptimisticMutation:function(action){
require('ActionQueue').appendToQueue(action);
_handleOptimisticMutation(action);},






handleServerMutation:function(payload,mutation){
var type=require('GraphQLMutationDataHandler').getMutationType(payload);
var clientMutationID=payload[type][CLIENT_MUTATION_ID];


var key=require('ActionCollisionMap').getKeyForClientMutationID(clientMutationID);
if(key){
var shiftedAction=require('ActionCollisionMap').shiftActionForKey(key);
!(
shiftedAction.getClientMutationID()===clientMutationID)?require('invariant')(0,
'action sent to server must be first in the list for its key'):undefined;

var nextAction=require('ActionCollisionMap').getFirstActionForKey(key);
if(nextAction){

nextAction.rerunServerAction();}}




var action=require('ActionQueue').getActionByID(clientMutationID);
if(action){
require('ActionQueue').removeFromQueue(clientMutationID);

clearQueue();
require('ActionQueue').iterateOverQueue(_handleOptimisticMutation);}


handleMutationResult(
payload,
mutation,
require('GraphQLMutatorConstants').SERVER_UPDATE);

require('RelayMutationTracker').deleteErrorNodeForMutation(clientMutationID);},






handleSubscriptionPayload:function(payload,subscription){
handleMutationResult(
payload,
subscription,
require('GraphQLMutatorConstants').SERVER_UPDATE);},














handleMutationRollback:function(clientMutationID){
var action=require('ActionQueue').getActionByID(clientMutationID);
if(action){

require('ActionQueue').removeFromQueue(clientMutationID);}


_cancelQueuedCollidingMutations(clientMutationID);

clearQueue();
require('ActionQueue').iterateOverQueue(_handleOptimisticMutation);},













handleMutationError:function(clientMutationID){
_cancelQueuedCollidingMutations(clientMutationID);
clearQueue();
require('ActionQueue').iterateOverQueue(_handleOptimisticMutation);},








setRangeAddErrorStatus:function(payload){
var type=require('GraphQLMutationDataHandler').getMutationType(payload);
payload=payload[type];
var multiMutationConfig=require('GraphQLMutatorHub').getConfigs(type);
!
multiMutationConfig.some(function(config){return (
config.type===require('RelayMutationType').RANGE_ADD);})?require('invariant')(0,

'GraphQLStore.setRangeAddErrorStatus expects a range-add payload'):undefined;

var clientMutationID=payload[CLIENT_MUTATION_ID];
var clientNodeID=
require('RelayMutationTracker').getClientIDForMutation(clientMutationID);
setErrorStatusForID(clientNodeID);
require('RelayMutationTracker').putErrorNodeForMutation(
clientNodeID,
clientMutationID);},










handleMutationRetry:function(clientID){
var mutationID=require('RelayMutationTracker').getMutationForErrorNode(clientID);
!
mutationID?require('invariant')(0,
'Can only retry mutations that encountered errors'):undefined;

var action=require('ActionQueue').getActionByID(mutationID);
!
action?require('invariant')(0,
'Cannot retry a mutation that has not previously been tried'):undefined;

require('RelayMutationTracker').deleteMutationForErrorNode(clientID);






clearErrorStatusForID(clientID);
action.rerunServerAction();},


__debug:{
cachedData:cachedData,
nodeData:nodeData,
queuedData:queuedData,
rootCallData:rootCallData}};













function handleMutationResult(result,mutation,updateType){
!(
require('QueryBuilder').getMutation(mutation)||
require('QueryBuilder').getSubscription(mutation))?require('invariant')(0,
'Must pass a mutation or subscription into handleMutationResult'):undefined;


var isOptimisticUpdate=
updateType===require('GraphQLMutatorConstants').OPTIMISTIC_UPDATE;
var type=require('GraphQLMutationDataHandler').getMutationType(result);
var payload=result[type];
storeData.handleUpdatePayload(
require('fromGraphQL').Operation(mutation),
payload,
{
configs:require('GraphQLMutatorHub').getConfigs(type),
isOptimisticUpdate:isOptimisticUpdate});}







function _handleOptimisticMutation(action){
handleMutationResult(
action.getOptimisticPayload(),
action.getOptimisticPayloadQuery(),
require('GraphQLMutatorConstants').OPTIMISTIC_UPDATE);


var clientMutationID=action.getClientMutationID();
var errorNodeID=
require('RelayMutationTracker').getErrorNodeForMutation(clientMutationID);
if(errorNodeID){
setErrorStatusForID(errorNodeID);}}






function setErrorStatusForID(dataID){
var queuedNode=queuedData[dataID];



!
queuedNode?require('invariant')(0,
'Invalid dataID %s was passed to `setErrorStatusForID`. '+
'Can only set status for queued node.',
dataID):undefined;


queuedNode.__status__=require('RelayRecordStatusMap').setErrorStatus(
queuedNode.__status__,
true);

changeEmitter.broadcastChangeForID(dataID);}





function clearErrorStatusForID(dataID){
var queuedNode=queuedData[dataID];

!
queuedNode?require('invariant')(0,
'Invalid dataID %s was passed to `clearErrorStatusForID`. '+
'Can only set status for queued node.',
dataID):undefined;


queuedNode.__status__=require('RelayRecordStatusMap').setErrorStatus(
queuedNode.__status__,
false);

changeEmitter.broadcastChangeForID(dataID);}


function clearQueue(){
for(var key in queuedData){
if(queuedData.hasOwnProperty(key)){
delete queuedData[key];
changeEmitter.broadcastChangeForID(key);}}}










function _cancelQueuedCollidingMutations(clientMutationID){
var key=require('ActionCollisionMap').getKeyForClientMutationID(clientMutationID);
if(!key){
return;}

require('ActionCollisionMap').shiftActionForKey(key);
require('ActionCollisionMap').iterateOverActionsForKey(key,function(action){
require('ActionQueue').removeFromQueue(action.getClientMutationID());});

require('ActionCollisionMap').clearActionsForKey(key);}


module.exports=GraphQLStore;