/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};

require('configureForRelayOSS');












describe('RelayDiskCacheReader', function () {var 
  getNode = require('RelayTestUtils').getNode;

  function readDiskCache(_ref) 










  {var cachedRecords = _ref.cachedRecords;var cachedRootCallMap = _ref.cachedRootCallMap;var dataID = _ref.dataID;var diskCacheData = _ref.diskCacheData;var fragment = _ref.fragment;var garbageCollector = _ref.garbageCollector;var path = _ref.path;var queries = _ref.queries;var records = _ref.records;var rootCallMap = _ref.rootCallMap;
    cachedRecords = cachedRecords || {};
    cachedRootCallMap = cachedRootCallMap || {};
    diskCacheData = diskCacheData || {};

    var store = new (require('RelayRecordStore'))(
    { 
      records: records || {}, 
      cachedRecords: cachedRecords }, 

    { 
      rootCallMap: rootCallMap || {}, 
      cachedRootCallMap: cachedRootCallMap });



    var cacheManager = { 
      readNode: jest.genMockFunction().mockImplementation(function (id, callback) {
        setTimeout(function () {
          callback(undefined, diskCacheData[id]);});}), 


      readRootCall: jest.genMockFunction().mockImplementation(
      function (callName, callArg, callback) {
        var rootKey = callName + '*' + callArg;
        setTimeout(function () {
          callback(undefined, diskCacheData[rootKey]);});}) };





    var changeTracker = new (require('RelayChangeTracker'))();

    var callbacks = { 
      onSuccess: jest.genMockFunction(), 
      onFailure: jest.genMockFunction() };


    var abort = undefined;
    if (queries) {var _RelayDiskCacheReader$readQueries = 
      require('RelayDiskCacheReader').readQueries(
      queries, 
      store, 
      cachedRecords, 
      cachedRootCallMap, 
      garbageCollector, 
      cacheManager, 
      changeTracker, 
      callbacks);abort = _RelayDiskCacheReader$readQueries.abort;} else 

    if (dataID && fragment && path) {var _RelayDiskCacheReader$readFragment = 
      require('RelayDiskCacheReader').readFragment(
      dataID, 
      fragment, 
      path, 
      store, 
      cachedRecords, 
      cachedRootCallMap, 
      garbageCollector, 
      cacheManager, 
      changeTracker, 
      callbacks);abort = _RelayDiskCacheReader$readFragment.abort;} else 

    {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(false, 'Input did not match for reading queries nor fragments');}


    return { abort: abort, cacheManager: cacheManager, callbacks: callbacks, changeTracker: changeTracker, store: store };}


  beforeEach(function () {
    jest.resetModuleRegistry();
    jest.clearAllTimers();
    jasmine.addMatchers(require('RelayTestUtils').matchers);});



  describe('read', function () {
    it('reads disk for custom root call', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'yuzhi' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayDiskCacheReader', type: 'Actor' };})()) };var _readDiskCache = 



      readDiskCache({ queries: queries });var cacheManager = _readDiskCache.cacheManager;

      var mockReadRoot = cacheManager.readRootCall.mock;
      expect(mockReadRoot.calls.length).toBe(1);
      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);});


    it('does not read disk for node root call', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };var _readDiskCache2 = 



      readDiskCache({ queries: queries });var cacheManager = _readDiskCache2.cacheManager;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);});


    it('calls `onFailure` when custom root call is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'yuzhi' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayDiskCacheReader', type: 'Actor' };})()) };var _readDiskCache3 = 



      readDiskCache({ queries: queries });var cacheManager = _readDiskCache3.cacheManager;var callbacks = _readDiskCache3.callbacks;

      var mockReadRoot = cacheManager.readRootCall.mock;
      expect(mockReadRoot.calls.length).toBe(1);
      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);

      jest.runAllTimers();
      expect(mockReadRoot.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls.length).toBe(0);
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);});


    it('calls `onSuccess` when custom root call is on disk ', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'yuzhi' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayDiskCacheReader', type: 'Actor' };})()) };



      var diskCacheData = { 
        'username*yuzhi': '1055790163', 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };var _readDiskCache4 = 




      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache4.cacheManager;var callbacks = _readDiskCache4.callbacks;var changeTracker = _readDiskCache4.changeTracker;var store = _readDiskCache4.store;

      var mockReadRoot = cacheManager.readRootCall.mock;
      expect(mockReadRoot.calls.length).toBe(1);
      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);

      jest.runAllTimers();

      expect(mockReadRoot.calls.length).toBe(1);
      var mockReadNode = cacheManager.readNode.mock;
      expect(mockReadNode.calls.length).toBe(1);
      expect(mockReadNode.calls[0][0]).toEqual('1055790163');
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          1055790163: true }, 

        updated: {} });});



    it('calls `onSuccess` when custom root call is in store ', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'yuzhi' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayDiskCacheReader', type: 'Actor' };})()) };



      var records = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };


      var rootCallMap = { username: { yuzhi: '1055790163' } };var _readDiskCache5 = 


      readDiskCache({ queries: queries, records: records, rootCallMap: rootCallMap });var cacheManager = _readDiskCache5.cacheManager;var callbacks = _readDiskCache5.callbacks;var changeTracker = _readDiskCache5.changeTracker;var store = _readDiskCache5.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(0);
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: {} });});



    it('calls `onSuccess` when custom root call is in cached store ', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'yuzhi' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayDiskCacheReader', type: 'Actor' };})()) };



      var cachedRecords = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };


      var cachedRootCallMap = { username: { yuzhi: '1055790163' } };var _readDiskCache6 = 


      readDiskCache({ queries: queries, cachedRecords: cachedRecords, cachedRootCallMap: cachedRootCallMap });var cacheManager = _readDiskCache6.cacheManager;var callbacks = _readDiskCache6.callbacks;var changeTracker = _readDiskCache6.changeTracker;var store = _readDiskCache6.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(0);
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: {} });});



    it('calls `onFailure` when node is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };var _readDiskCache7 = 



      readDiskCache({ queries: queries });var cacheManager = _readDiskCache7.cacheManager;var callbacks = _readDiskCache7.callbacks;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runAllTimers();
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);});


    it('calls `onFailure` when a field is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };




      // Missing `name`
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };var _readDiskCache8 = 




      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache8.cacheManager;var callbacks = _readDiskCache8.callbacks;var changeTracker = _readDiskCache8.changeTracker;var store = _readDiskCache8.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runAllTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Confirm that partial data was read into the cache:
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true }, 

        updated: {} });});



    it('calls `onFailure` when a nested node is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'hometown', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Page' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };




      // Missing `hometownid`
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          hometown: { __dataID__: 'hometownid' } } };var _readDiskCache9 = 




      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache9.cacheManager;var callbacks = _readDiskCache9.callbacks;var changeTracker = _readDiskCache9.changeTracker;var store = _readDiskCache9.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(cacheManager.readNode.mock.calls[1][0]).toBe('hometownid');

      jest.runAllTimers();
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Confirm that partial data was read into the cache:
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getLinkedRecordID('1055790163', 'hometown')).
      toBe('hometownid');
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getRecordState('hometownid')).toBe('UNKNOWN');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true }, 

        updated: {} });});



    it('calls `onFailure` when one of the plural nodes is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'service', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'screennames', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Screenname' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };




      // Missing `sn2`
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          screennames: [{ __dataID__: 'sn1' }, { __dataID__: 'sn2' }] }, 

        'sn1': { 
          __dataID__: 'sn1', 
          service: 'GTALK' } };var _readDiskCache10 = 




      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache10.cacheManager;var callbacks = _readDiskCache10.callbacks;var changeTracker = _readDiskCache10.changeTracker;var store = _readDiskCache10.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(3);
      expect(cacheManager.readNode.mock.calls[1][0]).toBe('sn1');
      expect(cacheManager.readNode.mock.calls[2][0]).toBe('sn2');

      jest.runAllTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(3);
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Confirm that partial data was read into the cache:
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getLinkedRecordIDs('1055790163', 'screennames')).
      toEqual(['sn1', 'sn2']);
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getRecordState('sn1')).toBe('EXISTENT');
      expect(store.getField('sn1', 'service')).toBe('GTALK');
      expect(store.getRecordState('sn2')).toBe('UNKNOWN');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true, 
          'sn1': true }, 

        updated: {} });});



    it('calls `onFailure` when range field is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '5' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };















      // Missing `__range__`
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          friends: { __dataID__: 'friends_id' } }, 

        'friends_id': { 
          __dataID__: 'friends_id', 
          count: 500 } };var _readDiskCache11 = 




      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache11.cacheManager;var callbacks = _readDiskCache11.callbacks;var changeTracker = _readDiskCache11.changeTracker;var store = _readDiskCache11.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');

      jest.runAllTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Confirm that partial data was read into the cache:
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getLinkedRecordID('1055790163', 'friends')).
      toBe('friends_id');
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getRecordState('friends_id')).toBe('EXISTENT');
      expect(store.getField('friends_id', 'count')).toBe(500);
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true, 
          'friends_id': true }, 

        updated: {} });});



    it('calls `onFailure` when range on disk has diff calls', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '5' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };















      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          friends: { __dataID__: 'friends_id' } }, 

        'friends_id': { 
          __dataID__: 'friends_id', 
          __range__: new (require('GraphQLRange'))() } };



      diskCacheData.friends_id.__range__.retrieveRangeInfoForQuery.
      mockReturnValue({ 
        requestedEdgeIDs: [], 
        diffCalls: [require('RelayTestUtils').createCall('first', 5)], 
        pageInfo: {} });var _readDiskCache12 = 


      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache12.cacheManager;var callbacks = _readDiskCache12.callbacks;var changeTracker = _readDiskCache12.changeTracker;var store = _readDiskCache12.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');

      jest.runAllTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Confirm that partial data was read into the cache:
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getLinkedRecordID('1055790163', 'friends')).
      toBe('friends_id');
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getRecordState('friends_id')).toBe('EXISTENT');
      expect(store.hasRange('friends_id')).toBe(true);
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true, 
          'friends_id': true }, 

        updated: {} });});



    it('calls `onFailure` when edge node is not on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '5' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };















      // Missing `edge_id`
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          friends: { __dataID__: 'friends_id' } }, 

        'friends_id': { 
          __dataID__: 'friends_id', 
          __range__: new (require('GraphQLRange'))() } };



      diskCacheData.friends_id.__range__.retrieveRangeInfoForQuery.
      mockReturnValue({ 
        requestedEdgeIDs: ['edge_id'], 
        diffCalls: [], 
        pageInfo: {} });var _readDiskCache13 = 


      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache13.cacheManager;var callbacks = _readDiskCache13.callbacks;var changeTracker = _readDiskCache13.changeTracker;var store = _readDiskCache13.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(3);
      expect(cacheManager.readNode.mock.calls[2][0]).toBe('edge_id');

      jest.runAllTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(3);
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Confirm that partial data was read into the cache:
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getLinkedRecordID('1055790163', 'friends')).
      toBe('friends_id');
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getRecordState('friends_id')).toBe('EXISTENT');
      expect(store.hasRange('friends_id')).toBe(true);
      expect(store.getRecordState('edge_id')).toBe('UNKNOWN');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true, 
          'friends_id': true }, 

        updated: {} });});



    it('calls `onSuccess` when connection is on disk', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '5' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };















      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          friends: { __dataID__: 'client:friends_id' } }, 

        'client:friends_id': { 
          __dataID__: 'client:friends_id', 
          __range__: new (require('GraphQLRange'))() }, 

        'client:edge_id': { 
          __dataID__: 'client:edge_id', 
          cursor: '1234', 
          node: { __dataID__: 'friend_id' } }, 

        'friend_id': { 
          __dataID__: 'friend_id', 
          id: 'friend_id', 
          name: 'name' } };



      var rangeInfo = { 
        requestedEdgeIDs: ['client:edge_id'], 
        diffCalls: [], 
        pageInfo: {} };

      diskCacheData['client:friends_id'].__range__.retrieveRangeInfoForQuery.
      mockReturnValue(rangeInfo);var _readDiskCache14 = 

      readDiskCache({ queries: queries, diskCacheData: diskCacheData });var cacheManager = _readDiskCache14.cacheManager;var callbacks = _readDiskCache14.callbacks;var changeTracker = _readDiskCache14.changeTracker;var store = _readDiskCache14.store;

      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(1);
      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(2);
      expect(cacheManager.readNode.mock.calls[1][0]).toBe('client:friends_id');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(3);
      expect(cacheManager.readNode.mock.calls[2][0]).toBe('client:edge_id');

      jest.runOnlyPendingTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(4);
      expect(cacheManager.readNode.mock.calls[3][0]).toBe('friend_id');

      jest.runAllTimers();
      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);
      expect(cacheManager.readNode.mock.calls.length).toBe(4);
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getLinkedRecordID('1055790163', 'friends')).
      toBe('client:friends_id');
      expect(store.getRecordState('client:friends_id')).toBe('EXISTENT');
      var query = queries.q0;
      var friendsField = query.getFieldByStorageKey('friends');
      var friendsPath = new (require('RelayQueryPath'))(query).
      getPath(query.getFieldByStorageKey('friends'), 'client:friends_id');
      expect(store.getPathToRecord('client:friends_id')).
      toMatchPath(friendsPath);
      expect(store.getRangeMetadata(
      'client:friends_id', 
      [{ name: 'first', value: '5' }])).
      toEqual(_extends({}, 
      rangeInfo, { 
        filterCalls: [], 
        filteredEdges: [{ 
          edgeID: 'client:edge_id', 
          nodeID: 'friend_id' }] }));


      expect(store.getRecordState('client:edge_id')).toBe('EXISTENT');
      var edgePath = friendsPath.
      getPath(friendsField.getFieldByStorageKey('edges'), 'client:edge_id');
      expect(store.getPathToRecord('client:edge_id')).toMatchPath(edgePath);
      expect(store.getField('client:edge_id', 'cursor')).toBe('1234');
      expect(store.getLinkedRecordID('client:edge_id', 'node')).
      toBe('friend_id');
      expect(store.getRecordState('friend_id')).toBe('EXISTENT');
      expect(store.getField('friend_id', 'id')).toBe('friend_id');
      expect(store.getField('friend_id', 'name')).toBe('name');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          '1055790163': true, 
          'client:friends_id': true, 
          'client:edge_id': true, 
          'friend_id': true }, 

        updated: {} });});



    it('marks records as updated when more fields are loaded from cache', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'service', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'screennames', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Screenname' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };










      var records = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };


      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          screennames: [{ __dataID__: 'sn1' }] }, 

        'sn1': { 
          __dataID__: 'sn1', 
          service: 'GTALK' } };var _readDiskCache15 = 



      readDiskCache({ queries: queries, diskCacheData: diskCacheData, records: records });var callbacks = _readDiskCache15.callbacks;var changeTracker = _readDiskCache15.changeTracker;var store = _readDiskCache15.store;

      jest.runAllTimers();

      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);

      // Updates the top-level record which existed in node data and creates the
      // linked record.
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getType('1055790163')).toBe('User');
      expect(store.getLinkedRecordIDs('1055790163', 'screennames')).
      toEqual(['sn1']);
      expect(store.getRecordState('sn1')).toBe('EXISTENT');
      expect(store.getField('sn1', 'service')).toBe('GTALK');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          'sn1': true }, 

        updated: { 
          '1055790163': true } });});




    it('marks records as created if they are null in the cache', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'service', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'screennames', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Screenname' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };










      var records = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };


      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          screennames: [{ __dataID__: 'sn1' }, { __dataID__: 'sn2' }] }, 

        'sn1': null, 
        'sn2': undefined };var _readDiskCache16 = 


      readDiskCache({ queries: queries, diskCacheData: diskCacheData, records: records });var callbacks = _readDiskCache16.callbacks;var changeTracker = _readDiskCache16.changeTracker;var store = _readDiskCache16.store;

      jest.runAllTimers();

      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);

      // Updates the top-level record which existed in node data and creates the
      // linked record.
      expect(store.getRecordState('sn1')).toBe('NONEXISTENT');
      expect(store.getRecordState('sn2')).toBe('UNKNOWN');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          'sn1': true }, 
        // sn2 not created since the value is unknown in the cache

        updated: { 
          '1055790163': true } });});




    it('does not mark deleted records as updated', function () {
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'service', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'screennames', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Screenname' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };










      var records = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' }, 

        // linked from the above in diskCache only
        'sn1': null };

      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User', 
          screennames: [{ __dataID__: 'sn1' }] }, 

        'sn1': { 
          __dataID__: 'sn1', 
          service: 'GTALK' } };var _readDiskCache17 = 



      readDiskCache({ queries: queries, diskCacheData: diskCacheData, records: records });var callbacks = _readDiskCache17.callbacks;var changeTracker = _readDiskCache17.changeTracker;var store = _readDiskCache17.store;

      jest.runAllTimers();

      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getLinkedRecordIDs('1055790163', 'screennames')).
      toEqual(['sn1']);
      expect(store.getRecordState('sn1')).toBe('NONEXISTENT');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: { 
          '1055790163': true } });});




    it('registers new records with the garbage collector', function () {
      var garbageCollector = new (require('RelayGarbageCollector'))();
      require('RelayGarbageCollector').prototype.register = jest.genMockFunction();
      var queries = { 
        q0: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()) };







      var records = {};

      var diskCacheData = { 
        '123': { 
          __dataID__: '123', 
          __typename: 'User', 
          id: '123' } };


      readDiskCache({ diskCacheData: diskCacheData, garbageCollector: garbageCollector, queries: queries, records: records });

      jest.runAllTimers();

      expect(garbageCollector.register.mock.calls.length).toBe(1);
      expect(garbageCollector.register.mock.calls[0][0]).toBe('123');});});



  // Most field types are already tested in the normal read function above.
  // This will test the various cases for the root node in `readFragment`.

  describe('readFragment', function () {
    it('calls `onFailure` when node is not in disk', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'fm8nnAveVoQe:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var diskCacheData = {};var _readDiskCache18 = 


      readDiskCache({ dataID: dataID, fragment: fragment, path: path, diskCacheData: diskCacheData });var cacheManager = _readDiskCache18.cacheManager;var callbacks = _readDiskCache18.callbacks;var changeTracker = _readDiskCache18.changeTracker;var store = _readDiskCache18.store;

      jest.runAllTimers();

      var mockReadNode = cacheManager.readNode.mock;
      expect(mockReadNode.calls.length).toBe(1);
      expect(mockReadNode.calls[0][0]).toEqual('1055790163');
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);
      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: {} });});



    it('calls `onFailure` when a field is not on disk', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'Ir+Ra/mBICZ/:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };var _readDiskCache19 = 




      readDiskCache({ dataID: dataID, fragment: fragment, path: path, diskCacheData: diskCacheData });var cacheManager = _readDiskCache19.cacheManager;var callbacks = _readDiskCache19.callbacks;var changeTracker = _readDiskCache19.changeTracker;var store = _readDiskCache19.store;

      jest.runAllTimers();

      var mockReadNode = cacheManager.readNode.mock;
      expect(mockReadNode.calls.length).toBe(1);
      expect(mockReadNode.calls[0][0]).toEqual('1055790163');
      expect(callbacks.onFailure.mock.calls.length).toBe(1);
      expect(callbacks.onSuccess.mock.calls.length).toBe(0);
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getField('1055790163', 'name')).toBe(undefined);
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          1055790163: true }, 

        updated: {} });});



    it('calls `onSuccess` when node is in disk', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'O3YKqqXG59UA:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          name: 'Yuzhi Zheng', 
          __typename: 'User' } };var _readDiskCache20 = 




      readDiskCache({ dataID: dataID, fragment: fragment, path: path, diskCacheData: diskCacheData });var cacheManager = _readDiskCache20.cacheManager;var callbacks = _readDiskCache20.callbacks;var changeTracker = _readDiskCache20.changeTracker;var store = _readDiskCache20.store;

      jest.runAllTimers();

      var mockReadNode = cacheManager.readNode.mock;
      expect(mockReadNode.calls.length).toBe(1);
      expect(mockReadNode.calls[0][0]).toEqual('1055790163');
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: { 
          1055790163: true }, 

        updated: {} });});



    it('calls `onSuccess` when node is in cached store', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'aN70XWRLrV9J:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var cachedRecords = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          name: 'Yuzhi Zheng', 
          __typename: 'User' } };var _readDiskCache21 = 




      readDiskCache({ dataID: dataID, fragment: fragment, path: path, cachedRecords: cachedRecords });var cacheManager = _readDiskCache21.cacheManager;var callbacks = _readDiskCache21.callbacks;var changeTracker = _readDiskCache21.changeTracker;var store = _readDiskCache21.store;

      jest.runAllTimers();

      var mockReadNode = cacheManager.readNode.mock;
      expect(mockReadNode.calls.length).toBe(0);
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: {} });});



    it('calls `onSuccess` when node is in store', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'BN2+YIPShhit:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var records = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          name: 'Yuzhi Zheng', 
          __typename: 'User' } };var _readDiskCache22 = 




      readDiskCache({ dataID: dataID, fragment: fragment, path: path, records: records });var cacheManager = _readDiskCache22.cacheManager;var callbacks = _readDiskCache22.callbacks;var changeTracker = _readDiskCache22.changeTracker;var store = _readDiskCache22.store;

      jest.runAllTimers();

      var mockReadNode = cacheManager.readNode.mock;
      expect(mockReadNode.calls.length).toBe(0);
      expect(callbacks.onFailure.mock.calls.length).toBe(0);
      expect(callbacks.onSuccess.mock.calls.length).toBe(1);
      expect(store.getRecordState('1055790163')).toBe('EXISTENT');
      expect(store.getField('1055790163', 'id')).toBe('1055790163');
      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');
      expect(store.getType('1055790163')).toBe('User');
      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: {} });});});




  describe('abort', function () {
    it('does not call `onSuccess` if aborted', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'vXqOeQQVc/MA:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          name: 'Yuzhi Zheng', 
          __typename: 'User' } };var _readDiskCache23 = 




      readDiskCache({ dataID: dataID, fragment: fragment, path: path, diskCacheData: diskCacheData });var abort = _readDiskCache23.abort;var callbacks = _readDiskCache23.callbacks;var store = _readDiskCache23.store;

      abort();
      // this would read 1055790163 from cache if not aborted
      jest.runAllTimers();

      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');
      expect(callbacks.onFailure).not.toBeCalled();
      expect(callbacks.onSuccess).not.toBeCalled();});


    it('does not `onFailure` if aborted', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'h/a7TE8bz9qG:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayDiskCacheReaderRelayQL', type: 'Node' };})());





      var path = new (require('RelayQueryPath'))(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '1055790163' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayDiskCacheReader', type: 'Node' };})()));




      var dataID = '1055790163';
      var diskCacheData = { 
        '1055790163': { 
          __dataID__: '1055790163', 
          id: '1055790163', 
          __typename: 'User' } };var _readDiskCache24 = 




      readDiskCache({ dataID: dataID, fragment: fragment, path: path, diskCacheData: diskCacheData });var abort = _readDiskCache24.abort;var callbacks = _readDiskCache24.callbacks;var store = _readDiskCache24.store;

      abort();
      // The read would fail since `name` is missing from cached data.
      jest.runAllTimers();

      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');
      expect(callbacks.onFailure).not.toBeCalled();
      expect(callbacks.onSuccess).not.toBeCalled();});});});