jest.






autoMockOff();var 

babelTransform=require('babel-core').transform;




function transform(source,extra){
return babelTransform(source,{
plugins:[
require('babel-preset-react-native/plugins')['babel-plugin-transform-react-jsx'],
[require('../index'),extra]]}).

code;}


function payload(obj){
obj.project=obj.project||'';
return JSON.stringify('__FBT__'+JSON.stringify(obj)+'__FBT__');}


function runTest(data,extra){
require('../../util/test-util').assertSourceAstEqual(
transform(data.input,extra),
data.output);}







var declarative={
'should convert simple strings':{
input:'var x = <fbt desc="It\'s simple">A simple string</fbt>;',

output:
'var x = fbt._('+payload({
"type":"text",
"texts":["A simple string"],
"desc":"It\'s simple"})+
');'},


'should strip out newlines':{
input:
'var x = '+
'<fbt desc="Test trailing space when not last child">\n'+
'  Preamble '+
'  <fbt:param name="parm">{blah}</fbt:param>\n'+
'</fbt>;\n'+
'baz();',

output:
'var x = fbt._('+
payload({
"type":"text",
"texts":["Preamble {parm}"],
"desc":"Test trailing space when not last child"})+
',[\nfbt.param("parm",blah)]\n);\nbaz();'},


'should strip out newlines in Reactish <Fbt>':{
input:
'var x = '+
'<Fbt desc="Test trailing space when not last child">\n'+
'  Preamble '+
'  <FbtParam name="parm">{blah}</FbtParam>\n'+
'</Fbt>;\n'+
'baz();',

output:
'var x = fbt._('+payload({
"type":"text",
"texts":["Preamble {parm}"],
"desc":"Test trailing space when not last child"})+
',[\nfbt.param("parm",blah)]\n);\nbaz();'},


'should strip out more newlines':{
input:
'var x = '+
'<fbt desc="moar lines">\n'+
'  A simple string...\n'+
'  with some other stuff.\n'+
'</fbt>;\n'+
'baz();',

output:
'var x = fbt._('+payload({
"type":"text",
"texts":["A simple string... with some other stuff."],
"desc":"moar lines"})+
');\nbaz();'},


'Squelch whitespace when in an expression':{
input:
'var x = '+
'<fbt desc="squelched">\n'+
'  {"Squelched white space... "}\n'+
'  with some other stuff.\n'+
'</fbt>;\n'+
'baz();',

output:
'var x = fbt._('+payload({
"type":"text",
"texts":["Squelched white space... with some other stuff."],
"desc":"squelched"})+
'\n\n\n);\nbaz();'},


'Enable explicit whitespace':{
input:
'var x = '+
'<fbt desc="squelched">\n'+
'  <fbt:param name="one">{one}</fbt:param>\n'+
'  {" "}\n'+
'  <fbt:param name="two">{two}</fbt:param>\n'+
'</fbt>;',

output:
'var x = fbt._('+payload({
"type":"text",
"texts":["{one} {two}"],
"desc":"squelched"})+
',[\nfbt.param("one",one),\n\n'+
'fbt.param("two",two)]\n);'},


'should handle params':{
input:
'var x = '+
'<fbt desc="a message!">\n'+
'  A parameterized message to:\n'+
'  <fbt:param name="personName">{theName}</fbt:param>\n'+
'</fbt>;',

output:
'var x = fbt._('+payload({
"type":"text",
"texts":["A parameterized message to: {personName}"],
"desc":"a message!"})+
',[\n\nfbt.param("personName",theName)]\n);'},


'should handle concatenated descriptions':{
input:
'<fbt desc={"A very long description " + "that we will concatenate " + '+
'"a few times"}\n project={"With" + "a" + "project"}>\n'+
'  Here it is\n'+
'</fbt>;',

output:
'fbt._('+payload({
"type":"text",
"texts":["Here it is"],
"desc":"A very long description that we will concatenate a few times",
"project":"Withaproject"})+
'\n);'},


'should be able to nest within React nodes':{
input:
'var x = '+
'  <div>\n'+
'    <fbt desc="nested!">\n'+
'      A nested string\n'+
'    </fbt>\n'+
'  </div>;',

output:
"var x =   React.createElement(\"div\", null,   fbt._("+
payload({
"type":"text",
"texts":["A nested string"],
"desc":"nested!"})+
') );'},


'should be able to house arbitrary markup within fbt:param nodes':{
input:
'<div>\n'+
'  <fbt desc="...">\n'+
'    <fbt:param name="time">{formatDate(date, "F d, Y")}</fbt:param>\n'+
'     by \n'+
'    <fbt:param name="user name">\n'+
'      <Link href={{url:user.link}}>\n'+
'        {user.name}\n'+
'      </Link>\n'+
'    </fbt:param>\n'+
'  </fbt>\n'+
'</div>;',

output:
'React.createElement(\"div\", null, \n  '+
'fbt._('+payload({
"type":"text",
"texts":["{time} by {user name}"],
"desc":"..."})+
',[\n'+
'fbt.param("time",formatDate(date, "F d, Y")),\n\n'+
'fbt.param("user name",\n'+
'React.createElement(Link, {href: {url:user.link}}, \n'+
'        user.name\n'+
'      ))]\n\n'+
')\n);'},


'should handle enums (with array values)':{
input:
'var x = '+
'  <fbt desc="enums!">\n'+
'    Click to see\n'+
'    <fbt:enum enum-range={{id1:"groups",\n'+
'                           id2:"photos",\n'+
'                           id3:"videos"}}\n'+
'              value={id} />\n'+
'  </fbt>;',

output:
'var x = '+
'  fbt._('+payload({
"type":"table",
"texts":["Click to see ",{
"type":"enum","values":{
id1:"groups",id2:"photos",id3:"videos"}}],
"desc":"enums!"})+
',[\n\nfbt["enum"](id,'+
'{"id1":"groups","id2":"photos","id3":"videos"})]);'},


'should handle enums with more text':{
input:
'var x = '+
'  <fbt desc="enums!">\n'+
'    Click to see\n'+
'    <fbt:enum enum-range={{id1:"groups",\n'+
'                           id2:"photos",\n'+
'                           id3:"videos"}}\n'+
'              value={id} />\n'+
'    Hey-hey!\n'+
'  </fbt>;',

output:
'var x = '+
'  fbt._('+payload({
"type":"table",
"texts":["Click to see ",{
"type":"enum","values":{
id1:"groups",id2:"photos",id3:"videos"}}," Hey-hey!"],
"desc":"enums!"})+
',[\n\nfbt["enum"](id,'+
'{"id1":"groups","id2":"photos","id3":"videos"})]);'},


'should handle variations':{
input:
'var x = '+
'  <fbt desc="variations!">\n'+
'    Click to see\n'+
'   <fbt:param name="count" number="true">{c}</fbt:param>\n'+
'  links\n'+
'  </fbt>;',

output:
'var x =   fbt._('+payload({
"type":"table",
"texts":["Click to see ",{
"type":"number","token":"count"},
" links"],
"desc":"variations!"})+
',[\n\nfbt.param("count",c, [0])]\n\n);'},


'should handle number={true} - (same output as above test)':{
input:
'var x = '+
'  <fbt desc="variations!">\n'+
'    Click to see\n'+
'   <fbt:param name="count" number={true}>{c}</fbt:param>\n'+
'  links\n'+
'  </fbt>;',

output:
'var x =   fbt._('+payload({
"type":"table",
"texts":["Click to see ",{
"type":"number","token":"count"},
" links"],
"desc":"variations!"})+
',[\n\nfbt.param("count",c, [0])]\n\n);'},


'should correctly destruct expression values in options':{
input:
'<fbt desc="d">str\n'+
'  <fbt:param name="count" number={someNum}>\n'+
'    {getNum()}\n'+
'  </fbt:param>'+
'</fbt>',

output:
'fbt._('+payload({
"type":"table",
"texts":["str ",{"type":"number","token":"count"}],
"desc":"d"})+
',[\nfbt.param("count",\ngetNum(),[0,someNum])]\n);'},


'should insert param value for same-param':{
input:
'<fbt desc="d">str\n'+
'  <fbt:param name="foo">{Bar}</fbt:param> and '+
'  <fbt:same-param name="foo"/>'+
'</fbt>',

output:
'fbt._('+payload({
"type":"text",
"texts":["str {foo} and {foo}"],
"desc":"d"})+
',[fbt.param("foo",Bar)]);'},


'should treat multiline descs as a single line':{
input:[
'<fbt ',
'desc="hi how are you today im doing well i guess',
'how is your mother is she well yeah why not lets go',
'home and never come back.">',
'lol',
'</fbt>'].
join('\n'),

output:
'fbt._('+payload({
"type":"text",
"texts":["lol"],
"desc":'hi how are you today im doing well i guess how is your '+
'mother is she well yeah why not lets go home and never come back.'})+
');'},


'should not insert extra space':{
input:[
'<fbt desc="Greating in i18n demo">',
'  Hello, <fbt:param name="guest">',
'  {guest}',
'</fbt:param>!',
'</fbt>'].
join('\n'),

output:'fbt._('+payload({
"type":"text",
"texts":["Hello, {guest}!"],
"desc":"Greating in i18n demo",
"project":""})+
', [fbt.param("guest",guest)]);'},


'should handle single expression with binary':{
input:[
'<fbt desc="foo">',
'  {"foo" + "bar"}',
'</fbt>'].
join('\n'),

output:'fbt._('+payload({
"type":"text",
"texts":["foobar"],
"desc":"foo",
"project":""})+
');'},


'should ignore invalid JSON from docblock':{
input:
'/**@fbt {project: "dev"}*/\n'+
'<fbt desc="some-desc">No default options</fbt>',

output:
'/**@fbt {project: "dev"}*/\n'+
'fbt._('+
payload({
"type":"text",
"texts":["No default options"],
"desc":"some-desc"})+
');'},


'should ignore invalid variations in fbt:param':{
input:
'<fbt desc="some-desc">\n'+
'  <fbt:param name="foo" qux="foo" desc="foo-desc">\n'+
'    {foo}\n'+
'  </fbt:param>\n'+
'</fbt>',

output:
'fbt._('+payload({
"type":"text",
"texts":["{foo}"],
"desc":"some-desc"})+
', [fbt.param("foo", foo)]);'},


'should ignore non-expression children in fbt:param':{
input:
'<fbt desc="some-desc">\n'+
'  <fbt:param name="foo">\n'+
'    !{foo}!\n'+
'  </fbt:param>\n'+
'</fbt>',

output:
'fbt._('+payload({
"type":"text",
"texts":["{foo}"],
"desc":"some-desc"})+
', [fbt.param("foo", foo)]);'},


'should maintain order of params and enums':{
input:
'<fbt desc="some-desc">\n'+
'  Hello, \n'+
'  <fbt:param name="foo">\n'+
'    {foo}\n'+
'  </fbt:param>\n'+
'  <fbt:enum enum-range={["x", "y"]} value={x} />\n'+
'  <fbt:param name="bar" number={n}>\n'+
'    {bar}\n'+
'  </fbt:param>\n'+
'</fbt>',

output:
'fbt._('+payload({
"type":"table",
"texts":[
"Hello, {foo}",
{type:"enum",values:{x:"x",y:"y"}},
{type:"number",token:"bar"}],

"desc":"some-desc"})+
', [fbt.param("foo", foo), '+
'fbt["enum"](x, {"x": "x", "y": "y"}), fbt.param("bar", bar, [0, n])]);'}};




describe('Test declarative (jsx) fbt syntax translation',function(){
for(var test in declarative){
it(test,function(test){
return function(){
runTest(declarative[test]);};}(

test));}});