{
  "_args": [
    [
      "redux-persist@https://registry.npmjs.org/redux-persist/-/redux-persist-1.5.6.tgz",
      "C:\\gitRepo\\f8app"
    ]
  ],
  "_from": "redux-persist@>=1.5.0 <1.6.0",
  "_id": "redux-persist@1.5.6",
  "_inCache": true,
  "_location": "/redux-persist",
  "_phantomChildren": {},
  "_requested": {
    "name": "redux-persist",
    "raw": "redux-persist@https://registry.npmjs.org/redux-persist/-/redux-persist-1.5.6.tgz",
    "rawSpec": "https://registry.npmjs.org/redux-persist/-/redux-persist-1.5.6.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/redux-persist/-/redux-persist-1.5.6.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/redux-persist/-/redux-persist-1.5.6.tgz",
  "_shasum": "360786aad1b0ea4dab4c991b35a557600bfa0b3d",
  "_shrinkwrap": null,
  "_spec": "redux-persist@https://registry.npmjs.org/redux-persist/-/redux-persist-1.5.6.tgz",
  "_where": "C:\\gitRepo\\f8app",
  "author": {
    "email": "zack@root-two.com",
    "name": "rt2zz"
  },
  "bugs": {
    "url": "https://github.com/rt2zz/redux-persist/issues"
  },
  "dependencies": {
    "lodash.foreach": "^3.0.3",
    "lodash.isplainobject": "^3.2.0"
  },
  "description": "persist and rehydrate redux stores",
  "devDependencies": {
    "babel": "^5.8.29",
    "babel-core": "^5.8.33",
    "babel-eslint": "^4.1.3",
    "expect": "~1.12.2",
    "immutable": "^3.7.6",
    "lodash": "^3.10.1",
    "mocha": "~2.3.3",
    "redux": "~3.0.4",
    "rimraf": "~2.4.3",
    "standard": "^5.3.1"
  },
  "files": [
    "lib",
    "src",
    "constants.js"
  ],
  "homepage": "https://github.com/rt2zz/redux-persist",
  "keywords": [
    "redux",
    "redux-middleware",
    "localstorage",
    "redux-persist",
    "redux-storage",
    "redux-rehydrate"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "redux-persist",
  "optionalDependencies": {},
  "readme": "# Redux Persist\nPersist and rehydrate a redux store.\n\nRedux Persist is [performant](#performance), easy to [implement](#basic-usage), and easy to [extend](#extend-and-customize).\n\nCheck out some [recipes](https://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md), or open an issue to discuss your use case.\n\n[![build status](https://img.shields.io/travis/rt2zz/redux-persist/master.svg?style=flat-square)](https://travis-ci.org/rt2zz/redux-persist)\n[![npm version](https://img.shields.io/npm/v/redux-persist.svg?style=flat-square)](https://www.npmjs.com/package/redux-persist)\n[![npm downloads](https://img.shields.io/npm/dm/redux-persist.svg?style=flat-square)](https://www.npmjs.com/package/redux-persist)\n\n## Basic Usage\nBasic usage requires adding three lines to a traditional redux application:\n```js\nimport {persistStore, autoRehydrate} from 'redux-persist'\nconst store = autoRehydrate()(createStore)(reducer)\npersistStore(store)\n```\nFor per reducer rehydration logic, you can opt-in by adding a handler to your reducer:\n```js\nimport {REHYDRATE} from 'redux-persist/constants'\n//...\ncase REHYDRATE:\n  if(action.key === 'myReducer'){\n    return {...state, ...action.payload, specialKey: processSpecial(action.payload.specialKey)}\n  }\n  return state\n```\nYou may also need to configure the persistence layer, or take action after rehydration has completed:\n```js\npersistStore(store, {blacklist: ['someTransientReducer']}, () => {\n  console.log('rehydration complete with state')\n})\n```\nAnd if things get out of wack, just purge the storage\n```js\npersistStore(store, config, callback).purge(['someReducer']) //or .purgeAll()\n```\n\n## API\n#### `persistStore(store, [config, callback])`\n  - arguments\n    - **store** *redux store* The store to be persisted.\n    - **config** *object*\n      - **blacklist** *array* keys (read: reducers) to ignore\n      - **whitelist** *array* keys (read: reducers) to persist, if set all other keys will be ignored.\n      - **storage** *object* a [conforming](https://github.com/rt2zz/redux-persist#storage-backends) storage engine.\n      - **transforms** *array* transforms to be applied during storage and during rehydration.\n      - **debounce** *integer* debounce interval applied to storage calls.\n      - **skipRestore** *boolean* true -> do not restore state.\n    - **callback** *function* will be called after rehydration is finished.\n  - returns **persistor** object\n\n#### `persistor object`\n  - the persistor object is returned by persistStore with the following methods:\n    - `.purge(keys)`\n      - **keys** *array* An array of keys to be purged from local storage. (this method is available on the return value of persistStore)\n    - `.purgeAll()`\n      - Purges all keys. (this method is available on the return value of persistStore)\n    - `.rehydrate(key, serialDataString)`\n      - This can be used to trigger rehydration from outside of persistStore, for example in crosstab syncing.\n\n#### `autoRehydrate()`\n  - This is a store enhancer that will automatically shallow merge the persisted state for each key. Additionally it queues any actions that are dispatched before rehydration is complete, and fires them after rehydration is finished.\n\n#### `constants`\n  - `import constants from 'redux-persist/constants'`. This includes rehydration action types, and other relevant constants.\n\n## Extend And Customize\nRedux-persist is very easy to extend with new functionality:\n* ImmutableJS support with [redux-persist-immutable](https://github.com/rt2zz/redux-persist-immutable)\n* Cross tab syncing with [redux-persist-crosstab](https://github.com/rt2zz/redux-persist-crosstab)\n* Browser Extensions [browser-redux-sync](https://github.com/zalmoxisus/browser-redux-sync)\n\n#### Example\n```js\nimport reduxPersistImmutable from 'redux-persist-immutable'\nimport crosstabSync from 'redux-persist-crosstab'\n\nconst persistor = persistStore(store, {transforms: [reduxPersistImmutable]}, () => crosstabSync(persistor))\n```\n\n## Semi Secret Advanced APIs\n**warning** these api's may change without warning\n#### initialState rehydration\n```js\nimport {getStoredState, autoRehydrate, persistStore} from 'redux-persist'\n\n//... set up everything per normal: finalCreateStore, reducer etc.\n\nconst persistConfig = {\n  skipRestore: true\n}\n\ngetStoredState(persistConfig, (err, initialState) => {\n  const store = finalCreateStore(reducer, initialState)\n  persistStore(store, persistConfig)\n  render(\n    <Root store={store} />,\n       document.getElementById('root')\n    </Root>\n  )\n})\n```\n\n#### Secondary Persistor\n```js\nconst persistor = persistStore(store)\nconst secondaryPersistor = persistStore(store, {storage: specialBackupStorage, skipRestore: false})\n```\n\n## Storage Backends\n**localStorage** (default), react-native **AsyncStorage**, or a conforming **custom** storage api. Custom storage API should be an object with the following methods: `setItem` `getItem` `removeItem` `getAllKeys` each with the function signature as found in [react-native AsyncStorage](http://facebook.github.io/react-native/docs/asyncstorage.html#content).\n\n```js\nimport {AsyncStorage} from 'react-native'\npersistStore(store, {storage: AsyncStorage})\n```\n## Rationale\n\n* Performant out of the box (uses a time iterator and operates on state partials)\n* Keeps custom rehydration logic in the reducers (where it intuitively belongs)\n* Supports localStorage, react-native AsyncStorage, or any conforming storage api\n\nThe core idea behind redux-persist is to provide performant persistence and rehydration methods. At the same time redux-persist is designed to minimize complexity by knowing as little about your application as possible.\n\nConceptually redux-persist encourages you to think on a per-reducer basis. This greatly simplifies the mental model (no filters or selectors!) and means that if you change your reducer schema, you will not need to mirror those changes in your persistence configuration.\n\nBecause persisting state is inherently stateful, `persistStore` lives outside of the redux store. Importantly this keeps the store 'pure' and makes testing and extending the persistor much easier.\n\n## About Auto Rehydrate\nautoRehydrate is a store enhancer that automatically rehydrates state.\n\nWhile auto rehydration works out of the box, individual reducers can opt in to handling their own rehydration, allowing for more complex operations like data transforms and cache invalidation. Simply define a handler for the rehydrate action in your reducer, and if the state is mutated, auto rehydrate will skip that key.\n\nWith autoRehydrate, actions dispatched before rehydration is complete are buffered and released immediately after rehydration is complete.\n\nAuto rehydrate is provided as a convenience. In a large application, or one with atypical reducer composition, auto rehydration may not be convenient. In this case, simply omit autoRehydrate. Rehydration actions will still be fired by `persistStore`, and can then be handled individually by reducers or using a custom rehydration handler.\n\n## Performance\nJSON serialization and localStorage (which is sync!) can both hurt performance. To work around this redux-persist implements a few performance tricks:\n* **During Rehydration** getItem calls are invoked once per key using setImmediate.  \n* **During Storage** setItem calls are invoked only on keys whose state has changed. If performance is impacted, set `config.debounce = 33` to stagger (debounce) the calls by 33ms intervals (i.e. 30fps).  \n\nAdditionally redux persist operates on a per reducer basis, which is a great lever for maximizing performance. If a piece of state is changing often (10+ times per second), isolate that state into it's own reducer, which will make the serialization and storage operations much faster.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rt2zz/redux-persist.git"
  },
  "scripts": {
    "build": "babel src --out-dir lib",
    "build:watch": "npm run build ./src -- -watch",
    "clean": "rimraf lib dist",
    "prepublish": "npm run clean && npm run build",
    "test": "standard && NODE_ENV=production mocha --compilers js:babel/register --recursive",
    "test:watch": "npm test -- --watch"
  },
  "standard": {
    "parser": "babel-eslint"
  },
  "version": "1.5.6"
}
