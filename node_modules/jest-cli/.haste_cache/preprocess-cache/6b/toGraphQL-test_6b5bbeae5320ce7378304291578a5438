/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');








describe('toGraphQL', function () {var 
  defer = require('RelayTestUtils').defer;var getNode = require('RelayTestUtils').getNode;

  var CONCRETE_KEYS = { 
    alias: true, 
    arguments: true, 
    calls: true, 
    children: true, 
    directives: true, 
    fieldName: true, 
    isDeferred: true, 
    jsonPath: true, 
    kind: true, 
    metadata: true, 
    name: true, 
    responseType: true, 
    sourceQueryID: true, 
    type: true, 
    value: true };


  function filterGraphQLNode(node) {
    node = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/filterObject')(node, function (value, key) {
      if (!CONCRETE_KEYS[key]) {
        return false;}

      return !!value && (!Array.isArray(value) || value.length);});

    if (node.calls) {
      node.calls = node.calls.length ? 
      node.calls.map(filterGraphQLNode) : 
      null;}

    if (node.children) {
      node.children = node.children.length ? 
      node.children.map(filterGraphQLNode) : 
      null;}

    if (node.directives) {
      node.directives = node.directives.length ? 
      node.directives.map(filterGraphQLNode) : 
      null;}

    if (node.metadata) {
      node.metadata = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/filterObject')(
      node.metadata, 
      function (value) {return !!value;});}


    return node;}


  beforeEach(function () {
    jest.resetModuleRegistry();

    jasmine.addMatchers({ 
      toConvert: function () {
        return { 
          compare: function (actual, query) {
            // This filters out extraneous properties from `GraphQL.*` nodes
            // such as `fields` or `fragments`, and reduces metadata down to
            // compare only truthy values. Once the printer outputs plain values
            // the filter step can be removed or simplified (might want to still
            // filter metadata).
            var expected = filterGraphQLNode(query);
            expect(filterGraphQLNode(actual(getNode(query)))).toEqual(expected);
            return { 
              pass: true };} };} });});







  it('converts query', function () {
    expect(require('toGraphQL').Query).toConvert((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'ToGraphQL', type: 'Viewer' };})());});











  it('converts query with root args', function () {
    expect(require('toGraphQL').Query).toConvert((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'ids', value: [{ kind: 'CallValue', callValue: '1' }, { kind: 'CallValue', callValue: '2' }, { kind: 'CallValue', callValue: '3' }] }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'nodes', kind: 'Query', metadata: { isPlural: true, isAbstract: true, identifyingArgName: 'ids' }, name: 'ToGraphQL', type: 'Node' };})());});









  it('converts fragment', function () {
    expect(require('toGraphQL').Fragment).toConvert((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], id: 'Do+t1zixVD1b:0', kind: 'Fragment', metadata: {}, name: 'ToGraphQLRelayQL', type: 'Viewer' };})());});









  it('converts field with calls', function () {
    expect(require('toGraphQL').Query).toConvert((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'site', value: { kind: 'CallValue', callValue: 'www' } }], fieldName: 'url', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'ToGraphQL', type: 'Viewer' };})());});











  it('converts connection and generated fields', function () {
    expect(require('toGraphQL').Query).toConvert((function () {return { children: [{ children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '5' } }], children: [{ children: [{ children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'ToGraphQL', type: 'Viewer' };})());});
















  it('preserves batch call information', function () {
    var fragment = (function () {return { children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], id: 'nMo1VV9yNHz2:0', kind: 'Fragment', metadata: {}, name: 'ToGraphQLRelayQL', type: 'User' };})();




    var query = (function (RQL_0) {return { children: [{ children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'ToGraphQL', type: 'Viewer' };})(



    defer(fragment));




    var splitQueries = require('splitDeferredRelayQueries')(getNode(query));
    var deferredQuery = require('toGraphQL').Query(splitQueries.deferred[0].required);
    var batchCall = deferredQuery.calls[0].value;

    expect(deferredQuery.isDeferred).toBe(true);
    expect(batchCall.sourceQueryID).toBe('q1');
    expect(batchCall.jsonPath).toBe('$.*.actor.id');});


  it('does not double-encode argument values', function () {
    var value = { query: 'Menlo Park' };
    var relayQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: { type: 'CheckinSearchInput' }, name: 'query', value: { kind: 'CallVariable', callVariableName: 'q' } }], children: [{ fieldName: 'query', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'checkinSearchQuery', kind: 'Query', metadata: { identifyingArgName: 'query', identifyingArgType: 'CheckinSearchInput' }, name: 'ToGraphQL', type: 'CheckinSearchResult' };})(), 





    { 
      q: value });

    var identifyingArg = relayQuery.getIdentifyingArg();
    expect(identifyingArg).toBeDefined();
    expect(identifyingArg.value).toEqual(value);
    var convertedQuery = require('toGraphQL').Query(relayQuery);
    expect(convertedQuery.calls[0].value.callValue).toBe(value);});});