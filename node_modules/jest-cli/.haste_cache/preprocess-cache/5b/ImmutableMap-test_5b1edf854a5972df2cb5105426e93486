"use strict";



















jest.
dontMock('Immutable').
dontMock('ImmutableMap');

var ImmutableMap;


var testDev=function(message,testFunc){
it(message,function(){
var old=window.__DEV__;
window.__DEV__=true;
testFunc();
window.__DEV__=old;});};



var testProd=function(message,testFunc){
it(message,function(){

var old=window.__DEV__;
window.__DEV__=false;
testFunc();
window.__DEV__=old;});};



var testDevAndProd=function(message,testFunc){
testDev(message+':DEV',testFunc);
testProd(message+':PROD',testFunc);};






var hasEmptyStringKey=[
{uniqueID:'',bla:'asdf'}];





var duplicate=function(itm,key,count){
return {
uniqueID:itm.uniqueID,
val:itm.val+key+count+this.justToTestScope};};





var hasNullAndUndefStringKey=[
{uniqueID:'undefined',val:'thisIsUndefined'},
{uniqueID:'null',val:'thisIsNull'}];

var hasNullAndUndefStringKeyObject={
'undefined':{val:'thisIsUndefined'},
'null':{val:'thisIsNull'}};

var hasNullKey=[
{uniqueID:'thisKeyIsFine',data:[]},
{uniqueID:'thisKeyIsAlsoFine',data:[]},
{uniqueID:null,data:[]}];


var hasObjectKey=[
{uniqueID:'thisKeyIsFine',data:[]},
{uniqueID:'thisKeyIsAlsoFine',data:[]},
{uniqueID:{},data:[]}];


var hasArrayKey=[
{uniqueID:'thisKeyIsFine',data:[]},
{uniqueID:'thisKeyIsAlsoFine',data:[]},
{uniqueID:[],data:[]}];



var hasNullStringKey=[
{uniqueID:'thisKeyIsFine',data:[]},
{uniqueID:'thisKeyIsAlsoFine',data:[]},
{uniqueID:'null',data:[]}];


var hasUndefinedKey=[
{uniqueID:'thisKeyIsFine',data:[]},
{uniqueID:'thisKeyIsAlsoFine',data:[]},
{uniqueID:undefined,data:[]}];


var hasUndefinedStringKey=[
{uniqueID:'thisKeyIsFine',data:[]},
{uniqueID:'thisKeyIsAlsoFine',data:[]},
{uniqueID:'undefined',data:[]}];


var hasPositiveNumericKey=[
{uniqueID:'notANumber',data:[]},
{uniqueID:'5',data:[]},
{uniqueID:'notAnotherNumber',data:[]}];


var hasZeroStringKey=[
{uniqueID:'greg',data:'grego'},
{uniqueID:'0',data:'0o'},
{uniqueID:'tom',data:'tomo'}];


var hasZeroNumberKey=[
{uniqueID:'greg',data:'grego'},
{uniqueID:0,data:'0o'},
{uniqueID:'tom',data:'tomo'}];


var hasAllNumericStringKeys=[
{uniqueID:'0',name:'Gregory'},
{uniqueID:'2',name:'James'},
{uniqueID:'1',name:'Tom'}];


var hasAllNumericKeys=[
{uniqueID:0,name:'Gregory'},
{uniqueID:2,name:'James'},
{uniqueID:1,name:'Tom'}];


var hasAllValidKeys=[
{uniqueID:'keyOne',value:'valueOne'},
{uniqueID:'keyTwo',value:'valueTwo'}];


var hasDuplicateKeys=[
{uniqueID:'keyOne',value:'valueOne'},
{uniqueID:'keyTwo',value:'valueTwo'},
{uniqueID:'keyOne',value:'valueThree'}];


var idEntities=[
{uniqueID:'greg',name:'Gregory'},
{uniqueID:'james',name:'James'},
{uniqueID:'tom',name:'Tom'}];


var hasEmptyKey=[
{uniqueID:'greg',name:'Gregory'},
{uniqueID:'',name:'James'},
{uniqueID:'tom',name:'Tom'}];


var extractUniqueID=function(entity){
return entity.uniqueID;};


describe('ImmutableMap',function(){
beforeEach(function(){
jest.resetModuleRegistry();
ImmutableMap=require('ImmutableMap');});


testDevAndProd('should create from array when providing an identity CB',function(){
expect(function(){
ImmutableMap.fromArray(idEntities,extractUniqueID);}).
not.toThrow();});


testDevAndProd('should throw if constructing from Array without identity CB',function(){
expect(function(){
ImmutableMap.fromArray(idEntities);}).
toThrow();});


testDevAndProd('should throw when fromArray extracts a numeric key',function(){
expect(function(){
ImmutableMap.fromArray(hasPositiveNumericKey,extractUniqueID);}).
toThrow();});



testDevAndProd('should throw if empty value (undefined)',function(){
expect(function(){
ImmutableMap.fromArray([
{uniqueID:'uniqueID'},
undefined],
extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.create({'uniqueID':undefined});}).
toThrow();});


testDevAndProd('should throw not thow if null value',function(){
var im;
var im2;
expect(function(){
im=ImmutableMap.create({'uniqueID':null});}).
not.toThrow();
expect(ImmutableMap.has(im,'uniqueID')).toBe(true);
expect(ImmutableMap.get(im,'uniqueID')).toBe(null);
expect(ImmutableMap.size(im)).toBe(1);

expect(function(){
im2=ImmutableMap.set(im,{'anotherUniqueID':null});}).
not.toThrow();
expect(ImmutableMap.has(im2,'anotherUniqueID')).toBe(true);
expect(ImmutableMap.get(im2,'anotherUniqueID')).toBe(null);
expect(ImmutableMap.size(im2)).toBe(2);});


testDevAndProd('should throw when any key is the empty string',function(){
expect(function(){
ImmutableMap.fromArray(hasEmptyKey,extractUniqueID);}).
toThrow();});


testDevAndProd('should not throw when a key is the string "undefined" or "null"',function(){
function validateIM(im){
expect(ImmutableMap.size(im)).toBe(2);
expect(ImmutableMap.indexOfKey(im,'undefined')).toBe(0);
expect(ImmutableMap.indexOfKey(im,'null')).toBe(1);
expect(ImmutableMap.keyAfter(im,'undefined')).toBe('null');
expect(ImmutableMap.keyAfter(im,'null')).toBe(undefined);
expect(ImmutableMap.keyBefore(im,'undefined')).toBe(undefined);
expect(ImmutableMap.has(im,'undefined')).toBe(true);
expect(ImmutableMap.has(im,'null')).toBe(true);
expect(ImmutableMap.get(im,'undefined').val).toBe('thisIsUndefined');
expect(ImmutableMap.get(im,'null').val).toBe('thisIsNull');}

var im=ImmutableMap.fromArray(hasNullAndUndefStringKey,extractUniqueID);
validateIM(im);
var imFromObject=ImmutableMap.create(hasNullAndUndefStringKeyObject);
validateIM(imFromObject);});






testDevAndProd('should throw when a key is the string/number zero',function(){
expect(function(){
ImmutableMap.fromArray(hasZeroNumberKey,extractUniqueID);}).
toThrow();});


testDevAndProd('should throw when any key is falsey',function(){
expect(function(){
ImmutableMap.fromArray(hasEmptyStringKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.fromArray(hasNullKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.fromArray(hasUndefinedKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.create({'':4});}).
toThrow();});



testDevAndProd('should not throw on string keys "undefined/null"',function(){
expect(function(){
ImmutableMap.fromArray(hasNullStringKey,extractUniqueID);}).
not.toThrow();

expect(function(){
ImmutableMap.fromArray(hasUndefinedStringKey,extractUniqueID);}).
not.toThrow();});


testDevAndProd('should throw on extracting keys that are not strings/nums',function(){
expect(function(){
ImmutableMap.fromArray(hasObjectKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.fromArray(hasArrayKey,extractUniqueID);}).
toThrow();});


testDevAndProd('should throw if instantiating with duplicate key',function(){
expect(function(){
ImmutableMap.fromArray(hasDuplicateKeys,extractUniqueID);}).
toThrow();});


testDevAndProd('should throw when a key is the string "0"',function(){
expect(function(){
ImmutableMap.fromArray(hasZeroStringKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.create({'0':true});}).
toThrow();});


testDevAndProd('should throw when getting invalid public key',function(){
var im=ImmutableMap.fromArray(hasAllValidKeys,extractUniqueID);
expect(function(){
ImmutableMap.has(im,0);}).
toThrow();
expect(function(){
ImmutableMap.get(im,0);}).
toThrow();
expect(function(){
ImmutableMap.has(im,'0');}).
toThrow();
expect(function(){
ImmutableMap.get(im,'0');}).
toThrow();
expect(function(){
ImmutableMap.has(im,'1');}).
toThrow();
expect(function(){
ImmutableMap.get(im,'1');}).
toThrow();
expect(function(){
ImmutableMap.has(im,1);}).
toThrow();
expect(function(){
ImmutableMap.get(im,1);}).
toThrow();
expect(function(){
ImmutableMap.has(im,undefined);}).
toThrow();
expect(function(){
ImmutableMap.get(im,undefined);}).
toThrow();
expect(function(){
ImmutableMap.has(im,null);}).
toThrow();
expect(function(){
ImmutableMap.get(im,null);}).
toThrow();
expect(function(){
ImmutableMap.has(im,'');}).
toThrow();
expect(function(){
ImmutableMap.get(im,'');}).
toThrow();});


testDevAndProd('should throw when any key is falsey',function(){
expect(function(){
ImmutableMap.fromArray(hasEmptyStringKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.fromArray(hasNullKey,extractUniqueID);}).
toThrow();

expect(function(){
ImmutableMap.fromArray(hasUndefinedKey,extractUniqueID);}).
toThrow();});



testDevAndProd('should throw when fromArray is passed crazy args',function(){


var validIM=ImmutableMap.fromArray(hasAllValidKeys,extractUniqueID);
expect(function(){
ImmutableMap.fromArray({uniqueID:'asdf'},extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray(validIM,extractUniqueID);}).
toThrow();});


testDevAndProd('should throw when fromArray is passed crazy things',function(){
expect(function(){
ImmutableMap.fromArray(null,extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray('stringgg',extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray(undefined,extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray(new Date(),extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray({},extractUniqueID);}).
toThrow();


expect(function(){
ImmutableMap.fromArray(idEntities);}).
toThrow();
expect(function(){
ImmutableMap.fromArray(idEntities,extractUniqueID);}).
not.toThrow();});



testDevAndProd('should not throw when from/merge is passed an non-ImmutableMap.',function(){

expect(function(){
ImmutableMap.fromArray(idEntities,extractUniqueID);}).
not.toThrow();


expect(function(){
ImmutableMap.set(
ImmutableMap.fromArray(idEntities,extractUniqueID),
{blah:'willFail'});}).

not.toThrow();});



testDevAndProd('should not throw when set is passed two ImmutableMaps.',function(){
expect(function(){
ImmutableMap.set(
ImmutableMap.fromArray(idEntities,extractUniqueID),
ImmutableMap.fromArray(idEntities,extractUniqueID));}).

not.toThrow();});



testDevAndProd('should not throw when set is passed one non-ImmutableMaps.',function(){
expect(function(){
var im=ImmutableMap.set(
ImmutableMap.fromArray(idEntities,extractUniqueID),
{mergeThis:'hi'});

expect(ImmutableMap.size(im)).toBe(4);
expect(ImmutableMap.keyAtIndex(im,0)).toBe('greg');
expect(ImmutableMap.keyAtIndex(im,1)).toBe('james');
expect(ImmutableMap.keyAtIndex(im,2)).toBe('tom');
expect(ImmutableMap.keyAtIndex(im,3)).toBe('mergeThis');}).

not.toThrow();

expect(function(){

ImmutableMap.set(
{mergeThis:'hi'},
ImmutableMap.fromArray(idEntities,extractUniqueID));}).

toThrow();});


testDevAndProd('should not throw when set is passed one non-ImmutableMaps.',function(){
expect(function(){
var im=ImmutableMap.set(
ImmutableMap.fromArray(idEntities,extractUniqueID),
{mergeThis:'hi'});

expect(ImmutableMap.size(im)).toBe(4);
expect(ImmutableMap.keyAtIndex(im,3)).toBe('mergeThis');}).
not.toThrow();});


testDevAndProd('should throw when accessing key before/after of non-key',function(){
function validate(im){
expect(function(){
ImmutableMap.keyBefore(im,'dog');}).
toThrow();
expect(function(){
ImmutableMap.keyAfter(im,'cat');}).
toThrow();
expect(function(){
ImmutableMap.keyAfter(im,null);}).
toThrow();
expect(function(){
ImmutableMap.keyAfter(im,undefined);}).
toThrow();}

var im=ImmutableMap.fromArray([
{uniqueID:'first'},
{uniqueID:'two'}],extractUniqueID);

validate(im);
var im2=ImmutableMap.create({
'first':{},
'second':{}});

validate(im2);});


testDevAndProd('should throw passing invalid/not-present-keys to before/after',function(){
function validate(im){
expect(function(){
ImmutableMap.keyBefore(im,'');}).
toThrow();
expect(function(){
ImmutableMap.keyBefore(im,null);}).
toThrow();
expect(function(){
ImmutableMap.keyBefore(im,undefined);}).
toThrow();
expect(function(){
ImmutableMap.keyBefore(im,'notInTheImmutableMap!');}).
toThrow();

expect(function(){
ImmutableMap.keyAfter(im,'');}).
toThrow();
expect(function(){
ImmutableMap.keyAfter(im,null);}).
toThrow();
expect(function(){
ImmutableMap.keyAfter(im,undefined);}).
toThrow();
expect(function(){
ImmutableMap.keyAfter(im,'notInTheImmutableMap!');}).
toThrow();

expect(function(){
ImmutableMap.nthKeyAfter(im,'',1);}).
toThrow();
expect(function(){
ImmutableMap.nthKeyAfter(im,null,1);}).
toThrow();
expect(function(){
ImmutableMap.nthKeyAfter(im,undefined,1);}).
toThrow();
expect(function(){
ImmutableMap.nthKeyAfter(im,'notInTheImmutableMap!',1);}).
toThrow();

expect(function(){
ImmutableMap.nthKeyBefore(im,'',1);}).
toThrow();
expect(function(){
ImmutableMap.nthKeyBefore(im,null,1);}).
toThrow();
expect(function(){
ImmutableMap.nthKeyBefore(im,undefined,1);}).
toThrow();
expect(function(){
ImmutableMap.nthKeyBefore(im,'notInTheImmutableMap!',1);}).
toThrow();}


var im=ImmutableMap.fromArray([
{uniqueID:'one',val:'first'},
{uniqueID:'two',val:'second'},
{uniqueID:'three',val:'third'},
{uniqueID:'four',val:'fourth'}],
extractUniqueID);
validate(im);

var im2=ImmutableMap.create({
'one':{val:'first'},
'two':{val:'second'},
'three':{val:'third'},
'four':{val:'fourth'}});

validate(im2);});



testDevAndProd('should correctly determine the nth key after before',function(){
function validateImmutableMap(im){
expect(ImmutableMap.keyBefore(im,'one')).toBe(undefined);
expect(ImmutableMap.keyBefore(im,'two')).toBe('one');
expect(ImmutableMap.keyBefore(im,'three')).toBe('two');
expect(ImmutableMap.keyBefore(im,'four')).toBe('three');

expect(ImmutableMap.keyAfter(im,'one')).toBe('two');
expect(ImmutableMap.keyAfter(im,'two')).toBe('three');
expect(ImmutableMap.keyAfter(im,'three')).toBe('four');
expect(ImmutableMap.keyAfter(im,'four')).toBe(undefined);

expect(ImmutableMap.nthKeyBefore(im,'one',0)).toBe('one');
expect(ImmutableMap.nthKeyBefore(im,'one',1)).toBe(undefined);
expect(ImmutableMap.nthKeyBefore(im,'one',2)).toBe(undefined);
expect(ImmutableMap.nthKeyBefore(im,'two',0)).toBe('two');
expect(ImmutableMap.nthKeyBefore(im,'two',1)).toBe('one');
expect(ImmutableMap.nthKeyBefore(im,'four',0)).toBe('four');
expect(ImmutableMap.nthKeyBefore(im,'four',1)).toBe('three');

expect(ImmutableMap.nthKeyAfter(im,'one',0)).toBe('one');
expect(ImmutableMap.nthKeyAfter(im,'one',1)).toBe('two');
expect(ImmutableMap.nthKeyAfter(im,'one',2)).toBe('three');
expect(ImmutableMap.nthKeyAfter(im,'two',0)).toBe('two');
expect(ImmutableMap.nthKeyAfter(im,'two',1)).toBe('three');
expect(ImmutableMap.nthKeyAfter(im,'four',0)).toBe('four');
expect(ImmutableMap.nthKeyAfter(im,'four',1)).toBe(undefined);}

var im=ImmutableMap.fromArray([
{uniqueID:'one',val:'first'},
{uniqueID:'two',val:'second'},
{uniqueID:'three',val:'third'},
{uniqueID:'four',val:'fourth'}],
extractUniqueID);
validateImmutableMap(im);
var imFromObject=ImmutableMap.create({
'one':'first',
'two':'second',
'three':'third',
'four':'fourth'});

validateImmutableMap(imFromObject);});


testDevAndProd('should compute key indices correctly',function(){
function validate(im){
expect(ImmutableMap.keyAtIndex(im,0)).toBe('one');
expect(ImmutableMap.keyAtIndex(im,1)).toBe('two');
expect(ImmutableMap.keyAtIndex(im,2)).toBe(undefined);
expect(ImmutableMap.indexOfKey(im,'one')).toBe(0);
expect(ImmutableMap.indexOfKey(im,'two')).toBe(1);
expect(ImmutableMap.indexOfKey(im,'nope')).toBe(undefined);
expect(function(){
ImmutableMap.indexOfKey(im,null);}).
toThrow();
expect(function(){
ImmutableMap.indexOfKey(im,undefined);}).
toThrow();
expect(function(){
ImmutableMap.indexOfKey(im,'');}).
toThrow();}

var im=ImmutableMap.fromArray([
{uniqueID:'one',val:'first'},
{uniqueID:'two',val:'second'}],
extractUniqueID);
validate(im);
var im2=ImmutableMap.create({
'one':{val:'first'},
'two':{val:'second'}});

validate(im2);});


testDevAndProd('should fail on array that extracted numeric ids',function(){
expect(function(){
ImmutableMap.fromArray(hasZeroStringKey,extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray(hasAllNumericStringKeys,extractUniqueID);}).
toThrow();
expect(function(){
ImmutableMap.fromArray(hasAllNumericKeys,extractUniqueID);}).
toThrow();});


testDevAndProd('should compute indices on mutually exclusive merge',function(){

function validate(res){
expect(ImmutableMap.size(res)).toBe(3);

expect(ImmutableMap.keyAtIndex(res,0)).toBe('one');
expect(ImmutableMap.keyAtIndex(res,1)).toBe('two');
expect(ImmutableMap.keyAtIndex(res,2)).toBe('three');
expect(ImmutableMap.keyAtIndex(res,3)).toBe(undefined);

expect(ImmutableMap.indexOfKey(res,'one')).toBe(0);
expect(ImmutableMap.indexOfKey(res,'two')).toBe(1);
expect(ImmutableMap.indexOfKey(res,'three')).toBe(2);
expect(ImmutableMap.indexOfKey(res,'dog')).toBe(undefined);

expect(ImmutableMap.has(res,'one')).toBe(true);
expect(ImmutableMap.has(res,'two')).toBe(true);
expect(ImmutableMap.has(res,'three')).toBe(true);
expect(ImmutableMap.has(res,'dog')).toBe(false);

expect(ImmutableMap.get(res,'one').val).toBe('first');
expect(ImmutableMap.get(res,'two').val).toBe('second');
expect(ImmutableMap.get(res,'three').val).toBe('third');
expect(ImmutableMap.get(res,'dog')).toBe(undefined);}


var im=ImmutableMap.fromArray([
{uniqueID:'one',val:'first'},
{uniqueID:'two',val:'second'}],
extractUniqueID);
var im2=ImmutableMap.fromArray([
{uniqueID:'three',val:'third'}],
extractUniqueID);
var im_=ImmutableMap.create({
'one':{val:'first'},
'two':{val:'second'}});

var im2_=ImmutableMap.create({
'three':{val:'third'}});

validate(ImmutableMap.set(im_,im2_));
validate(ImmutableMap.set(im,im2));
validate(ImmutableMap.set(im,im2_));
validate(ImmutableMap.set(im_,im2));});


testDevAndProd('should compute indices on intersected merge',function(){
var oneTwo=ImmutableMap.fromArray([
{uniqueID:'one',val:'first'},
{uniqueID:'two',val:'secondIM1'}],
extractUniqueID);
var oneTwo_=ImmutableMap.create({
'one':{val:'first'},
'two':{val:'secondIM1'}});


var twoThree=ImmutableMap.fromArray([
{uniqueID:'two',val:'secondIM2'},
{uniqueID:'three',val:'third'}],
extractUniqueID);
var twoThree_=ImmutableMap.create({
'two':{val:'secondIM2'},
'three':{val:'third'}});


var testOneTwoMergedWithTwoThree=function(res){
expect(ImmutableMap.size(res)).toBe(3);
expect(ImmutableMap.keyAtIndex(res,0)).toBe('one');
expect(ImmutableMap.keyAtIndex(res,1)).toBe('two');
expect(ImmutableMap.keyAtIndex(res,2)).toBe('three');
expect(ImmutableMap.keyAtIndex(res,3)).toBe(undefined);
expect(ImmutableMap.indexOfKey(res,'one')).toBe(0);
expect(ImmutableMap.indexOfKey(res,'two')).toBe(1);
expect(ImmutableMap.indexOfKey(res,'three')).toBe(2);
expect(ImmutableMap.indexOfKey(res,'dog')).toBe(undefined);
expect(ImmutableMap.has(res,'one')).toBe(true);
expect(ImmutableMap.has(res,'two')).toBe(true);
expect(ImmutableMap.has(res,'three')).toBe(true);
expect(ImmutableMap.has(res,'dog')).toBe(false);
expect(ImmutableMap.get(res,'one').val).toBe('first');
expect(ImmutableMap.get(res,'two').val).toBe('secondIM2');
expect(ImmutableMap.get(res,'three').val).toBe('third');
expect(ImmutableMap.get(res,'dog')).toBe(undefined);};


testOneTwoMergedWithTwoThree(ImmutableMap.set(oneTwo,twoThree));
testOneTwoMergedWithTwoThree(ImmutableMap.set(oneTwo_,twoThree));
testOneTwoMergedWithTwoThree(ImmutableMap.set(oneTwo,twoThree_));
testOneTwoMergedWithTwoThree(ImmutableMap.set(oneTwo_,twoThree_));



var testTwoThreeMergedWithOneTwo=function(res){
expect(ImmutableMap.size(res)).toBe(3);
expect(ImmutableMap.keyAtIndex(res,0)).toBe('two');
expect(ImmutableMap.keyAtIndex(res,1)).toBe('three');
expect(ImmutableMap.keyAtIndex(res,2)).toBe('one');
expect(ImmutableMap.keyAtIndex(res,3)).toBe(undefined);
expect(ImmutableMap.indexOfKey(res,'two')).toBe(0);
expect(ImmutableMap.indexOfKey(res,'three')).toBe(1);
expect(ImmutableMap.indexOfKey(res,'one')).toBe(2);
expect(ImmutableMap.indexOfKey(res,'cat')).toBe(undefined);
expect(ImmutableMap.has(res,'two')).toBe(true);
expect(ImmutableMap.has(res,'three')).toBe(true);
expect(ImmutableMap.has(res,'one')).toBe(true);
expect(ImmutableMap.has(res,'dog')).toBe(false);
expect(ImmutableMap.get(res,'one').val).toBe('first');
expect(ImmutableMap.get(res,'two').val).toBe('secondIM1');
expect(ImmutableMap.get(res,'three').val).toBe('third');
expect(ImmutableMap.get(res,'dog')).toBe(undefined);};

testTwoThreeMergedWithOneTwo(ImmutableMap.set(twoThree,oneTwo));
testTwoThreeMergedWithOneTwo(ImmutableMap.set(twoThree_,oneTwo));
testTwoThreeMergedWithOneTwo(ImmutableMap.set(twoThree,oneTwo_));
testTwoThreeMergedWithOneTwo(ImmutableMap.set(twoThree_,oneTwo_));});



testDevAndProd('should merge mutually exclusive keys to the end.',function(){
var im=ImmutableMap.fromArray([
{uniqueID:'one',val:'first'},
{uniqueID:'two',val:'second'}],
extractUniqueID);
var im2=ImmutableMap.fromArray([
{uniqueID:'three',val:'third'},
{uniqueID:'four',val:'fourth'}],
extractUniqueID);
var im_=ImmutableMap.create({
'one':{val:'first'},
'two':{val:'second'}});

var im2_=ImmutableMap.create({
'three':{val:'third'},
'four':{val:'fourth'}});

expect(ImmutableMap.size(ImmutableMap.set(im,im2))).toBe(4);
expect(ImmutableMap.valueAtIndex(ImmutableMap.set(im,im2),3).val).toBe('fourth');

expect(ImmutableMap.size(ImmutableMap.set(im_,im2))).toBe(4);
expect(ImmutableMap.valueAtIndex(ImmutableMap.set(im_,im2),3).val).toBe('fourth');

expect(ImmutableMap.size(ImmutableMap.set(im,im2_))).toBe(4);
expect(ImmutableMap.valueAtIndex(ImmutableMap.set(im,im2_),3).val).toBe('fourth');

expect(ImmutableMap.size(ImmutableMap.set(im_,im2_))).toBe(4);
expect(ImmutableMap.valueAtIndex(ImmutableMap.set(im_,im2_),3).val).toBe('fourth');});


testDevAndProd('should map correctly',function(){
var im=ImmutableMap.fromArray([
{uniqueID:'x',val:'xx'},
{uniqueID:'y',val:'yy'},
{uniqueID:'z',val:'zz'}],
extractUniqueID);
var im_=ImmutableMap.create({
'x':{uniqueID:'x',val:'xx'},
'y':{uniqueID:'y',val:'yy'},
'z':{uniqueID:'z',val:'zz'}});

var scope={justToTestScope:'justTestingScope'};
var verifyResult=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(3);
expect(ImmutableMap.keyAtIndex(omResult,0)).toBe('x');
expect(ImmutableMap.keyAtIndex(omResult,1)).toBe('y');
expect(ImmutableMap.keyAtIndex(omResult,2)).toBe('z');
expect(ImmutableMap.get(omResult,'x').val).toBe('xxx0justTestingScope');
expect(ImmutableMap.get(omResult,'y').val).toBe('yyy1justTestingScope');
expect(ImmutableMap.get(omResult,'z').val).toBe('zzz2justTestingScope');};

var mapper=function(itm,key,count){
return {
uniqueID:itm.uniqueID,
val:itm.val+key+count+this.justToTestScope};};


var resultIM=ImmutableMap.map(im,mapper,scope);
verifyResult(resultIM);
var resultIM_=ImmutableMap.map(im_,mapper,scope);
verifyResult(resultIM_);

var forEacher=function(itm,key,count){
resArray.push({
uniqueID:itm.uniqueID,
val:itm.val+key+count+this.justToTestScope});};


var resArray=[];
ImmutableMap.forEach(im,forEacher,scope);
resultIM=ImmutableMap.fromArray(resArray,extractUniqueID);
verifyResult(resultIM);

resArray=[];
ImmutableMap.forEach(im_,forEacher,scope);
resultIM_=ImmutableMap.fromArray(resArray,extractUniqueID);
verifyResult(resultIM_);});


testDevAndProd('should filter correctly',function(){
var im=ImmutableMap.fromArray([
{uniqueID:'x',val:'xx'},
{uniqueID:'y',val:'yy'},
{uniqueID:'z',val:'zz'}],
extractUniqueID);
var im_=ImmutableMap.create({
'x':{val:'xx'},
'y':{val:'yy'},
'z':{val:'zz'}});

var scope={justToTestScope:'justTestingScope'};

var filteringCallback=function(item,key,indexInOriginal){
expect(this).toBe(scope);
expect(key==='x'||key==='y'||key==='z').toBe(true);
if(key==='x'){
expect(item.val).toBe('xx');
expect(indexInOriginal).toBe(0);
return false;}else 
if(key==='y'){
expect(item.val).toBe('yy');
expect(indexInOriginal).toBe(1);
return true;}else 
{
expect(item.val).toBe('zz');
expect(indexInOriginal).toBe(2);
return true;}};



var verifyResult=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(2);
expect(ImmutableMap.keyAtIndex(omResult,0)).toBe('y');
expect(ImmutableMap.keyAtIndex(omResult,1)).toBe('z');
expect(ImmutableMap.has(omResult,'x')).toBe(false);
expect(ImmutableMap.has(omResult,'z')).toBe(true);
expect(ImmutableMap.get(omResult,'z').val).toBe('zz');
expect(ImmutableMap.has(omResult,'y')).toBe(true);
expect(ImmutableMap.get(omResult,'y').val).toBe('yy');};


var resultIM=ImmutableMap.filter(im,filteringCallback,scope);
verifyResult(resultIM);
var resultIM_=ImmutableMap.filter(im_,filteringCallback,scope);
verifyResult(resultIM_);});


testDevAndProd('should throw when providing invalid ranges to ranging',function(){
var im=ImmutableMap.fromArray([
{uniqueID:'x',val:'xx'},
{uniqueID:'y',val:'yy'},
{uniqueID:'z',val:'zz'}],
extractUniqueID);
var im_=ImmutableMap.create({
'x':{val:'xx'},
'y':{val:'yy'},
'z':{val:'zz'}});

var scope={justToTestScope:'justTestingScope'};

function validate(im){
expect(function(){
ImmutableMap.mapRange(im,duplicate,0,3,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,0,3,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,0,3,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'x',3,scope);}).
toThrowError(
'invalid key for ImmutableMap');

expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'x',3,scope);}).
toThrowError(
'invalid key for ImmutableMap');


expect(function(){
ImmutableMap.mapRange(im,duplicate,0,4,scope);}).
toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,0,4,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,0,4,scope);}).
toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'x',null,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'x',null,scope);}).
toThrow();

expect(function(){
ImmutableMap.mapRange(im,duplicate,-1,1,scope);}).
toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,-1,1,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,-1,1,scope);}).
toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,null,'y',scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,null,'y',scope);}).
toThrow();

expect(function(){
ImmutableMap.mapRange(im,duplicate,0,0,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,0,0,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,0,0,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'x','x',scope);}).
not.toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'x','x',scope);}).
not.toThrow();

expect(function(){
ImmutableMap.mapRange(im,duplicate,0,-1,scope);}).
toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,0,-1,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,0,-1,scope);}).
toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'x',null,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'x',null,scope);}).
toThrow();

expect(function(){
ImmutableMap.mapRange(im,duplicate,2,1,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,2,1,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,2,1,scope);}).
not.toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'z','z',scope);}).
not.toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'z','z',scope);}).
not.toThrow();

expect(function(){
ImmutableMap.mapRange(im,duplicate,2,2,scope);}).
toThrow();
expect(function(){
ImmutableMap.filterRange(im,duplicate,2,2,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachRange(im,duplicate,2,2,scope);}).
toThrow();
expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'z',null,scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'z',null,scope);}).
toThrow();


expect(function(){
ImmutableMap.mapKeyRange(im,duplicate,'y','x',scope);}).
toThrow();
expect(function(){
ImmutableMap.forEachKeyRange(im,duplicate,'y','x',scope);}).
toThrow();}

validate(im);
validate(im_);});




testDevAndProd('should map range correctly',function(){
var im=ImmutableMap.fromArray([
{uniqueID:'x',val:'xx'},
{uniqueID:'y',val:'yy'},
{uniqueID:'z',val:'zz'}],
extractUniqueID);
var im_=ImmutableMap.create({
'x':{uniqueID:'x',val:'xx'},
'y':{uniqueID:'y',val:'yy'},
'z':{uniqueID:'z',val:'zz'}});

var scope={justToTestScope:'justTestingScope'};
var verifyThreeItems=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(3);
expect(ImmutableMap.keyAtIndex(omResult,0)).toBe('x');
expect(ImmutableMap.keyAtIndex(omResult,1)).toBe('y');
expect(ImmutableMap.keyAtIndex(omResult,2)).toBe('z');
expect(ImmutableMap.get(omResult,'x').val).toBe('xxx0justTestingScope');
expect(ImmutableMap.get(omResult,'y').val).toBe('yyy1justTestingScope');
expect(ImmutableMap.get(omResult,'z').val).toBe('zzz2justTestingScope');};

var verifyFirstTwoItems=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(2);
expect(ImmutableMap.keyAtIndex(omResult,0)).toBe('x');
expect(ImmutableMap.keyAtIndex(omResult,1)).toBe('y');
expect(ImmutableMap.get(omResult,'x').val).toBe('xxx0justTestingScope');
expect(ImmutableMap.get(omResult,'y').val).toBe('yyy1justTestingScope');};


var verifyLastTwoItems=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(2);
expect(ImmutableMap.keyAtIndex(omResult,0)).toBe('y');
expect(ImmutableMap.keyAtIndex(omResult,1)).toBe('z');
expect(ImmutableMap.get(omResult,'y').val).toBe('yyy1justTestingScope');
expect(ImmutableMap.get(omResult,'z').val).toBe('zzz2justTestingScope');};


var verifyMiddleItem=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(1);
expect(ImmutableMap.keyAtIndex(omResult,0)).toBe('y');
expect(ImmutableMap.get(omResult,'y').val).toBe('yyy1justTestingScope');};


var verifyEmpty=function(omResult){
expect(ImmutableMap.size(omResult)).toBe(0);};


test(im);
test(im_);
function test(im){
var omResultThree=ImmutableMap.mapRange(im,duplicate,0,3,scope);
verifyThreeItems(omResultThree);
var resArray=[];
var pushToResArray=function(itm,key,count){
resArray.push({
uniqueID:itm.uniqueID,
val:itm.val+key+count+this.justToTestScope});};



ImmutableMap.forEachRange(im,pushToResArray,0,3,scope);
omResultThree=ImmutableMap.fromArray(resArray,extractUniqueID);
verifyThreeItems(omResultThree);

var omResultFirstTwo=ImmutableMap.mapRange(im,duplicate,0,2,scope);
verifyFirstTwoItems(omResultFirstTwo);
resArray=[];
ImmutableMap.forEachRange(im,pushToResArray,0,2,scope);
omResultFirstTwo=ImmutableMap.fromArray(resArray,extractUniqueID);
verifyFirstTwoItems(omResultFirstTwo);

var omResultLastTwo=ImmutableMap.mapRange(im,duplicate,1,2,scope);
verifyLastTwoItems(omResultLastTwo);
resArray=[];
ImmutableMap.forEachRange(im,pushToResArray,1,2,scope);
omResultLastTwo=ImmutableMap.fromArray(resArray,extractUniqueID);
verifyLastTwoItems(omResultLastTwo);

var omResultMiddle=ImmutableMap.mapRange(im,duplicate,1,1,scope);
verifyMiddleItem(omResultMiddle);
resArray=[];
ImmutableMap.forEachRange(im,pushToResArray,1,1,scope);
omResultMiddle=ImmutableMap.fromArray(resArray,extractUniqueID);
verifyMiddleItem(omResultMiddle);

var omResultNone=ImmutableMap.mapRange(im,duplicate,1,0,scope);
verifyEmpty(omResultNone);}});});