'use strict';


























jest.
autoMockOff().
mock('ErrorUtils');



function assetStringNotEmpty(str){
expect(!!str&&typeof str==='string').toBe(true);}


describe('NavigationLegacyNavigatorRouteStack:',function(){

var ROUTES=[
'foo',
1,
true,
{foo:'bar'},
['foo']];



it('gets index',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c']);
expect(stack.index).toBe(1);});


it('gets size',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c']);
expect(stack.size).toBe(3);});


it('gets route',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b','c']);
expect(stack.get(2)).toBe('c');});


it('converts to an array',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
expect(stack.toArray()).toEqual(['a','b']);});


it('creates a new stack after mutation',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
var stack2=stack1.push('c');
expect(stack1).not.toBe(stack2);});


it('throws at index out of bound',function(){
expect(function(){
new (require('NavigationLegacyNavigatorRouteStack'))(-1,['a','b']);}).
toThrow();

expect(function(){
new (require('NavigationLegacyNavigatorRouteStack'))(100,['a','b']);}).
toThrow();});


it('finds index',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
expect(stack.indexOf('b')).toBe(1);
expect(stack.indexOf('c')).toBe(-1);});



it('gets key for route',function(){
var test=function(route){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a']);
var key=stack.push(route).keyOf(route);
expect(typeof key).toBe('string');
expect(!!key).toBe(true);};


ROUTES.forEach(test);});


it('gets a key of larger value for route',function(){
var lastKey='';
var test=function(route){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a']);
var key=stack.push(route).keyOf(route);
expect(key>lastKey).toBe(true);
lastKey=key;};


ROUTES.forEach(test);});


it('gets an unique key for a different route',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a']);
var keys={};

var test=function(route){
stack=stack.push(route);
var key=stack.keyOf(route);
expect(keys[key]).toBe(undefined);
keys[key]=true;};


ROUTES.forEach(test);});


it('gets the same unique key for the same route',function(){
var test=function(route){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,[route]);
expect(stack.keyOf(route)).toBe(stack.keyOf(route));};


ROUTES.forEach(test);});



it('gets the same unique key form the derived stack',function(){
var test=function(route){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,[route]);
var derivedStack=stack.push('wow').pop().slice(0,10).push('blah');
expect(derivedStack.keyOf(route)).toBe(stack.keyOf(route));};


ROUTES.forEach(test);});


it('gets a different key from a different stack',function(){
var test=function(route){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(0,[route]);
var stack2=new (require('NavigationLegacyNavigatorRouteStack'))(0,[route]);
expect(stack1.keyOf(route)).not.toBe(stack2.keyOf(route));};


ROUTES.forEach(test);});


it('gets no key for a route that does not contains this route',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a']);
expect(stack.keyOf('b')).toBe(null);});


it('gets a new key for a route that was removed and added again',function(){
var test=function(route){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a']);

var key1=stack.push(route).keyOf(route);
var key2=stack.push(route).pop().push(route).keyOf(route);
expect(key1).not.toBe(key2);};


ROUTES.forEach(test);});



it('slices',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c','d']);
var stack2=stack1.slice(1,3);
expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['b','c']);});


it('may update index after slicing',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(2,['a','b','c']);
expect(stack.slice().index).toBe(2);
expect(stack.slice(0,1).index).toBe(0);
expect(stack.slice(0,2).index).toBe(1);
expect(stack.slice(0,3).index).toBe(2);
expect(stack.slice(0,100).index).toBe(2);
expect(stack.slice(-2).index).toBe(1);});


it('slices without specifying params',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c']);
var stack2=stack1.slice();
expect(stack2).toBe(stack1);});


it('slices to from the end',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c','d']);
var stack2=stack1.slice(-2);
expect(stack2.toArray()).toEqual(['c','d']);});


it('throws when slicing to empty',function(){
expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.slice(100);}).
toThrow();});



it('pushes route',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
var stack2=stack1.push('c');

expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['a','b','c']);
expect(stack2.index).toBe(2);
expect(stack2.size).toBe(3);});


it('throws when pushing empty route',function(){
expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.push(null);}).
toThrow();

expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.push('');}).
toThrow();

expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.push(undefined);}).
toThrow();});


it('replaces routes on push',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c']);
var stack2=stack1.push('d');
expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['a','b','d']);
expect(stack2.index).toBe(2);});



it('pops route',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(2,['a','b','c']);
var stack2=stack1.pop();
expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['a','b']);
expect(stack2.index).toBe(1);
expect(stack2.size).toBe(2);});


it('replaces routes on pop',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b','c']);
var stack2=stack1.pop();
expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['a']);
expect(stack2.index).toBe(0);});


it('throws when popping to empty stack',function(){
expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a']);
stack.pop();}).
toThrow();});



it('jumps to index',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b','c']);
var stack2=stack1.jumpToIndex(2);

expect(stack2).not.toBe(stack1);
expect(stack2.index).toBe(2);});


it('throws then jumping to index out of bound',function(){
expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.jumpToIndex(2);}).
toThrow();

expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.jumpToIndex(-1);}).
toThrow();});



it('replaces route at index',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
var stack2=stack1.replaceAtIndex(0,'x');

expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['x','b']);
expect(stack2.index).toBe(0);});


it('replaces route at negative index',function(){
var stack1=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
var stack2=stack1.replaceAtIndex(-1,'x');

expect(stack2).not.toBe(stack1);
expect(stack2.toArray()).toEqual(['a','x']);
expect(stack2.index).toBe(1);});


it('throws when replacing empty route',function(){
expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.replaceAtIndex(1,null);}).
toThrow();});


it('throws when replacing at index out of bound',function(){
expect(function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(1,['a','b']);
stack.replaceAtIndex(100,'x');}).
toThrow();});



it('iterates each item',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
var logs=[];
var keys={};
var context={name:'yo'};

stack.forEach(function(route,index,key){
assetStringNotEmpty(key);
if(!keys.hasOwnProperty(key)){
keys[key]=true;
logs.push([
route,
index,
this.name]);}},


context);

expect(logs).toEqual([
['a',0,'yo'],
['b',1,'yo']]);});



it('Maps to an array',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
var keys={};
var context={name:'yo'};

var logs=stack.mapToArray(function(route,index,key){
assetStringNotEmpty(key);
if(!keys.hasOwnProperty(key)){
keys[key]=true;
return [
route,
index,
this.name];}},


context);

expect(logs).toEqual([
['a',0,'yo'],
['b',1,'yo']]);});




it('coverts to navigation state',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
var state=stack.toNavigationState();
expect(state).toEqual({
index:0,
key:'0',
children:[
{key:'0',route:'a'},
{key:'1',route:'b'}]});});




it('coverts from navigation state',function(){
var stack=new (require('NavigationLegacyNavigatorRouteStack'))(0,['a','b']);
var state=stack.toNavigationState().children[0];
var route=require('NavigationLegacyNavigatorRouteStack').getRouteByNavigationState(state);
expect(route).toBe('a');});});