'use strict';











































































var containerContextTypes={
relay:require('RelayPropTypes').Environment,
route:require('RelayPropTypes').QueryConfig.isRequired};















function createContainerComponent(
Component,
spec)
{
var componentName=Component.displayName||Component.name;
var containerName='Relay('+componentName+')';

var fragments=spec.fragments;
var fragmentNames=Object.keys(fragments);
var initialVariables=spec.initialVariables||{};
var prepareVariables=spec.prepareVariables;var 

RelayContainer=function(_React$Component){babelHelpers.inherits(RelayContainer,_React$Component);















function RelayContainer(props,context){babelHelpers.classCallCheck(this,RelayContainer);var _this=babelHelpers.possibleConstructorReturn(this,Object.getPrototypeOf(RelayContainer).call(this,
props,context));var 

relay=context.relay;var route=context.route;
!
require('isRelayEnvironment')(relay)?require('invariant')(0,
'RelayContainer: `%s` was rendered with invalid Relay context `%s`. '+
'Make sure the `relay` property on the React context conforms to the '+
'`RelayEnvironment` interface.',
containerName,
relay):undefined;

!(
route&&typeof route.name==='string')?require('invariant')(0,
'RelayContainer: `%s` was rendered without a valid route. Make sure '+
'the route is valid, and make sure that it is correctly set on the '+
'parent component\'s context (e.g. using <RelayRootContainer>).',
containerName):undefined;


_this.forceFetch=_this.forceFetch.bind(_this);
_this.getPendingTransactions=_this.getPendingTransactions.bind(_this);
_this.hasFragmentData=_this.hasFragmentData.bind(_this);
_this.hasOptimisticUpdate=_this.hasOptimisticUpdate.bind(_this);
_this.hasPartialData=_this.hasPartialData.bind(_this);
_this.setVariables=_this.setVariables.bind(_this);

_this.$RelayContainer_didShowFakeDataWarning=false;
_this.$RelayContainer_fragmentPointers={};
_this.$RelayContainer_hasStaleQueryData=false;
_this.$RelayContainer_fragmentResolvers={};

_this.mounted=true;
_this.pending=null;
_this.state={
variables:{},
queryData:{}};return _this;}babelHelpers.createClass(RelayContainer,[{key:'setVariables',value:function setVariables(









partialVariables,
callback)
{
this.$RelayContainer_runVariables(partialVariables,callback,false);}},{key:'forceFetch',value:function forceFetch(








partialVariables,
callback)
{
this.$RelayContainer_runVariables(partialVariables,callback,true);}},{key:'$RelayContainer_createQuerySetAndFragmentPointers',value:function $RelayContainer_createQuerySetAndFragmentPointers(








variables)


{var _this2=this;
var fragmentPointers={};
var querySet={};
var storeData=this.context.relay.getStoreData();
fragmentNames.forEach(function(fragmentName){
var fragment=
getFragment(fragmentName,_this2.context.route,variables);
var queryData=_this2.state.queryData[fragmentName];
if(!fragment||queryData==null){
return;}


var fragmentPointer=undefined;
if(fragment.isPlural()){(function(){
!
Array.isArray(queryData)?require('invariant')(0,
'RelayContainer: Invalid queryData for `%s`, expected an array '+
'of records because the corresponding fragment is plural.',
fragmentName):undefined;

var dataIDs=[];
queryData.forEach(function(data,ii){
var dataID=require('RelayRecord').getDataID(data);
if(dataID){
querySet[fragmentName+ii]=
storeData.buildFragmentQueryForDataID(fragment,dataID);
dataIDs.push(dataID);}});


if(dataIDs.length){
fragmentPointer={fragment:fragment,dataIDs:dataIDs};}})();}else 

{


var dataID=require('RelayRecord').getDataID(queryData);
if(dataID){
fragmentPointer={
fragment:fragment,
dataIDs:dataID};

querySet[fragmentName]=
storeData.buildFragmentQueryForDataID(fragment,dataID);}}



fragmentPointers[fragmentName]=fragmentPointer;});

return {fragmentPointers:fragmentPointers,querySet:querySet};}},{key:'$RelayContainer_runVariables',value:function $RelayContainer_runVariables(



partialVariables,
callback,
forceFetch)
{var _this3=this;
var lastVariables=this.state.variables;
var prevVariables=
this.pending?this.pending.variables:lastVariables;
var nextVariables=mergeVariables(prevVariables,partialVariables);

this.pending&&this.pending.request.abort();

var completeProfiler=require('RelayProfiler').profile(
'RelayContainer.setVariables',{
containerName:containerName,
nextVariables:nextVariables});






var querySet={};
var fragmentPointers=null;
if(forceFetch||!require('shallowEqual')(nextVariables,lastVariables)){var _$RelayContainer_crea=

this.$RelayContainer_createQuerySetAndFragmentPointers(nextVariables);querySet=_$RelayContainer_crea.querySet;fragmentPointers=_$RelayContainer_crea.fragmentPointers;}


var onReadyStateChange=require('ErrorUtils').guard(function(readyState){var 
aborted=readyState.aborted;var done=readyState.done;var error=readyState.error;var ready=readyState.ready;
var isComplete=aborted||done||error;
if(isComplete&&_this3.pending===current){
_this3.pending=null;}

var partialState=undefined;
if(ready&&fragmentPointers){



_this3.$RelayContainer_fragmentPointers=fragmentPointers;
_this3.$RelayContainer_updateFragmentResolvers(_this3.context.relay);
var _queryData=_this3.$RelayContainer_getQueryData(_this3.props);
partialState={variables:nextVariables,queryData:_queryData};}else 
{
partialState={};}

var mounted=_this3.mounted;
if(mounted){(function(){
var updateProfiler=require('RelayProfiler').profile('RelayContainer.update');
require('relayUnstableBatchedUpdates')(function(){
_this3.setState(partialState,function(){
updateProfiler.stop();
if(isComplete){
completeProfiler.stop();}});


if(callback){
callback.call(
_this3.refs.component||null,babelHelpers.extends({},
readyState,{mounted:mounted}));}});})();}else 



{
if(callback){
callback(babelHelpers.extends({},readyState,{mounted:mounted}));}

if(isComplete){
completeProfiler.stop();}}},


'RelayContainer.onReadyStateChange');

var current={
variables:nextVariables,
request:forceFetch?
this.context.relay.forceFetch(querySet,onReadyStateChange):
this.context.relay.primeCache(querySet,onReadyStateChange)};

this.pending=current;}},{key:'hasOptimisticUpdate',value:function hasOptimisticUpdate(






record)
{
var dataID=require('RelayRecord').getDataID(record);
!(
dataID!=null)?require('invariant')(0,
'RelayContainer.hasOptimisticUpdate(): Expected a record in `%s`.',
componentName):undefined;

return this.context.relay.getStoreData().hasOptimisticUpdate(dataID);}},{key:'getPendingTransactions',value:function getPendingTransactions(





record){
var dataID=require('RelayRecord').getDataID(record);
!(
dataID!=null)?require('invariant')(0,
'RelayContainer.getPendingTransactions(): Expected a record in `%s`.',
componentName):undefined;

var storeData=this.context.relay.getStoreData();
var mutationIDs=storeData.getClientMutationIDs(dataID);
if(!mutationIDs){
return null;}

var mutationQueue=storeData.getMutationQueue();
return mutationIDs.map(function(id){return mutationQueue.getTransaction(id);});}},{key:'hasFragmentData',value:function hasFragmentData(








fragmentReference,
record)
{
var storeData=this.context.relay.getStoreData();
if(!storeData.getPendingQueryTracker().hasPendingQueries()){

return true;}


var dataID=require('RelayRecord').getDataID(record);
!(
dataID!=null)?require('invariant')(0,
'RelayContainer.hasFragmentData(): Second argument is not a valid '+
'record. For `<%s X={this.props.X} />`, use '+
'`this.props.hasFragmentData(%s.getFragment(\'X\'), this.props.X)`.',
componentName,
componentName):undefined;

var fragment=getDeferredFragment(
fragmentReference,
this.context,
this.state.variables);

!(
fragment instanceof require('RelayQuery').Fragment)?require('invariant')(0,
'RelayContainer.hasFragmentData(): First argument is not a valid '+
'fragment. Ensure that there are no failing `if` or `unless` '+
'conditions.'):undefined;

return storeData.getCachedStore().hasDeferredFragmentData(
dataID,
fragment.getCompositeHash());}},{key:'hasPartialData',value:function hasPartialData(







record)
{
return require('RelayRecordStatusMap').isPartialStatus(
record[require('RelayRecord').MetadataKey.STATUS]);}},{key:'componentWillMount',value:function componentWillMount()



{var _context=
this.context;var relay=_context.relay;var route=_context.route;
if(route.useMockData){
return;}

this.setState(
this.$RelayContainer_initialize(
this.props,
relay,
route,
initialVariables));}},{key:'componentWillReceiveProps',value:function componentWillReceiveProps(





nextProps,
nextContext)
{var _this4=this;var _nullthrows=
require('nullthrows')(nextContext);var relay=_nullthrows.relay;var route=_nullthrows.route;
if(route.useMockData){
return;}

this.setState(function(state){
if(_this4.context.relay!==relay){
_this4.$RelayContainer_cleanup();}

return _this4.$RelayContainer_initialize(
nextProps,
relay,
route,
resetPropOverridesForVariables(spec,nextProps,state.variables));});}},{key:'componentWillUnmount',value:function componentWillUnmount()




{
this.$RelayContainer_cleanup();
this.mounted=false;}},{key:'$RelayContainer_initialize',value:function $RelayContainer_initialize(



props,
environment,
route,
prevVariables)
{
var variables=getVariablesWithPropOverrides(
spec,
props,
prevVariables);

this.$RelayContainer_updateFragmentPointers(props,route,variables);
this.$RelayContainer_updateFragmentResolvers(environment);
return {
variables:variables,
queryData:this.$RelayContainer_getQueryData(props)};}},{key:'$RelayContainer_cleanup',value:function $RelayContainer_cleanup()



{

if(this.$RelayContainer_fragmentResolvers){
require('forEachObject')(
this.$RelayContainer_fragmentResolvers,
function(fragmentResolver){return fragmentResolver&&fragmentResolver.dispose();});}



this.$RelayContainer_fragmentPointers={};
this.$RelayContainer_fragmentResolvers={};

var pending=this.pending;
if(pending){
pending.request.abort();
this.pending=null;}}},{key:'$RelayContainer_updateFragmentResolvers',value:function $RelayContainer_updateFragmentResolvers(



environment){var _this5=this;
var fragmentPointers=this.$RelayContainer_fragmentPointers;
var fragmentResolvers=this.$RelayContainer_fragmentResolvers;
fragmentNames.forEach(function(fragmentName){
var fragmentPointer=fragmentPointers[fragmentName];
var fragmentResolver=fragmentResolvers[fragmentName];
if(!fragmentPointer){
if(fragmentResolver){
fragmentResolver.dispose();
fragmentResolvers[fragmentName]=null;}}else 

if(!fragmentResolver){
fragmentResolver=environment.getFragmentResolver(
fragmentPointer.fragment,
_this5.$RelayContainer_handleFragmentDataUpdate.bind(_this5));

fragmentResolvers[fragmentName]=fragmentResolver;}});}},{key:'$RelayContainer_handleFragmentDataUpdate',value:function $RelayContainer_handleFragmentDataUpdate()




{
if(!this.mounted){
return;}

var queryData=this.$RelayContainer_getQueryData(this.props);
var updateProfiler=require('RelayProfiler').profile(
'RelayContainer.handleFragmentDataUpdate');

this.setState({queryData:queryData},updateProfiler.stop);}},{key:'$RelayContainer_updateFragmentPointers',value:function $RelayContainer_updateFragmentPointers(



props,
route,
variables)
{var _this6=this;
var fragmentPointers=this.$RelayContainer_fragmentPointers;
fragmentNames.forEach(function(fragmentName){
var propValue=props[fragmentName];
require('warning')(
propValue!==undefined,
'RelayContainer: Expected prop `%s` to be supplied to `%s`, but '+
'got `undefined`. Pass an explicit `null` if this is intentional.',
fragmentName,
componentName);

if(propValue==null){
fragmentPointers[fragmentName]=null;
return;}


if(typeof propValue!=='object'){
require('warning')(
false,
'RelayContainer: Expected prop `%s` supplied to `%s` to be an '+
'object, got `%s`.',
fragmentName,
componentName,
propValue);

fragmentPointers[fragmentName]=null;
return;}

var fragment=getFragment(fragmentName,route,variables);
var dataIDOrIDs=undefined;

if(fragment.isPlural()){var _ret3=function(){



!
Array.isArray(propValue)?require('invariant')(0,
'RelayContainer: Invalid prop `%s` supplied to `%s`, expected an '+
'array of records because the corresponding fragment has '+
'`@relay(plural: true)`.',
fragmentName,
componentName):undefined;

if(!propValue.length){

fragmentPointers[fragmentName]=null;
return {v:undefined};}

var dataIDs=null;
propValue.forEach(function(item,ii){
if(typeof item==='object'&&item!=null){
var dataID=require('RelayFragmentPointer').getDataID(item,fragment);
if(dataID){
dataIDs=dataIDs||[];
dataIDs.push(dataID);}}});



if(dataIDs){
!(
dataIDs.length===propValue.length)?require('invariant')(0,
'RelayContainer: Invalid prop `%s` supplied to `%s`. Some '+
'array items contain data fetched by Relay and some items '+
'contain null/mock data.',
fragmentName,
componentName):undefined;}


dataIDOrIDs=dataIDs;}();if(typeof _ret3==="object")return _ret3.v;}else 
{
!
!Array.isArray(propValue)?require('invariant')(0,
'RelayContainer: Invalid prop `%s` supplied to `%s`, expected a '+
'single record because the corresponding fragment is not plural '+
'(i.e. does not have `@relay(plural: true)`).',
fragmentName,
componentName):undefined;

dataIDOrIDs=require('RelayFragmentPointer').getDataID(propValue,fragment);}

if(dataIDOrIDs==null){

if(__DEV__){
if(!route.useMockData&&!_this6.$RelayContainer_didShowFakeDataWarning){
_this6.$RelayContainer_didShowFakeDataWarning=true;
require('warning')(
false,
'RelayContainer: Expected prop `%s` supplied to `%s` to '+
'be data fetched by Relay. This is likely an error unless '+
'you are purposely passing in mock data that conforms to '+
'the shape of this component\'s fragment.',
fragmentName,
componentName);}}}




fragmentPointers[fragmentName]=dataIDOrIDs?
{fragment:fragment,dataIDs:dataIDOrIDs}:
null;});

if(__DEV__){

fragmentNames.forEach(function(fragmentName){
if(fragmentPointers[fragmentName]){
return;}

var fragment=getFragment(fragmentName,route,variables);
Object.keys(props).forEach(function(propName){
require('warning')(
fragmentPointers[propName]||
!require('RelayRecord').isRecord(props[propName])||
typeof props[propName]!=='object'||
props[propName]==null||
!require('RelayFragmentPointer').getDataID(
props[propName],
fragment),

'RelayContainer: Expected record data for prop `%s` on `%s`, '+
'but it was instead on prop `%s`. Did you misspell a prop or '+
'pass record data into the wrong prop?',
fragmentName,
componentName,
propName);});});}}},{key:'$RelayContainer_getQueryData',value:function $RelayContainer_getQueryData(







props)
{var _this7=this;
var queryData={};
var fragmentPointers=this.$RelayContainer_fragmentPointers;
require('forEachObject')(this.$RelayContainer_fragmentResolvers,function(fragmentResolver,propName){
var propValue=props[propName];
var fragmentPointer=fragmentPointers[propName];

if(!propValue||!fragmentPointer){

fragmentResolver&&fragmentResolver.dispose();

queryData[propName]=propValue;}else 
{
queryData[propName]=fragmentResolver.resolve(
fragmentPointer.fragment,
fragmentPointer.dataIDs);}


if(_this7.state.queryData.hasOwnProperty(propName)&&
queryData[propName]!==_this7.state.queryData[propName]){
_this7.$RelayContainer_hasStaleQueryData=true;}});


return queryData;}},{key:'shouldComponentUpdate',value:function shouldComponentUpdate(



nextProps,
nextState,
nextContext)
{

if(this.$RelayContainer_hasStaleQueryData){
this.$RelayContainer_hasStaleQueryData=false;
return true;}


if(this.context.relay!==nextContext.relay||
this.context.route!==nextContext.route){
return true;}


var fragmentPointers=this.$RelayContainer_fragmentPointers;
return (
!require('RelayContainerComparators').areNonQueryPropsEqual(
fragments,
this.props,
nextProps)||


fragmentPointers&&
!require('RelayContainerComparators').areQueryResultsEqual(
fragmentPointers,
this.state.queryData,
nextState.queryData)||


!require('RelayContainerComparators').areQueryVariablesEqual(
this.state.variables,
nextState.variables));}},{key:'render',value:function render()




{
var relayProps={
forceFetch:this.forceFetch,
getPendingTransactions:this.getPendingTransactions,
hasFragmentData:this.hasFragmentData,
hasOptimisticUpdate:this.hasOptimisticUpdate,
hasPartialData:this.hasPartialData,
route:this.context.route,
setVariables:this.setVariables,
variables:this.state.variables};

return (
require('React').createElement(Component,babelHelpers.extends({},
this.props,
this.state.queryData,
require('prepareRelayContainerProps')(relayProps,this),{
ref:require('isReactComponent')(Component)?'component':null})));}}]);return RelayContainer;}(require('React').Component);





function getFragment(
fragmentName,
route,
variables)
{
var fragmentBuilder=fragments[fragmentName];
!
fragmentBuilder?require('invariant')(0,
'RelayContainer: Expected `%s` to have a query fragment named `%s`.',
containerName,
fragmentName):undefined;

var fragment=buildContainerFragment(
containerName,
fragmentName,
fragmentBuilder,
initialVariables);


var metaRoute=require('RelayMetaRoute').get(route.name);
if(prepareVariables){
variables=prepareVariables(variables,metaRoute);}

return require('RelayQuery').Fragment.create(
fragment,
metaRoute,
variables);}



initializeProfiler(RelayContainer);
RelayContainer.contextTypes=containerContextTypes;
RelayContainer.displayName=containerName;
require('RelayContainerProxy').proxyMethods(RelayContainer,Component);

return RelayContainer;}





function getVariablesWithPropOverrides(
spec,
props,
variables)
{
var initialVariables=spec.initialVariables;
if(initialVariables){
var mergedVariables=undefined;
for(var _key in initialVariables){
if(_key in props){
mergedVariables=mergedVariables||babelHelpers.extends({},variables);
mergedVariables[_key]=props[_key];}}


variables=mergedVariables||variables;}

return variables;}








function resetPropOverridesForVariables(
spec,
props,
variables)
{
var initialVariables=spec.initialVariables;
for(var _key2 in initialVariables){
if(_key2 in props&&props[_key2]!==variables[_key2]){
return initialVariables;}}


return variables;}


function initializeProfiler(RelayContainer){
require('RelayProfiler').instrumentMethods(RelayContainer.prototype,{
componentWillMount:
'RelayContainer.prototype.componentWillMount',
componentWillReceiveProps:
'RelayContainer.prototype.componentWillReceiveProps',
shouldComponentUpdate:
'RelayContainer.prototype.shouldComponentUpdate'});}







function mergeVariables(
currentVariables,
partialVariables)
{
if(partialVariables){
for(var _key3 in partialVariables){
if(currentVariables[_key3]!==partialVariables[_key3]){
return babelHelpers.extends({},currentVariables,partialVariables);}}}



return currentVariables;}





function buildContainerFragment(
containerName,
fragmentName,
fragmentBuilder,
variables)
{
var fragment=require('buildRQL').Fragment(
fragmentBuilder,
variables);

!
fragment?require('invariant')(0,
'Relay.QL defined on container `%s` named `%s` is not a valid fragment. '+
'A typical fragment is defined using: Relay.QL`fragment on Type {...}`',
containerName,
fragmentName):undefined;

return fragment;}


function getDeferredFragment(
fragmentReference,
context,
variables)
{
var route=require('RelayMetaRoute').get(context.route.name);
var concreteFragment=fragmentReference.getFragment(variables);
var concreteVariables=fragmentReference.getVariables(route,variables);
return require('RelayQuery').Fragment.create(
concreteFragment,
route,
concreteVariables,
{
isDeferred:true,
isContainerFragment:fragmentReference.isContainerFragment()});}








function create(
Component,
spec)
{
var componentName=Component.displayName||Component.name;
var containerName='Relay('+componentName+')';

var fragments=spec.fragments;
!(
typeof fragments==='object'&&fragments)?require('invariant')(0,
'Relay.createContainer(%s, ...): Missing `fragments`, which is expected '+
'to be an object mapping from `propName` to: () => Relay.QL`...`',
componentName):undefined;

var fragmentNames=Object.keys(fragments);
var initialVariables=spec.initialVariables||{};
var prepareVariables=spec.prepareVariables;

var Container=undefined;
function ContainerConstructor(props,context){
if(!Container){
Container=createContainerComponent(Component,spec);}

return new Container(props,context);}


ContainerConstructor.getFragmentNames=function(){return fragmentNames;};
ContainerConstructor.hasFragment=function(fragmentName){return !!fragments[fragmentName];};
ContainerConstructor.hasVariable=function(variableName){return (
Object.prototype.hasOwnProperty.call(initialVariables,variableName));};





ContainerConstructor.getFragment=function(
fragmentName,
variableMapping)
{
var fragmentBuilder=fragments[fragmentName];
if(!fragmentBuilder){
!
false?require('invariant')(0,
'%s.getFragment(): `%s` is not a valid fragment name. Available '+
'fragments names: %s',
containerName,
fragmentName,
fragmentNames.map(function(name){return '`'+name+'`';}).join(', ')):undefined;}


!(
typeof fragmentBuilder==='function')?require('invariant')(0,
'RelayContainer: Expected `%s.fragments.%s` to be a function returning '+
'a fragment. Example: `%s: () => Relay.QL`fragment on ...`',
containerName,
fragmentName,
fragmentName):undefined;

return require('RelayFragmentReference').createForContainer(
function(){return buildContainerFragment(
containerName,
fragmentName,
fragmentBuilder,
initialVariables);},

initialVariables,
variableMapping,
prepareVariables);};



ContainerConstructor.contextTypes=containerContextTypes;
ContainerConstructor.displayName=containerName;
ContainerConstructor.moduleName=null;

return ContainerConstructor;}


module.exports={create:create};