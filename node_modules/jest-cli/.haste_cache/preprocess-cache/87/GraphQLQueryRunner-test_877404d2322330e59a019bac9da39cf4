/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};

require('configureForRelayOSS');

jest.
mock('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning').
dontMock('GraphQLQueryRunner').
dontMock('RelayTaskQueue');












describe('GraphQLQueryRunner', function () {
  var queryRunner;
  var pendingQueryTracker;

  var mockCallback;
  var mockQuerySet;var 

  defer = require('RelayTestUtils').defer;var getNode = require('RelayTestUtils').getNode;

  /**
   * Helper method, returns a clone of `query` that has been marked as
   * deferred.
   */
  function deferQuery(relayQuery) {
    var node = _extends({}, 
    relayQuery.getConcreteQueryNode(), { 
      isDeferred: true });

    return getNode(node, relayQuery.getVariables());}


  function mockSplitDeferredQueries() {
    require('splitDeferredRelayQueries').mockImplementation(
    function (query) {return { 
        required: query, 
        deferred: [] };});}




  beforeEach(function () {
    jest.resetModuleRegistry();

    require('RelayNetworkLayer').injectNetworkLayer({ 
      supports: function () {return true;} });


    var storeData = new (require('RelayStoreData'))();
    queryRunner = storeData.getQueryRunner();
    pendingQueryTracker = storeData.getPendingQueryTracker();

    mockCallback = jest.genMockFunction();
    mockQuerySet = { 
      foo: getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})()), 
      bar: getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '4' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'GraphQLQueryRunner', type: 'Node' };})()), 
      baz: null };


    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  it('immediately succeeds for empty queries', function () {
    queryRunner.run({}, mockCallback);

    expect(mockCallback).not.toBeCalled();
    jest.runAllTimers();
    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: true, error: null, ready: true, stale: false }]]);});



  it('immediately succeeds for no diff queries', function () {
    require('diffRelayQuery').mockReturnValue([]);

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    var diffQueryCalls = require('diffRelayQuery').mock.calls;
    expect(diffQueryCalls.length).toBe(2);
    expect(diffQueryCalls[0][0]).toEqualQueryNode(mockQuerySet.foo);
    expect(diffQueryCalls[1][0]).toEqualQueryNode(mockQuerySet.bar);
    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: true, error: null, ready: true, stale: false }]]);});



  it('warns and uses fallback when defer is unsupported', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    require('checkRelayQueryData').mockImplementation(function () {return false;});
    require('RelayNetworkLayer').injectNetworkLayer({ 
      supports: function () {return false;} });


    var fragment = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'EVbT04rUE3pa:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'GraphQLQueryRunnerRelayQL', type: 'Node' };})();
    var querySet = { 
      foo: getNode((function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'GraphQLQueryRunner', type: 'Node' };})(defer(fragment))) };


    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning').mockClear();
    queryRunner.run(querySet, mockCallback);
    jest.runAllTimers();

    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);
    expect(pendingQueryTracker.add.mock.calls[0][0].query).
    toBe(querySet.foo);
    expect(require('splitDeferredRelayQueries')).not.toBeCalled();
    expect(require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning').mock.calls[0]).toEqual([
    false, 
    'Relay: Query `%s` contains a deferred fragment (e.g. ' + 
    '`getFragment(\'foo\').defer()`) which is not supported by the ' + 
    'default network layer. This query will be sent without deferral.', 
    querySet.foo.getName()]);});



  it('is not ready if required data is being fetched', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    require('checkRelayQueryData').mockImplementation(function () {return false;});
    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }]]);});



  it('adds all split and diff queries to the pending query tracker', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    expect(pendingQueryTracker.add.mock.calls.length).toBe(2);
    expect(pendingQueryTracker.add.mock.calls[0][0].query).
    toEqualQueryNode(mockQuerySet.foo);
    expect(pendingQueryTracker.add.mock.calls[1][0].query).
    toEqualQueryNode(mockQuerySet.bar);});


  it('waits for all required data before being ready', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    pendingQueryTracker.add.mock.fetches[0].resolve();
    jest.runAllTimers();
    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }]]);


    pendingQueryTracker.add.mock.fetches[1].resolve();
    jest.runAllTimers();
    expect(mockCallback).lastCalledWith(
    { aborted: false, done: true, error: null, ready: true, stale: false });});



  it('throws to global if the callback throws', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    mockSplitDeferredQueries();

    var mockError = new Error('Expected callback error.');
    mockCallback.mockImplementation(function () {
      throw mockError;});


    queryRunner.run(mockQuerySet, mockCallback);
    expect(function () {
      jest.runAllTimers();}).
    toThrow(mockError);});


  it('is immediately ready for no required queries', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    // Treat all queries as deferred.
    require('splitDeferredRelayQueries').mockImplementation(function (query) {return { 
        required: null, 
        deferred: [{ 
          required: deferQuery(query), 
          deferred: [] }] };});



    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: true, stale: false }]]);});



  it('calls the callback for each deferred query', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    require('splitDeferredRelayQueries').mockImplementation(function (query) {
      if (query.getFieldName() === 'viewer') {
        return { 
          required: query, 
          deferred: [] };} else 

      {
        // Treat `mockQuerySet.bar` as deferred.
        return { 
          query: null, 
          deferred: [{ 
            required: deferQuery(query), 
            deferred: [] }] };}});





    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    pendingQueryTracker.add.mock.fetches[0].resolve();
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }], 
    [{ aborted: false, done: false, error: null, ready: true, stale: false }]]);


    pendingQueryTracker.add.mock.fetches[1].resolve();
    jest.runAllTimers();

    expect(mockCallback).lastCalledWith(
    { aborted: false, done: true, error: null, ready: true, stale: false });});



  it('calls the callback only once when completing all queries', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }]]);


    pendingQueryTracker.add.mock.fetches[0].resolve();
    pendingQueryTracker.add.mock.fetches[1].resolve();
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }], 
    [{ aborted: false, done: true, error: null, ready: true, stale: false }]]);});



  it('is done after all data is fetched', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    pendingQueryTracker.add.mock.fetches[0].resolve();
    pendingQueryTracker.add.mock.fetches[1].resolve();
    jest.runAllTimers();

    expect(mockCallback).lastCalledWith(
    { aborted: false, done: true, error: null, ready: true, stale: false });});



  it('calls the callback when aborted', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback).abort();
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: true, done: false, error: null, ready: false, stale: false }]]);});



  it('is ready if required data is in disk cache', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [query];});
    require('RelayStoreData').prototype.hasCacheManager = 
    jest.genMockFunction().mockImplementation(function () {return true;});
    require('RelayStoreData').prototype.readFromDiskCache = 
    jest.genMockFunction().mockImplementation(function (queries, callback) {
      callback.onSuccess();});

    mockSplitDeferredQueries();

    queryRunner.run(mockQuerySet, mockCallback);
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }], 
    [{ aborted: false, done: false, error: null, ready: true, stale: true }]]);});



  it('adds query on `forceFetch` even if there are no diff queries', function () {
    require('diffRelayQuery').mockImplementation(function (query) {return [];});
    mockSplitDeferredQueries();

    var singleMockQuery = { foo: mockQuerySet.foo };
    queryRunner.forceFetch(singleMockQuery, mockCallback);
    jest.runAllTimers();

    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);
    expect(pendingQueryTracker.add.mock.calls[0][0].query).
    toEqualQueryNode(singleMockQuery.foo);});


  it('is completely ready on `forceFetch` when all data is available', function () {
    require('diffRelayQuery').mockImplementation(function () {return [];});
    require('checkRelayQueryData').mockImplementation(function () {return true;});
    mockSplitDeferredQueries();
    var singleMockQuery = { foo: mockQuerySet.foo };
    queryRunner.forceFetch(singleMockQuery, mockCallback);
    jest.runAllTimers();

    expect(mockCallback.mock.calls).toEqual([
    [{ aborted: false, done: false, error: null, ready: false, stale: false }], 
    [{ aborted: false, done: false, error: null, ready: true, stale: true }]]);

    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);

    pendingQueryTracker.add.mock.fetches[0].resolve();
    jest.runAllTimers();

    expect(mockCallback).lastCalledWith(
    { aborted: false, done: true, error: null, ready: true, stale: false });});



  describe('Batch callback for multiple queries', function () {
    var runTest;
    var fetchMode;
    beforeEach(function () {
      require('diffRelayQuery').mockImplementation(function (query) {return [query];});

      var mockQuery = getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'firstName', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'lastName', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'hometown', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Page' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})());





      var mockSplitQueries = { 
        required: getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})()), 




        deferred: [(function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})(), (function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'hometown', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Page' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})(), (function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'firstName', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})(), (function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'lastName', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'GraphQLQueryRunner', type: 'Viewer' };})()].




















        map(function (query) {return { 
            required: deferQuery(getNode(query)), 
            deferred: [] };}) };



      require('splitDeferredRelayQueries').mockImplementation(function (query) {
        expect(query).toEqualQueryNode(mockQuery);
        return mockSplitQueries;});


      var resolveSplitQueryByIndex = function (index) {
        pendingQueryTracker.add.mock.fetches[index].resolve();};

      runTest = function () {
        queryRunner.run(
        { foo: mockQuery }, 
        mockCallback, 
        fetchMode);

        resolveSplitQueryByIndex(1);
        resolveSplitQueryByIndex(0);
        jest.runAllTimers();

        var defaultState = { 
          aborted: false, 
          done: false, 
          error: null, 
          ready: false, 
          stale: false };


        // Only called once after both splitQuery#0 and splitQuery#1.
        expect(mockCallback.mock.calls).toEqual([
        [_extends({}, defaultState)], 
        [_extends({}, defaultState, { ready: true })]]);


        resolveSplitQueryByIndex(2);
        resolveSplitQueryByIndex(3);
        jest.runAllTimers();

        // Only called once more after both splitQuery#2 and splitQuery#3.
        expect(mockCallback.mock.calls).toEqual([
        [_extends({}, defaultState, { ready: false })], 
        [_extends({}, defaultState, { ready: true })], 
        [_extends({}, defaultState, { ready: true })]]);


        resolveSplitQueryByIndex(4);
        jest.runAllTimers();

        expect(mockCallback).lastCalledWith(_extends({}, 
        defaultState, { done: true, ready: true }));};});




    it('does in preload mode', function () {
      fetchMode = require('RelayFetchMode').PRELOAD;
      runTest();});


    it('does in client mode', function () {
      fetchMode = require('RelayFetchMode').CLIENT;
      runTest();});});});