/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');






describe('RelayContainer', function () {
  describe('hasFragmentData()', function () {
    var mockContainerInstance = undefined;
    var mockFragmentReference = undefined;
    var mockPointer = undefined;
    var pendingQueryTracker = undefined;
    var store = undefined;

    beforeEach(function () {
      jest.resetModuleRegistry();
      var MockComponent = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createClass({ displayName: 'MockComponent', render: function () {return require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createElement('div', null);} });
      var MockContainer = require('Relay').createContainer(MockComponent, { 
        fragments: { 
          foo: function () {return (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: '+Mv8b+UbjNdd:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayContainer_hasFragmentDataRelayQL', type: 'Node' };})();} } });


      var relayContext = new (require('RelayContext'))();
      var RelayTestRenderer = require('RelayTestUtils').createRenderer();
      mockContainerInstance = RelayTestRenderer.render(
      function (genMockPointer) {return require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createElement(MockContainer, { foo: genMockPointer('42') });}, 
      relayContext);

      mockFragmentReference = MockContainer.getFragment('foo');
      mockPointer = { __dataID__: '42' };
      var storeData = relayContext.getStoreData();
      pendingQueryTracker = storeData.getPendingQueryTracker();
      store = storeData.getCachedStore();});


    it('returns true when there are no pending queries', function () {
      pendingQueryTracker.hasPendingQueries = 
      jest.genMockFn().mockImplementation(function () {return false;});
      var hasData = mockContainerInstance.hasFragmentData(
      mockFragmentReference, 
      mockPointer);

      expect(hasData).toBe(true);});


    it('returns true when there are pending queries, but the fragment we are ' + 
    'interested in has resolved', function () {
      pendingQueryTracker.hasPendingQueries = 
      jest.genMockFn().mockImplementation(function () {return true;});
      store.hasDeferredFragmentData = 
      jest.genMockFn().mockReturnValue(true);
      var hasData = mockContainerInstance.hasFragmentData(
      mockFragmentReference, 
      mockPointer);

      expect(hasData).toBe(true);
      expect(store.hasDeferredFragmentData.mock.calls[0][0]).toBe('42');
      // FIXME: If you can get the fragment ID, implement this expectation!
      // expect(store.hasDeferredFragmentData.mock.calls[0][1]).toBe('???');
    });

    it('returns false when there are pending queries, but the fragment we ' + 
    'are interested in has not resolved', function () {
      pendingQueryTracker.hasPendingQueries = 
      jest.genMockFn().mockImplementation(function () {return true;});
      store.hasDeferredFragmentData = 
      jest.genMockFn().mockReturnValue(false);
      var hasData = mockContainerInstance.hasFragmentData(
      mockFragmentReference, 
      mockPointer);

      expect(hasData).toBe(false);
      expect(store.hasDeferredFragmentData.mock.calls[0][0]).toBe('42');
      // FIXME: If you can get the fragment ID, implement this expectation!
      // expect(store.hasDeferredFragmentData.mock.calls[0][1]).toBe('???');
    });});});