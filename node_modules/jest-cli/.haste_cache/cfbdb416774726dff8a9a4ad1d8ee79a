{"/Users/cpojer/Projects/relay/src/__forks__/traversal/__mocks__/printRelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('printRelayQuery');\n","dependencies":["printRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('printRelayQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/__forks__/traversal/__mocks__/printRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/__forks__/interface/__mocks__/RelayNodeInterface.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayNodeInterface');\n","dependencies":["RelayNodeInterface"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayNodeInterface');\n"},"name":"/Users/cpojer/Projects/relay/src/__forks__/interface/__mocks__/RelayNodeInterface.js"}},"/Users/cpojer/Projects/relay/src/__forks__/interface/__mocks__/RelayConnectionInterface.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayConnectionInterface');\n","dependencies":["RelayConnectionInterface"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayConnectionInterface');\n"},"name":"/Users/cpojer/Projects/relay/src/__forks__/interface/__mocks__/RelayConnectionInterface.js"}},"/Users/cpojer/Projects/relay/src/__forks__/container/__mocks__/RelayContainerProxy.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayContainerProxy');\n","dependencies":["RelayContainerProxy"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayContainerProxy');\n"},"name":"/Users/cpojer/Projects/relay/src/__forks__/container/__mocks__/RelayContainerProxy.js"}},"/Users/cpojer/Projects/relay/src/__forks__/container/__mocks__/prepareRelayContainerProps.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('prepareRelayContainerProps');\n","dependencies":["prepareRelayContainerProps"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('prepareRelayContainerProps');\n"},"name":"/Users/cpojer/Projects/relay/src/__forks__/container/__mocks__/prepareRelayContainerProps.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/recycleNodesInto.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\njest.dontMock('recycleNodesInto');\n\nmodule.exports = require('recycleNodesInto');\n","dependencies":["recycleNodesInto"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\njest.dontMock('recycleNodesInto');\n\nmodule.exports = require('recycleNodesInto');\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/recycleNodesInto.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreTestUtils.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar matchRecord = require('matchRecord');\n\nvar GraphQLStoreTestUtils = {\n  matchers: {\n    /**\n     * Compare the returned result from the GraphQLStore with the expected\n     * result object. Result can have extra clientIDs appended to nodes, without\n     * ones. This function compares if they are equal, while ignoring the\n     * clientIDs.\n     */\n    toMatchResult() {\n      return {compare: matchRecord};\n    },\n  },\n  /**\n   * @param {object} node\n   * @param {function} callback\n   * @return {object}\n   */\n  filterFields: function(node, callback) {\n    return node.shallowClone(\n      node.getOwnFields()\n        .map(field => GraphQLStoreTestUtils.filterFields(field, callback))\n        .filter(callback),\n      node.getFragments().filter(\n        fragment => GraphQLStoreTestUtils.filterFields(fragment, callback)\n      )\n    );\n  },\n  /**\n   * @param {string} type For example: 'log', 'warn', 'error'\n   * @return {function}\n   */\n  genMockConsoleFunction: function(type) {\n    /* globals expect: false */\n    var consoleFunction = console[type];\n    var whitelistedStrings = [];\n    var mockFunction = jest.genMockFunction().mockImplementation(\n      function(...args) {\n        var formatString = args[0];\n        if (whitelistedStrings.indexOf(formatString) >= 0) {\n          return;\n        }\n        consoleFunction.apply(console, args);\n        // NOTE: This will fail the unit test (and help prevent log spew).\n        expect(whitelistedStrings).toContain(formatString);\n      }\n    );\n    // Unit tests should use this method to expect and silence console logs.\n    mockFunction.mockWhitelistString = function(string) {\n      whitelistedStrings.push(string);\n    };\n    mockFunction.originalFunction = consoleFunction;\n    return mockFunction;\n  },\n  deepUnmockRQL: function() {\n    jest\n      .dontMock('RelayFragmentPointer');\n  },\n};\n\nmodule.exports = GraphQLStoreTestUtils;\n","dependencies":["matchRecord"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar matchRecord = require('matchRecord');\n\nvar GraphQLStoreTestUtils = {\n  matchers: {\n    /**\n     * Compare the returned result from the GraphQLStore with the expected\n     * result object. Result can have extra clientIDs appended to nodes, without\n     * ones. This function compares if they are equal, while ignoring the\n     * clientIDs.\n     */\n    toMatchResult() {\n      return {compare: matchRecord};\n    },\n  },\n  /**\n   * @param {object} node\n   * @param {function} callback\n   * @return {object}\n   */\n  filterFields: function(node, callback) {\n    return node.shallowClone(\n      node.getOwnFields()\n        .map(field => GraphQLStoreTestUtils.filterFields(field, callback))\n        .filter(callback),\n      node.getFragments().filter(\n        fragment => GraphQLStoreTestUtils.filterFields(fragment, callback)\n      )\n    );\n  },\n  /**\n   * @param {string} type For example: 'log', 'warn', 'error'\n   * @return {function}\n   */\n  genMockConsoleFunction: function(type) {\n    /* globals expect: false */\n    var consoleFunction = console[type];\n    var whitelistedStrings = [];\n    var mockFunction = jest.genMockFunction().mockImplementation(\n      function(...args) {\n        var formatString = args[0];\n        if (whitelistedStrings.indexOf(formatString) >= 0) {\n          return;\n        }\n        consoleFunction.apply(console, args);\n        // NOTE: This will fail the unit test (and help prevent log spew).\n        expect(whitelistedStrings).toContain(formatString);\n      }\n    );\n    // Unit tests should use this method to expect and silence console logs.\n    mockFunction.mockWhitelistString = function(string) {\n      whitelistedStrings.push(string);\n    };\n    mockFunction.originalFunction = consoleFunction;\n    return mockFunction;\n  },\n  deepUnmockRQL: function() {\n    jest\n      .dontMock('RelayFragmentPointer');\n  },\n};\n\nmodule.exports = GraphQLStoreTestUtils;\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreTestUtils.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreRangeUtils.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst GraphQLStoreRangeUtils = require.requireActual('GraphQLStoreRangeUtils');\n\nObject.getOwnPropertyNames(GraphQLStoreRangeUtils.prototype).forEach(name => {\n  const property = GraphQLStoreRangeUtils.prototype[name];\n  if (typeof property === 'function') {\n    GraphQLStoreRangeUtils.prototype[name] =\n      jest.genMockFunction().mockImplementation(property);\n  }\n});\n\nmodule.exports = require.requireActual('GraphQLStoreRangeUtils');\n","dependencies":["GraphQLStoreRangeUtils","GraphQLStoreRangeUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nconst GraphQLStoreRangeUtils = require.requireActual('GraphQLStoreRangeUtils');\n\nObject.getOwnPropertyNames(GraphQLStoreRangeUtils.prototype).forEach(name => {\n  const property = GraphQLStoreRangeUtils.prototype[name];\n  if (typeof property === 'function') {\n    GraphQLStoreRangeUtils.prototype[name] =\n      jest.genMockFunction().mockImplementation(property);\n  }\n});\n\nmodule.exports = require.requireActual('GraphQLStoreRangeUtils');\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreRangeUtils.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreQueryResolver.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nclass GraphQLStoreQueryResolver {\n\n  constructor(store, queryFragment, callback) {\n    var mockInstances = GraphQLStoreQueryResolver.mock.instances;\n    this.mock = {\n      callback,\n      index: mockInstances.length,\n      queryFragment,\n      store,\n    };\n    this.resolve = jest.genMockFunction().mockImplementation((...args) => {\n      var mockConstructor = GraphQLStoreQueryResolver.mock;\n      var mockResolve =\n        mockConstructor.resolveImplementations[this.mock.index] ||\n        mockConstructor.defaultResolveImplementation;\n      return mockResolve.apply(this, args);\n    });\n    this.reset = jest.genMockFunction();\n    this.dispose = jest.genMockFunction();\n    mockInstances.push(this);\n  }\n\n  static mockResolveImplementation(mockResolverIndex, callback) {\n    this.mock.resolveImplementations[mockResolverIndex] = callback;\n  }\n\n  static mockDefaultResolveImplementation(callback) {\n    GraphQLStoreQueryResolver.mock.defaultResolveImplementation = callback;\n  }\n}\n\nGraphQLStoreQueryResolver.mock = {\n  instances: [],\n  resolveImplementations: [],\n  defaultResolveImplementation: () => undefined,\n};\n\nmodule.exports = GraphQLStoreQueryResolver;\n","dependencies":[],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nclass GraphQLStoreQueryResolver {\n\n  constructor(store, queryFragment, callback) {\n    var mockInstances = GraphQLStoreQueryResolver.mock.instances;\n    this.mock = {\n      callback,\n      index: mockInstances.length,\n      queryFragment,\n      store,\n    };\n    this.resolve = jest.genMockFunction().mockImplementation((...args) => {\n      var mockConstructor = GraphQLStoreQueryResolver.mock;\n      var mockResolve =\n        mockConstructor.resolveImplementations[this.mock.index] ||\n        mockConstructor.defaultResolveImplementation;\n      return mockResolve.apply(this, args);\n    });\n    this.reset = jest.genMockFunction();\n    this.dispose = jest.genMockFunction();\n    mockInstances.push(this);\n  }\n\n  static mockResolveImplementation(mockResolverIndex, callback) {\n    this.mock.resolveImplementations[mockResolverIndex] = callback;\n  }\n\n  static mockDefaultResolveImplementation(callback) {\n    GraphQLStoreQueryResolver.mock.defaultResolveImplementation = callback;\n  }\n}\n\nGraphQLStoreQueryResolver.mock = {\n  instances: [],\n  resolveImplementations: [],\n  defaultResolveImplementation: () => undefined,\n};\n\nmodule.exports = GraphQLStoreQueryResolver;\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreQueryResolver.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreChangeEmitter.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar GraphQLStoreChangeEmitter = jest.genMockFromModule('GraphQLStoreChangeEmitter');\n\nGraphQLStoreChangeEmitter.mockImplementation(function() {\n  this.addListenerForIDs.mock.remove = [];\n  this.addListenerForIDs.mockImplementation(() => {\n    var returnValue = {remove: jest.genMockFunction()};\n    this.addListenerForIDs.mock.remove.push(\n      returnValue.remove\n    );\n    return returnValue;\n  });\n\n  return this;\n});\n\nmodule.exports = GraphQLStoreChangeEmitter;\n","dependencies":["GraphQLStoreChangeEmitter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar GraphQLStoreChangeEmitter = jest.genMockFromModule('GraphQLStoreChangeEmitter');\n\nGraphQLStoreChangeEmitter.mockImplementation(function() {\n  this.addListenerForIDs.mock.remove = [];\n  this.addListenerForIDs.mockImplementation(() => {\n    var returnValue = {remove: jest.genMockFunction()};\n    this.addListenerForIDs.mock.remove.push(\n      returnValue.remove\n    );\n    return returnValue;\n  });\n\n  return this;\n});\n\nmodule.exports = GraphQLStoreChangeEmitter;\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLStoreChangeEmitter.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLQueryRunner.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar GraphQLQueryRunner = jest.genMockFromModule('GraphQLQueryRunner');\n\nconst resolveImmediate = require('resolveImmediate');\n\n/**\n * Mock object to simulate the behavior of a request. Example usage:\n *\n *   GraphQLQueryRunner.run(...);\n *   GraphQLQueryRunner.run.mock.requests[0].block();\n *   GraphQLQueryRunner.run.mock.requests[0].fail(new Error());\n *\n * A normal request should follow one of the following behaviors:\n *\n *   block? -> resolve* -> succeed\n *   block? -> resolve* -> fail\n *\n */\nfunction genMockRequest(args) {\n  var ready = false;\n  return {\n    abort() {\n      args[1]({aborted: true, done: false, error: null, ready, stale: false});\n    },\n    block() {\n      args[1]({aborted: false, done: false, error: null, ready, stale: false});\n    },\n    resolve() {\n      ready = true;\n      args[1]({aborted: false, done: false, error: null, ready, stale: false});\n    },\n    succeed() {\n      ready = true;\n      args[1]({aborted: false, done: true, error: null, ready, stale: false});\n    },\n    fail(error) {\n      args[1]({aborted: false, done: false, error, ready, stale: false});\n    },\n  };\n}\n\nGraphQLQueryRunner.mockImplementation(function() {\n  this.run.mock.abort = [];\n  this.run.mock.requests = [];\n  this.run.mockImplementation((...args) => {\n    var request = genMockRequest(args);\n    var returnValue = {\n      abort: jest.genMockFunction().mockImplementation(() => {\n        resolveImmediate(request.abort);\n      }),\n    };\n    this.run.mock.abort.push(returnValue.abort);\n    this.run.mock.requests.push(request);\n    return returnValue;\n  });\n\n  this.forceFetch.mock.abort = [];\n  this.forceFetch.mock.requests = [];\n  this.forceFetch.mockImplementation((...args) => {\n    var request = genMockRequest(args);\n    var returnValue = {\n      abort: jest.genMockFunction().mockImplementation(() => {\n        resolveImmediate(request.abort);\n      }),\n    };\n    this.forceFetch.mock.abort.push(returnValue.abort);\n    this.forceFetch.mock.requests.push(request);\n    return returnValue;\n  });\n\n  return this;\n});\n\nmodule.exports = GraphQLQueryRunner;\n","dependencies":["resolveImmediate","GraphQLQueryRunner"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar GraphQLQueryRunner = jest.genMockFromModule('GraphQLQueryRunner');\n\nconst resolveImmediate = require('resolveImmediate');\n\n/**\n * Mock object to simulate the behavior of a request. Example usage:\n *\n *   GraphQLQueryRunner.run(...);\n *   GraphQLQueryRunner.run.mock.requests[0].block();\n *   GraphQLQueryRunner.run.mock.requests[0].fail(new Error());\n *\n * A normal request should follow one of the following behaviors:\n *\n *   block? -> resolve* -> succeed\n *   block? -> resolve* -> fail\n *\n */\nfunction genMockRequest(args) {\n  var ready = false;\n  return {\n    abort() {\n      args[1]({aborted: true, done: false, error: null, ready, stale: false});\n    },\n    block() {\n      args[1]({aborted: false, done: false, error: null, ready, stale: false});\n    },\n    resolve() {\n      ready = true;\n      args[1]({aborted: false, done: false, error: null, ready, stale: false});\n    },\n    succeed() {\n      ready = true;\n      args[1]({aborted: false, done: true, error: null, ready, stale: false});\n    },\n    fail(error) {\n      args[1]({aborted: false, done: false, error, ready, stale: false});\n    },\n  };\n}\n\nGraphQLQueryRunner.mockImplementation(function() {\n  this.run.mock.abort = [];\n  this.run.mock.requests = [];\n  this.run.mockImplementation((...args) => {\n    var request = genMockRequest(args);\n    var returnValue = {\n      abort: jest.genMockFunction().mockImplementation(() => {\n        resolveImmediate(request.abort);\n      }),\n    };\n    this.run.mock.abort.push(returnValue.abort);\n    this.run.mock.requests.push(request);\n    return returnValue;\n  });\n\n  this.forceFetch.mock.abort = [];\n  this.forceFetch.mock.requests = [];\n  this.forceFetch.mockImplementation((...args) => {\n    var request = genMockRequest(args);\n    var returnValue = {\n      abort: jest.genMockFunction().mockImplementation(() => {\n        resolveImmediate(request.abort);\n      }),\n    };\n    this.forceFetch.mock.abort.push(returnValue.abort);\n    this.forceFetch.mock.requests.push(request);\n    return returnValue;\n  });\n\n  return this;\n});\n\nmodule.exports = GraphQLQueryRunner;\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLQueryRunner.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLMutatorConstants.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('GraphQLMutatorConstants');\n","dependencies":["GraphQLMutatorConstants"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('GraphQLMutatorConstants');\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/GraphQLMutatorConstants.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/generateForceIndex.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('generateForceIndex');\n","dependencies":["generateForceIndex"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('generateForceIndex');\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/generateForceIndex.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/generateClientID.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar count = 1;\n\nvar generateClientID = jest.genMockFunction().mockImplementation(\n  () => { return 'client:' + count++; }\n);\n\nmodule.exports = generateClientID;\n","dependencies":[],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar count = 1;\n\nvar generateClientID = jest.genMockFunction().mockImplementation(\n  () => { return 'client:' + count++; }\n);\n\nmodule.exports = generateClientID;\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/generateClientID.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/generateClientEdgeID.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('generateClientEdgeID');\n","dependencies":["generateClientEdgeID"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('generateClientEdgeID');\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__mocks__/generateClientEdgeID.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/recycleNodesInto-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('recycleNodesInto');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst recycleNodesInto = require('recycleNodesInto');\n\ndescribe('recycleNodesInto', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  describe('scalars', () => {\n    it('ignores when `prevData` is null or undefined', () => {\n      var nextData = {};\n      expect(recycleNodesInto(null, nextData)).toBe(nextData);\n      expect(recycleNodesInto(undefined, nextData)).toBe(nextData);\n    });\n\n    it('returns when `nextData` is null or undefined', () => {\n      var prevData = {};\n      expect(recycleNodesInto(prevData, null)).toBe(null);\n      expect(recycleNodesInto(prevData, undefined)).toBe(undefined);\n    });\n\n    it('returns when `nextData` is a string or number', () => {\n      expect(recycleNodesInto(null, 'foo')).toBe('foo');\n      expect(recycleNodesInto(null, 1)).toBe(1);\n    });\n\n    it('ignores when `prevData` is not exactly the same', () => {\n      expect(recycleNodesInto(1, '1')).toBe('1');\n      expect(recycleNodesInto(null, '')).toBe('');\n    });\n  });\n\n  describe('objects', () => {\n    it('recycles equal leaf objects', () => {\n      var prevData = {foo: 1};\n      var nextData = {foo: 1};\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles parent objects with equal leaf objects', () => {\n      var prevData = {foo: {bar: 1}};\n      var nextData = {foo: {bar: 1}};\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('does not recycle unequal leaf objects', () => {\n      var prevData = {foo: 1};\n      var nextData = {foo: 100};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('does not recycle parent objects with unequal leaf objects', () => {\n      var prevData = {foo: {bar: 1}};\n      var nextData = {foo: {bar: 100}};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('does not recycle object with fewer properties', () => {\n      var prevData = {foo: 1};\n      var nextData = {foo: 1, bar: 2};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('does not recycle object with more properties', () => {\n      var prevData = {foo: 1, bar: 2};\n      var nextData = {foo: 1};\n      expect(recycleNodesInto(prevData, nextData)).toEqual({foo: 1});\n    });\n\n    it('recycles equal leaf objects with unequal parent objects', () => {\n      var prevData = {foo: {bar: 1}, baz: 2};\n      var nextData = {foo: {bar: 1}, baz: 200};\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled.bar).toBe(prevData.bar);\n    });\n\n    it('does not recycle arrays as objects', () => {\n      var prevData = [1, 2];\n      var nextData = {0: 1, 1: 2};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n  });\n\n  describe('arrays', () => {\n    it('recycles arrays with equal scalars', () => {\n      var prevData = [1, 2, 3];\n      var nextData = [1, 2, 3];\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('does not recycle arrays with unequal scalars', () => {\n      var prevData = [1, 2, 3];\n      var nextData = [4, 5, 6];\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('recycles arrays with equal objects without mutating `prevData`', () => {\n      var prevData = [{foo: 1}, {bar: 2}];\n      var nextData = [{foo: 1}, {bar: 2}];\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles arrays without mutating `prevData`', () => {\n      var prevItem = {foo: 1};\n      var prevData = [prevItem];\n      var nextData = [{foo: 1}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).toBe(prevData);\n      expect(recycled[0]).toBe(prevItem);\n    });\n\n    it('recycles arrays with equal objects but unequal parent objects', () => {\n      var prevData = {foo: [{foo: 1}, {bar: 2}], qux: 3};\n      var nextData = {foo: [{foo: 1}, {bar: 2}], qux: 300};\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled.foo).toBe(prevData.foo);\n    });\n\n    it('recycles equal objects from an array with unequal siblings', () => {\n      var prevData = [{foo: 1}, {bar: 2}];\n      var nextData = [{foo: 1}, {bar: 200}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled[0]).toBe(prevData[0]);\n      expect(recycled[1]).not.toBe(prevData[1]);\n    });\n\n    it('recycles equal objects from an array with fewer siblings', () => {\n      var prevData = [{foo: 1}];\n      var nextData = [{foo: 1}, {bar: 2}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled[0]).toBe(prevData[0]);\n      expect(recycled[1]).toEqual({bar: 2});\n    });\n\n    it('recycles equal objects from an array with more siblings', () => {\n      var prevData = [{foo: 1}, {bar: 2}];\n      var nextData = [{foo: 1}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled[0]).toBe(prevData[0]);\n      expect(recycled.length).toBe(1);\n    });\n\n    it('does not recycle objects as arrays', () => {\n      var prevData = Object.assign(Object.create({length: 2}), {0: 1, 1: 2});\n      var nextData = [1, 2];\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n  });\n\n  describe('fragment pointers', () => {\n    var getPointer;\n\n    beforeEach(() => {\n      var {getNode} = RelayTestUtils;\n\n      var fragment = getNode(Relay.QL`fragment on Node{id}`);\n      getPointer = function(dataID) {\n        return RelayTestUtils.getPointer(dataID, fragment);\n      };\n    });\n\n    it('recycles equal fragment pointers', () => {\n      var prevData = getPointer('A');\n      var nextData = getPointer('A');\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles parent objects with equal fragment pointers', () => {\n      var prevData = {foo: getPointer('A')};\n      var nextData = {foo: getPointer('A')};\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles arrays with equal fragment pointers', () => {\n      var prevData = [getPointer('A')];\n      var nextData = [getPointer('A')];\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('does not recycle unequal fragment pointers', () => {\n      var prevData = getPointer('A');\n      var nextData = getPointer('B');\n      expect(recycleNodesInto(prevData, nextData)).toBe(nextData);\n    });\n\n    it('does not recycle parent objects with unequal fragment pointers', () => {\n      var prevData = {foo: getPointer('A')};\n      var nextData = {foo: getPointer('B')};\n      expect(recycleNodesInto(prevData, nextData)).toBe(nextData);\n    });\n\n    it('does not recycle arrays with unequal fragment pointers', () => {\n      var prevData = [getPointer('A')];\n      var nextData = [getPointer('B')];\n      expect(recycleNodesInto(prevData, nextData)).toBe(nextData);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","recycleNodesInto"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('recycleNodesInto');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst recycleNodesInto = require('recycleNodesInto');\n\ndescribe('recycleNodesInto', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  describe('scalars', () => {\n    it('ignores when `prevData` is null or undefined', () => {\n      var nextData = {};\n      expect(recycleNodesInto(null, nextData)).toBe(nextData);\n      expect(recycleNodesInto(undefined, nextData)).toBe(nextData);\n    });\n\n    it('returns when `nextData` is null or undefined', () => {\n      var prevData = {};\n      expect(recycleNodesInto(prevData, null)).toBe(null);\n      expect(recycleNodesInto(prevData, undefined)).toBe(undefined);\n    });\n\n    it('returns when `nextData` is a string or number', () => {\n      expect(recycleNodesInto(null, 'foo')).toBe('foo');\n      expect(recycleNodesInto(null, 1)).toBe(1);\n    });\n\n    it('ignores when `prevData` is not exactly the same', () => {\n      expect(recycleNodesInto(1, '1')).toBe('1');\n      expect(recycleNodesInto(null, '')).toBe('');\n    });\n  });\n\n  describe('objects', () => {\n    it('recycles equal leaf objects', () => {\n      var prevData = {foo: 1};\n      var nextData = {foo: 1};\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles parent objects with equal leaf objects', () => {\n      var prevData = {foo: {bar: 1}};\n      var nextData = {foo: {bar: 1}};\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('does not recycle unequal leaf objects', () => {\n      var prevData = {foo: 1};\n      var nextData = {foo: 100};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('does not recycle parent objects with unequal leaf objects', () => {\n      var prevData = {foo: {bar: 1}};\n      var nextData = {foo: {bar: 100}};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('does not recycle object with fewer properties', () => {\n      var prevData = {foo: 1};\n      var nextData = {foo: 1, bar: 2};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('does not recycle object with more properties', () => {\n      var prevData = {foo: 1, bar: 2};\n      var nextData = {foo: 1};\n      expect(recycleNodesInto(prevData, nextData)).toEqual({foo: 1});\n    });\n\n    it('recycles equal leaf objects with unequal parent objects', () => {\n      var prevData = {foo: {bar: 1}, baz: 2};\n      var nextData = {foo: {bar: 1}, baz: 200};\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled.bar).toBe(prevData.bar);\n    });\n\n    it('does not recycle arrays as objects', () => {\n      var prevData = [1, 2];\n      var nextData = {0: 1, 1: 2};\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n  });\n\n  describe('arrays', () => {\n    it('recycles arrays with equal scalars', () => {\n      var prevData = [1, 2, 3];\n      var nextData = [1, 2, 3];\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('does not recycle arrays with unequal scalars', () => {\n      var prevData = [1, 2, 3];\n      var nextData = [4, 5, 6];\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n\n    it('recycles arrays with equal objects without mutating `prevData`', () => {\n      var prevData = [{foo: 1}, {bar: 2}];\n      var nextData = [{foo: 1}, {bar: 2}];\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles arrays without mutating `prevData`', () => {\n      var prevItem = {foo: 1};\n      var prevData = [prevItem];\n      var nextData = [{foo: 1}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).toBe(prevData);\n      expect(recycled[0]).toBe(prevItem);\n    });\n\n    it('recycles arrays with equal objects but unequal parent objects', () => {\n      var prevData = {foo: [{foo: 1}, {bar: 2}], qux: 3};\n      var nextData = {foo: [{foo: 1}, {bar: 2}], qux: 300};\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled.foo).toBe(prevData.foo);\n    });\n\n    it('recycles equal objects from an array with unequal siblings', () => {\n      var prevData = [{foo: 1}, {bar: 2}];\n      var nextData = [{foo: 1}, {bar: 200}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled[0]).toBe(prevData[0]);\n      expect(recycled[1]).not.toBe(prevData[1]);\n    });\n\n    it('recycles equal objects from an array with fewer siblings', () => {\n      var prevData = [{foo: 1}];\n      var nextData = [{foo: 1}, {bar: 2}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled[0]).toBe(prevData[0]);\n      expect(recycled[1]).toEqual({bar: 2});\n    });\n\n    it('recycles equal objects from an array with more siblings', () => {\n      var prevData = [{foo: 1}, {bar: 2}];\n      var nextData = [{foo: 1}];\n      var recycled = recycleNodesInto(prevData, nextData);\n\n      expect(recycled).not.toBe(prevData);\n      expect(recycled[0]).toBe(prevData[0]);\n      expect(recycled.length).toBe(1);\n    });\n\n    it('does not recycle objects as arrays', () => {\n      var prevData = Object.assign(Object.create({length: 2}), {0: 1, 1: 2});\n      var nextData = [1, 2];\n      expect(recycleNodesInto(prevData, nextData)).not.toBe(prevData);\n    });\n  });\n\n  describe('fragment pointers', () => {\n    var getPointer;\n\n    beforeEach(() => {\n      var {getNode} = RelayTestUtils;\n\n      var fragment = getNode(Relay.QL`fragment on Node{id}`);\n      getPointer = function(dataID) {\n        return RelayTestUtils.getPointer(dataID, fragment);\n      };\n    });\n\n    it('recycles equal fragment pointers', () => {\n      var prevData = getPointer('A');\n      var nextData = getPointer('A');\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles parent objects with equal fragment pointers', () => {\n      var prevData = {foo: getPointer('A')};\n      var nextData = {foo: getPointer('A')};\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('recycles arrays with equal fragment pointers', () => {\n      var prevData = [getPointer('A')];\n      var nextData = [getPointer('A')];\n      expect(recycleNodesInto(prevData, nextData)).toBe(prevData);\n    });\n\n    it('does not recycle unequal fragment pointers', () => {\n      var prevData = getPointer('A');\n      var nextData = getPointer('B');\n      expect(recycleNodesInto(prevData, nextData)).toBe(nextData);\n    });\n\n    it('does not recycle parent objects with unequal fragment pointers', () => {\n      var prevData = {foo: getPointer('A')};\n      var nextData = {foo: getPointer('B')};\n      expect(recycleNodesInto(prevData, nextData)).toBe(nextData);\n    });\n\n    it('does not recycle arrays with unequal fragment pointers', () => {\n      var prevData = [getPointer('A')];\n      var nextData = [getPointer('B')];\n      expect(recycleNodesInto(prevData, nextData)).toBe(nextData);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/recycleNodesInto-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLStoreRangeUtils-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('GraphQLStoreRangeUtils');\n\nconst QueryBuilder = require('QueryBuilder');\nconst GraphQLStoreRangeUtils = require('GraphQLStoreRangeUtils');\n\ndescribe('GraphQLStoreRangeUtils', () => {\n  var rangeData;\n\n  beforeEach(() => {\n    rangeData = new GraphQLStoreRangeUtils();\n  });\n\n  it('should encode and decode', () => {\n    var id = 'client:1';\n    var callValues = {count: '1', cursor: '123456'};\n\n    var firstCall = QueryBuilder.createCall(\n      'first',\n      QueryBuilder.createCallVariable('count')\n    );\n\n    var afterCall = QueryBuilder.createCall(\n      'after',\n      QueryBuilder.createCallVariable('cursor')\n    );\n\n    var calls = [firstCall, afterCall];\n\n    var rangeID = rangeData.getClientIDForRangeWithID(\n      calls,\n      callValues,\n      id\n    );\n\n    // TODO: This is technically an implementation detail. We shouldn't test\n    // the actual value of the string; instead we should just confirm that it's\n    // the same given the same id and calls, and that it's different given\n    // a different ID or different calls.\n    expect(rangeID).toEqual('client:1_first(1),after(123456)');\n\n    var parsed = rangeData.parseRangeClientID(rangeID);\n    expect(parsed.dataID).toBe(id);\n    expect(parsed.calls).toBe(calls);\n    expect(parsed.callValues).toBe(callValues);\n  });\n\n  it('removes range data for records', () => {\n    var id = 'client:1';\n    var calls = [QueryBuilder.createCall(\n      'first',\n      QueryBuilder.createCallValue(1)\n    )];\n    var callValues = {};\n    var rangeID = rangeData.getClientIDForRangeWithID(\n      calls,\n      callValues,\n      id\n    );\n    expect(rangeData.parseRangeClientID(rangeID)).toEqual({\n      dataID: id,\n      calls,\n      callValues,\n    });\n\n    rangeData.removeRecord(id);\n    expect(rangeData.parseRangeClientID(rangeID)).toBe(null);\n  });\n\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","GraphQLStoreRangeUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('GraphQLStoreRangeUtils');\n\nconst QueryBuilder = require('QueryBuilder');\nconst GraphQLStoreRangeUtils = require('GraphQLStoreRangeUtils');\n\ndescribe('GraphQLStoreRangeUtils', () => {\n  var rangeData;\n\n  beforeEach(() => {\n    rangeData = new GraphQLStoreRangeUtils();\n  });\n\n  it('should encode and decode', () => {\n    var id = 'client:1';\n    var callValues = {count: '1', cursor: '123456'};\n\n    var firstCall = QueryBuilder.createCall(\n      'first',\n      QueryBuilder.createCallVariable('count')\n    );\n\n    var afterCall = QueryBuilder.createCall(\n      'after',\n      QueryBuilder.createCallVariable('cursor')\n    );\n\n    var calls = [firstCall, afterCall];\n\n    var rangeID = rangeData.getClientIDForRangeWithID(\n      calls,\n      callValues,\n      id\n    );\n\n    // TODO: This is technically an implementation detail. We shouldn't test\n    // the actual value of the string; instead we should just confirm that it's\n    // the same given the same id and calls, and that it's different given\n    // a different ID or different calls.\n    expect(rangeID).toEqual('client:1_first(1),after(123456)');\n\n    var parsed = rangeData.parseRangeClientID(rangeID);\n    expect(parsed.dataID).toBe(id);\n    expect(parsed.calls).toBe(calls);\n    expect(parsed.callValues).toBe(callValues);\n  });\n\n  it('removes range data for records', () => {\n    var id = 'client:1';\n    var calls = [QueryBuilder.createCall(\n      'first',\n      QueryBuilder.createCallValue(1)\n    )];\n    var callValues = {};\n    var rangeID = rangeData.getClientIDForRangeWithID(\n      calls,\n      callValues,\n      id\n    );\n    expect(rangeData.parseRangeClientID(rangeID)).toEqual({\n      dataID: id,\n      calls,\n      callValues,\n    });\n\n    rangeData.removeRecord(id);\n    expect(rangeData.parseRangeClientID(rangeID)).toBe(null);\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLStoreRangeUtils-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLStoreQueryResolver-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .dontMock('GraphQLStoreQueryResolver');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst Relay = require('Relay');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst readRelayQueryData = require('readRelayQueryData');\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('GraphQLStoreQueryResolver', () => {\n  var changeEmitter;\n  var storeData;\n\n  var dataID;\n  var mockCallback;\n  var mockQueryFragment;\n  var mockPluralQueryFragment;\n\n  var {getNode} = RelayTestUtils;\n\n  function mockReader(mockResult) {\n    readRelayQueryData.mockImplementation((_, __, dataID) => {\n      return {\n        dataIDs: {[dataID]: true},\n        data: mockResult[dataID],\n      };\n    });\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    storeData = new RelayStoreData();\n    changeEmitter = storeData.getChangeEmitter();\n\n    dataID = '1038750002';\n    mockCallback = jest.genMockFunction();\n    mockQueryFragment = getNode(Relay.QL`fragment on Node{id,name}`);\n    mockPluralQueryFragment = getNode(Relay.QL`\n      fragment on Node @relay(plural:true) {\n        id,\n        name,\n      }\n    `);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('should resolve a pointer', () => {\n    var mockResult = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n    readRelayQueryData.mockReturnValue({data: mockResult});\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n    var resolved = resolver.resolve(mockQueryFragment, dataID);\n\n    expect(resolved).toBe(mockResult);\n\n    expect(readRelayQueryData).toBeCalled();\n    expect(readRelayQueryData.mock.calls[0][1]).toBe(mockQueryFragment);\n    expect(readRelayQueryData.mock.calls[0][2]).toEqual(dataID);\n  });\n\n  it('should subscribe to IDs in resolved pointer', () => {\n    var mockResult = {\n      '1038750002': {__dataID__: '1038750002', id: '1038750002', name: 'Tim'},\n    };\n    mockReader(mockResult);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n    resolver.resolve(mockQueryFragment, dataID);\n\n    var addListenersForIDs = changeEmitter.addListenerForIDs;\n    expect(addListenersForIDs).toBeCalled();\n    expect(addListenersForIDs.mock.calls[0][0]).toEqual(['1038750002']);\n  });\n\n  it('should not re-resolve pointers without change events', () => {\n    var mockResultA = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n    var mockResultB = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    readRelayQueryData.mockReturnValue({data: mockResultA});\n    var resolvedA = resolver.resolve(mockQueryFragment, dataID);\n\n    readRelayQueryData.mockReturnValue({data: mockResultB});\n    var resolvedB = resolver.resolve(mockQueryFragment, dataID);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(1);\n    expect(resolvedA).toBe(resolvedB);\n  });\n\n  it('should re-resolve pointers with change events', () => {\n    var mockResultA = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n    var mockResultB = {__dataID__: '1038750002', id: '1038750002', name: 'Tee'};\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    mockReader({\n      [mockResultA.id]: mockResultA,\n    });\n    var resolvedA = resolver.resolve(mockQueryFragment, dataID);\n\n    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];\n    callback(['1038750002']);\n\n    mockReader({\n      [mockResultB.id]: mockResultB,\n    });\n    var resolvedB = resolver.resolve(mockQueryFragment, dataID);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(2);\n    expect(resolvedA).toBe(mockResultA);\n    expect(resolvedB).toBe(mockResultB);\n  });\n\n  it('should re-resolve pointers whose calls differ', () => {\n    var dataIDA = 'client:123_first(10)';\n    var dataIDB = 'client:123_first(20)';\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    require('GraphQLStoreRangeUtils').getCanonicalClientID =\n      // The canonical ID of a range customarily excludes the calls\n      jest.genMockFunction().mockReturnValue('client:123');\n\n    resolver.resolve(mockQueryFragment, dataIDA);\n    resolver.resolve(mockQueryFragment, dataIDB);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(2);\n  });\n\n  it('should invoke the callback when change events fire', () => {\n    var mockResult = {\n      '1038750002': {__dataID__: '1038750002', id: '1038750002', name: 'Tim'},\n    };\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    mockReader(mockResult);\n    resolver.resolve(mockQueryFragment, dataID);\n\n    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];\n    callback(['1038750002']);\n\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should resolve an array of pointers', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolved = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n    expect(resolved.length).toBe(2);\n    expect(resolved[0]).toBe(mockResults['1']);\n    expect(resolved[1]).toBe(mockResults['2']);\n\n    expect(readRelayQueryData.mock.calls[0][2]).toEqual('1');\n    expect(readRelayQueryData.mock.calls[1][2]).toEqual('2');\n  });\n\n  it('should not re-resolve if the pointer array has no changes', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolvedA = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n    var resolvedB = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n\n    expect(resolvedA).toBe(resolvedB);\n  });\n\n  it('should only re-resolve pointers with changes in an array', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolvedA = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n\n    mockResults['1'] = {__dataID__: '1', name: 'Won'};\n    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];\n    callback(['1']);\n\n    var resolvedB = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n\n    expect(resolvedA).not.toBe(resolvedB);\n\n    expect(resolvedB.length).toBe(2);\n    expect(resolvedB[0]).toBe(mockResults['1']);\n    expect(resolvedB[1]).toBe(mockResults['2']);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(3);\n    expect(readRelayQueryData.mock.calls[2][2]).toEqual('1');\n  });\n\n  it('should create a new array if the pointer array shortens', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolvedA = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n    var resolvedB = resolver.resolve(mockPluralQueryFragment, ['1']);\n\n    expect(resolvedA).not.toBe(resolvedB);\n\n    expect(resolvedA.length).toBe(2);\n    expect(resolvedB.length).toBe(1);\n  });\n\n  describe('garbage collection', () => {\n    let dataID;\n    let fragment;\n\n    beforeEach(() => {\n      storeData.initializeGarbageCollector(run => {\n        while (run()) {}\n      });\n      const containerFragment = RelayTestUtils.createContainerFragment(Relay.QL`\n        fragment on NewsFeedConnection {\n          edges {\n            node {\n              id\n            }\n          }\n        }\n      `);\n      let concreteFragment = Relay.QL`\n        fragment on Viewer {\n          actor {\n            id\n          }\n          newsFeed(first: \"1\") {\n            ${containerFragment}\n          }\n        }\n      `;\n      const query = getNode(Relay.QL`\n        query {\n          viewer {\n            ${concreteFragment}\n          }\n        }\n      `);\n      const payload = {\n        viewer: {\n          actor: {\n            __typename: 'User',\n            id: '123',\n          },\n          newsFeed: {\n            edges: [\n              {\n                node: {\n                  __typename: 'Story',\n                  id: '456',\n                },\n              },\n            ],\n          },\n        },\n      };\n      storeData.handleQueryPayload(\n        query,\n        transformRelayQueryPayload(query, payload),\n        1\n      );\n      dataID = 'client:1';\n      fragment = getNode(concreteFragment);\n    });\n\n    it('increments references to read data', () => {\n      const queryResolver = new GraphQLStoreQueryResolver(\n        storeData,\n        fragment,\n        jest.genMockFunction()\n      );\n      // read data and set up subscriptions\n      queryResolver.resolve(fragment, dataID);\n      // evict unreferenced nodes\n      storeData.getGarbageCollector().collect();\n      jest.runAllTimers();\n      // nodes referenced by the fragment should not be evicted\n      expect(Object.keys(storeData.getNodeData())).toEqual([\n        '123',      // viewer.actor\n        'client:1', // viewer\n        'client:2', // viewer.newsFeed\n      ]);\n    });\n\n    it('decrements references to previously read fields', () => {\n      const queryResolver = new GraphQLStoreQueryResolver(\n        storeData,\n        fragment,\n        jest.genMockFunction()\n      );\n      // read data and increment GC ref counts\n      queryResolver.resolve(fragment, dataID);\n      const callback =\n        storeData.getChangeEmitter().addListenerForIDs.mock.calls[0][1];\n\n      // Remove the link to viewer.actor and broadcast an update\n      storeData.getRecordWriter().putField('client:1', 'actor', null);\n      storeData.getRecordWriter().putField('client:1', 'newsFeed', null);\n      callback(['client:1']);\n\n      // re-read and increment/decrement GC ref counts\n      queryResolver.resolve(fragment, dataID);\n\n      // evict unreferenced nodes\n      storeData.getGarbageCollector().collect();\n      jest.runAllTimers();\n      // nodes referenced by the fragment should not be evicted\n      expect(Object.keys(storeData.getNodeData())).toEqual([\n        // '123' (actor) is unreferenced and collected\n        // 'client:2' (viewer.newsFeed) is unreferenced and collected\n        'client:1', // viewer\n      ]);\n    });\n\n    it('decrements references when disposed', () => {\n      const queryResolver = new GraphQLStoreQueryResolver(\n        storeData,\n        fragment,\n        jest.genMockFunction()\n      );\n      // read data and increment GC ref counts\n      queryResolver.resolve(fragment, dataID);\n      // reset the resolver; should unreference all nodes\n      queryResolver.dispose();\n\n      // evict unreferenced nodes\n      storeData.getGarbageCollector().collect();\n      jest.runAllTimers();\n      // all nodes are unreferenced and should be removed\n      expect(storeData.getNodeData()).toEqual({});\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","Relay","RelayStoreData","RelayTestUtils","readRelayQueryData","transformRelayQueryPayload","GraphQLStoreRangeUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .dontMock('GraphQLStoreQueryResolver');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst Relay = require('Relay');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst readRelayQueryData = require('readRelayQueryData');\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('GraphQLStoreQueryResolver', () => {\n  var changeEmitter;\n  var storeData;\n\n  var dataID;\n  var mockCallback;\n  var mockQueryFragment;\n  var mockPluralQueryFragment;\n\n  var {getNode} = RelayTestUtils;\n\n  function mockReader(mockResult) {\n    readRelayQueryData.mockImplementation((_, __, dataID) => {\n      return {\n        dataIDs: {[dataID]: true},\n        data: mockResult[dataID],\n      };\n    });\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    storeData = new RelayStoreData();\n    changeEmitter = storeData.getChangeEmitter();\n\n    dataID = '1038750002';\n    mockCallback = jest.genMockFunction();\n    mockQueryFragment = getNode(Relay.QL`fragment on Node{id,name}`);\n    mockPluralQueryFragment = getNode(Relay.QL`\n      fragment on Node @relay(plural:true) {\n        id,\n        name,\n      }\n    `);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('should resolve a pointer', () => {\n    var mockResult = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n    readRelayQueryData.mockReturnValue({data: mockResult});\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n    var resolved = resolver.resolve(mockQueryFragment, dataID);\n\n    expect(resolved).toBe(mockResult);\n\n    expect(readRelayQueryData).toBeCalled();\n    expect(readRelayQueryData.mock.calls[0][1]).toBe(mockQueryFragment);\n    expect(readRelayQueryData.mock.calls[0][2]).toEqual(dataID);\n  });\n\n  it('should subscribe to IDs in resolved pointer', () => {\n    var mockResult = {\n      '1038750002': {__dataID__: '1038750002', id: '1038750002', name: 'Tim'},\n    };\n    mockReader(mockResult);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n    resolver.resolve(mockQueryFragment, dataID);\n\n    var addListenersForIDs = changeEmitter.addListenerForIDs;\n    expect(addListenersForIDs).toBeCalled();\n    expect(addListenersForIDs.mock.calls[0][0]).toEqual(['1038750002']);\n  });\n\n  it('should not re-resolve pointers without change events', () => {\n    var mockResultA = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n    var mockResultB = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    readRelayQueryData.mockReturnValue({data: mockResultA});\n    var resolvedA = resolver.resolve(mockQueryFragment, dataID);\n\n    readRelayQueryData.mockReturnValue({data: mockResultB});\n    var resolvedB = resolver.resolve(mockQueryFragment, dataID);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(1);\n    expect(resolvedA).toBe(resolvedB);\n  });\n\n  it('should re-resolve pointers with change events', () => {\n    var mockResultA = {__dataID__: '1038750002', id: '1038750002', name: 'Tim'};\n    var mockResultB = {__dataID__: '1038750002', id: '1038750002', name: 'Tee'};\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    mockReader({\n      [mockResultA.id]: mockResultA,\n    });\n    var resolvedA = resolver.resolve(mockQueryFragment, dataID);\n\n    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];\n    callback(['1038750002']);\n\n    mockReader({\n      [mockResultB.id]: mockResultB,\n    });\n    var resolvedB = resolver.resolve(mockQueryFragment, dataID);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(2);\n    expect(resolvedA).toBe(mockResultA);\n    expect(resolvedB).toBe(mockResultB);\n  });\n\n  it('should re-resolve pointers whose calls differ', () => {\n    var dataIDA = 'client:123_first(10)';\n    var dataIDB = 'client:123_first(20)';\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    require('GraphQLStoreRangeUtils').getCanonicalClientID =\n      // The canonical ID of a range customarily excludes the calls\n      jest.genMockFunction().mockReturnValue('client:123');\n\n    resolver.resolve(mockQueryFragment, dataIDA);\n    resolver.resolve(mockQueryFragment, dataIDB);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(2);\n  });\n\n  it('should invoke the callback when change events fire', () => {\n    var mockResult = {\n      '1038750002': {__dataID__: '1038750002', id: '1038750002', name: 'Tim'},\n    };\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockQueryFragment,\n      mockCallback\n    );\n\n    mockReader(mockResult);\n    resolver.resolve(mockQueryFragment, dataID);\n\n    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];\n    callback(['1038750002']);\n\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should resolve an array of pointers', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolved = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n    expect(resolved.length).toBe(2);\n    expect(resolved[0]).toBe(mockResults['1']);\n    expect(resolved[1]).toBe(mockResults['2']);\n\n    expect(readRelayQueryData.mock.calls[0][2]).toEqual('1');\n    expect(readRelayQueryData.mock.calls[1][2]).toEqual('2');\n  });\n\n  it('should not re-resolve if the pointer array has no changes', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolvedA = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n    var resolvedB = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n\n    expect(resolvedA).toBe(resolvedB);\n  });\n\n  it('should only re-resolve pointers with changes in an array', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolvedA = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n\n    mockResults['1'] = {__dataID__: '1', name: 'Won'};\n    var callback = changeEmitter.addListenerForIDs.mock.calls[0][1];\n    callback(['1']);\n\n    var resolvedB = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n\n    expect(resolvedA).not.toBe(resolvedB);\n\n    expect(resolvedB.length).toBe(2);\n    expect(resolvedB[0]).toBe(mockResults['1']);\n    expect(resolvedB[1]).toBe(mockResults['2']);\n\n    expect(readRelayQueryData.mock.calls.length).toBe(3);\n    expect(readRelayQueryData.mock.calls[2][2]).toEqual('1');\n  });\n\n  it('should create a new array if the pointer array shortens', () => {\n    var mockResults = {\n      '1': {__dataID__: '1', name: 'One'},\n      '2': {__dataID__: '2', name: 'Two'},\n    };\n    mockReader(mockResults);\n\n    var resolver = new GraphQLStoreQueryResolver(\n      storeData,\n      mockPluralQueryFragment,\n      mockCallback\n    );\n\n    var resolvedA = resolver.resolve(mockPluralQueryFragment, ['1', '2']);\n    var resolvedB = resolver.resolve(mockPluralQueryFragment, ['1']);\n\n    expect(resolvedA).not.toBe(resolvedB);\n\n    expect(resolvedA.length).toBe(2);\n    expect(resolvedB.length).toBe(1);\n  });\n\n  describe('garbage collection', () => {\n    let dataID;\n    let fragment;\n\n    beforeEach(() => {\n      storeData.initializeGarbageCollector(run => {\n        while (run()) {}\n      });\n      const containerFragment = RelayTestUtils.createContainerFragment(Relay.QL`\n        fragment on NewsFeedConnection {\n          edges {\n            node {\n              id\n            }\n          }\n        }\n      `);\n      let concreteFragment = Relay.QL`\n        fragment on Viewer {\n          actor {\n            id\n          }\n          newsFeed(first: \"1\") {\n            ${containerFragment}\n          }\n        }\n      `;\n      const query = getNode(Relay.QL`\n        query {\n          viewer {\n            ${concreteFragment}\n          }\n        }\n      `);\n      const payload = {\n        viewer: {\n          actor: {\n            __typename: 'User',\n            id: '123',\n          },\n          newsFeed: {\n            edges: [\n              {\n                node: {\n                  __typename: 'Story',\n                  id: '456',\n                },\n              },\n            ],\n          },\n        },\n      };\n      storeData.handleQueryPayload(\n        query,\n        transformRelayQueryPayload(query, payload),\n        1\n      );\n      dataID = 'client:1';\n      fragment = getNode(concreteFragment);\n    });\n\n    it('increments references to read data', () => {\n      const queryResolver = new GraphQLStoreQueryResolver(\n        storeData,\n        fragment,\n        jest.genMockFunction()\n      );\n      // read data and set up subscriptions\n      queryResolver.resolve(fragment, dataID);\n      // evict unreferenced nodes\n      storeData.getGarbageCollector().collect();\n      jest.runAllTimers();\n      // nodes referenced by the fragment should not be evicted\n      expect(Object.keys(storeData.getNodeData())).toEqual([\n        '123',      // viewer.actor\n        'client:1', // viewer\n        'client:2', // viewer.newsFeed\n      ]);\n    });\n\n    it('decrements references to previously read fields', () => {\n      const queryResolver = new GraphQLStoreQueryResolver(\n        storeData,\n        fragment,\n        jest.genMockFunction()\n      );\n      // read data and increment GC ref counts\n      queryResolver.resolve(fragment, dataID);\n      const callback =\n        storeData.getChangeEmitter().addListenerForIDs.mock.calls[0][1];\n\n      // Remove the link to viewer.actor and broadcast an update\n      storeData.getRecordWriter().putField('client:1', 'actor', null);\n      storeData.getRecordWriter().putField('client:1', 'newsFeed', null);\n      callback(['client:1']);\n\n      // re-read and increment/decrement GC ref counts\n      queryResolver.resolve(fragment, dataID);\n\n      // evict unreferenced nodes\n      storeData.getGarbageCollector().collect();\n      jest.runAllTimers();\n      // nodes referenced by the fragment should not be evicted\n      expect(Object.keys(storeData.getNodeData())).toEqual([\n        // '123' (actor) is unreferenced and collected\n        // 'client:2' (viewer.newsFeed) is unreferenced and collected\n        'client:1', // viewer\n      ]);\n    });\n\n    it('decrements references when disposed', () => {\n      const queryResolver = new GraphQLStoreQueryResolver(\n        storeData,\n        fragment,\n        jest.genMockFunction()\n      );\n      // read data and increment GC ref counts\n      queryResolver.resolve(fragment, dataID);\n      // reset the resolver; should unreference all nodes\n      queryResolver.dispose();\n\n      // evict unreferenced nodes\n      storeData.getGarbageCollector().collect();\n      jest.runAllTimers();\n      // all nodes are unreferenced and should be removed\n      expect(storeData.getNodeData()).toEqual({});\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLStoreQueryResolver-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLStoreChangeEmitter-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('GraphQLStoreChangeEmitter');\n\nconst ErrorUtils = require('ErrorUtils');\nconst GraphQLStoreChangeEmitter = require('GraphQLStoreChangeEmitter');\nconst GraphQLStoreRangeUtils = require('GraphQLStoreRangeUtils');\n\ndescribe('GraphQLStoreChangeEmitter', () => {\n  var changeEmitter;\n  var mockCallback;\n  var rangeData;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    rangeData = new GraphQLStoreRangeUtils();\n    changeEmitter = new GraphQLStoreChangeEmitter(rangeData);\n\n    rangeData.getCanonicalClientID.mockImplementation(id => id);\n\n    ErrorUtils.applyWithGuard.mockImplementation(callback => {\n      try {\n        callback();\n      } catch (guarded) {}\n    });\n    mockCallback = jest.genMockFunction();\n  });\n\n  it('should broadcast changes asynchronously', () => {\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    expect(mockCallback).not.toBeCalled();\n    jest.runAllTimers();\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should broadcast exclusively to subscribed IDs', () => {\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('bar');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).not.toBeCalled();\n  });\n\n  it('should not broadcast to removed callbacks', () => {\n    changeEmitter.addListenerForIDs(['foo'], mockCallback).remove();\n    changeEmitter.broadcastChangeForID('foo');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).not.toBeCalled();\n  });\n\n  it('should only invoke callbacks subscribed at the time of broadcast', () => {\n    changeEmitter.broadcastChangeForID('foo');\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n\n    jest.runAllTimers();\n\n    expect(mockCallback).not.toBeCalled();\n  });\n\n  it('should only broadcast once per execution loop', () => {\n    changeEmitter.addListenerForIDs(['foo', 'bar'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n    changeEmitter.broadcastChangeForID('bar');\n\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls.length).toBe(1);\n\n    changeEmitter.broadcastChangeForID('bar');\n    changeEmitter.broadcastChangeForID('foo');\n\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls.length).toBe(2);\n  });\n\n  it('should correctly broadcast changes to range IDs', () => {\n    rangeData.getCanonicalClientID.mockImplementation(\n      id => id === 'baz_first(5)' ? 'baz' : id\n    );\n\n    changeEmitter.addListenerForIDs(['baz_first(5)'], mockCallback);\n    changeEmitter.broadcastChangeForID('baz');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should guard against callback errors', () => {\n    var mockThrowingCallback = jest.genMockFunction().mockImplementation(() => {\n      throw new Error();\n    });\n\n    changeEmitter.addListenerForIDs(['foo'], mockThrowingCallback);\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    expect(() => {\n      jest.runAllTimers();\n    }).not.toThrow();\n\n    expect(mockThrowingCallback).toBeCalled();\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should use the injected strategy to batch updates', () => {\n    var mockBatching = false;\n    var mockBatchingStrategy = jest.genMockFunction().mockImplementation(\n      callback => {\n        mockBatching = true;\n        callback();\n        mockBatching = false;\n      }\n    );\n    changeEmitter.injectBatchingStrategy(mockBatchingStrategy);\n\n    mockCallback.mockImplementation(() => {\n      expect(mockBatching).toBe(true);\n    });\n\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    expect(mockBatchingStrategy.mock.calls.length).toBe(0);\n    jest.runAllTimers();\n    expect(mockBatchingStrategy.mock.calls.length).toBe(1);\n  });\n\n  it('schedules changes during broadcasts in the next execution loop', () => {\n    var mockBatchingStrategy = jest.genMockFunction().mockImplementation(\n      callback => callback()\n    );\n    changeEmitter.injectBatchingStrategy(mockBatchingStrategy);\n\n    changeEmitter.addListenerForIDs(['foo'], () => {\n      changeEmitter.broadcastChangeForID('bar');\n    });\n    changeEmitter.addListenerForIDs(['bar'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).toBeCalled();\n    // Jest does not allow running only one tick, so just assert that broadcasts\n    // occurring twice means `mockCallback` was invoked separately.\n    expect(mockBatchingStrategy.mock.calls.length).toBe(2);\n  });\n});\n","dependencies":["ErrorUtils","GraphQLStoreChangeEmitter","GraphQLStoreRangeUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('GraphQLStoreChangeEmitter');\n\nconst ErrorUtils = require('ErrorUtils');\nconst GraphQLStoreChangeEmitter = require('GraphQLStoreChangeEmitter');\nconst GraphQLStoreRangeUtils = require('GraphQLStoreRangeUtils');\n\ndescribe('GraphQLStoreChangeEmitter', () => {\n  var changeEmitter;\n  var mockCallback;\n  var rangeData;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    rangeData = new GraphQLStoreRangeUtils();\n    changeEmitter = new GraphQLStoreChangeEmitter(rangeData);\n\n    rangeData.getCanonicalClientID.mockImplementation(id => id);\n\n    ErrorUtils.applyWithGuard.mockImplementation(callback => {\n      try {\n        callback();\n      } catch (guarded) {}\n    });\n    mockCallback = jest.genMockFunction();\n  });\n\n  it('should broadcast changes asynchronously', () => {\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    expect(mockCallback).not.toBeCalled();\n    jest.runAllTimers();\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should broadcast exclusively to subscribed IDs', () => {\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('bar');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).not.toBeCalled();\n  });\n\n  it('should not broadcast to removed callbacks', () => {\n    changeEmitter.addListenerForIDs(['foo'], mockCallback).remove();\n    changeEmitter.broadcastChangeForID('foo');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).not.toBeCalled();\n  });\n\n  it('should only invoke callbacks subscribed at the time of broadcast', () => {\n    changeEmitter.broadcastChangeForID('foo');\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n\n    jest.runAllTimers();\n\n    expect(mockCallback).not.toBeCalled();\n  });\n\n  it('should only broadcast once per execution loop', () => {\n    changeEmitter.addListenerForIDs(['foo', 'bar'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n    changeEmitter.broadcastChangeForID('bar');\n\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls.length).toBe(1);\n\n    changeEmitter.broadcastChangeForID('bar');\n    changeEmitter.broadcastChangeForID('foo');\n\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls.length).toBe(2);\n  });\n\n  it('should correctly broadcast changes to range IDs', () => {\n    rangeData.getCanonicalClientID.mockImplementation(\n      id => id === 'baz_first(5)' ? 'baz' : id\n    );\n\n    changeEmitter.addListenerForIDs(['baz_first(5)'], mockCallback);\n    changeEmitter.broadcastChangeForID('baz');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should guard against callback errors', () => {\n    var mockThrowingCallback = jest.genMockFunction().mockImplementation(() => {\n      throw new Error();\n    });\n\n    changeEmitter.addListenerForIDs(['foo'], mockThrowingCallback);\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    expect(() => {\n      jest.runAllTimers();\n    }).not.toThrow();\n\n    expect(mockThrowingCallback).toBeCalled();\n    expect(mockCallback).toBeCalled();\n  });\n\n  it('should use the injected strategy to batch updates', () => {\n    var mockBatching = false;\n    var mockBatchingStrategy = jest.genMockFunction().mockImplementation(\n      callback => {\n        mockBatching = true;\n        callback();\n        mockBatching = false;\n      }\n    );\n    changeEmitter.injectBatchingStrategy(mockBatchingStrategy);\n\n    mockCallback.mockImplementation(() => {\n      expect(mockBatching).toBe(true);\n    });\n\n    changeEmitter.addListenerForIDs(['foo'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    expect(mockBatchingStrategy.mock.calls.length).toBe(0);\n    jest.runAllTimers();\n    expect(mockBatchingStrategy.mock.calls.length).toBe(1);\n  });\n\n  it('schedules changes during broadcasts in the next execution loop', () => {\n    var mockBatchingStrategy = jest.genMockFunction().mockImplementation(\n      callback => callback()\n    );\n    changeEmitter.injectBatchingStrategy(mockBatchingStrategy);\n\n    changeEmitter.addListenerForIDs(['foo'], () => {\n      changeEmitter.broadcastChangeForID('bar');\n    });\n    changeEmitter.addListenerForIDs(['bar'], mockCallback);\n    changeEmitter.broadcastChangeForID('foo');\n\n    jest.runAllTimers();\n\n    expect(mockCallback).toBeCalled();\n    // Jest does not allow running only one tick, so just assert that broadcasts\n    // occurring twice means `mockCallback` was invoked separately.\n    expect(mockBatchingStrategy.mock.calls.length).toBe(2);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLStoreChangeEmitter-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLSegment-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('GraphQLSegment');\n\nconst GraphQLSegment = require('GraphQLSegment');\nconst RelayRecord = require('RelayRecord');\n\nRelayRecord.getDataID.mockImplementation(function(data) {\n  return data.__dataID__;\n});\n\nvar edges = [\n  {\n    __dataID__:'edge1',\n    node: {__dataID__: 'id1'},\n    cursor: 'cursor1',\n  }, {\n    __dataID__:'edge2',\n    node: {__dataID__: 'id2'},\n    cursor: 'cursor2',\n  }, {\n    __dataID__:'edge3',\n    node: {__dataID__: 'id3'},\n    cursor: 'cursor3',\n  },\n];\n\nvar moreEdges = [\n  {\n    __dataID__:'edge4',\n    node: {__dataID__: 'id4'},\n    cursor: 'cursor4',\n  }, {\n    __dataID__:'edge5',\n    node: {__dataID__: 'id5'},\n    cursor: 'cursor5',\n  }, {\n    __dataID__:'edge6',\n    node: {__dataID__: 'id6'},\n    cursor: 'cursor6',\n  },\n];\n\nvar lastEdges = [\n  {\n    __dataID__:'edge98',\n    node: {__dataID__: 'id98'},\n    cursor: 'cursor98',\n  }, {\n    __dataID__:'edge99',\n    node: {__dataID__: 'id99'},\n    cursor: 'cursor99',\n  }, {\n    __dataID__:'edge100',\n    node: {__dataID__: 'id100'},\n    cursor: 'cursor100',\n  },\n];\n\nvar beforeLastEdges = [\n  {\n    __dataID__:'edge95',\n    node: {__dataID__: 'id95'},\n    cursor: 'cursor95',\n  }, {\n    __dataID__:'edge96',\n    node: {__dataID__: 'id96'},\n    cursor: 'cursor96',\n  }, {\n    __dataID__:'edge97',\n    node: {__dataID__: 'id97'},\n    cursor: 'cursor97',\n  },\n];\n\nvar oneEdge = {\n  __dataID__:'edgeOneEdge',\n  node: {__dataID__: 'idOneEdge'},\n  cursor: 'cursorOneEdge',\n};\n\nvar anotherEdge = {\n  __dataID__:'edgeAnotherEdge',\n  node: {__dataID__: 'idAnotherEdge'},\n  cursor: 'cursorAnotherEdge',\n};\n\n/**\n * Returns all valid ids and cursors.\n */\nfunction getAllMetadata(segment) {\n  return segment.getMetadataAfterCursor(segment.getLength(), null);\n}\n\ndescribe('GraphQLSegment', () => {\n  var segment;\n  var consoleWarn;\n\n  beforeEach(() => {\n    segment = new GraphQLSegment();\n    consoleWarn = console.warn;\n  });\n\n  afterEach(() => {\n    console.warn = consoleWarn;\n  });\n\n  it('should add after', () => {\n    // Initial add\n    segment.addEdgesAfterCursor(edges, null);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n\n    // Add more\n    segment.addEdgesAfterCursor(moreEdges, 'cursor3');\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5', 'edge6']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5', 'cursor6']\n    );\n\n  });\n\n  it('should add before', () => {\n    // Initial add\n    segment.addEdgesBeforeCursor(lastEdges, null);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge98', 'edge99', 'edge100']);\n    expect(metadata.cursors).toEqual(['cursor98', 'cursor99', 'cursor100']);\n\n    // Add more\n    segment.addEdgesBeforeCursor(beforeLastEdges, 'cursor98');\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge95', 'edge96', 'edge97', 'edge98', 'edge99', 'edge100']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor95', 'cursor96', 'cursor97', 'cursor98', 'cursor99', 'cursor100']\n    );\n\n  });\n\n  it('should handle repeated edges', () => {\n    console.warn = jest.genMockFunction();\n    var repeatedEdges = edges.concat(edges.slice(0, 1));\n\n    // Attempting to add edges 1 2 3 1.\n    segment.addEdgesAfterCursor(repeatedEdges, null);\n    expect(console.warn.mock.calls.length).toBe(1);\n    expect(console.warn).toBeCalledWith(\n      'Attempted to add an ID already in GraphQLSegment: %s',\n      'edge1'\n    );\n\n    // Should have skipped the repeated ones.\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n  });\n\n  it('should prepend', () => {\n    // Prepend on new segment\n    segment.prependEdge(oneEdge);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeOneEdge']);\n    expect(metadata.cursors).toEqual(['cursorOneEdge']);\n\n    // Prepend on segment that already has item\n    segment.prependEdge(anotherEdge);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeAnotherEdge', 'edgeOneEdge']);\n    expect(metadata.cursors).toEqual(['cursorAnotherEdge', 'cursorOneEdge']);\n  });\n\n  it('should append', () => {\n    // Append on new segment\n    segment.appendEdge(oneEdge);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeOneEdge']);\n    expect(metadata.cursors).toEqual(['cursorOneEdge']);\n\n    // Append on segment that already has item\n    segment.appendEdge(anotherEdge);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeOneEdge', 'edgeAnotherEdge']);\n    expect(metadata.cursors).toEqual(['cursorOneEdge', 'cursorAnotherEdge']);\n  });\n\n  it('should retrieve metadata correctly', () => {\n    var before = segment.getMetadataBeforeCursor(\n      segment.getLength(),\n      null\n    );\n    var after = segment.getMetadataAfterCursor(\n      segment.getLength(),\n      null\n    );\n\n    expect(before.edgeIDs).toEqual([]);\n    expect(before.edgeIDs).toEqual(after.edgeIDs);\n    expect(before.cursors).toEqual([]);\n    expect(before.cursors).toEqual(after.cursors);\n\n    segment.addEdgesAfterCursor(edges, null);\n    before = segment.getMetadataBeforeCursor(\n      segment.getLength(),\n      null\n    );\n    after = segment.getMetadataAfterCursor(\n      segment.getLength(),\n      null\n    );\n    expect(before.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(before.edgeIDs).toEqual(after.edgeIDs);\n    expect(before.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n    expect(before.cursors).toEqual(after.cursors);\n  });\n\n  it('should remove', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    // Remove the middle edge\n    segment.removeEdge('edge2');\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor3']);\n  });\n\n  it('should include removed edges in `getLength()` calculation', () => {\n    expect(segment.getCount()).toBe(0);\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getLength()).toBe(3);\n    segment.removeEdge('edge2');\n    expect(segment.getLength()).toBe(3);\n  });\n\n  it('should exclude removed edges from `getCount()` calculation', () => {\n    // with addEdgesAfterCursor\n    expect(segment.getCount()).toBe(0);\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getCount()).toBe(3);\n    segment.removeEdge('edge2');\n    expect(segment.getCount()).toBe(2);\n\n    // with concatSegment\n    var otherSegment = new GraphQLSegment();\n    otherSegment.addEdgesAfterCursor(edges.slice(0, 2), null);\n    expect(otherSegment.getCount()).toBe(2);\n    otherSegment.removeEdge('edge2');\n    expect(otherSegment.getCount()).toBe(1);\n    segment.removeEdge('edge1');\n    otherSegment.concatSegment(segment, null);\n    expect(otherSegment.getCount()).toBe(2);\n  });\n\n  it('rolls back failed concatSegment operations', () => {\n    console.warn = jest.genMockFunction();\n    segment.addEdgesAfterCursor(edges.slice(0, 2), null);\n    expect(segment.getCount()).toBe(2);\n    expect(segment.getLength()).toBe(2);\n\n    var otherSegment = new GraphQLSegment();\n    otherSegment.addEdgesAfterCursor(edges.slice(1, 2), null);\n\n    var concatResult = segment.concatSegment(otherSegment);\n    expect(concatResult).toBe(false);\n    expect(console.warn).toBeCalledWith(\n      'Attempt to concat an ID already in GraphQLSegment: %s',\n      'edge2'\n    );\n    expect(segment.getCount()).toBe(2);\n    expect(segment.getLength()).toBe(2);\n  });\n\n  it('rolls back bumped edges from failed concatSegment operations', () => {\n    console.warn = jest.genMockFunction();\n    segment.addEdgesAfterCursor(edges.slice(0, 2), null);\n    expect(segment.__debug().idToIndices.edge2.length).toBe(1);\n\n    var otherSegment = new GraphQLSegment();\n    var edge2 = edges.slice(1, 2);\n    otherSegment.addEdgesAfterCursor(edge2, null);\n    // bumping the edge\n    otherSegment.removeEdge('edge2', 1001);\n    otherSegment.addEdgesAfterCursor(edge2, null, 1001);\n\n    var concatResult = segment.concatSegment(otherSegment);\n    expect(concatResult).toBe(false);\n    expect(console.warn).toBeCalledWith(\n      'Attempt to concat an ID already in GraphQLSegment: %s',\n      'edge2'\n    );\n    // Make sure it rolled back the deleted edge from indices map\n    expect(segment.__debug().idToIndices.edge2.length).toBe(1);\n  });\n\n  it('should check for valid id in segment', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    // Remove the middle edge\n    segment.removeEdge('edge2');\n\n    // Never added\n    expect(segment.containsEdgeWithID('edge0')).toBeFalsy();\n    // Added\n    expect(segment.containsEdgeWithID('edge1')).toBeTruthy();\n    // Deleted\n    expect(segment.containsEdgeWithID('edge2')).toBeFalsy();\n  });\n\n  it('should check for valid cursor in segment', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    // Remove the middle edge\n    segment.removeEdge('edge2');\n\n    // Never added\n    expect(segment.containsEdgeWithCursor('cursor0')).toBeFalsy();\n    // Added\n    expect(segment.containsEdgeWithCursor('cursor1')).toBeTruthy();\n    // Deleted\n    expect(segment.containsEdgeWithCursor('cursor2')).toBeFalsy();\n  });\n\n  it('should get first and last cursor in segment', () => {\n    // Returns undefined for empty segment\n    expect(segment.getFirstCursor()).toBeUndefined();\n    expect(segment.getLastCursor()).toBeUndefined();\n\n    // Returns property for basic edges\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getFirstCursor()).toEqual('cursor1');\n    expect(segment.getLastCursor()).toEqual('cursor3');\n\n    // Skips over deleted edges\n    segment.removeEdge('edge1');\n    segment.removeEdge('edge3');\n    expect(segment.getFirstCursor()).toEqual('cursor2');\n    expect(segment.getLastCursor()).toEqual('cursor2');\n\n    // Returns undefined when all edges are deleted\n    segment.removeEdge('edge2');\n    expect(segment.getFirstCursor()).toBeUndefined();\n    expect(segment.getLastCursor()).toBeUndefined();\n\n    // Appends and prepends new edges\n    segment.prependEdge(oneEdge);\n    segment.appendEdge(anotherEdge);\n    expect(segment.getFirstCursor()).toEqual('cursorOneEdge');\n    expect(segment.getLastCursor()).toEqual('cursorAnotherEdge');\n\n    // Returns null for null cursors\n    segment = new GraphQLSegment();\n    segment.addEdgesAfterCursor(\n      [{__dataID__: 'edgeid', cursor: null, node: {__dataID__: 'id'}}],\n      null\n    );\n    expect(segment.getFirstCursor()).toBeNull();\n    expect(segment.getLastCursor()).toBeNull();\n  });\n\n  it('should get first and last id in segment', () => {\n    // Returns undefined for empty segment\n    expect(segment.getFirstID()).toBeUndefined();\n    expect(segment.getLastID()).toBeUndefined();\n\n    // Returns property for basic edges\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getFirstID()).toEqual('edge1');\n    expect(segment.getLastID()).toEqual('edge3');\n\n    // Skips over deleted edges\n    segment.removeEdge('edge1');\n    segment.removeEdge('edge3');\n    expect(segment.getFirstID()).toEqual('edge2');\n    expect(segment.getLastID()).toEqual('edge2');\n\n    // Returns undefined when all edges are deleted\n    segment.removeEdge('edge2');\n    expect(segment.getFirstID()).toBeUndefined();\n    expect(segment.getLastID()).toBeUndefined();\n\n    // Appends and prepends new edges\n    segment.prependEdge(oneEdge);\n    segment.appendEdge(anotherEdge);\n    expect(segment.getFirstID()).toEqual('edgeOneEdge');\n    expect(segment.getLastID()).toEqual('edgeAnotherEdge');\n  });\n\n  it('should concat segments', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    var segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(moreEdges, null);\n    var concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5', 'edge6']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5', 'cursor6']\n    );\n  });\n\n  it('should concat with empty segments', () => {\n    var segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(edges, null);\n    // Concatenating from an empty segment\n    var concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n\n    var segment3 = new GraphQLSegment();\n    // Concatenating empty segment\n    concatenated = segment.concatSegment(segment3);\n    expect(concatenated).toBe(true);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n  });\n\n  it('should concat with deleted edges', () => {\n    // Makes sure we update cursor and id to index map correctly\n    // based on removal time.\n    var edges345 = [\n      {\n        __dataID__: 'edge3',\n        node: {__dataID__: 'id3'},\n        cursor: 'cursor3',\n      }, {\n        __dataID__: 'edge4',\n        node: {__dataID__: 'id4'},\n        cursor: 'cursor4',\n      }, {\n        __dataID__: 'edge5',\n        node: {__dataID__: 'id5'},\n        cursor: 'cursor5',\n      },\n    ];\n\n    // deleted edge in the original segment\n    segment.addEdgesAfterCursor(edges, null);\n    segment.removeEdge('edge3');\n    var segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(edges345, null);\n    var concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5']\n    );\n    expect(segment.containsEdgeWithID('edge3')).toBe(true);\n    expect(segment.containsEdgeWithCursor('cursor3')).toBe(true);\n\n    // deleted edge in the input segment\n    segment = new GraphQLSegment();\n    segment.addEdgesAfterCursor(edges, null);\n    segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(edges345, null);\n    segment2.removeEdge('edge3');\n    concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5']\n    );\n    expect(segment.containsEdgeWithID('edge3')).toBe(true);\n    expect(segment.containsEdgeWithCursor('cursor3')).toBe(true);\n  });\n\n  it('should toJSON', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    var actual = JSON.stringify(segment);\n    expect(actual).toEqual('[{\"0\":{\"edgeID\":\"edge1\",\"cursor\":\"cursor1\",' +\n      '\"deleted\":false},\"1\":{\"edgeID\":\"edge2\",\"cursor\":\"cursor2\",' +\n      '\"deleted\":false},\"2\":{\"edgeID\":\"edge3\",\"cursor\":\"cursor3\",\"deleted\"' +\n      ':false}},{\"edge1\":[0],\"edge2\":[1],\"edge3\":[2]},{\"cursor1\":0,' +\n      '\"cursor2\":1,\"cursor3\":2},0,2,3]'\n    );\n\n    segment = GraphQLSegment.fromJSON(JSON.parse(actual));\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n  });\n});\n","dependencies":["GraphQLSegment","RelayRecord"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('GraphQLSegment');\n\nconst GraphQLSegment = require('GraphQLSegment');\nconst RelayRecord = require('RelayRecord');\n\nRelayRecord.getDataID.mockImplementation(function(data) {\n  return data.__dataID__;\n});\n\nvar edges = [\n  {\n    __dataID__:'edge1',\n    node: {__dataID__: 'id1'},\n    cursor: 'cursor1',\n  }, {\n    __dataID__:'edge2',\n    node: {__dataID__: 'id2'},\n    cursor: 'cursor2',\n  }, {\n    __dataID__:'edge3',\n    node: {__dataID__: 'id3'},\n    cursor: 'cursor3',\n  },\n];\n\nvar moreEdges = [\n  {\n    __dataID__:'edge4',\n    node: {__dataID__: 'id4'},\n    cursor: 'cursor4',\n  }, {\n    __dataID__:'edge5',\n    node: {__dataID__: 'id5'},\n    cursor: 'cursor5',\n  }, {\n    __dataID__:'edge6',\n    node: {__dataID__: 'id6'},\n    cursor: 'cursor6',\n  },\n];\n\nvar lastEdges = [\n  {\n    __dataID__:'edge98',\n    node: {__dataID__: 'id98'},\n    cursor: 'cursor98',\n  }, {\n    __dataID__:'edge99',\n    node: {__dataID__: 'id99'},\n    cursor: 'cursor99',\n  }, {\n    __dataID__:'edge100',\n    node: {__dataID__: 'id100'},\n    cursor: 'cursor100',\n  },\n];\n\nvar beforeLastEdges = [\n  {\n    __dataID__:'edge95',\n    node: {__dataID__: 'id95'},\n    cursor: 'cursor95',\n  }, {\n    __dataID__:'edge96',\n    node: {__dataID__: 'id96'},\n    cursor: 'cursor96',\n  }, {\n    __dataID__:'edge97',\n    node: {__dataID__: 'id97'},\n    cursor: 'cursor97',\n  },\n];\n\nvar oneEdge = {\n  __dataID__:'edgeOneEdge',\n  node: {__dataID__: 'idOneEdge'},\n  cursor: 'cursorOneEdge',\n};\n\nvar anotherEdge = {\n  __dataID__:'edgeAnotherEdge',\n  node: {__dataID__: 'idAnotherEdge'},\n  cursor: 'cursorAnotherEdge',\n};\n\n/**\n * Returns all valid ids and cursors.\n */\nfunction getAllMetadata(segment) {\n  return segment.getMetadataAfterCursor(segment.getLength(), null);\n}\n\ndescribe('GraphQLSegment', () => {\n  var segment;\n  var consoleWarn;\n\n  beforeEach(() => {\n    segment = new GraphQLSegment();\n    consoleWarn = console.warn;\n  });\n\n  afterEach(() => {\n    console.warn = consoleWarn;\n  });\n\n  it('should add after', () => {\n    // Initial add\n    segment.addEdgesAfterCursor(edges, null);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n\n    // Add more\n    segment.addEdgesAfterCursor(moreEdges, 'cursor3');\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5', 'edge6']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5', 'cursor6']\n    );\n\n  });\n\n  it('should add before', () => {\n    // Initial add\n    segment.addEdgesBeforeCursor(lastEdges, null);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge98', 'edge99', 'edge100']);\n    expect(metadata.cursors).toEqual(['cursor98', 'cursor99', 'cursor100']);\n\n    // Add more\n    segment.addEdgesBeforeCursor(beforeLastEdges, 'cursor98');\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge95', 'edge96', 'edge97', 'edge98', 'edge99', 'edge100']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor95', 'cursor96', 'cursor97', 'cursor98', 'cursor99', 'cursor100']\n    );\n\n  });\n\n  it('should handle repeated edges', () => {\n    console.warn = jest.genMockFunction();\n    var repeatedEdges = edges.concat(edges.slice(0, 1));\n\n    // Attempting to add edges 1 2 3 1.\n    segment.addEdgesAfterCursor(repeatedEdges, null);\n    expect(console.warn.mock.calls.length).toBe(1);\n    expect(console.warn).toBeCalledWith(\n      'Attempted to add an ID already in GraphQLSegment: %s',\n      'edge1'\n    );\n\n    // Should have skipped the repeated ones.\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n  });\n\n  it('should prepend', () => {\n    // Prepend on new segment\n    segment.prependEdge(oneEdge);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeOneEdge']);\n    expect(metadata.cursors).toEqual(['cursorOneEdge']);\n\n    // Prepend on segment that already has item\n    segment.prependEdge(anotherEdge);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeAnotherEdge', 'edgeOneEdge']);\n    expect(metadata.cursors).toEqual(['cursorAnotherEdge', 'cursorOneEdge']);\n  });\n\n  it('should append', () => {\n    // Append on new segment\n    segment.appendEdge(oneEdge);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeOneEdge']);\n    expect(metadata.cursors).toEqual(['cursorOneEdge']);\n\n    // Append on segment that already has item\n    segment.appendEdge(anotherEdge);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edgeOneEdge', 'edgeAnotherEdge']);\n    expect(metadata.cursors).toEqual(['cursorOneEdge', 'cursorAnotherEdge']);\n  });\n\n  it('should retrieve metadata correctly', () => {\n    var before = segment.getMetadataBeforeCursor(\n      segment.getLength(),\n      null\n    );\n    var after = segment.getMetadataAfterCursor(\n      segment.getLength(),\n      null\n    );\n\n    expect(before.edgeIDs).toEqual([]);\n    expect(before.edgeIDs).toEqual(after.edgeIDs);\n    expect(before.cursors).toEqual([]);\n    expect(before.cursors).toEqual(after.cursors);\n\n    segment.addEdgesAfterCursor(edges, null);\n    before = segment.getMetadataBeforeCursor(\n      segment.getLength(),\n      null\n    );\n    after = segment.getMetadataAfterCursor(\n      segment.getLength(),\n      null\n    );\n    expect(before.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(before.edgeIDs).toEqual(after.edgeIDs);\n    expect(before.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n    expect(before.cursors).toEqual(after.cursors);\n  });\n\n  it('should remove', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    // Remove the middle edge\n    segment.removeEdge('edge2');\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor3']);\n  });\n\n  it('should include removed edges in `getLength()` calculation', () => {\n    expect(segment.getCount()).toBe(0);\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getLength()).toBe(3);\n    segment.removeEdge('edge2');\n    expect(segment.getLength()).toBe(3);\n  });\n\n  it('should exclude removed edges from `getCount()` calculation', () => {\n    // with addEdgesAfterCursor\n    expect(segment.getCount()).toBe(0);\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getCount()).toBe(3);\n    segment.removeEdge('edge2');\n    expect(segment.getCount()).toBe(2);\n\n    // with concatSegment\n    var otherSegment = new GraphQLSegment();\n    otherSegment.addEdgesAfterCursor(edges.slice(0, 2), null);\n    expect(otherSegment.getCount()).toBe(2);\n    otherSegment.removeEdge('edge2');\n    expect(otherSegment.getCount()).toBe(1);\n    segment.removeEdge('edge1');\n    otherSegment.concatSegment(segment, null);\n    expect(otherSegment.getCount()).toBe(2);\n  });\n\n  it('rolls back failed concatSegment operations', () => {\n    console.warn = jest.genMockFunction();\n    segment.addEdgesAfterCursor(edges.slice(0, 2), null);\n    expect(segment.getCount()).toBe(2);\n    expect(segment.getLength()).toBe(2);\n\n    var otherSegment = new GraphQLSegment();\n    otherSegment.addEdgesAfterCursor(edges.slice(1, 2), null);\n\n    var concatResult = segment.concatSegment(otherSegment);\n    expect(concatResult).toBe(false);\n    expect(console.warn).toBeCalledWith(\n      'Attempt to concat an ID already in GraphQLSegment: %s',\n      'edge2'\n    );\n    expect(segment.getCount()).toBe(2);\n    expect(segment.getLength()).toBe(2);\n  });\n\n  it('rolls back bumped edges from failed concatSegment operations', () => {\n    console.warn = jest.genMockFunction();\n    segment.addEdgesAfterCursor(edges.slice(0, 2), null);\n    expect(segment.__debug().idToIndices.edge2.length).toBe(1);\n\n    var otherSegment = new GraphQLSegment();\n    var edge2 = edges.slice(1, 2);\n    otherSegment.addEdgesAfterCursor(edge2, null);\n    // bumping the edge\n    otherSegment.removeEdge('edge2', 1001);\n    otherSegment.addEdgesAfterCursor(edge2, null, 1001);\n\n    var concatResult = segment.concatSegment(otherSegment);\n    expect(concatResult).toBe(false);\n    expect(console.warn).toBeCalledWith(\n      'Attempt to concat an ID already in GraphQLSegment: %s',\n      'edge2'\n    );\n    // Make sure it rolled back the deleted edge from indices map\n    expect(segment.__debug().idToIndices.edge2.length).toBe(1);\n  });\n\n  it('should check for valid id in segment', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    // Remove the middle edge\n    segment.removeEdge('edge2');\n\n    // Never added\n    expect(segment.containsEdgeWithID('edge0')).toBeFalsy();\n    // Added\n    expect(segment.containsEdgeWithID('edge1')).toBeTruthy();\n    // Deleted\n    expect(segment.containsEdgeWithID('edge2')).toBeFalsy();\n  });\n\n  it('should check for valid cursor in segment', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    // Remove the middle edge\n    segment.removeEdge('edge2');\n\n    // Never added\n    expect(segment.containsEdgeWithCursor('cursor0')).toBeFalsy();\n    // Added\n    expect(segment.containsEdgeWithCursor('cursor1')).toBeTruthy();\n    // Deleted\n    expect(segment.containsEdgeWithCursor('cursor2')).toBeFalsy();\n  });\n\n  it('should get first and last cursor in segment', () => {\n    // Returns undefined for empty segment\n    expect(segment.getFirstCursor()).toBeUndefined();\n    expect(segment.getLastCursor()).toBeUndefined();\n\n    // Returns property for basic edges\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getFirstCursor()).toEqual('cursor1');\n    expect(segment.getLastCursor()).toEqual('cursor3');\n\n    // Skips over deleted edges\n    segment.removeEdge('edge1');\n    segment.removeEdge('edge3');\n    expect(segment.getFirstCursor()).toEqual('cursor2');\n    expect(segment.getLastCursor()).toEqual('cursor2');\n\n    // Returns undefined when all edges are deleted\n    segment.removeEdge('edge2');\n    expect(segment.getFirstCursor()).toBeUndefined();\n    expect(segment.getLastCursor()).toBeUndefined();\n\n    // Appends and prepends new edges\n    segment.prependEdge(oneEdge);\n    segment.appendEdge(anotherEdge);\n    expect(segment.getFirstCursor()).toEqual('cursorOneEdge');\n    expect(segment.getLastCursor()).toEqual('cursorAnotherEdge');\n\n    // Returns null for null cursors\n    segment = new GraphQLSegment();\n    segment.addEdgesAfterCursor(\n      [{__dataID__: 'edgeid', cursor: null, node: {__dataID__: 'id'}}],\n      null\n    );\n    expect(segment.getFirstCursor()).toBeNull();\n    expect(segment.getLastCursor()).toBeNull();\n  });\n\n  it('should get first and last id in segment', () => {\n    // Returns undefined for empty segment\n    expect(segment.getFirstID()).toBeUndefined();\n    expect(segment.getLastID()).toBeUndefined();\n\n    // Returns property for basic edges\n    segment.addEdgesAfterCursor(edges, null);\n    expect(segment.getFirstID()).toEqual('edge1');\n    expect(segment.getLastID()).toEqual('edge3');\n\n    // Skips over deleted edges\n    segment.removeEdge('edge1');\n    segment.removeEdge('edge3');\n    expect(segment.getFirstID()).toEqual('edge2');\n    expect(segment.getLastID()).toEqual('edge2');\n\n    // Returns undefined when all edges are deleted\n    segment.removeEdge('edge2');\n    expect(segment.getFirstID()).toBeUndefined();\n    expect(segment.getLastID()).toBeUndefined();\n\n    // Appends and prepends new edges\n    segment.prependEdge(oneEdge);\n    segment.appendEdge(anotherEdge);\n    expect(segment.getFirstID()).toEqual('edgeOneEdge');\n    expect(segment.getLastID()).toEqual('edgeAnotherEdge');\n  });\n\n  it('should concat segments', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    var segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(moreEdges, null);\n    var concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5', 'edge6']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5', 'cursor6']\n    );\n  });\n\n  it('should concat with empty segments', () => {\n    var segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(edges, null);\n    // Concatenating from an empty segment\n    var concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n\n    var segment3 = new GraphQLSegment();\n    // Concatenating empty segment\n    concatenated = segment.concatSegment(segment3);\n    expect(concatenated).toBe(true);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n  });\n\n  it('should concat with deleted edges', () => {\n    // Makes sure we update cursor and id to index map correctly\n    // based on removal time.\n    var edges345 = [\n      {\n        __dataID__: 'edge3',\n        node: {__dataID__: 'id3'},\n        cursor: 'cursor3',\n      }, {\n        __dataID__: 'edge4',\n        node: {__dataID__: 'id4'},\n        cursor: 'cursor4',\n      }, {\n        __dataID__: 'edge5',\n        node: {__dataID__: 'id5'},\n        cursor: 'cursor5',\n      },\n    ];\n\n    // deleted edge in the original segment\n    segment.addEdgesAfterCursor(edges, null);\n    segment.removeEdge('edge3');\n    var segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(edges345, null);\n    var concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5']\n    );\n    expect(segment.containsEdgeWithID('edge3')).toBe(true);\n    expect(segment.containsEdgeWithCursor('cursor3')).toBe(true);\n\n    // deleted edge in the input segment\n    segment = new GraphQLSegment();\n    segment.addEdgesAfterCursor(edges, null);\n    segment2 = new GraphQLSegment();\n    segment2.addEdgesAfterCursor(edges345, null);\n    segment2.removeEdge('edge3');\n    concatenated = segment.concatSegment(segment2);\n    expect(concatenated).toBe(true);\n    metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(\n      ['edge1', 'edge2', 'edge3', 'edge4', 'edge5']\n    );\n    expect(metadata.cursors).toEqual(\n      ['cursor1', 'cursor2', 'cursor3', 'cursor4', 'cursor5']\n    );\n    expect(segment.containsEdgeWithID('edge3')).toBe(true);\n    expect(segment.containsEdgeWithCursor('cursor3')).toBe(true);\n  });\n\n  it('should toJSON', () => {\n    segment.addEdgesAfterCursor(edges, null);\n    var actual = JSON.stringify(segment);\n    expect(actual).toEqual('[{\"0\":{\"edgeID\":\"edge1\",\"cursor\":\"cursor1\",' +\n      '\"deleted\":false},\"1\":{\"edgeID\":\"edge2\",\"cursor\":\"cursor2\",' +\n      '\"deleted\":false},\"2\":{\"edgeID\":\"edge3\",\"cursor\":\"cursor3\",\"deleted\"' +\n      ':false}},{\"edge1\":[0],\"edge2\":[1],\"edge3\":[2]},{\"cursor1\":0,' +\n      '\"cursor2\":1,\"cursor3\":2},0,2,3]'\n    );\n\n    segment = GraphQLSegment.fromJSON(JSON.parse(actual));\n    var metadata = getAllMetadata(segment);\n    expect(metadata.edgeIDs).toEqual(['edge1', 'edge2', 'edge3']);\n    expect(metadata.cursors).toEqual(['cursor1', 'cursor2', 'cursor3']);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLSegment-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLRange-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayTestUtils = require('RelayTestUtils');\n\njest\n  .dontMock('GraphQLSegment')\n  .dontMock('GraphQLRange')\n  .mock('warning');\n\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayRecord = require('RelayRecord');\n\nfunction getFirstSegment(range) {\n  return range.__debug().orderedSegments[0];\n}\n\nfunction getLastSegment(range) {\n  var orderedSegments = range.__debug().orderedSegments;\n  return orderedSegments[orderedSegments.length - 1];\n}\n\nfunction mockEdge(id, hasNullCursor) {\n  var dataID = 'edge' + (hasNullCursor ? 'WithNullCursor' : '') + id;\n  var edge = {\n    __dataID__: dataID,\n    node: {__dataID__: 'id' + id},\n    cursor: (hasNullCursor ? null : 'cursor' + id),\n  };\n  return edge;\n}\n\nvar edgeNeg10 = mockEdge('-10');\nvar edgeNeg9 = mockEdge('-9');\nvar edgeNeg3 = mockEdge('-3');\nvar edgeNeg2 = mockEdge('-2');\nvar edgeNeg1 = mockEdge('-1');\nvar edge0 = mockEdge('0');\nvar edge1 = mockEdge('1');\nvar edge2 = mockEdge('2');\nvar edge3 = mockEdge('3');\nvar edge4 = mockEdge('4');\nvar edge5 = mockEdge('5');\nvar edge96 = mockEdge('96');\nvar edge97 = mockEdge('97');\nvar edge98 = mockEdge('98');\nvar edge99 = mockEdge('99');\nvar edge100 = mockEdge('100');\nvar edge101 = mockEdge('101');\nvar edge102 = mockEdge('102');\nvar edge103 = mockEdge('103');\nvar edge104 = mockEdge('104');\nvar edge110 = mockEdge('110');\nvar edge111 = mockEdge('111');\nvar edgeWithNullCursor1 = mockEdge('1', true);\nvar edgeWithNullCursor2 = mockEdge('2', true);\nvar edgeWithNullCursor3 = mockEdge('3', true);\n\nvar first3Edges = [edge1, edge2, edge3];\nvar first5Edges = [edge1, edge2, edge3, edge4, edge5];\nvar last3Edges = [edge98, edge99, edge100];\nvar last5Edges = [edge96, edge97, edge98, edge99, edge100];\n\ndescribe('GraphQLRange', () => {\n  var consoleError;\n  var consoleWarn;\n  var range;\n\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    consoleError = console.error;\n    consoleWarn = console.warn;\n\n    RelayRecord.getDataID.mockImplementation(function(data) {\n      return data.__dataID__;\n    });\n    range = new GraphQLRange();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  afterEach(() => {\n    console.error = consoleError;\n    console.warn = consoleWarn;\n  });\n\n  it('should add for first() query', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for after().first() query', () => {\n    var queryCalls = [\n      {name: 'after', value: null},\n      {name: 'first', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      queryCalls,\n      first3Edges,\n      pageInfo\n    );\n\n    var incrementalEdges = [edge4, edge5];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    queryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ];\n    range.addItems(\n      queryCalls,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'after', value: null},\n      {name: 'first', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge4.__dataID__,\n      edge5.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for after().first() query in last segment', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'first', value: 2},\n    ];\n    var incrementalEdges = [edge101, edge102];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n      edge101.__dataID__,\n      edge102.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for before().first() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n\n    var incrementalEdges = [edgeNeg1, edge0];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n    // Request the full set to make sure it is stitched properly\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edgeNeg1.__dataID__,\n      edge0.__dataID__,\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for before().first() query with gap', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n\n    var incrementalEdges = [edgeNeg10, edgeNeg9];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n    // Request super set\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edgeNeg10.__dataID__, edgeNeg9.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor-9'},\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 3},\n    ]);\n\n  });\n\n  it('should add for last() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery(queryCalls, {count: 3});\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for before().last() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edge96, edge97];\n\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge96.__dataID__,\n      edge97.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for before().last() query in first segment', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edgeNeg1, edge0];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edgeNeg1.__dataID__,\n      edge0.__dataID__,\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for after().last() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    var incrementalQueryCall = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edge101, edge102];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n      edge101.__dataID__,\n      edge102.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for after().last() with gap', () => {\n    var queryCalls = [\n      {name: 'after', value: null},\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    queryCalls = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ];\n    range.addItems(\n      queryCalls,\n      [edge110, edge111],\n      {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: true}\n    );\n\n    // Request the super set\n    queryCalls = [\n      {name: 'after', value: null},\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge110.__dataID__, edge111.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor110'},\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 3},\n    ]);\n  });\n\n  it('should error for invalid call value', () => {\n    console.error = jest.genMockFunction();\n    var queryCalls = [\n      {name: 'first', value: 0},\n    ];\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(console.error.mock.calls.length).toBe(1);\n    expect(console.error.mock.calls[0]).toEqual([\n      'GraphQLRange only supports first(<count>) or last(<count>) ' +\n      'where count is greater than 0',\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve for first() queries', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    // Request from empty range\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([{name: 'first', value: 3}]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request the full set\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a subset\n    queryCalls = [\n      {name: 'first', value: 2},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a superset\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n  });\n\n  it('should retrieve for after().first() queries', () => {\n    var queryCalls = [\n      {name: 'after', value: null},\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      queryCalls,\n      first3Edges,\n      pageInfo\n    );\n\n    // Request a subset with after\n    queryCalls = [\n      {name: 'after', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a superset with after\n    queryCalls = [\n      {name: 'after', value: 'cursor1'},\n      {name: 'first', value: 5},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 3},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a non-intersecting superset with after\n    queryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n  });\n\n  it('should retrieve for last() queries', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    // Request the from empty range\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([{name: 'last', value: 3}]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request the full set\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a subset\n    queryCalls = [{name: 'last', value: 2}];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Requst a superset\n    queryCalls = [{name: 'last', value: 5}];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n  });\n\n  it('should retrieve for before().last() queries', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request a subset with before\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor100'},\n      {name: 'last', value: 5},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 3},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a non-intersecting superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n  });\n\n  it('should retrieve for after().first() from last segment', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request a subset with after\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'after', value: 'cursor98'},\n      {name: 'first', value: 1},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([edge99.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a superset with after\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'after', value: 'cursor98'},\n      {name: 'first', value: 5},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a non-intersecting superset with after\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'after', value: 'cursor100'},\n      {name: 'first', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n  });\n\n  it('should retrieve for before().last() from first segment', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request a subset with before\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor3'},\n      {name: 'last', value: 1},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([edge2.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor3'},\n      {name: 'last', value: 5},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a non-intersecting superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor1'},\n      {name: 'last', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n  });\n\n  it('should support calls with no arguments', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n      {name: 'dummy_call', value: null},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 3},\n      {name: 'dummy_call', value: null},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support nodes with null cursors', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    var first3EdgesWithNullCursors = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    range.addItems(queryCalls, first3EdgesWithNullCursors, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 3},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n      'edgeWithNullCursor3',\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support prepending edge to range', () => {\n    // Prepend on new range\n    range.prependEdge(edge2);\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 1},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([edge2.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Prepend on range that already has edge\n    range.prependEdge(edge1);\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 2},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support appending edge to range', () => {\n    // Append on new range\n    range.appendEdge(edge1);\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 1},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([edge1.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Append on range that already has an edge\n    range.appendEdge(edge2);\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 2},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support bumping', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var afterQueryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ];\n\n    // Testing add after: adding id2 to end of range\n    range.addItems(afterQueryCalls, [first3Edges[1]], pageInfo);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // Testing prepend: adding id3 to the front of the range\n    range.prependEdge(first3Edges[2]);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge3.__dataID__, edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var beforeQueryCalls = [\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 1},\n    ];\n\n    // Testing add before: adding id99 to end of range\n    range.addItems(beforeQueryCalls, [last3Edges[1]], pageInfo);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge98.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // Testing append: adding id98 to the end of the range\n    range.appendEdge(last3Edges[0]);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__, edge98.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should not generate diff query when range is empty', () => {\n    var queryFirstCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var queryLastCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    // Add empty first edges\n    range.addItems(queryFirstCalls, [], pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryFirstCalls);\n    expect(result.diffCalls.length).toBe(0);\n    result = range.retrieveRangeInfoForQuery(queryLastCalls);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Add empty last edges\n    range = new GraphQLRange();\n    range.addItems(queryLastCalls, [], pageInfo);\n\n    result = range.retrieveRangeInfoForQuery(queryFirstCalls);\n    expect(result.diffCalls.length).toBe(0);\n    result = range.retrieveRangeInfoForQuery(queryLastCalls);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should collesce segments when we reach end', () => {\n    var queryFirstCalls = [\n      {name: 'first', value: 1},\n    ];\n\n    var queryLastCalls = [\n      {name: 'last', value: 1},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryFirstCalls, [edge1], pageInfo);\n    range.addItems(queryLastCalls, [edge1], pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryFirstCalls);\n    expect(result.requestedEdgeIDs).toEqual([edge1.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n    result = range.retrieveRangeInfoForQuery(queryLastCalls);\n    expect(result.requestedEdgeIDs).toEqual([edge1.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should not generate diff query when there is no more', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    var beforeQueryCalls = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'last', value: 1},\n    ];\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(beforeQueryCalls);\n    // We know there is no more before cursor1 since that is the first edge\n    expect(result.diffCalls.length).toBe(0);\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    var afterQueryCalls = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'first', value: 1},\n    ];\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(afterQueryCalls);\n    // We know there is no more after cursor100 since that is the last edge\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add  and retrieve for surrounds() query', () => {\n    var queryCalls = [\n      {name: 'surrounds', value: ['id2', 1]},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should not return surrounds query data for first query', () => {\n    var surroundQueryCalls = [\n      {name: 'surrounds', value: ['id2', 1]},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(surroundQueryCalls, first3Edges, pageInfo);\n\n    var firstQueryCalls = [\n      {name: 'first', value: 5},\n    ];\n\n    var resultForFirstQuery = range.retrieveRangeInfoForQuery(\n      firstQueryCalls,\n    );\n\n    expect(resultForFirstQuery.requestedEdgeIDs).toEqual([]);\n    expect(resultForFirstQuery.diffCalls).toEqual(firstQueryCalls);\n  });\n\n  it('should warn when reconciling conflicting first() ranges', () => {\n    console.error = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, [edge1, edge2, edge3], pageInfo);\n    range.addItems(queryCalls, [edge1, edge3, edge4], pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect([\n      'Relay was unable to reconcile edges on a connection. This most ' +\n      'likely occurred while trying to handle a server response that ' +\n      'includes connection edges with nodes that lack an `id` field.',\n    ]).toBeWarnedNTimes(1);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n  });\n\n  it('should warn when reconciling conflicting last() ranges', () => {\n    console.error = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    // Add items twice\n    range.addItems(queryCalls, [edge98, edge99, edge100], pageInfo);\n    range.addItems(queryCalls, [edge98, edge1, edge100], pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect([\n      'Relay was unable to reconcile edges on a connection. This most ' +\n      'likely occurred while trying to handle a server response that ' +\n      'includes connection edges with nodes that lack an `id` field.',\n    ]).toBeWarnedNTimes(1);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n  });\n\n  it('should reconcile duplicated queries', () => {\n    console.error = jest.genMockFunction();\n    console.warn = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    // Add items twice\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    // Add items twice\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n  });\n\n  it('should reconcile duplicated queries with no cursor', () => {\n    console.error = jest.genMockFunction();\n    console.warn = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    const e1 = mockEdge('1', true);\n    const e2 = mockEdge('2', true);\n    const e3 = mockEdge('3', true);\n\n    var edges = [e1, e2, e3];\n\n    // Add items twice\n    range.addItems(queryCalls, edges, pageInfo);\n    range.addItems(queryCalls, edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [e1.__dataID__, e2.__dataID__, e3.__dataID__]\n    );\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    const e100 = mockEdge('100', true);\n    const e99 = mockEdge('99', true);\n    const e98 = mockEdge('98', true);\n\n    edges = [e98, e99, e100];\n\n    // Add items twice\n    range.addItems(queryCalls, edges, pageInfo);\n    range.addItems(queryCalls, edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [e98.__dataID__, e99.__dataID__, e100.__dataID__]\n    );\n  });\n\n  it('should reconcile extending queries', () => {\n    console.error = jest.genMockFunction();\n    console.warn = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    range.addItems(queryCalls, first5Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge4.__dataID__,\n      edge5.__dataID__,\n    ]);\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    range.addItems(queryCalls, last5Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge96.__dataID__,\n      edge97.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n  });\n\n  it('should stitch first and last segment', () => {\n    var firstQueryCalls = [\n      {name: 'first', value: 3},\n    ];\n    var lastQueryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(firstQueryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(lastQueryCalls);\n\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'last', value: 3},\n    ]);\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(result.diffCalls, last3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n\n    range = new GraphQLRange();\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(lastQueryCalls, last3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(firstQueryCalls);\n\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'first', value: 3},\n    ]);\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(result.diffCalls, first3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n  });\n\n  it('should stitch up gap in first segment', () => {\n    // Add initial edges\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    // Create gap\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n    var incrementalEdges = [edgeNeg3, edgeNeg2];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 5},\n    ]);\n    var diffCalls = result.diffCalls;\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor-2'},\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 3},\n    ]);\n\n    // Fill in gap\n    var gapEdges = [edgeNeg1, edge0];\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(diffCalls, gapEdges, pageInfo);\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 5},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([\n      edgeNeg3.__dataID__,\n      edgeNeg2.__dataID__,\n      edgeNeg1.__dataID__,\n      edge0.__dataID__,\n      edge1.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should stitch up gap in last segment', () => {\n    // Add initial edges\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    // Create gap\n    var incrementalQueryCall = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edge103, edge104];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 5},\n    ]);\n    var diffCalls = result.diffCalls;\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor103'},\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 3},\n    ]);\n\n    // Fill in gap\n    var gapEdges = [edge101, edge102];\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(diffCalls, gapEdges, pageInfo);\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 5},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge100.__dataID__,\n      edge101.__dataID__,\n      edge102.__dataID__,\n      edge103.__dataID__,\n      edge104.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should refetch for whole ranges for null cursor', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    range.addItems(queryCalls, nullCursorEdges, pageInfo);\n    var five = [{name: 'first', value: 5}];\n    var result = range.retrieveRangeInfoForQuery(five);\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n      'edgeWithNullCursor3',\n    ]);\n    expect(result.diffCalls).toEqual(five);\n  });\n\n  it('replaces whole first() ranges when working with null cursors', () => {\n    var queryCalls = [\n      {name: 'first', value: 1},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    // we don't replace empty ranges\n    var segment = getFirstSegment(range);\n    range.addItems(queryCalls, nullCursorEdges.slice(0, 1), pageInfo);\n    expect(segment).toBe(getFirstSegment(range));\n\n    // if we request more results but get the same number, we replace\n    // (in case there were deleted items, different items, or reordering)\n    var three = [{name: 'first', value: 3}];\n    range.addItems(three, nullCursorEdges.slice(0, 1), pageInfo);\n    expect(segment).not.toBe(getFirstSegment(range));\n\n    // if the range has gotten bigger, we replace it\n    segment = getFirstSegment(range);\n    range.addItems(three, nullCursorEdges, pageInfo);\n    expect(segment).not.toBe(getFirstSegment(range));\n\n    // if the range has gotten bigger but has cursor info, we don't replace it\n    var cursorEdges = [\n      edge0,\n      edge1,\n      edge2,\n    ];\n    range = new GraphQLRange();\n    segment = getFirstSegment(range);\n    range.addItems(queryCalls, cursorEdges.slice(0, 1), pageInfo);\n    expect(segment).toBe(getFirstSegment(range));\n    range.addItems(three, cursorEdges, pageInfo);\n    expect(segment).toBe(getFirstSegment(range));\n  });\n\n  it('replaces whole last() ranges when working with null cursors', () => {\n    var queryCalls = [\n      {name: 'last', value: 1},\n    ];\n\n    var pageInfo = {\n      [HAS_PREV_PAGE]: true,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    // we don't replace empty ranges\n    var segment = getLastSegment(range);\n    range.addItems(queryCalls, nullCursorEdges.slice(2), pageInfo);\n    expect(segment).toBe(getLastSegment(range));\n\n    // if we request more results but get the same number, we replace\n    // (in case there were deleted items, different items, or reordering)\n    var three = [{name: 'last', value: 3}];\n    range.addItems(three, nullCursorEdges.slice(2), pageInfo);\n    expect(segment).not.toBe(getLastSegment(range));\n\n    // if the range has gotten bigger, we replace it\n    segment = getLastSegment(range);\n    range.addItems(three, nullCursorEdges, pageInfo);\n    expect(segment).not.toBe(getLastSegment(range));\n\n    // if the range has gotten bigger but has cursor info, we don't replace it\n    var cursorEdges = [\n      edge0,\n      edge1,\n      edge2,\n    ];\n    range = new GraphQLRange();\n    segment = getLastSegment(range);\n    range.addItems(queryCalls, cursorEdges.slice(2), pageInfo);\n    expect(segment).toBe(getLastSegment(range));\n    range.addItems(three, cursorEdges, pageInfo);\n    expect(segment).toBe(getLastSegment(range));\n  });\n\n  it('should retrieve correct page_info for ranges with null cursors', () => {\n    var two = [{name: 'first', value: 2}];\n    var three = [{name: 'first', value: 3}];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    range.addItems(three, nullCursorEdges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(two);\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n    ]);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n\n    result = range.retrieveRangeInfoForQuery(three);\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n      'edgeWithNullCursor3',\n    ]);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n  });\n\n  it('should delete', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    range.removeEdgeWithID(edge2.__dataID__);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ]);\n  });\n\n  it('should not retrieve deleted bumped edges', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    // bump the second edge\n    var afterQueryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ];\n\n    range.addItems(afterQueryCalls, [first3Edges[1]], pageInfo);\n\n    // delete the second edge\n    range.removeEdgeWithID(edge2.__dataID__);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ]);\n    var queryCallsWithSession = [\n      {name: 'first', value: 3},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCallsWithSession);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ]);\n  });\n\n  it('should retrieve info for first() query given optimistic data', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationPrepend__: [edge4.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge4.__dataID__, edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationPrepend__: [edge4.__dataID__, edge5.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge4.__dataID__, edge5.__dataID__, edge1.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // append shouldn't affect 'first' call\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationAppend__: [edge4.__dataID__, edge5.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 2}],\n      {\n        __rangeOperationRemove__: [edge1.__dataID__],\n      }\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {\n        __rangeOperationPrepend__: [edge4.__dataID__, edge5.__dataID__],\n        __rangeOperationRemove__: [edge4.__dataID__, edge1.__dataID__],\n      }\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge5.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve optimistically appended edges when the last edge has been fetched', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    // No next page means we have the very last edge.\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 4}],\n      {__rangeOperationAppend__: [edge4.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__, edge4.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // Should not return extra edges\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationAppend__: [edge4.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve info for last() query given optimistic data', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationAppend__: [edge97.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__, edge97.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationAppend__: [edge97.__dataID__, edge96.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge100.__dataID__, edge97.__dataID__, edge96.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // prepend shouldn't affect 'last' call\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationPrepend__: [edge97.__dataID__, edge96.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 2}],\n      {__rangeOperationRemove__: [edge99.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {\n        __rangeOperationAppend__: [edge97.__dataID__, edge96.__dataID__],\n        __rangeOperationRemove__: [edge100.__dataID__, edge96.__dataID__],\n      }\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge97.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve optimistically prepended edges when the first edge has been fetched', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    // No previous page means we have the very first edge.\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 4}],\n      {__rangeOperationPrepend__: [edge97.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge97.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Should not return extra edges\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationPrepend__: [edge97.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should toJSON', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var actual = JSON.stringify(range);\n\n    expect(actual).toEqual('[true,false,{},[[{' +\n      '\"0\":{\"edgeID\":\"edge1\",\"cursor\":\"cursor1\",\"deleted\":false},' +\n      '\"1\":{\"edgeID\":\"edge2\",\"cursor\":\"cursor2\",\"deleted\":false},' +\n      '\"2\":{\"edgeID\":\"edge3\",\"cursor\":\"cursor3\",\"deleted\":false}},' +\n      '{\"edge1\":[0],\"edge2\":[1],\"edge3\":[2]},' +\n      '{\"cursor1\":0,\"cursor2\":1,\"cursor3\":2},0,2,3],' +\n      '[{},{},{},null,null,0]]]'\n    );\n\n    range = GraphQLRange.fromJSON(JSON.parse(actual));\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('returns the DataIDs of all edges', () => {\n    // Add a static edges\n    var surroundQueryCalls = [\n      {name: 'surrounds', value: ['id2', 1]},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(surroundQueryCalls, first3Edges, pageInfo);\n\n    // Non-static edges\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    // Sorting the IDs to make testing easier.\n    expect(range.getEdgeIDs().sort()).toEqual([\n      edge1.__dataID__,\n      edge100.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n    ]);\n  });\n});\n","dependencies":["RelayTestUtils","GraphQLRange","RelayConnectionInterface","RelayRecord"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayTestUtils = require('RelayTestUtils');\n\njest\n  .dontMock('GraphQLSegment')\n  .dontMock('GraphQLRange')\n  .mock('warning');\n\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayRecord = require('RelayRecord');\n\nfunction getFirstSegment(range) {\n  return range.__debug().orderedSegments[0];\n}\n\nfunction getLastSegment(range) {\n  var orderedSegments = range.__debug().orderedSegments;\n  return orderedSegments[orderedSegments.length - 1];\n}\n\nfunction mockEdge(id, hasNullCursor) {\n  var dataID = 'edge' + (hasNullCursor ? 'WithNullCursor' : '') + id;\n  var edge = {\n    __dataID__: dataID,\n    node: {__dataID__: 'id' + id},\n    cursor: (hasNullCursor ? null : 'cursor' + id),\n  };\n  return edge;\n}\n\nvar edgeNeg10 = mockEdge('-10');\nvar edgeNeg9 = mockEdge('-9');\nvar edgeNeg3 = mockEdge('-3');\nvar edgeNeg2 = mockEdge('-2');\nvar edgeNeg1 = mockEdge('-1');\nvar edge0 = mockEdge('0');\nvar edge1 = mockEdge('1');\nvar edge2 = mockEdge('2');\nvar edge3 = mockEdge('3');\nvar edge4 = mockEdge('4');\nvar edge5 = mockEdge('5');\nvar edge96 = mockEdge('96');\nvar edge97 = mockEdge('97');\nvar edge98 = mockEdge('98');\nvar edge99 = mockEdge('99');\nvar edge100 = mockEdge('100');\nvar edge101 = mockEdge('101');\nvar edge102 = mockEdge('102');\nvar edge103 = mockEdge('103');\nvar edge104 = mockEdge('104');\nvar edge110 = mockEdge('110');\nvar edge111 = mockEdge('111');\nvar edgeWithNullCursor1 = mockEdge('1', true);\nvar edgeWithNullCursor2 = mockEdge('2', true);\nvar edgeWithNullCursor3 = mockEdge('3', true);\n\nvar first3Edges = [edge1, edge2, edge3];\nvar first5Edges = [edge1, edge2, edge3, edge4, edge5];\nvar last3Edges = [edge98, edge99, edge100];\nvar last5Edges = [edge96, edge97, edge98, edge99, edge100];\n\ndescribe('GraphQLRange', () => {\n  var consoleError;\n  var consoleWarn;\n  var range;\n\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    consoleError = console.error;\n    consoleWarn = console.warn;\n\n    RelayRecord.getDataID.mockImplementation(function(data) {\n      return data.__dataID__;\n    });\n    range = new GraphQLRange();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  afterEach(() => {\n    console.error = consoleError;\n    console.warn = consoleWarn;\n  });\n\n  it('should add for first() query', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for after().first() query', () => {\n    var queryCalls = [\n      {name: 'after', value: null},\n      {name: 'first', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      queryCalls,\n      first3Edges,\n      pageInfo\n    );\n\n    var incrementalEdges = [edge4, edge5];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    queryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ];\n    range.addItems(\n      queryCalls,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'after', value: null},\n      {name: 'first', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge4.__dataID__,\n      edge5.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for after().first() query in last segment', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'first', value: 2},\n    ];\n    var incrementalEdges = [edge101, edge102];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n      edge101.__dataID__,\n      edge102.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for before().first() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n\n    var incrementalEdges = [edgeNeg1, edge0];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n    // Request the full set to make sure it is stitched properly\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edgeNeg1.__dataID__,\n      edge0.__dataID__,\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for before().first() query with gap', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n\n    var incrementalEdges = [edgeNeg10, edgeNeg9];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n    // Request super set\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edgeNeg10.__dataID__, edgeNeg9.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor-9'},\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 3},\n    ]);\n\n  });\n\n  it('should add for last() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery(queryCalls, {count: 3});\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for before().last() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edge96, edge97];\n\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge96.__dataID__,\n      edge97.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for before().last() query in first segment', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edgeNeg1, edge0];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edgeNeg1.__dataID__,\n      edge0.__dataID__,\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add for after().last() query', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    var incrementalQueryCall = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edge101, edge102];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    // Request the full set\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n      edge101.__dataID__,\n      edge102.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n  });\n\n  it('should add for after().last() with gap', () => {\n    var queryCalls = [\n      {name: 'after', value: null},\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    queryCalls = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ];\n    range.addItems(\n      queryCalls,\n      [edge110, edge111],\n      {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: true}\n    );\n\n    // Request the super set\n    queryCalls = [\n      {name: 'after', value: null},\n      {name: 'last', value: 5},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge110.__dataID__, edge111.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor110'},\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 3},\n    ]);\n  });\n\n  it('should error for invalid call value', () => {\n    console.error = jest.genMockFunction();\n    var queryCalls = [\n      {name: 'first', value: 0},\n    ];\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(console.error.mock.calls.length).toBe(1);\n    expect(console.error.mock.calls[0]).toEqual([\n      'GraphQLRange only supports first(<count>) or last(<count>) ' +\n      'where count is greater than 0',\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve for first() queries', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    // Request from empty range\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([{name: 'first', value: 3}]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request the full set\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a subset\n    queryCalls = [\n      {name: 'first', value: 2},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a superset\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n  });\n\n  it('should retrieve for after().first() queries', () => {\n    var queryCalls = [\n      {name: 'after', value: null},\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(\n      queryCalls,\n      first3Edges,\n      pageInfo\n    );\n\n    // Request a subset with after\n    queryCalls = [\n      {name: 'after', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a superset with after\n    queryCalls = [\n      {name: 'after', value: 'cursor1'},\n      {name: 'first', value: 5},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 3},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a non-intersecting superset with after\n    queryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n  });\n\n  it('should retrieve for last() queries', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    // Request the from empty range\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([{name: 'last', value: 3}]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request the full set\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a subset\n    queryCalls = [{name: 'last', value: 2}];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Requst a superset\n    queryCalls = [{name: 'last', value: 5}];\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n  });\n\n  it('should retrieve for before().last() queries', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request a subset with before\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor100'},\n      {name: 'last', value: 5},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 3},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a non-intersecting superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 2},\n    ]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n  });\n\n  it('should retrieve for after().first() from last segment', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    // Request a subset with after\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'after', value: 'cursor98'},\n      {name: 'first', value: 1},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([edge99.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n\n    // Request a superset with after\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'after', value: 'cursor98'},\n      {name: 'first', value: 5},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a non-intersecting superset with after\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'after', value: 'cursor100'},\n      {name: 'first', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n  });\n\n  it('should retrieve for before().last() from first segment', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request a subset with before\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor3'},\n      {name: 'last', value: 1},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([edge2.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor3'},\n      {name: 'last', value: 5},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n    // Request a non-intersecting superset with before\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'before', value: 'cursor1'},\n      {name: 'last', value: 2},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([]);\n    expect(result.diffCalls).toEqual([]);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n\n  });\n\n  it('should support calls with no arguments', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n      {name: 'dummy_call', value: null},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 3},\n      {name: 'dummy_call', value: null},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support nodes with null cursors', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    var first3EdgesWithNullCursors = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    range.addItems(queryCalls, first3EdgesWithNullCursors, pageInfo);\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 3},\n    ]);\n\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n      'edgeWithNullCursor3',\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support prepending edge to range', () => {\n    // Prepend on new range\n    range.prependEdge(edge2);\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 1},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([edge2.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Prepend on range that already has edge\n    range.prependEdge(edge1);\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 2},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support appending edge to range', () => {\n    // Append on new range\n    range.appendEdge(edge1);\n    var result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 1},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([edge1.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Append on range that already has an edge\n    range.appendEdge(edge2);\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 2},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should support bumping', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var afterQueryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ];\n\n    // Testing add after: adding id2 to end of range\n    range.addItems(afterQueryCalls, [first3Edges[1]], pageInfo);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // Testing prepend: adding id3 to the front of the range\n    range.prependEdge(first3Edges[2]);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge3.__dataID__, edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var beforeQueryCalls = [\n      {name: 'before', value: 'cursor98'},\n      {name: 'last', value: 1},\n    ];\n\n    // Testing add before: adding id99 to end of range\n    range.addItems(beforeQueryCalls, [last3Edges[1]], pageInfo);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge98.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // Testing append: adding id98 to the end of the range\n    range.appendEdge(last3Edges[0]);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__, edge98.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should not generate diff query when range is empty', () => {\n    var queryFirstCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var queryLastCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    // Add empty first edges\n    range.addItems(queryFirstCalls, [], pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryFirstCalls);\n    expect(result.diffCalls.length).toBe(0);\n    result = range.retrieveRangeInfoForQuery(queryLastCalls);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Add empty last edges\n    range = new GraphQLRange();\n    range.addItems(queryLastCalls, [], pageInfo);\n\n    result = range.retrieveRangeInfoForQuery(queryFirstCalls);\n    expect(result.diffCalls.length).toBe(0);\n    result = range.retrieveRangeInfoForQuery(queryLastCalls);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should collesce segments when we reach end', () => {\n    var queryFirstCalls = [\n      {name: 'first', value: 1},\n    ];\n\n    var queryLastCalls = [\n      {name: 'last', value: 1},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryFirstCalls, [edge1], pageInfo);\n    range.addItems(queryLastCalls, [edge1], pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryFirstCalls);\n    expect(result.requestedEdgeIDs).toEqual([edge1.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n    result = range.retrieveRangeInfoForQuery(queryLastCalls);\n    expect(result.requestedEdgeIDs).toEqual([edge1.__dataID__]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should not generate diff query when there is no more', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    var beforeQueryCalls = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'last', value: 1},\n    ];\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(beforeQueryCalls);\n    // We know there is no more before cursor1 since that is the first edge\n    expect(result.diffCalls.length).toBe(0);\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    var afterQueryCalls = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'first', value: 1},\n    ];\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(afterQueryCalls);\n    // We know there is no more after cursor100 since that is the last edge\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should add  and retrieve for surrounds() query', () => {\n    var queryCalls = [\n      {name: 'surrounds', value: ['id2', 1]},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should not return surrounds query data for first query', () => {\n    var surroundQueryCalls = [\n      {name: 'surrounds', value: ['id2', 1]},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(surroundQueryCalls, first3Edges, pageInfo);\n\n    var firstQueryCalls = [\n      {name: 'first', value: 5},\n    ];\n\n    var resultForFirstQuery = range.retrieveRangeInfoForQuery(\n      firstQueryCalls,\n    );\n\n    expect(resultForFirstQuery.requestedEdgeIDs).toEqual([]);\n    expect(resultForFirstQuery.diffCalls).toEqual(firstQueryCalls);\n  });\n\n  it('should warn when reconciling conflicting first() ranges', () => {\n    console.error = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, [edge1, edge2, edge3], pageInfo);\n    range.addItems(queryCalls, [edge1, edge3, edge4], pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect([\n      'Relay was unable to reconcile edges on a connection. This most ' +\n      'likely occurred while trying to handle a server response that ' +\n      'includes connection edges with nodes that lack an `id` field.',\n    ]).toBeWarnedNTimes(1);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n  });\n\n  it('should warn when reconciling conflicting last() ranges', () => {\n    console.error = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    // Add items twice\n    range.addItems(queryCalls, [edge98, edge99, edge100], pageInfo);\n    range.addItems(queryCalls, [edge98, edge1, edge100], pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect([\n      'Relay was unable to reconcile edges on a connection. This most ' +\n      'likely occurred while trying to handle a server response that ' +\n      'includes connection edges with nodes that lack an `id` field.',\n    ]).toBeWarnedNTimes(1);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n  });\n\n  it('should reconcile duplicated queries', () => {\n    console.error = jest.genMockFunction();\n    console.warn = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    // Add items twice\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    // Add items twice\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n  });\n\n  it('should reconcile duplicated queries with no cursor', () => {\n    console.error = jest.genMockFunction();\n    console.warn = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    const e1 = mockEdge('1', true);\n    const e2 = mockEdge('2', true);\n    const e3 = mockEdge('3', true);\n\n    var edges = [e1, e2, e3];\n\n    // Add items twice\n    range.addItems(queryCalls, edges, pageInfo);\n    range.addItems(queryCalls, edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [e1.__dataID__, e2.__dataID__, e3.__dataID__]\n    );\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    const e100 = mockEdge('100', true);\n    const e99 = mockEdge('99', true);\n    const e98 = mockEdge('98', true);\n\n    edges = [e98, e99, e100];\n\n    // Add items twice\n    range.addItems(queryCalls, edges, pageInfo);\n    range.addItems(queryCalls, edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [e98.__dataID__, e99.__dataID__, e100.__dataID__]\n    );\n  });\n\n  it('should reconcile extending queries', () => {\n    console.error = jest.genMockFunction();\n    console.warn = jest.genMockFunction();\n\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    queryCalls = [\n      {name: 'first', value: 5},\n    ];\n    range.addItems(queryCalls, first5Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge4.__dataID__,\n      edge5.__dataID__,\n    ]);\n\n    queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    queryCalls = [\n      {name: 'last', value: 5},\n    ];\n    range.addItems(queryCalls, last5Edges, pageInfo);\n\n    expect(console.error.mock.calls.length).toBe(0);\n    expect(console.warn.mock.calls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge96.__dataID__,\n      edge97.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n  });\n\n  it('should stitch first and last segment', () => {\n    var firstQueryCalls = [\n      {name: 'first', value: 3},\n    ];\n    var lastQueryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(firstQueryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(lastQueryCalls);\n\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'last', value: 3},\n    ]);\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(result.diffCalls, last3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n\n    range = new GraphQLRange();\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(lastQueryCalls, last3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(firstQueryCalls);\n\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor98'},\n      {name: 'first', value: 3},\n    ]);\n\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(result.diffCalls, first3Edges, pageInfo);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 6}],\n    );\n    expect(result.diffCalls.length).toBe(0);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge1.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n  });\n\n  it('should stitch up gap in first segment', () => {\n    // Add initial edges\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    // Create gap\n    var incrementalQueryCall = [\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 2},\n    ];\n    var incrementalEdges = [edgeNeg3, edgeNeg2];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 5},\n    ]);\n    var diffCalls = result.diffCalls;\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor-2'},\n      {name: 'before', value: 'cursor1'},\n      {name: 'first', value: 3},\n    ]);\n\n    // Fill in gap\n    var gapEdges = [edgeNeg1, edge0];\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(diffCalls, gapEdges, pageInfo);\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'first', value: 5},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([\n      edgeNeg3.__dataID__,\n      edgeNeg2.__dataID__,\n      edgeNeg1.__dataID__,\n      edge0.__dataID__,\n      edge1.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should stitch up gap in last segment', () => {\n    // Add initial edges\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    // Create gap\n    var incrementalQueryCall = [\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 2},\n    ];\n\n    var incrementalEdges = [edge103, edge104];\n    var incrementalPageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n    range.addItems(\n      incrementalQueryCall,\n      incrementalEdges,\n      incrementalPageInfo\n    );\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 5},\n    ]);\n    var diffCalls = result.diffCalls;\n    expect(result.diffCalls).toEqual([\n      {name: 'before', value: 'cursor103'},\n      {name: 'after', value: 'cursor100'},\n      {name: 'last', value: 3},\n    ]);\n\n    // Fill in gap\n    var gapEdges = [edge101, edge102];\n    pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(diffCalls, gapEdges, pageInfo);\n\n    result = range.retrieveRangeInfoForQuery([\n      {name: 'last', value: 5},\n    ]);\n    expect(result.requestedEdgeIDs).toEqual([\n      edge100.__dataID__,\n      edge101.__dataID__,\n      edge102.__dataID__,\n      edge103.__dataID__,\n      edge104.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should refetch for whole ranges for null cursor', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    range.addItems(queryCalls, nullCursorEdges, pageInfo);\n    var five = [{name: 'first', value: 5}];\n    var result = range.retrieveRangeInfoForQuery(five);\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n      'edgeWithNullCursor3',\n    ]);\n    expect(result.diffCalls).toEqual(five);\n  });\n\n  it('replaces whole first() ranges when working with null cursors', () => {\n    var queryCalls = [\n      {name: 'first', value: 1},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    // we don't replace empty ranges\n    var segment = getFirstSegment(range);\n    range.addItems(queryCalls, nullCursorEdges.slice(0, 1), pageInfo);\n    expect(segment).toBe(getFirstSegment(range));\n\n    // if we request more results but get the same number, we replace\n    // (in case there were deleted items, different items, or reordering)\n    var three = [{name: 'first', value: 3}];\n    range.addItems(three, nullCursorEdges.slice(0, 1), pageInfo);\n    expect(segment).not.toBe(getFirstSegment(range));\n\n    // if the range has gotten bigger, we replace it\n    segment = getFirstSegment(range);\n    range.addItems(three, nullCursorEdges, pageInfo);\n    expect(segment).not.toBe(getFirstSegment(range));\n\n    // if the range has gotten bigger but has cursor info, we don't replace it\n    var cursorEdges = [\n      edge0,\n      edge1,\n      edge2,\n    ];\n    range = new GraphQLRange();\n    segment = getFirstSegment(range);\n    range.addItems(queryCalls, cursorEdges.slice(0, 1), pageInfo);\n    expect(segment).toBe(getFirstSegment(range));\n    range.addItems(three, cursorEdges, pageInfo);\n    expect(segment).toBe(getFirstSegment(range));\n  });\n\n  it('replaces whole last() ranges when working with null cursors', () => {\n    var queryCalls = [\n      {name: 'last', value: 1},\n    ];\n\n    var pageInfo = {\n      [HAS_PREV_PAGE]: true,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    // we don't replace empty ranges\n    var segment = getLastSegment(range);\n    range.addItems(queryCalls, nullCursorEdges.slice(2), pageInfo);\n    expect(segment).toBe(getLastSegment(range));\n\n    // if we request more results but get the same number, we replace\n    // (in case there were deleted items, different items, or reordering)\n    var three = [{name: 'last', value: 3}];\n    range.addItems(three, nullCursorEdges.slice(2), pageInfo);\n    expect(segment).not.toBe(getLastSegment(range));\n\n    // if the range has gotten bigger, we replace it\n    segment = getLastSegment(range);\n    range.addItems(three, nullCursorEdges, pageInfo);\n    expect(segment).not.toBe(getLastSegment(range));\n\n    // if the range has gotten bigger but has cursor info, we don't replace it\n    var cursorEdges = [\n      edge0,\n      edge1,\n      edge2,\n    ];\n    range = new GraphQLRange();\n    segment = getLastSegment(range);\n    range.addItems(queryCalls, cursorEdges.slice(2), pageInfo);\n    expect(segment).toBe(getLastSegment(range));\n    range.addItems(three, cursorEdges, pageInfo);\n    expect(segment).toBe(getLastSegment(range));\n  });\n\n  it('should retrieve correct page_info for ranges with null cursors', () => {\n    var two = [{name: 'first', value: 2}];\n    var three = [{name: 'first', value: 3}];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    var nullCursorEdges = [\n      edgeWithNullCursor1,\n      edgeWithNullCursor2,\n      edgeWithNullCursor3,\n    ];\n\n    range.addItems(three, nullCursorEdges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(two);\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n    ]);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(true);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n\n    result = range.retrieveRangeInfoForQuery(three);\n    expect(result.requestedEdgeIDs).toEqual([\n      'edgeWithNullCursor1',\n      'edgeWithNullCursor2',\n      'edgeWithNullCursor3',\n    ]);\n    expect(result.pageInfo[HAS_NEXT_PAGE]).toBe(false);\n    expect(result.pageInfo[HAS_PREV_PAGE]).toBe(false);\n  });\n\n  it('should delete', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    range.removeEdgeWithID(edge2.__dataID__);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ]);\n  });\n\n  it('should not retrieve deleted bumped edges', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    // bump the second edge\n    var afterQueryCalls = [\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ];\n\n    range.addItems(afterQueryCalls, [first3Edges[1]], pageInfo);\n\n    // delete the second edge\n    range.removeEdgeWithID(edge2.__dataID__);\n    result = range.retrieveRangeInfoForQuery(queryCalls);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ]);\n    var queryCallsWithSession = [\n      {name: 'first', value: 3},\n    ];\n    result = range.retrieveRangeInfoForQuery(queryCallsWithSession);\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls).toEqual([\n      {name: 'after', value: 'cursor3'},\n      {name: 'first', value: 1},\n    ]);\n  });\n\n  it('should retrieve info for first() query given optimistic data', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationPrepend__: [edge4.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge4.__dataID__, edge1.__dataID__, edge2.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationPrepend__: [edge4.__dataID__, edge5.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge4.__dataID__, edge5.__dataID__, edge1.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // append shouldn't affect 'first' call\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationAppend__: [edge4.__dataID__, edge5.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 2}],\n      {\n        __rangeOperationRemove__: [edge1.__dataID__],\n      }\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {\n        __rangeOperationPrepend__: [edge4.__dataID__, edge5.__dataID__],\n        __rangeOperationRemove__: [edge4.__dataID__, edge1.__dataID__],\n      }\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge5.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve optimistically appended edges when the last edge has been fetched', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n\n    // No next page means we have the very last edge.\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 4}],\n      {__rangeOperationAppend__: [edge4.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__, edge4.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // Should not return extra edges\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'first', value: 3}],\n      {__rangeOperationAppend__: [edge4.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve info for last() query given optimistic data', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: true,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationAppend__: [edge97.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge99.__dataID__, edge100.__dataID__, edge97.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationAppend__: [edge97.__dataID__, edge96.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge100.__dataID__, edge97.__dataID__, edge96.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    // prepend shouldn't affect 'last' call\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationPrepend__: [edge97.__dataID__, edge96.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 2}],\n      {__rangeOperationRemove__: [edge99.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge100.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {\n        __rangeOperationAppend__: [edge97.__dataID__, edge96.__dataID__],\n        __rangeOperationRemove__: [edge100.__dataID__, edge96.__dataID__],\n      }\n    );\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge98.__dataID__, edge99.__dataID__, edge97.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should retrieve optimistically prepended edges when the first edge has been fetched', () => {\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n\n    // No previous page means we have the very first edge.\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, last3Edges, pageInfo);\n\n    var result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 4}],\n      {__rangeOperationPrepend__: [edge97.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge97.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n\n    // Should not return extra edges\n    result = range.retrieveRangeInfoForQuery(\n      [{name: 'last', value: 3}],\n      {__rangeOperationPrepend__: [edge97.__dataID__]}\n    );\n\n    expect(result.requestedEdgeIDs).toEqual([\n      edge98.__dataID__,\n      edge99.__dataID__,\n      edge100.__dataID__,\n    ]);\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('should toJSON', () => {\n    var queryCalls = [\n      {name: 'first', value: 3},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: true,\n      [HAS_PREV_PAGE]: false,\n    };\n\n    range.addItems(queryCalls, first3Edges, pageInfo);\n    var actual = JSON.stringify(range);\n\n    expect(actual).toEqual('[true,false,{},[[{' +\n      '\"0\":{\"edgeID\":\"edge1\",\"cursor\":\"cursor1\",\"deleted\":false},' +\n      '\"1\":{\"edgeID\":\"edge2\",\"cursor\":\"cursor2\",\"deleted\":false},' +\n      '\"2\":{\"edgeID\":\"edge3\",\"cursor\":\"cursor3\",\"deleted\":false}},' +\n      '{\"edge1\":[0],\"edge2\":[1],\"edge3\":[2]},' +\n      '{\"cursor1\":0,\"cursor2\":1,\"cursor3\":2},0,2,3],' +\n      '[{},{},{},null,null,0]]]'\n    );\n\n    range = GraphQLRange.fromJSON(JSON.parse(actual));\n\n    // Request the full set\n    var result = range.retrieveRangeInfoForQuery(queryCalls);\n\n    expect(result.requestedEdgeIDs).toEqual(\n      [edge1.__dataID__, edge2.__dataID__, edge3.__dataID__]\n    );\n    expect(result.diffCalls.length).toBe(0);\n  });\n\n  it('returns the DataIDs of all edges', () => {\n    // Add a static edges\n    var surroundQueryCalls = [\n      {name: 'surrounds', value: ['id2', 1]},\n    ];\n    var pageInfo = {\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n    };\n    range.addItems(surroundQueryCalls, first3Edges, pageInfo);\n\n    // Non-static edges\n    var queryCalls = [\n      {name: 'last', value: 3},\n    ];\n    range.addItems(queryCalls, last3Edges, pageInfo);\n    // Sorting the IDs to make testing easier.\n    expect(range.getEdgeIDs().sort()).toEqual([\n      edge1.__dataID__,\n      edge100.__dataID__,\n      edge2.__dataID__,\n      edge3.__dataID__,\n      edge98.__dataID__,\n      edge99.__dataID__,\n    ]);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLRange-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLQueryRunner-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .mock('warning')\n  .dontMock('GraphQLQueryRunner')\n  .dontMock('RelayTaskQueue');\n\nconst Relay = require('Relay');\nconst RelayFetchMode = require('RelayFetchMode');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst checkRelayQueryData = require('checkRelayQueryData');\nconst diffRelayQuery = require('diffRelayQuery');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\nconst warning = require('warning');\n\ndescribe('GraphQLQueryRunner', () => {\n  var queryRunner;\n  var pendingQueryTracker;\n\n  var mockCallback;\n  var mockQuerySet;\n\n  var {defer, getNode} = RelayTestUtils;\n\n  /**\n   * Helper method, returns a clone of `query` that has been marked as\n   * deferred.\n   */\n  function deferQuery(relayQuery) {\n    var node = {\n      ...relayQuery.getConcreteQueryNode(),\n      isDeferred: true,\n    };\n    return getNode(node, relayQuery.getVariables());\n  }\n\n  function mockSplitDeferredQueries() {\n    splitDeferredRelayQueries.mockImplementation(\n      query => ({\n        required: query,\n        deferred: [],\n      })\n    );\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayNetworkLayer.injectNetworkLayer({\n      supports: () => true,\n    });\n\n    var storeData = new RelayStoreData();\n    queryRunner = storeData.getQueryRunner();\n    pendingQueryTracker = storeData.getPendingQueryTracker();\n\n    mockCallback = jest.genMockFunction();\n    mockQuerySet = {\n      foo: getNode(Relay.QL`query{viewer{actor{id,name}}}`),\n      bar: getNode(Relay.QL`query{node(id:\"4\"){id,name}}`),\n      baz: null,\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('immediately succeeds for empty queries', () => {\n    queryRunner.run({}, mockCallback);\n\n    expect(mockCallback).not.toBeCalled();\n    jest.runAllTimers();\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('immediately succeeds for no diff queries', () => {\n    diffRelayQuery.mockReturnValue([]);\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    var diffQueryCalls = diffRelayQuery.mock.calls;\n    expect(diffQueryCalls.length).toBe(2);\n    expect(diffQueryCalls[0][0]).toEqualQueryNode(mockQuerySet.foo);\n    expect(diffQueryCalls[1][0]).toEqualQueryNode(mockQuerySet.bar);\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('warns and uses fallback when defer is unsupported', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    checkRelayQueryData.mockImplementation(() => false);\n    RelayNetworkLayer.injectNetworkLayer({\n      supports: () => false,\n    });\n\n    var fragment = Relay.QL`fragment on Node{id}`;\n    var querySet = {\n      foo: getNode(Relay.QL`query{node(id:\"123\"){${defer(fragment)}}}`),\n    };\n\n    warning.mockClear();\n    queryRunner.run(querySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);\n    expect(pendingQueryTracker.add.mock.calls[0][0].query)\n      .toBe(querySet.foo);\n    expect(splitDeferredRelayQueries).not.toBeCalled();\n    expect(warning.mock.calls[0]).toEqual([\n      false,\n      'Relay: Query `%s` contains a deferred fragment (e.g. ' +\n      '`getFragment(\\'foo\\').defer()`) which is not supported by the ' +\n      'default network layer. This query will be sent without deferral.',\n      querySet.foo.getName(),\n    ]);\n  });\n\n  it('is not ready if required data is being fetched', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    checkRelayQueryData.mockImplementation(() => false);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('adds all split and diff queries to the pending query tracker', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(2);\n    expect(pendingQueryTracker.add.mock.calls[0][0].query)\n      .toEqualQueryNode(mockQuerySet.foo);\n    expect(pendingQueryTracker.add.mock.calls[1][0].query)\n      .toEqualQueryNode(mockQuerySet.bar);\n  });\n\n  it('waits for all required data before being ready', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    jest.runAllTimers();\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n    ]);\n\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  it('throws to global if the callback throws', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    var mockError = new Error('Expected callback error.');\n    mockCallback.mockImplementation(() => {\n      throw mockError;\n    });\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    expect(() => {\n      jest.runAllTimers();\n    }).toThrow(mockError);\n  });\n\n  it('is immediately ready for no required queries', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    // Treat all queries as deferred.\n    splitDeferredRelayQueries.mockImplementation(query => ({\n      required: null,\n      deferred: [{\n        required: deferQuery(query),\n        deferred: [],\n      }],\n    }));\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('calls the callback for each deferred query', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    splitDeferredRelayQueries.mockImplementation(query => {\n      if (query.getFieldName() === 'viewer') {\n        return {\n          required: query,\n          deferred: [],\n        };\n      } else {\n        // Treat `mockQuerySet.bar` as deferred.\n        return {\n          query: null,\n          deferred: [{\n            required: deferQuery(query),\n            deferred: [],\n          }],\n        };\n      }\n    });\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: false, error: null, ready: true, stale: false}],\n    ]);\n\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  it('calls the callback only once when completing all queries', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n    ]);\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('is done after all data is fetched', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  it('calls the callback when aborted', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback).abort();\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: true, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('is ready if required data is in disk cache', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    RelayStoreData.prototype.hasCacheManager =\n      jest.genMockFunction().mockImplementation(() => true);\n    RelayStoreData.prototype.readFromDiskCache =\n      jest.genMockFunction().mockImplementation((queries, callback) => {\n        callback.onSuccess();\n      });\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: false, error: null, ready: true, stale: true}],\n    ]);\n  });\n\n  it('adds query on `forceFetch` even if there are no diff queries', () => {\n    diffRelayQuery.mockImplementation(query => []);\n    mockSplitDeferredQueries();\n\n    var singleMockQuery = {foo: mockQuerySet.foo};\n    queryRunner.forceFetch(singleMockQuery, mockCallback);\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);\n    expect(pendingQueryTracker.add.mock.calls[0][0].query)\n      .toEqualQueryNode(singleMockQuery.foo);\n  });\n\n  it('is completely ready on `forceFetch` when all data is available', () => {\n    diffRelayQuery.mockImplementation(() => []);\n    checkRelayQueryData.mockImplementation(() => true);\n    mockSplitDeferredQueries();\n    var singleMockQuery = {foo: mockQuerySet.foo};\n    queryRunner.forceFetch(singleMockQuery, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: false, error: null, ready: true, stale: true}],\n    ]);\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  describe('Batch callback for multiple queries', () => {\n    var runTest;\n    var fetchMode;\n    beforeEach(() => {\n      diffRelayQuery.mockImplementation(query => [query]);\n\n      var mockQuery = getNode(Relay.QL`\n        query {\n          viewer{actor{id,firstName,lastName,name,address{city},hometown{id}}}\n        }\n      `);\n\n      var mockSplitQueries = {\n        required: getNode(Relay.QL`\n          query {\n            viewer{actor{id,name}}\n          }\n        `),\n        deferred: [\n          Relay.QL`\n            query {\n              viewer{actor{id,address{city}}}\n            }\n          `,\n          Relay.QL`\n            query {\n              viewer{actor{id,hometown{id}}}\n            }\n          `,\n          Relay.QL`\n            query {\n              viewer{actor{id,firstName}}\n            }\n          `,\n          Relay.QL`\n            query {\n              viewer{actor{id,lastName}}\n            }\n          `,\n        ].map(query => ({\n          required: deferQuery(getNode(query)),\n          deferred: [],\n        })),\n      };\n\n      splitDeferredRelayQueries.mockImplementation(query => {\n        expect(query).toEqualQueryNode(mockQuery);\n        return mockSplitQueries;\n      });\n\n      var resolveSplitQueryByIndex = index => {\n        pendingQueryTracker.add.mock.fetches[index].resolve();\n      };\n      runTest = () => {\n        queryRunner.run(\n          {foo: mockQuery},\n          mockCallback,\n          fetchMode\n        );\n        resolveSplitQueryByIndex(1);\n        resolveSplitQueryByIndex(0);\n        jest.runAllTimers();\n\n        var defaultState = {\n          aborted: false,\n          done: false,\n          error: null,\n          ready: false,\n          stale: false,\n        };\n\n        // Only called once after both splitQuery#0 and splitQuery#1.\n        expect(mockCallback.mock.calls).toEqual([\n          [{...defaultState}],\n          [{...defaultState, ready: true}],\n        ]);\n\n        resolveSplitQueryByIndex(2);\n        resolveSplitQueryByIndex(3);\n        jest.runAllTimers();\n\n        // Only called once more after both splitQuery#2 and splitQuery#3.\n        expect(mockCallback.mock.calls).toEqual([\n          [{...defaultState, ready: false}],\n          [{...defaultState, ready: true}],\n          [{...defaultState, ready: true}],\n        ]);\n\n        resolveSplitQueryByIndex(4);\n        jest.runAllTimers();\n\n        expect(mockCallback).lastCalledWith(\n          {...defaultState, done: true, ready: true}\n        );\n      };\n    });\n\n    it('does in preload mode', () => {\n      fetchMode = RelayFetchMode.PRELOAD;\n      runTest();\n    });\n\n    it('does in client mode', () => {\n      fetchMode = RelayFetchMode.CLIENT;\n      runTest();\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayFetchMode","RelayNetworkLayer","RelayStoreData","RelayTestUtils","checkRelayQueryData","diffRelayQuery","splitDeferredRelayQueries","warning"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .mock('warning')\n  .dontMock('GraphQLQueryRunner')\n  .dontMock('RelayTaskQueue');\n\nconst Relay = require('Relay');\nconst RelayFetchMode = require('RelayFetchMode');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst checkRelayQueryData = require('checkRelayQueryData');\nconst diffRelayQuery = require('diffRelayQuery');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\nconst warning = require('warning');\n\ndescribe('GraphQLQueryRunner', () => {\n  var queryRunner;\n  var pendingQueryTracker;\n\n  var mockCallback;\n  var mockQuerySet;\n\n  var {defer, getNode} = RelayTestUtils;\n\n  /**\n   * Helper method, returns a clone of `query` that has been marked as\n   * deferred.\n   */\n  function deferQuery(relayQuery) {\n    var node = {\n      ...relayQuery.getConcreteQueryNode(),\n      isDeferred: true,\n    };\n    return getNode(node, relayQuery.getVariables());\n  }\n\n  function mockSplitDeferredQueries() {\n    splitDeferredRelayQueries.mockImplementation(\n      query => ({\n        required: query,\n        deferred: [],\n      })\n    );\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayNetworkLayer.injectNetworkLayer({\n      supports: () => true,\n    });\n\n    var storeData = new RelayStoreData();\n    queryRunner = storeData.getQueryRunner();\n    pendingQueryTracker = storeData.getPendingQueryTracker();\n\n    mockCallback = jest.genMockFunction();\n    mockQuerySet = {\n      foo: getNode(Relay.QL`query{viewer{actor{id,name}}}`),\n      bar: getNode(Relay.QL`query{node(id:\"4\"){id,name}}`),\n      baz: null,\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('immediately succeeds for empty queries', () => {\n    queryRunner.run({}, mockCallback);\n\n    expect(mockCallback).not.toBeCalled();\n    jest.runAllTimers();\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('immediately succeeds for no diff queries', () => {\n    diffRelayQuery.mockReturnValue([]);\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    var diffQueryCalls = diffRelayQuery.mock.calls;\n    expect(diffQueryCalls.length).toBe(2);\n    expect(diffQueryCalls[0][0]).toEqualQueryNode(mockQuerySet.foo);\n    expect(diffQueryCalls[1][0]).toEqualQueryNode(mockQuerySet.bar);\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('warns and uses fallback when defer is unsupported', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    checkRelayQueryData.mockImplementation(() => false);\n    RelayNetworkLayer.injectNetworkLayer({\n      supports: () => false,\n    });\n\n    var fragment = Relay.QL`fragment on Node{id}`;\n    var querySet = {\n      foo: getNode(Relay.QL`query{node(id:\"123\"){${defer(fragment)}}}`),\n    };\n\n    warning.mockClear();\n    queryRunner.run(querySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);\n    expect(pendingQueryTracker.add.mock.calls[0][0].query)\n      .toBe(querySet.foo);\n    expect(splitDeferredRelayQueries).not.toBeCalled();\n    expect(warning.mock.calls[0]).toEqual([\n      false,\n      'Relay: Query `%s` contains a deferred fragment (e.g. ' +\n      '`getFragment(\\'foo\\').defer()`) which is not supported by the ' +\n      'default network layer. This query will be sent without deferral.',\n      querySet.foo.getName(),\n    ]);\n  });\n\n  it('is not ready if required data is being fetched', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    checkRelayQueryData.mockImplementation(() => false);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('adds all split and diff queries to the pending query tracker', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(2);\n    expect(pendingQueryTracker.add.mock.calls[0][0].query)\n      .toEqualQueryNode(mockQuerySet.foo);\n    expect(pendingQueryTracker.add.mock.calls[1][0].query)\n      .toEqualQueryNode(mockQuerySet.bar);\n  });\n\n  it('waits for all required data before being ready', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    jest.runAllTimers();\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n    ]);\n\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  it('throws to global if the callback throws', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    var mockError = new Error('Expected callback error.');\n    mockCallback.mockImplementation(() => {\n      throw mockError;\n    });\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    expect(() => {\n      jest.runAllTimers();\n    }).toThrow(mockError);\n  });\n\n  it('is immediately ready for no required queries', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    // Treat all queries as deferred.\n    splitDeferredRelayQueries.mockImplementation(query => ({\n      required: null,\n      deferred: [{\n        required: deferQuery(query),\n        deferred: [],\n      }],\n    }));\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('calls the callback for each deferred query', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    splitDeferredRelayQueries.mockImplementation(query => {\n      if (query.getFieldName() === 'viewer') {\n        return {\n          required: query,\n          deferred: [],\n        };\n      } else {\n        // Treat `mockQuerySet.bar` as deferred.\n        return {\n          query: null,\n          deferred: [{\n            required: deferQuery(query),\n            deferred: [],\n          }],\n        };\n      }\n    });\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: false, error: null, ready: true, stale: false}],\n    ]);\n\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  it('calls the callback only once when completing all queries', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n    ]);\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('is done after all data is fetched', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    pendingQueryTracker.add.mock.fetches[1].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  it('calls the callback when aborted', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback).abort();\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: true, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('is ready if required data is in disk cache', () => {\n    diffRelayQuery.mockImplementation(query => [query]);\n    RelayStoreData.prototype.hasCacheManager =\n      jest.genMockFunction().mockImplementation(() => true);\n    RelayStoreData.prototype.readFromDiskCache =\n      jest.genMockFunction().mockImplementation((queries, callback) => {\n        callback.onSuccess();\n      });\n    mockSplitDeferredQueries();\n\n    queryRunner.run(mockQuerySet, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: false, error: null, ready: true, stale: true}],\n    ]);\n  });\n\n  it('adds query on `forceFetch` even if there are no diff queries', () => {\n    diffRelayQuery.mockImplementation(query => []);\n    mockSplitDeferredQueries();\n\n    var singleMockQuery = {foo: mockQuerySet.foo};\n    queryRunner.forceFetch(singleMockQuery, mockCallback);\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);\n    expect(pendingQueryTracker.add.mock.calls[0][0].query)\n      .toEqualQueryNode(singleMockQuery.foo);\n  });\n\n  it('is completely ready on `forceFetch` when all data is available', () => {\n    diffRelayQuery.mockImplementation(() => []);\n    checkRelayQueryData.mockImplementation(() => true);\n    mockSplitDeferredQueries();\n    var singleMockQuery = {foo: mockQuerySet.foo};\n    queryRunner.forceFetch(singleMockQuery, mockCallback);\n    jest.runAllTimers();\n\n    expect(mockCallback.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: false, stale: false}],\n      [{aborted: false, done: false, error: null, ready: true, stale: true}],\n    ]);\n    expect(pendingQueryTracker.add.mock.calls.length).toBe(1);\n\n    pendingQueryTracker.add.mock.fetches[0].resolve();\n    jest.runAllTimers();\n\n    expect(mockCallback).lastCalledWith(\n      {aborted: false, done: true, error: null, ready: true, stale: false}\n    );\n  });\n\n  describe('Batch callback for multiple queries', () => {\n    var runTest;\n    var fetchMode;\n    beforeEach(() => {\n      diffRelayQuery.mockImplementation(query => [query]);\n\n      var mockQuery = getNode(Relay.QL`\n        query {\n          viewer{actor{id,firstName,lastName,name,address{city},hometown{id}}}\n        }\n      `);\n\n      var mockSplitQueries = {\n        required: getNode(Relay.QL`\n          query {\n            viewer{actor{id,name}}\n          }\n        `),\n        deferred: [\n          Relay.QL`\n            query {\n              viewer{actor{id,address{city}}}\n            }\n          `,\n          Relay.QL`\n            query {\n              viewer{actor{id,hometown{id}}}\n            }\n          `,\n          Relay.QL`\n            query {\n              viewer{actor{id,firstName}}\n            }\n          `,\n          Relay.QL`\n            query {\n              viewer{actor{id,lastName}}\n            }\n          `,\n        ].map(query => ({\n          required: deferQuery(getNode(query)),\n          deferred: [],\n        })),\n      };\n\n      splitDeferredRelayQueries.mockImplementation(query => {\n        expect(query).toEqualQueryNode(mockQuery);\n        return mockSplitQueries;\n      });\n\n      var resolveSplitQueryByIndex = index => {\n        pendingQueryTracker.add.mock.fetches[index].resolve();\n      };\n      runTest = () => {\n        queryRunner.run(\n          {foo: mockQuery},\n          mockCallback,\n          fetchMode\n        );\n        resolveSplitQueryByIndex(1);\n        resolveSplitQueryByIndex(0);\n        jest.runAllTimers();\n\n        var defaultState = {\n          aborted: false,\n          done: false,\n          error: null,\n          ready: false,\n          stale: false,\n        };\n\n        // Only called once after both splitQuery#0 and splitQuery#1.\n        expect(mockCallback.mock.calls).toEqual([\n          [{...defaultState}],\n          [{...defaultState, ready: true}],\n        ]);\n\n        resolveSplitQueryByIndex(2);\n        resolveSplitQueryByIndex(3);\n        jest.runAllTimers();\n\n        // Only called once more after both splitQuery#2 and splitQuery#3.\n        expect(mockCallback.mock.calls).toEqual([\n          [{...defaultState, ready: false}],\n          [{...defaultState, ready: true}],\n          [{...defaultState, ready: true}],\n        ]);\n\n        resolveSplitQueryByIndex(4);\n        jest.runAllTimers();\n\n        expect(mockCallback).lastCalledWith(\n          {...defaultState, done: true, ready: true}\n        );\n      };\n    });\n\n    it('does in preload mode', () => {\n      fetchMode = RelayFetchMode.PRELOAD;\n      runTest();\n    });\n\n    it('does in client mode', () => {\n      fetchMode = RelayFetchMode.CLIENT;\n      runTest();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/store/__tests__/GraphQLQueryRunner-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/mutation/__mocks__/GraphQLMutatorConstants.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('GraphQLMutatorConstants');\n","dependencies":["GraphQLMutatorConstants"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('GraphQLMutatorConstants');\n"},"name":"/Users/cpojer/Projects/relay/src/legacy/mutation/__mocks__/GraphQLMutatorConstants.js"}},"/Users/cpojer/Projects/relay/src/network-layer/default/__mocks__/RelayDefaultNetworkLayer.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayDefaultNetworkLayer');\n","dependencies":["RelayDefaultNetworkLayer"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayDefaultNetworkLayer');\n"},"name":"/Users/cpojer/Projects/relay/src/network-layer/default/__mocks__/RelayDefaultNetworkLayer.js"}},"/Users/cpojer/Projects/relay/src/network-layer/default/__tests__/RelayDefaultNetworkLayer-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayDefaultNetworkLayer = require('RelayDefaultNetworkLayer');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayMutationRequest = require('RelayMutationRequest');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryRequest = require('RelayQueryRequest');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst fetch = require('fetch');\nconst fetchWithRetries = require('fetchWithRetries');\n\ndescribe('RelayDefaultNetworkLayer', () => {\n  var networkConfig;\n  var networkLayer;\n\n  function genResponse(data) {\n    return {\n      json: () => Promise.resolve(data),\n      status: 200,\n    };\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    networkConfig = {\n      uri: '/graphql',\n      init: {\n        fetchTimeout: 15000,\n        headers: {\n          // This should be merged into headers.\n          'Content-Encoding': 'gzip',\n          // This should always be ignored.\n          'Content-Type': 'application/bogus',\n        },\n        // This should always be ignored.\n        method: 'GET',\n        retryDelays: [1000, 3000],\n      },\n    };\n    // Spread properties to test that functions are bound correctly.\n    networkLayer = {\n      ...new RelayDefaultNetworkLayer(\n        networkConfig.uri,\n        networkConfig.init\n      ),\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('sendMutation', () => {\n    var request;\n    var variables;\n    var responseCallback;\n    var rejectCallback;\n\n    beforeEach(() => {\n      responseCallback = jest.genMockFunction();\n      rejectCallback = jest.genMockFunction();\n\n      variables = {\n        input: {\n          [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'client:a',\n          actor_id: 4,\n        },\n      };\n      var mutation = RelayQuery.Mutation.build(\n        'FeedbackLikeMutation',\n        'FeedbackLikeResponsePayload',\n        'feedback_like',\n        variables.input,\n        [RelayQuery.Field.build({\n          fieldName: 'does_viewer_like',\n          type: 'Boolean',\n        })],\n        {inputType: 'FeedbackLikeInput'}\n      );\n      request = new RelayMutationRequest(mutation);\n      request.getPromise().then(responseCallback).catch(rejectCallback);\n    });\n\n    it('sends correct data to server', () => {\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      var call = fetch.mock.calls[0];\n      expect(call[0]).toBe(networkConfig.uri);\n      var {body, headers, method} = call[1];\n\n      expect(method).toBe('POST');\n      expect(headers).toEqual({\n        'Accept': '*/*',\n        'Content-Encoding': 'gzip',\n        'Content-Type': 'application/json',\n      });\n      expect(body).toEqual(JSON.stringify({\n        query: request.getQueryString(),\n        variables: {\n          input_0: variables.input,\n        },\n      }));\n    });\n\n    it('handles responses', () => {\n      var response = {\n        data: {\n          test_call: {\n            field: 1,\n          },\n        },\n      };\n\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      fetch.mock.deferreds[0].resolve(genResponse(response));\n      jest.runAllTimers();\n\n      expect(rejectCallback.mock.calls.length).toBe(0);\n      expect(responseCallback.mock.calls.length).toBe(1);\n      expect(responseCallback.mock.calls[0][0]).toEqual({\n        response: response.data,\n      });\n    });\n\n    it('handles errors', () => {\n      var response = {\n        errors: [{\n          message: 'Something went wrong.',\n          locations: [{\n            column: 10,\n            line: 1,\n          }],\n        }],\n      };\n\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      fetch.mock.deferreds[0].resolve(genResponse(response));\n      jest.runAllTimers();\n\n      expect(rejectCallback.mock.calls.length).toBe(1);\n      var error = rejectCallback.mock.calls[0][0];\n      expect(error instanceof Error).toBe(true);\n      expect(error.message).toEqual([\n        'Server request for mutation \\`FeedbackLikeMutation\\` failed for the ' +\n          'following reasons:',\n        '',\n        '1. Something went wrong.',\n        '   ' + request.getQueryString().substr(0, 60),\n        '            ^^^',\n      ].join('\\n'));\n      expect(error.source).toEqual(response);\n    });\n\n    it('handles custom errors', () => {\n      var response = {\n        errors: [{\n          message: 'Something went wrong.',\n        }],\n      };\n\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      fetch.mock.deferreds[0].resolve(genResponse(response));\n      jest.runAllTimers();\n\n      expect(rejectCallback.mock.calls.length).toBe(1);\n      var error = rejectCallback.mock.calls[0][0];\n      expect(error instanceof Error).toBe(true);\n      expect(error.message).toEqual([\n        'Server request for mutation \\`FeedbackLikeMutation\\` failed for the ' +\n          'following reasons:',\n        '',\n        '1. Something went wrong.',\n      ].join('\\n'));\n      expect(error.source).toEqual(response);\n    });\n\n  });\n\n  describe('sendQueries', () => {\n    var queryA;\n    var queryB;\n    var requestA;\n    var requestB;\n    var route;\n\n    beforeEach(() => {\n      route = RelayMetaRoute.get('$fetchRelayQuery');\n      queryA = RelayQuery.Root.create(\n        Relay.QL`query{node(id:\"123\"){id}}`, route, {}\n      );\n      queryB = RelayQuery.Root.create(\n        Relay.QL`query{node(id:\"456\"){id}}`, route, {}\n      );\n      requestA = new RelayQueryRequest(queryA);\n      requestB = new RelayQueryRequest(queryB);\n    });\n\n    it('invokes `fetchWithRetries` with the correct values', () => {\n      expect(fetchWithRetries).not.toBeCalled();\n      networkLayer.sendQueries([requestA]);\n      expect(fetchWithRetries).toBeCalled();\n      var call = fetchWithRetries.mock.calls[0];\n      expect(call[0]).toBe(networkConfig.uri);\n      var {body, fetchTimeout, headers, method, retryDelays} = call[1];\n      expect(body).toBe(JSON.stringify({\n        query: requestA.getQueryString(),\n        variables: queryA.getVariables(),\n      }));\n      expect(fetchTimeout).toBe(networkConfig.init.fetchTimeout);\n      expect(headers).toEqual({\n        'Accept': '*/*',\n        'Content-Encoding': 'gzip',\n        'Content-Type': 'application/json',\n      });\n      expect(method).toBe('POST');\n      expect(retryDelays).toEqual(networkConfig.init.retryDelays);\n    });\n\n    it('resolves with fetched response payloads', () => {\n      var resolveACallback = jest.genMockFunction();\n      var resolveBCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA, requestB]);\n      requestA.getPromise().done(resolveACallback);\n      requestB.getPromise().done(resolveBCallback);\n      jest.runAllTimers();\n\n      var payloadA = {\n        data: {'123': {id: '123'}},\n      };\n      var payloadB = {\n        data: {'456': {id: '456'}},\n      };\n      fetchWithRetries.mock.deferreds[0].resolve(genResponse(payloadA));\n      fetchWithRetries.mock.deferreds[1].resolve(genResponse(payloadB));\n      jest.runAllTimers();\n\n      expect(resolveACallback.mock.calls.length).toBe(1);\n      expect(resolveACallback.mock.calls[0][0]).toEqual({\n        response: payloadA.data,\n      });\n      expect(resolveBCallback.mock.calls.length).toBe(1);\n      expect(resolveBCallback.mock.calls[0][0]).toEqual({\n        response: payloadB.data,\n      });\n    });\n\n    it('rejects invalid JSON response payloads', () => {\n      var rejectCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA]);\n      requestA.getPromise().catch(rejectCallback);\n      jest.runAllTimers();\n\n      fetchWithRetries.mock.deferreds[0].resolve({\n        json: () => Promise.reject(JSON.parse('{ // invalid')),\n        status: 200,\n      });\n      jest.runAllTimers();\n\n      expect(rejectCallback).toBeCalled();\n      expect(rejectCallback.mock.calls[0][0].message).toEqual(\n        'Unexpected token /'\n      );\n    });\n\n    it('rejects errors in query responses', () => {\n      var rejectCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA]);\n      requestA.getPromise().catch(rejectCallback);\n      jest.runAllTimers();\n\n      var payloadA = {\n        data: {},\n        errors: [{\n          message: 'Something went wrong.',\n          locations: [{\n            column: 7,\n            line: 1,\n          }],\n        }],\n      };\n      fetchWithRetries.mock.deferreds[0].resolve(genResponse(payloadA));\n      jest.runAllTimers();\n\n      expect(rejectCallback).toBeCalled();\n      var error = rejectCallback.mock.calls[0][0];\n      expect(error.message).toEqual([\n        'Server request for query `RelayDefaultNetworkLayer` failed for the ' +\n          'following reasons:',\n        '',\n        '1. Something went wrong.',\n        '   ' + requestA.getQueryString().substr(0, 60),\n        '         ^^^',\n      ].join('\\n'));\n      expect(error.source).toEqual(payloadA);\n    });\n\n    it('rejects requests with missing responses', () => {\n      var rejectACallback = jest.genMockFunction();\n      var resolveBCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA, requestB]);\n      requestA.getPromise().catch(rejectACallback);\n      requestB.getPromise().done(resolveBCallback);\n      jest.runAllTimers();\n\n      var payload = {\n        data: {'456': {id: '456'}},\n      };\n      fetchWithRetries.mock.deferreds[0].resolve(genResponse({}));\n      fetchWithRetries.mock.deferreds[1].resolve(genResponse(payload));\n      jest.runAllTimers();\n\n      expect(resolveBCallback).toBeCalled();\n      expect(rejectACallback).toBeCalled();\n      expect(rejectACallback.mock.calls[0][0].message).toEqual(\n        'Server response was missing for query `RelayDefaultNetworkLayer`.'\n      );\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayDefaultNetworkLayer","RelayMetaRoute","RelayMutationRequest","RelayQuery","RelayQueryRequest","RelayTestUtils","fetch","fetchWithRetries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayDefaultNetworkLayer = require('RelayDefaultNetworkLayer');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayMutationRequest = require('RelayMutationRequest');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryRequest = require('RelayQueryRequest');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst fetch = require('fetch');\nconst fetchWithRetries = require('fetchWithRetries');\n\ndescribe('RelayDefaultNetworkLayer', () => {\n  var networkConfig;\n  var networkLayer;\n\n  function genResponse(data) {\n    return {\n      json: () => Promise.resolve(data),\n      status: 200,\n    };\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    networkConfig = {\n      uri: '/graphql',\n      init: {\n        fetchTimeout: 15000,\n        headers: {\n          // This should be merged into headers.\n          'Content-Encoding': 'gzip',\n          // This should always be ignored.\n          'Content-Type': 'application/bogus',\n        },\n        // This should always be ignored.\n        method: 'GET',\n        retryDelays: [1000, 3000],\n      },\n    };\n    // Spread properties to test that functions are bound correctly.\n    networkLayer = {\n      ...new RelayDefaultNetworkLayer(\n        networkConfig.uri,\n        networkConfig.init\n      ),\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('sendMutation', () => {\n    var request;\n    var variables;\n    var responseCallback;\n    var rejectCallback;\n\n    beforeEach(() => {\n      responseCallback = jest.genMockFunction();\n      rejectCallback = jest.genMockFunction();\n\n      variables = {\n        input: {\n          [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'client:a',\n          actor_id: 4,\n        },\n      };\n      var mutation = RelayQuery.Mutation.build(\n        'FeedbackLikeMutation',\n        'FeedbackLikeResponsePayload',\n        'feedback_like',\n        variables.input,\n        [RelayQuery.Field.build({\n          fieldName: 'does_viewer_like',\n          type: 'Boolean',\n        })],\n        {inputType: 'FeedbackLikeInput'}\n      );\n      request = new RelayMutationRequest(mutation);\n      request.getPromise().then(responseCallback).catch(rejectCallback);\n    });\n\n    it('sends correct data to server', () => {\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      var call = fetch.mock.calls[0];\n      expect(call[0]).toBe(networkConfig.uri);\n      var {body, headers, method} = call[1];\n\n      expect(method).toBe('POST');\n      expect(headers).toEqual({\n        'Accept': '*/*',\n        'Content-Encoding': 'gzip',\n        'Content-Type': 'application/json',\n      });\n      expect(body).toEqual(JSON.stringify({\n        query: request.getQueryString(),\n        variables: {\n          input_0: variables.input,\n        },\n      }));\n    });\n\n    it('handles responses', () => {\n      var response = {\n        data: {\n          test_call: {\n            field: 1,\n          },\n        },\n      };\n\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      fetch.mock.deferreds[0].resolve(genResponse(response));\n      jest.runAllTimers();\n\n      expect(rejectCallback.mock.calls.length).toBe(0);\n      expect(responseCallback.mock.calls.length).toBe(1);\n      expect(responseCallback.mock.calls[0][0]).toEqual({\n        response: response.data,\n      });\n    });\n\n    it('handles errors', () => {\n      var response = {\n        errors: [{\n          message: 'Something went wrong.',\n          locations: [{\n            column: 10,\n            line: 1,\n          }],\n        }],\n      };\n\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      fetch.mock.deferreds[0].resolve(genResponse(response));\n      jest.runAllTimers();\n\n      expect(rejectCallback.mock.calls.length).toBe(1);\n      var error = rejectCallback.mock.calls[0][0];\n      expect(error instanceof Error).toBe(true);\n      expect(error.message).toEqual([\n        'Server request for mutation \\`FeedbackLikeMutation\\` failed for the ' +\n          'following reasons:',\n        '',\n        '1. Something went wrong.',\n        '   ' + request.getQueryString().substr(0, 60),\n        '            ^^^',\n      ].join('\\n'));\n      expect(error.source).toEqual(response);\n    });\n\n    it('handles custom errors', () => {\n      var response = {\n        errors: [{\n          message: 'Something went wrong.',\n        }],\n      };\n\n      expect(fetch).not.toBeCalled();\n      networkLayer.sendMutation(request);\n      expect(fetch).toBeCalled();\n\n      fetch.mock.deferreds[0].resolve(genResponse(response));\n      jest.runAllTimers();\n\n      expect(rejectCallback.mock.calls.length).toBe(1);\n      var error = rejectCallback.mock.calls[0][0];\n      expect(error instanceof Error).toBe(true);\n      expect(error.message).toEqual([\n        'Server request for mutation \\`FeedbackLikeMutation\\` failed for the ' +\n          'following reasons:',\n        '',\n        '1. Something went wrong.',\n      ].join('\\n'));\n      expect(error.source).toEqual(response);\n    });\n\n  });\n\n  describe('sendQueries', () => {\n    var queryA;\n    var queryB;\n    var requestA;\n    var requestB;\n    var route;\n\n    beforeEach(() => {\n      route = RelayMetaRoute.get('$fetchRelayQuery');\n      queryA = RelayQuery.Root.create(\n        Relay.QL`query{node(id:\"123\"){id}}`, route, {}\n      );\n      queryB = RelayQuery.Root.create(\n        Relay.QL`query{node(id:\"456\"){id}}`, route, {}\n      );\n      requestA = new RelayQueryRequest(queryA);\n      requestB = new RelayQueryRequest(queryB);\n    });\n\n    it('invokes `fetchWithRetries` with the correct values', () => {\n      expect(fetchWithRetries).not.toBeCalled();\n      networkLayer.sendQueries([requestA]);\n      expect(fetchWithRetries).toBeCalled();\n      var call = fetchWithRetries.mock.calls[0];\n      expect(call[0]).toBe(networkConfig.uri);\n      var {body, fetchTimeout, headers, method, retryDelays} = call[1];\n      expect(body).toBe(JSON.stringify({\n        query: requestA.getQueryString(),\n        variables: queryA.getVariables(),\n      }));\n      expect(fetchTimeout).toBe(networkConfig.init.fetchTimeout);\n      expect(headers).toEqual({\n        'Accept': '*/*',\n        'Content-Encoding': 'gzip',\n        'Content-Type': 'application/json',\n      });\n      expect(method).toBe('POST');\n      expect(retryDelays).toEqual(networkConfig.init.retryDelays);\n    });\n\n    it('resolves with fetched response payloads', () => {\n      var resolveACallback = jest.genMockFunction();\n      var resolveBCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA, requestB]);\n      requestA.getPromise().done(resolveACallback);\n      requestB.getPromise().done(resolveBCallback);\n      jest.runAllTimers();\n\n      var payloadA = {\n        data: {'123': {id: '123'}},\n      };\n      var payloadB = {\n        data: {'456': {id: '456'}},\n      };\n      fetchWithRetries.mock.deferreds[0].resolve(genResponse(payloadA));\n      fetchWithRetries.mock.deferreds[1].resolve(genResponse(payloadB));\n      jest.runAllTimers();\n\n      expect(resolveACallback.mock.calls.length).toBe(1);\n      expect(resolveACallback.mock.calls[0][0]).toEqual({\n        response: payloadA.data,\n      });\n      expect(resolveBCallback.mock.calls.length).toBe(1);\n      expect(resolveBCallback.mock.calls[0][0]).toEqual({\n        response: payloadB.data,\n      });\n    });\n\n    it('rejects invalid JSON response payloads', () => {\n      var rejectCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA]);\n      requestA.getPromise().catch(rejectCallback);\n      jest.runAllTimers();\n\n      fetchWithRetries.mock.deferreds[0].resolve({\n        json: () => Promise.reject(JSON.parse('{ // invalid')),\n        status: 200,\n      });\n      jest.runAllTimers();\n\n      expect(rejectCallback).toBeCalled();\n      expect(rejectCallback.mock.calls[0][0].message).toEqual(\n        'Unexpected token /'\n      );\n    });\n\n    it('rejects errors in query responses', () => {\n      var rejectCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA]);\n      requestA.getPromise().catch(rejectCallback);\n      jest.runAllTimers();\n\n      var payloadA = {\n        data: {},\n        errors: [{\n          message: 'Something went wrong.',\n          locations: [{\n            column: 7,\n            line: 1,\n          }],\n        }],\n      };\n      fetchWithRetries.mock.deferreds[0].resolve(genResponse(payloadA));\n      jest.runAllTimers();\n\n      expect(rejectCallback).toBeCalled();\n      var error = rejectCallback.mock.calls[0][0];\n      expect(error.message).toEqual([\n        'Server request for query `RelayDefaultNetworkLayer` failed for the ' +\n          'following reasons:',\n        '',\n        '1. Something went wrong.',\n        '   ' + requestA.getQueryString().substr(0, 60),\n        '         ^^^',\n      ].join('\\n'));\n      expect(error.source).toEqual(payloadA);\n    });\n\n    it('rejects requests with missing responses', () => {\n      var rejectACallback = jest.genMockFunction();\n      var resolveBCallback = jest.genMockFunction();\n      networkLayer.sendQueries([requestA, requestB]);\n      requestA.getPromise().catch(rejectACallback);\n      requestB.getPromise().done(resolveBCallback);\n      jest.runAllTimers();\n\n      var payload = {\n        data: {'456': {id: '456'}},\n      };\n      fetchWithRetries.mock.deferreds[0].resolve(genResponse({}));\n      fetchWithRetries.mock.deferreds[1].resolve(genResponse(payload));\n      jest.runAllTimers();\n\n      expect(resolveBCallback).toBeCalled();\n      expect(rejectACallback).toBeCalled();\n      expect(rejectACallback.mock.calls[0][0].message).toEqual(\n        'Server response was missing for query `RelayDefaultNetworkLayer`.'\n      );\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/network-layer/default/__tests__/RelayDefaultNetworkLayer-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/writeRelayUpdatePayload.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('writeRelayUpdatePayload');\n","dependencies":["writeRelayUpdatePayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('writeRelayUpdatePayload');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/writeRelayUpdatePayload.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/writeRelayQueryPayload.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('writeRelayQueryPayload')\n);\n","dependencies":["writeRelayQueryPayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('writeRelayQueryPayload')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/writeRelayQueryPayload.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/transformRelayQueryPayload.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('transformRelayQueryPayload');\n","dependencies":["transformRelayQueryPayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('transformRelayQueryPayload');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/transformRelayQueryPayload.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/subtractRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('subtractRelayQuery')\n);\n","dependencies":["subtractRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('subtractRelayQuery')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/subtractRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/splitDeferredRelayQueries.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('splitDeferredRelayQueries')\n);\n","dependencies":["splitDeferredRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('splitDeferredRelayQueries')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/splitDeferredRelayQueries.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/sortTypeFirst.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('sortTypeFirst');\n","dependencies":["sortTypeFirst"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('sortTypeFirst');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/sortTypeFirst.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/printRelayOSSQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('printRelayOSSQuery');\n","dependencies":["printRelayOSSQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('printRelayOSSQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/printRelayOSSQuery.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/intersectRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('intersectRelayQuery')\n);\n","dependencies":["intersectRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('intersectRelayQuery')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/intersectRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/inferRelayFieldsFromData.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('inferRelayFieldsFromData')\n);\n","dependencies":["inferRelayFieldsFromData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('inferRelayFieldsFromData')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/inferRelayFieldsFromData.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/flattenSplitRelayQueries.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('flattenSplitRelayQueries');\n","dependencies":["flattenSplitRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('flattenSplitRelayQueries');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/flattenSplitRelayQueries.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/flattenRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('flattenRelayQuery');\n","dependencies":["flattenRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('flattenRelayQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/flattenRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/findRelayQueryLeaves.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('findRelayQueryLeaves')\n);\n","dependencies":["findRelayQueryLeaves"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('findRelayQueryLeaves')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/findRelayQueryLeaves.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/filterRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('filterRelayQuery');\n","dependencies":["filterRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('filterRelayQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/filterRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/diffRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('diffRelayQuery')\n);\n","dependencies":["diffRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('diffRelayQuery')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/diffRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/containsRelayQueryRootCall.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('containsRelayQueryRootCall');\n","dependencies":["containsRelayQueryRootCall"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('containsRelayQueryRootCall');\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/containsRelayQueryRootCall.js"}},"/Users/cpojer/Projects/relay/src/traversal/__mocks__/checkRelayQueryData.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('checkRelayQueryData')\n);\n","dependencies":["checkRelayQueryData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('checkRelayQueryData')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__mocks__/checkRelayQueryData.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayUpdatePayload-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst Relay = require('Relay');\nconst RelayChangeTracker = require('RelayChangeTracker');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayQueryWriter = require('RelayQueryWriter');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateClientEdgeID = require('generateClientEdgeID');\nconst writeRelayUpdatePayload = require('writeRelayUpdatePayload');\n\ndescribe('writePayload()', () => {\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('range delete mutations', () => {\n    var store, queueStore, writer, queueWriter, commentID, connectionID, edgeID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var nodeConnectionMap = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      commentID = '123';\n\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false,\n        nodeConnectionMap\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        nodeConnectionMap,\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"feedback_id\") {\n            topLevelComments(first:\"1\") {\n              count,\n              edges {\n                node {\n                  id,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: 'feedback_id',\n          topLevelComments: {\n            count: 1,\n            edges: [\n              {\n                cursor: commentID + ':cursor',\n                node: {\n                  id: commentID,\n                },\n              },\n            ],\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      connectionID = store.getLinkedRecordID(\n        'feedback_id',\n        'topLevelComments'\n      );\n      edgeID = generateClientEdgeID(connectionID, commentID);\n    });\n\n    it('optimistically removes range edges', () => {\n      // create the mutation and payload\n      var input = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: commentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              topLevelComments {\n                count,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n        pathToConnection: ['feedback', 'topLevelComments'],\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: commentID,\n        feedback: {\n          id: 'feedback_id',\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range edge deleted & count changed\n          [edgeID]: true, // edge deleted\n          // `commentID` is not modified\n        },\n      });\n\n      expect(queueStore.getField(connectionID, 'count')).toBe(0);\n      expect(queueStore.getRecordState(edgeID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(commentID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([]);\n\n      expect(store.getField(connectionID, 'count')).toBe(1);\n      expect(store.getRecordState(edgeID)).toBe('EXISTENT');\n      // the range still contains this edge\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n      ]);\n    });\n\n    it('non-optimistically removes range edges', () => {\n      // create the mutation and payload\n      var input = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: commentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              topLevelComments {\n                count,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n        pathToConnection: ['feedback', 'topLevelComments'],\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: commentID,\n        feedback: {\n          id: 'feedback_id',\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range edge deleted & count changed\n          [edgeID]: true, // edge deleted\n          // `commentID` is not modified\n        },\n      });\n\n      expect(store.getField(connectionID, 'count')).toBe(0);\n      expect(store.getRecordState(edgeID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(commentID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([]);\n    });\n\n    it('removes range edge with a \"deleted field ID path\"', () => {\n      writePayload(\n        store,\n        writer,\n        getNode(Relay.QL`\n          query {\n            viewer {\n              actor {\n                friends(first: \"1\") {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            }\n          }\n        `),\n        {\n          viewer: {\n            actor: {\n              id: '123',\n              friends: {\n                edges: [\n                  {\n                    node: {\n                      id: '456',\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        }\n      );\n      const friendConnectionID = store.getLinkedRecordID('123', 'friends');\n      const friendEdgeID = generateClientEdgeID(friendConnectionID, '456');\n\n      const input = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        friendId: '456',\n      };\n      const mutation = getNode(Relay.QL`\n        mutation {\n          unfriend(input: $input) {\n            actor {\n              friends(first: \"1\") {\n                edges {\n                  node {\n                    id\n                  }\n                }\n              }\n            }\n            formerFriend {\n              id\n            }\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      const configs = [{\n        type: RelayMutationType.RANGE_DELETE,\n        parentName: 'actor',\n        parentID: '123',\n        connectionName: 'friends',\n        deletedIDFieldName: ['formerFriend'],\n        pathToConnection: ['actor', 'friends'],\n      }];\n\n      const payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        actor: {\n          id: '123',\n          friends: {\n            edges: [],\n          },\n        },\n        formerFriend: {\n          id: '456',\n        },\n      };\n      const changeTracker = new RelayChangeTracker();\n      const queryTracker = new RelayQueryTracker();\n      const queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [friendConnectionID]: true,\n          [friendEdgeID]: true,\n        },\n      });\n\n      expect(store.getRecordState(friendEdgeID)).toBe('NONEXISTENT');\n      expect(store.getRecordState('456')).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(store.getRangeMetadata(\n        friendConnectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([]);\n    });\n  });\n\n  describe('node/range delete mutations', () => {\n    var store, queueStore, writer, queueWriter, feedbackID, connectionID,\n      firstCommentID,  secondCommentID, firstEdgeID, secondEdgeID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var nodeConnectionMap = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      feedbackID = 'feedback123';\n      firstCommentID = 'comment456';\n      secondCommentID = 'comment789';\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false,\n        nodeConnectionMap\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        nodeConnectionMap,\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"feedback123\") {\n            topLevelComments(first:\"1\") {\n              count,\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 1,\n            edges: [\n              {\n                cursor: firstCommentID + ':cursor',\n                node: {\n                  id: firstCommentID,\n                },\n              },\n              {\n                cursor: secondCommentID + ':cursor',\n                node: {\n                  id: secondCommentID,\n                },\n              },\n            ],\n          },\n        },\n      };\n\n      writePayload(store, writer, query, payload);\n      connectionID = store.getLinkedRecordID(feedbackID, 'topLevelComments');\n      firstEdgeID = generateClientEdgeID(connectionID, firstCommentID);\n      secondEdgeID = generateClientEdgeID(connectionID, secondCommentID);\n    });\n\n    it('optimistically deletes comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: firstCommentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              id,\n              topLevelComments {\n                count\n              }\n            }\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: firstCommentID,\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range item deleted & count changed\n          [firstEdgeID]: true, // edge deleted\n          [firstCommentID]: true, // node deleted\n        },\n      });\n\n      // node is deleted\n      expect(queueStore.getRecordState(firstCommentID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(secondCommentID)).toBe('EXISTENT');\n      // corresponding edge is deleted for every range this node appears in\n      expect(queueStore.getRecordState(firstEdgeID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(secondEdgeID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        secondEdgeID,\n      ]);\n      // connection metadata is merged into the queued store\n      expect(queueStore.getField(connectionID, 'count')).toBe(0);\n\n      // base records are not modified: node & edge exist, the edge is still\n      // in the range, and the connection metadata is unchanged\n      expect(store.getRecordState(firstCommentID)).toBe('EXISTENT');\n      expect(store.getRecordState(secondCommentID)).toBe('EXISTENT');\n      expect(store.getRecordState(firstEdgeID)).toBe('EXISTENT');\n      expect(store.getRecordState(secondEdgeID)).toBe('EXISTENT');\n      expect(store.getField(connectionID, 'count')).toBe(1);\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        firstEdgeID,\n        secondEdgeID,\n      ]);\n    });\n\n    it('non-optimistically deletes comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: firstCommentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              id,\n              topLevelComments {\n                count\n              }\n            }\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: firstCommentID,\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the base store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range item deleted & count changed\n          [firstEdgeID]: true, // edge deleted\n          [firstCommentID]: true, // node deleted\n        },\n      });\n\n      // node is deleted\n      expect(store.getRecordState(firstCommentID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(secondCommentID)).toBe('EXISTENT');\n      // corresponding edge is deleted for every range this node appears in\n      expect(store.getRecordState(firstEdgeID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(secondEdgeID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        secondEdgeID,\n      ]);\n      // connection metadata is merged into the queued store\n      expect(store.getField(connectionID, 'count')).toBe(0);\n    });\n  });\n\n  describe('plural node delete mutation', () => {\n    var store, queueStore, writer, queueWriter, firstRequestID, secondRequestID,\n      thirdRequestID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      firstRequestID = 'request1';\n      secondRequestID = 'request2';\n      thirdRequestID = 'request3';\n\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        {}\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        {}\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        {},\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          nodes(ids:[\"request1\",\"request2\",\"request3\"]) {\n            id\n          }\n        }\n      `);\n      var payload = {\n        nodes: [\n          {id: firstRequestID},\n          {id: secondRequestID},\n          {id: thirdRequestID},\n        ],\n      };\n\n      writePayload(store, writer, query, payload);\n\n    });\n    it('optimistically deletes requests', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          applicationRequestDeleteAll(input:$input) {\n            deletedRequestIds,\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedRequestIds',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [firstRequestID]: true, // node deleted\n          [secondRequestID]: true, // node deleted\n        },\n      });\n\n      // node is deleted\n      expect(queueStore.getRecordState(firstRequestID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(secondRequestID)).toBe('NONEXISTENT');\n      // third node is not deleted\n      expect(queueStore.getRecordState(thirdRequestID)).toBe('EXISTENT');\n\n      // base records are not modified: node & edge exist, the edge is still\n      // in the range, and the connection metadata is unchanged\n      expect(store.getRecordState(firstRequestID)).toBe('EXISTENT');\n      expect(store.getRecordState(secondRequestID)).toBe('EXISTENT');\n      expect(store.getRecordState(thirdRequestID)).toBe('EXISTENT');\n    });\n\n    it('non-optimistically deletes requests', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          applicationRequestDeleteAll(input:$input) {\n            deletedRequestIds,\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedRequestIds',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n\n      // write to the base store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [firstRequestID]: true, // node deleted\n          [secondRequestID]: true,\n        },\n      });\n\n      // node is deleted\n      expect(store.getRecordState(firstRequestID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(secondRequestID)).toBe('NONEXISTENT');\n      // third node is not deleted\n      expect(store.getRecordState(thirdRequestID)).toBe('EXISTENT');\n    });\n  });\n\n  describe('range add mutations', () => {\n    var store, queueStore, writer, queueWriter, feedbackID, connectionID,\n      commentID, edgeID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var nodeConnectionMap = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      feedbackID = 'feedback123';\n      commentID = 'comment456';\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false,\n        nodeConnectionMap\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        nodeConnectionMap,\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"feedback123\") {\n            topLevelComments(first:\"1\") {\n              count,\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 1,\n            edges: [\n              {\n                cursor: commentID + ':cursor',\n                node: {\n                  id: commentID,\n                },\n              },\n            ],\n          },\n        },\n      };\n\n      writePayload(store, writer, query, payload);\n      connectionID = store.getLinkedRecordID(feedbackID, 'topLevelComments');\n      edgeID = generateClientEdgeID(connectionID, commentID);\n    });\n\n    it('warns if the created `edge` field is missing in the payload', () => {\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        feedback_id: feedbackID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            feedback {\n              id,\n              topLevelComments {\n                count,\n              },\n            },\n          }\n        }\n      `, {input: JSON.stringify(input)}\n      );\n      var configs = [{\n        type: RelayMutationType.RANGE_ADD,\n        connectionName: 'topLevelComments',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n      }];\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 2,\n          },\n        },\n      };\n\n      // write to queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect([\n        'writeRelayUpdatePayload(): Expected response payload to include the ' +\n        'newly created edge `%s` and its `node` field. Did you forget to ' +\n        'update the `RANGE_ADD` mutation config?',\n        'feedbackCommentEdge',\n      ]).toBeWarnedNTimes(1);\n\n      // feedback is updated, but the edge is not added\n      expect(queueStore.getField(connectionID, 'count')).toBe(2);\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([edgeID]);\n    });\n\n    it('optimistically prepends comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        feedback_id: feedbackID,\n        message: {\n          text: 'Hello!',\n          ranges: [],\n        },\n      };\n\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            feedback {\n              id,\n              topLevelComments {\n                count,\n              },\n            },\n            feedbackCommentEdge {\n              cursor,\n              node {\n                id,\n                body {\n                  text,\n                },\n              },\n              source {\n                id,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_ADD,\n        connectionName: 'topLevelComments',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n      }];\n\n      var nextCursor = 'comment789:cursor';\n      var nextNodeID = 'comment789';\n      var bodyID = 'client:2';\n      var nextEdgeID = generateClientEdgeID(connectionID, nextNodeID);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 2,\n          },\n        },\n        feedbackCommentEdge: {\n          cursor: nextCursor,\n          node: {\n            id: nextNodeID,\n            body: {\n              text: input.message.text,\n            },\n          },\n          source: {\n            id: feedbackID,\n          },\n        },\n      };\n\n      // write to queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          [nextNodeID]: true, // node added\n          [nextEdgeID]: true, // edge added\n          [bodyID]: true, // `body` subfield\n        },\n        updated: {\n          [connectionID]: true, // range item added & count changed\n        },\n      });\n\n      // queued records are updated: edge/node added\n      expect(queueStore.getField(connectionID, 'count')).toBe(2);\n      expect(queueStore.getLinkedRecordID(nextEdgeID, 'source')).toBe(\n        feedbackID\n      );\n      expect(queueStore.getField(nextEdgeID, 'cursor')).toBe(nextCursor);\n      expect(queueStore.getLinkedRecordID(nextEdgeID, 'node')).toBe(nextNodeID);\n      expect(queueStore.getField(nextNodeID, 'id')).toBe(nextNodeID);\n      expect(queueStore.getLinkedRecordID(nextNodeID, 'body')).toBe(bodyID);\n      expect(queueStore.getField(bodyID, 'text')).toBe(input.message.text);\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        nextEdgeID,\n        edgeID,\n      ]);\n\n      // base records are not modified\n      expect(store.getField(connectionID, 'count')).toBe(1);\n      expect(store.getRecordState(nextEdgeID)).toBe('UNKNOWN');\n      expect(store.getRecordState(nextNodeID)).toBe('UNKNOWN');\n      expect(store.getRecordState(bodyID)).toBe('UNKNOWN');\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n      ]);\n    });\n\n    it('non-optimistically prepends comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        feedback_id: feedbackID,\n        message: {\n          text: 'Hello!',\n          ranges: [],\n        },\n      };\n\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            feedback {\n              id,\n              topLevelComments {\n                count,\n              },\n            },\n            feedbackCommentEdge {\n              cursor,\n              node {\n                id,\n                body {\n                  text,\n                },\n              },\n              source {\n                id,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_ADD,\n        connectionName: 'topLevelComments',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n      }];\n\n      var nextCursor = 'comment789:cursor';\n      var nextNodeID = 'comment789';\n      var bodyID = 'client:2';\n      var nextEdgeID = generateClientEdgeID(connectionID, nextNodeID);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 2,\n          },\n        },\n        feedbackCommentEdge: {\n          cursor: nextCursor,\n          node: {\n            id: nextNodeID,\n            body: {\n              text: input.message.text,\n            },\n          },\n          source: {\n            id: feedbackID,\n          },\n        },\n      };\n\n      // write to base store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          [nextNodeID]: true, // node added\n          [nextEdgeID]: true, // edge added\n          [bodyID]: true, // `body` subfield\n        },\n        updated: {\n          [connectionID]: true, // range item added & count changed\n        },\n      });\n\n      // base records are updated: edge/node added\n      expect(store.getField(connectionID, 'count')).toBe(2);\n      expect(store.getLinkedRecordID(nextEdgeID, 'source')).toBe(\n        feedbackID\n      );\n      expect(store.getField(nextEdgeID, 'cursor')).toBe(nextCursor);\n      expect(store.getLinkedRecordID(nextEdgeID, 'node')).toBe(nextNodeID);\n      expect(store.getField(nextNodeID, 'id')).toBe(nextNodeID);\n      expect(store.getType(nextNodeID)).toBe('Comment');\n      expect(store.getLinkedRecordID(nextNodeID, 'body')).toBe(bodyID);\n      expect(store.getField(bodyID, 'text')).toBe(input.message.text);\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        nextEdgeID,\n        edgeID,\n      ]);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLMutatorConstants","Relay","RelayChangeTracker","RelayConnectionInterface","RelayMutationType","RelayQueryTracker","RelayQueryWriter","RelayRecordStore","RelayRecordWriter","RelayTestUtils","generateClientEdgeID","writeRelayUpdatePayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst Relay = require('Relay');\nconst RelayChangeTracker = require('RelayChangeTracker');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayQueryWriter = require('RelayQueryWriter');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateClientEdgeID = require('generateClientEdgeID');\nconst writeRelayUpdatePayload = require('writeRelayUpdatePayload');\n\ndescribe('writePayload()', () => {\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('range delete mutations', () => {\n    var store, queueStore, writer, queueWriter, commentID, connectionID, edgeID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var nodeConnectionMap = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      commentID = '123';\n\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false,\n        nodeConnectionMap\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        nodeConnectionMap,\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"feedback_id\") {\n            topLevelComments(first:\"1\") {\n              count,\n              edges {\n                node {\n                  id,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: 'feedback_id',\n          topLevelComments: {\n            count: 1,\n            edges: [\n              {\n                cursor: commentID + ':cursor',\n                node: {\n                  id: commentID,\n                },\n              },\n            ],\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      connectionID = store.getLinkedRecordID(\n        'feedback_id',\n        'topLevelComments'\n      );\n      edgeID = generateClientEdgeID(connectionID, commentID);\n    });\n\n    it('optimistically removes range edges', () => {\n      // create the mutation and payload\n      var input = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: commentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              topLevelComments {\n                count,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n        pathToConnection: ['feedback', 'topLevelComments'],\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: commentID,\n        feedback: {\n          id: 'feedback_id',\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range edge deleted & count changed\n          [edgeID]: true, // edge deleted\n          // `commentID` is not modified\n        },\n      });\n\n      expect(queueStore.getField(connectionID, 'count')).toBe(0);\n      expect(queueStore.getRecordState(edgeID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(commentID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([]);\n\n      expect(store.getField(connectionID, 'count')).toBe(1);\n      expect(store.getRecordState(edgeID)).toBe('EXISTENT');\n      // the range still contains this edge\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n      ]);\n    });\n\n    it('non-optimistically removes range edges', () => {\n      // create the mutation and payload\n      var input = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: commentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              topLevelComments {\n                count,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n        pathToConnection: ['feedback', 'topLevelComments'],\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: commentID,\n        feedback: {\n          id: 'feedback_id',\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range edge deleted & count changed\n          [edgeID]: true, // edge deleted\n          // `commentID` is not modified\n        },\n      });\n\n      expect(store.getField(connectionID, 'count')).toBe(0);\n      expect(store.getRecordState(edgeID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(commentID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([]);\n    });\n\n    it('removes range edge with a \"deleted field ID path\"', () => {\n      writePayload(\n        store,\n        writer,\n        getNode(Relay.QL`\n          query {\n            viewer {\n              actor {\n                friends(first: \"1\") {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n            }\n          }\n        `),\n        {\n          viewer: {\n            actor: {\n              id: '123',\n              friends: {\n                edges: [\n                  {\n                    node: {\n                      id: '456',\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        }\n      );\n      const friendConnectionID = store.getLinkedRecordID('123', 'friends');\n      const friendEdgeID = generateClientEdgeID(friendConnectionID, '456');\n\n      const input = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        friendId: '456',\n      };\n      const mutation = getNode(Relay.QL`\n        mutation {\n          unfriend(input: $input) {\n            actor {\n              friends(first: \"1\") {\n                edges {\n                  node {\n                    id\n                  }\n                }\n              }\n            }\n            formerFriend {\n              id\n            }\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      const configs = [{\n        type: RelayMutationType.RANGE_DELETE,\n        parentName: 'actor',\n        parentID: '123',\n        connectionName: 'friends',\n        deletedIDFieldName: ['formerFriend'],\n        pathToConnection: ['actor', 'friends'],\n      }];\n\n      const payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        actor: {\n          id: '123',\n          friends: {\n            edges: [],\n          },\n        },\n        formerFriend: {\n          id: '456',\n        },\n      };\n      const changeTracker = new RelayChangeTracker();\n      const queryTracker = new RelayQueryTracker();\n      const queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [friendConnectionID]: true,\n          [friendEdgeID]: true,\n        },\n      });\n\n      expect(store.getRecordState(friendEdgeID)).toBe('NONEXISTENT');\n      expect(store.getRecordState('456')).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(store.getRangeMetadata(\n        friendConnectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([]);\n    });\n  });\n\n  describe('node/range delete mutations', () => {\n    var store, queueStore, writer, queueWriter, feedbackID, connectionID,\n      firstCommentID,  secondCommentID, firstEdgeID, secondEdgeID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var nodeConnectionMap = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      feedbackID = 'feedback123';\n      firstCommentID = 'comment456';\n      secondCommentID = 'comment789';\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false,\n        nodeConnectionMap\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        nodeConnectionMap,\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"feedback123\") {\n            topLevelComments(first:\"1\") {\n              count,\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 1,\n            edges: [\n              {\n                cursor: firstCommentID + ':cursor',\n                node: {\n                  id: firstCommentID,\n                },\n              },\n              {\n                cursor: secondCommentID + ':cursor',\n                node: {\n                  id: secondCommentID,\n                },\n              },\n            ],\n          },\n        },\n      };\n\n      writePayload(store, writer, query, payload);\n      connectionID = store.getLinkedRecordID(feedbackID, 'topLevelComments');\n      firstEdgeID = generateClientEdgeID(connectionID, firstCommentID);\n      secondEdgeID = generateClientEdgeID(connectionID, secondCommentID);\n    });\n\n    it('optimistically deletes comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: firstCommentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              id,\n              topLevelComments {\n                count\n              }\n            }\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: firstCommentID,\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range item deleted & count changed\n          [firstEdgeID]: true, // edge deleted\n          [firstCommentID]: true, // node deleted\n        },\n      });\n\n      // node is deleted\n      expect(queueStore.getRecordState(firstCommentID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(secondCommentID)).toBe('EXISTENT');\n      // corresponding edge is deleted for every range this node appears in\n      expect(queueStore.getRecordState(firstEdgeID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(secondEdgeID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        secondEdgeID,\n      ]);\n      // connection metadata is merged into the queued store\n      expect(queueStore.getField(connectionID, 'count')).toBe(0);\n\n      // base records are not modified: node & edge exist, the edge is still\n      // in the range, and the connection metadata is unchanged\n      expect(store.getRecordState(firstCommentID)).toBe('EXISTENT');\n      expect(store.getRecordState(secondCommentID)).toBe('EXISTENT');\n      expect(store.getRecordState(firstEdgeID)).toBe('EXISTENT');\n      expect(store.getRecordState(secondEdgeID)).toBe('EXISTENT');\n      expect(store.getField(connectionID, 'count')).toBe(1);\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        firstEdgeID,\n        secondEdgeID,\n      ]);\n    });\n\n    it('non-optimistically deletes comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedCommentId: firstCommentID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            deletedCommentId,\n            feedback {\n              id,\n              topLevelComments {\n                count\n              }\n            }\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedCommentId',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedCommentId: firstCommentID,\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 0,\n          },\n        },\n      };\n\n      // write to the base store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [connectionID]: true, // range item deleted & count changed\n          [firstEdgeID]: true, // edge deleted\n          [firstCommentID]: true, // node deleted\n        },\n      });\n\n      // node is deleted\n      expect(store.getRecordState(firstCommentID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(secondCommentID)).toBe('EXISTENT');\n      // corresponding edge is deleted for every range this node appears in\n      expect(store.getRecordState(firstEdgeID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(secondEdgeID)).toBe('EXISTENT');\n      // the range no longer returns this edge\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '1'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        secondEdgeID,\n      ]);\n      // connection metadata is merged into the queued store\n      expect(store.getField(connectionID, 'count')).toBe(0);\n    });\n  });\n\n  describe('plural node delete mutation', () => {\n    var store, queueStore, writer, queueWriter, firstRequestID, secondRequestID,\n      thirdRequestID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      firstRequestID = 'request1';\n      secondRequestID = 'request2';\n      thirdRequestID = 'request3';\n\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        {}\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        {}\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        {},\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          nodes(ids:[\"request1\",\"request2\",\"request3\"]) {\n            id\n          }\n        }\n      `);\n      var payload = {\n        nodes: [\n          {id: firstRequestID},\n          {id: secondRequestID},\n          {id: thirdRequestID},\n        ],\n      };\n\n      writePayload(store, writer, query, payload);\n\n    });\n    it('optimistically deletes requests', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          applicationRequestDeleteAll(input:$input) {\n            deletedRequestIds,\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedRequestIds',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n\n      // write to the queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [firstRequestID]: true, // node deleted\n          [secondRequestID]: true, // node deleted\n        },\n      });\n\n      // node is deleted\n      expect(queueStore.getRecordState(firstRequestID)).toBe('NONEXISTENT');\n      expect(queueStore.getRecordState(secondRequestID)).toBe('NONEXISTENT');\n      // third node is not deleted\n      expect(queueStore.getRecordState(thirdRequestID)).toBe('EXISTENT');\n\n      // base records are not modified: node & edge exist, the edge is still\n      // in the range, and the connection metadata is unchanged\n      expect(store.getRecordState(firstRequestID)).toBe('EXISTENT');\n      expect(store.getRecordState(secondRequestID)).toBe('EXISTENT');\n      expect(store.getRecordState(thirdRequestID)).toBe('EXISTENT');\n    });\n\n    it('non-optimistically deletes requests', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          applicationRequestDeleteAll(input:$input) {\n            deletedRequestIds,\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.NODE_DELETE,\n        deletedIDFieldName: 'deletedRequestIds',\n      }];\n\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        deletedRequestIds: [firstRequestID, secondRequestID],\n      };\n\n      // write to the base store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          [firstRequestID]: true, // node deleted\n          [secondRequestID]: true,\n        },\n      });\n\n      // node is deleted\n      expect(store.getRecordState(firstRequestID)).toBe('NONEXISTENT');\n      expect(store.getRecordState(secondRequestID)).toBe('NONEXISTENT');\n      // third node is not deleted\n      expect(store.getRecordState(thirdRequestID)).toBe('EXISTENT');\n    });\n  });\n\n  describe('range add mutations', () => {\n    var store, queueStore, writer, queueWriter, feedbackID, connectionID,\n      commentID, edgeID;\n\n    beforeEach(() => {\n      var records = {};\n      var queuedRecords = {};\n      var nodeConnectionMap = {};\n      var rootCallMap = {};\n      var rootCallMaps = {rootCallMap};\n\n      feedbackID = 'feedback123';\n      commentID = 'comment456';\n      store = new RelayRecordStore(\n        {records},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      queueStore = new RelayRecordStore(\n        {records, queuedRecords},\n        rootCallMaps,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        rootCallMap,\n        false,\n        nodeConnectionMap\n      );\n      queueWriter = new RelayRecordWriter(\n        queuedRecords,\n        rootCallMap,\n        true,\n        nodeConnectionMap,\n        null,\n        'mutationID'\n      );\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"feedback123\") {\n            topLevelComments(first:\"1\") {\n              count,\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 1,\n            edges: [\n              {\n                cursor: commentID + ':cursor',\n                node: {\n                  id: commentID,\n                },\n              },\n            ],\n          },\n        },\n      };\n\n      writePayload(store, writer, query, payload);\n      connectionID = store.getLinkedRecordID(feedbackID, 'topLevelComments');\n      edgeID = generateClientEdgeID(connectionID, commentID);\n    });\n\n    it('warns if the created `edge` field is missing in the payload', () => {\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        feedback_id: feedbackID,\n      };\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            feedback {\n              id,\n              topLevelComments {\n                count,\n              },\n            },\n          }\n        }\n      `, {input: JSON.stringify(input)}\n      );\n      var configs = [{\n        type: RelayMutationType.RANGE_ADD,\n        connectionName: 'topLevelComments',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n      }];\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 2,\n          },\n        },\n      };\n\n      // write to queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect([\n        'writeRelayUpdatePayload(): Expected response payload to include the ' +\n        'newly created edge `%s` and its `node` field. Did you forget to ' +\n        'update the `RANGE_ADD` mutation config?',\n        'feedbackCommentEdge',\n      ]).toBeWarnedNTimes(1);\n\n      // feedback is updated, but the edge is not added\n      expect(queueStore.getField(connectionID, 'count')).toBe(2);\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([edgeID]);\n    });\n\n    it('optimistically prepends comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        feedback_id: feedbackID,\n        message: {\n          text: 'Hello!',\n          ranges: [],\n        },\n      };\n\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            feedback {\n              id,\n              topLevelComments {\n                count,\n              },\n            },\n            feedbackCommentEdge {\n              cursor,\n              node {\n                id,\n                body {\n                  text,\n                },\n              },\n              source {\n                id,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_ADD,\n        connectionName: 'topLevelComments',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n      }];\n\n      var nextCursor = 'comment789:cursor';\n      var nextNodeID = 'comment789';\n      var bodyID = 'client:2';\n      var nextEdgeID = generateClientEdgeID(connectionID, nextNodeID);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 2,\n          },\n        },\n        feedbackCommentEdge: {\n          cursor: nextCursor,\n          node: {\n            id: nextNodeID,\n            body: {\n              text: input.message.text,\n            },\n          },\n          source: {\n            id: feedbackID,\n          },\n        },\n      };\n\n      // write to queued store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        queueStore,\n        queueWriter,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: true}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          [nextNodeID]: true, // node added\n          [nextEdgeID]: true, // edge added\n          [bodyID]: true, // `body` subfield\n        },\n        updated: {\n          [connectionID]: true, // range item added & count changed\n        },\n      });\n\n      // queued records are updated: edge/node added\n      expect(queueStore.getField(connectionID, 'count')).toBe(2);\n      expect(queueStore.getLinkedRecordID(nextEdgeID, 'source')).toBe(\n        feedbackID\n      );\n      expect(queueStore.getField(nextEdgeID, 'cursor')).toBe(nextCursor);\n      expect(queueStore.getLinkedRecordID(nextEdgeID, 'node')).toBe(nextNodeID);\n      expect(queueStore.getField(nextNodeID, 'id')).toBe(nextNodeID);\n      expect(queueStore.getLinkedRecordID(nextNodeID, 'body')).toBe(bodyID);\n      expect(queueStore.getField(bodyID, 'text')).toBe(input.message.text);\n      expect(queueStore.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        nextEdgeID,\n        edgeID,\n      ]);\n\n      // base records are not modified\n      expect(store.getField(connectionID, 'count')).toBe(1);\n      expect(store.getRecordState(nextEdgeID)).toBe('UNKNOWN');\n      expect(store.getRecordState(nextNodeID)).toBe('UNKNOWN');\n      expect(store.getRecordState(bodyID)).toBe('UNKNOWN');\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n      ]);\n    });\n\n    it('non-optimistically prepends comments', () => {\n      // create the mutation and payload\n      var input = {\n        actor_id: 'actor:123',\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n        feedback_id: feedbackID,\n        message: {\n          text: 'Hello!',\n          ranges: [],\n        },\n      };\n\n      var mutation = getNode(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            feedback {\n              id,\n              topLevelComments {\n                count,\n              },\n            },\n            feedbackCommentEdge {\n              cursor,\n              node {\n                id,\n                body {\n                  text,\n                },\n              },\n              source {\n                id,\n              },\n            },\n          }\n        }\n      `, {\n        input: JSON.stringify(input),\n      });\n      var configs = [{\n        type: RelayMutationType.RANGE_ADD,\n        connectionName: 'topLevelComments',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n      }];\n\n      var nextCursor = 'comment789:cursor';\n      var nextNodeID = 'comment789';\n      var bodyID = 'client:2';\n      var nextEdgeID = generateClientEdgeID(connectionID, nextNodeID);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]:\n          input[RelayConnectionInterface.CLIENT_MUTATION_ID],\n        feedback: {\n          id: feedbackID,\n          topLevelComments: {\n            count: 2,\n          },\n        },\n        feedbackCommentEdge: {\n          cursor: nextCursor,\n          node: {\n            id: nextNodeID,\n            body: {\n              text: input.message.text,\n            },\n          },\n          source: {\n            id: feedbackID,\n          },\n        },\n      };\n\n      // write to base store\n      var changeTracker = new RelayChangeTracker();\n      var queryTracker = new RelayQueryTracker();\n      var queryWriter = new RelayQueryWriter(\n        store,\n        writer,\n        queryTracker,\n        changeTracker\n      );\n\n      writeRelayUpdatePayload(\n        queryWriter,\n        mutation,\n        payload,\n        {configs, isOptimisticUpdate: false}\n      );\n\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          [nextNodeID]: true, // node added\n          [nextEdgeID]: true, // edge added\n          [bodyID]: true, // `body` subfield\n        },\n        updated: {\n          [connectionID]: true, // range item added & count changed\n        },\n      });\n\n      // base records are updated: edge/node added\n      expect(store.getField(connectionID, 'count')).toBe(2);\n      expect(store.getLinkedRecordID(nextEdgeID, 'source')).toBe(\n        feedbackID\n      );\n      expect(store.getField(nextEdgeID, 'cursor')).toBe(nextCursor);\n      expect(store.getLinkedRecordID(nextEdgeID, 'node')).toBe(nextNodeID);\n      expect(store.getField(nextNodeID, 'id')).toBe(nextNodeID);\n      expect(store.getType(nextNodeID)).toBe('Comment');\n      expect(store.getLinkedRecordID(nextNodeID, 'body')).toBe(bodyID);\n      expect(store.getField(bodyID, 'text')).toBe(input.message.text);\n      expect(store.getRangeMetadata(\n        connectionID,\n        [{name: 'first', value: '2'}]\n      ).filteredEdges.map(edge => edge.edgeID)).toEqual([\n        nextEdgeID,\n        edgeID,\n      ]);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayUpdatePayload-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_scalarField-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('scalar fields', () => {\n    it('created with null when the response is null', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getField('123', 'name')).toBe(null);\n    });\n\n    it('adds null fields to an existing record when response is null', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'name')).toBe(null);\n    });\n\n    it('updates fields when the response is null', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'name')).toBe(null);\n    });\n\n    it('does not add undefined fields to a new record', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: undefined,\n          __typename: 'User',\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getField('123', 'name')).toBe(undefined);\n    });\n\n    it('does not add undefined fields to an existing record', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getField('123', 'name')).toBe(undefined);\n    });\n\n    it('does not update fields when the response is undefined', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getField('123', 'name')).toBe('Joe');\n    });\n\n    it('updates fields wth new scalar values', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: 'Joseph',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'name')).toBe('Joseph');\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('scalar fields', () => {\n    it('created with null when the response is null', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getField('123', 'name')).toBe(null);\n    });\n\n    it('adds null fields to an existing record when response is null', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'name')).toBe(null);\n    });\n\n    it('updates fields when the response is null', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'name')).toBe(null);\n    });\n\n    it('does not add undefined fields to a new record', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: undefined,\n          __typename: 'User',\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getField('123', 'name')).toBe(undefined);\n    });\n\n    it('does not add undefined fields to an existing record', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getField('123', 'name')).toBe(undefined);\n    });\n\n    it('does not update fields when the response is undefined', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getField('123', 'name')).toBe('Joe');\n    });\n\n    it('updates fields wth new scalar values', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          name: 'Joseph',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'name')).toBe('Joseph');\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_scalarField-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_rootRecord-test.js":{"metadata":{"mtime":1456300207000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {\n    getNode,\n    getRefNode,\n    getVerbatimNode,\n    writePayload,\n    writeVerbatimPayload,\n  } = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('root record', () => {\n\n    it('is created for argument-less custom root calls with an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var query = getNode(Relay.QL`\n        query {\n          me {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        me: {\n          id: '123',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          123: true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getDataID('me')).toBe('123');\n    });\n\n    it('is created for argument-less custom root calls without an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe('123');\n      expect(store.getDataID('viewer')).toBe('client:1');\n    });\n\n    it('uses existing id for custom root calls without an id', () => {\n      const cachedRootCallMap = {\n        'viewer': {'': 'client:12345'},\n      };\n      const cachedRecords = {\n        'client:12345': {__dataID__: 'client:12345'},\n      };\n      const rootCallMap = {};\n      const records = {};\n      const store = new RelayRecordStore({records}, {rootCallMap});\n      const writer = new RelayRecordWriter(records, rootCallMap, false);\n      const cachedStore = new RelayRecordStore(\n        {records, cachedRecords},\n        {cachedRootCallMap, rootCallMap}\n      );\n      const query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n            },\n          }\n        }\n      `);\n      const payload = {\n        viewer: {\n          actor: {\n            id: '123',\n          },\n        },\n      };\n      const results = writePayload(cachedStore, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {\n          'client:12345': true,\n        },\n      });\n      expect(store.getRecordState('client:12345')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:12345', 'actor')).toBe('123');\n      expect(store.getDataID('viewer')).toBe('client:12345');\n    });\n\n    it('is created for custom root calls with an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var query = getNode(Relay.QL`\n        query {\n          username(name:\"yuzhi\") {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        username: {\n          id: '1055790163',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '1055790163': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n    });\n\n    it('is created for custom root calls without an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      // note: this test simulates an `id`-less root call\n      var query = getNode(Relay.QL`\n        query {\n          username(name:\"yuzhi\") {\n            name,\n          }\n        }\n      `);\n      // remove the autogenerated `id` field\n      query = query.clone(query.getChildren().slice(0, 1));\n      // no `id` value is present, so the root ID is autogenerated\n      var payload = {\n        username: {\n          name: 'Yuzhi Zheng',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getField('client:1', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getDataID('username', 'yuzhi')).toBe('client:1');\n    });\n\n    it('is created for custom root calls with batch call variables', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getRefNode(Relay.QL`\n        query {\n          nodes(ids:$ref_q0) {\n            id\n          }\n        }\n      `, {path: '$.*.id'}); // This path is bogus.\n      var payload = {\n        nodes: [\n          {\n            id: '123',\n          },\n        ],\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n    });\n\n    it('are created for plural identifying root calls', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          nodes(ids: [\"123\",\"456\"]) {\n            id\n          }\n        }\n      `);\n      var payload = {\n        nodes: [\n          {\n            id: '123',\n          },\n          {\n            id: '456',\n          },\n        ],\n      };\n      var results = writeVerbatimPayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n          '456': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getRecordState('456')).toBe('EXISTENT');\n      expect(store.getField('456', 'id')).toBe('456');\n    });\n\n    it('requires arguments to `node()` root calls', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: null,\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayRecordStore.getDataID(): Argument to `node()` cannot be ' +\n        'null or undefined.'\n      );\n    });\n\n    it('is created and set to null when the response is null', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: null,\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('NONEXISTENT');\n    });\n\n    it('is deleted when a response returns null', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: null,\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getRecordState('123')).toBe('NONEXISTENT');\n    });\n\n    it('requires an array if root args is an array', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          nodes(ids:[\"123\", \"456\"]) {\n            id\n          }\n        }\n      `);\n      var payload = {\n        me: {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayOSSNodeInterface: Expected payload for root field `nodes` to ' +\n        'be an array with 2 results, instead received a single non-array ' +\n        'result.'\n      );\n    });\n\n    it('requires a single result if root args is a single value', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          me {\n            id\n          }\n        }\n      `);\n      var payload = {\n        me: [\n          {\n            __dataID__: '123',\n            id: '123',\n          },\n          {\n            __dataID__: '456',\n            id: '456',\n          },\n        ],\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayOSSNodeInterface: Expected payload for root field `me` to be a ' +\n        'single non-array result, instead received an array with 2 results.'\n      );\n    });\n\n    it('handles plural results for ref queries', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getRefNode(Relay.QL`\n        query {\n          nodes(ids:$ref_q0) {\n            id,\n            name\n          }\n        }\n      `, {path: '$.*.id'}); // This path is bogus.\n      var payload = {\n        nodes: [\n          {\n            __dataID__: '123',\n            id: '123',\n            name: 'Yuzhi',\n          },\n          {\n            __dataID__: '456',\n            id: '456',\n            name: 'Jing',\n          },\n        ],\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'name')).toBe('Yuzhi');\n      expect(store.getRecordState('456')).toBe('EXISTENT');\n      expect(store.getField('456', 'name')).toBe('Jing');\n    });\n\n    it('is not created when the response is undefined', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: undefined,\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayQueryWriter: Unexpectedly encountered `undefined` in payload. ' +\n        'Cannot set root record `123` to undefined.'\n      );\n      expect(store.getRecordState('123')).toBe('UNKNOWN');\n    });\n\n    it('is not deleted when the response is undefined', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: undefined,\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayQueryWriter: Unexpectedly encountered `undefined` in payload. ' +\n        'Cannot set root record `123` to undefined.'\n      );\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n    });\n\n    it('is created when a new record returns a value', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n    });\n\n    it('is not updated if the record exists and has no changes', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n    });\n\n    it('is updated if the record has changes', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joseph',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'name')).toBe('Joseph');\n    });\n\n    it('is not affected by non-requested fields', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joseph',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'name')).toBe(undefined);\n    });\n\n    it('records the concrete type if `__typename` is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            id,\n            __typename\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          __typename: 'User',\n          foo: 'bar',\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n    });\n\n    it('warns if the typename cannot be determined for a node', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      // No `id` or `__typename` fields\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            name\n          }\n        }\n      `);\n      // But the payload contains an `id` so the writer will attempt to store a\n      // `__typename`.\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      writeVerbatimPayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe(null);\n      expect([\n        'RelayQueryWriter: Could not find a type name for record `%s`.',\n        '123',\n      ]).toBeWarnedNTimes(1);\n    });\n\n    it('does not warn if the typename is already known', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      // Add the record to the store with a concrete type\n      writer.putRecord('123', 'User', null);\n      // No `id` or `__typename` fields\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            name\n          }\n        }\n      `);\n      // No typename in the payload; this will warn for new records, but\n      // shouldn't for existing ones with a known type.\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      writeVerbatimPayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n      expect([\n        'RelayQueryWriter: Could not find a type name for record `%s`.',\n        '123',\n      ]).toBeWarnedNTimes(0);\n    });\n\n    it('stores types for client records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              name\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            name: 'Joe',\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('client:1')).toBe('Viewer');\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {\n    getNode,\n    getRefNode,\n    getVerbatimNode,\n    writePayload,\n    writeVerbatimPayload,\n  } = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('root record', () => {\n\n    it('is created for argument-less custom root calls with an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var query = getNode(Relay.QL`\n        query {\n          me {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        me: {\n          id: '123',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          123: true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getDataID('me')).toBe('123');\n    });\n\n    it('is created for argument-less custom root calls without an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe('123');\n      expect(store.getDataID('viewer')).toBe('client:1');\n    });\n\n    it('uses existing id for custom root calls without an id', () => {\n      const cachedRootCallMap = {\n        'viewer': {'': 'client:12345'},\n      };\n      const cachedRecords = {\n        'client:12345': {__dataID__: 'client:12345'},\n      };\n      const rootCallMap = {};\n      const records = {};\n      const store = new RelayRecordStore({records}, {rootCallMap});\n      const writer = new RelayRecordWriter(records, rootCallMap, false);\n      const cachedStore = new RelayRecordStore(\n        {records, cachedRecords},\n        {cachedRootCallMap, rootCallMap}\n      );\n      const query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n            },\n          }\n        }\n      `);\n      const payload = {\n        viewer: {\n          actor: {\n            id: '123',\n          },\n        },\n      };\n      const results = writePayload(cachedStore, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {\n          'client:12345': true,\n        },\n      });\n      expect(store.getRecordState('client:12345')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:12345', 'actor')).toBe('123');\n      expect(store.getDataID('viewer')).toBe('client:12345');\n    });\n\n    it('is created for custom root calls with an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var query = getNode(Relay.QL`\n        query {\n          username(name:\"yuzhi\") {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        username: {\n          id: '1055790163',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '1055790163': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n    });\n\n    it('is created for custom root calls without an id', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      // note: this test simulates an `id`-less root call\n      var query = getNode(Relay.QL`\n        query {\n          username(name:\"yuzhi\") {\n            name,\n          }\n        }\n      `);\n      // remove the autogenerated `id` field\n      query = query.clone(query.getChildren().slice(0, 1));\n      // no `id` value is present, so the root ID is autogenerated\n      var payload = {\n        username: {\n          name: 'Yuzhi Zheng',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getField('client:1', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getDataID('username', 'yuzhi')).toBe('client:1');\n    });\n\n    it('is created for custom root calls with batch call variables', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getRefNode(Relay.QL`\n        query {\n          nodes(ids:$ref_q0) {\n            id\n          }\n        }\n      `, {path: '$.*.id'}); // This path is bogus.\n      var payload = {\n        nodes: [\n          {\n            id: '123',\n          },\n        ],\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n    });\n\n    it('are created for plural identifying root calls', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          nodes(ids: [\"123\",\"456\"]) {\n            id\n          }\n        }\n      `);\n      var payload = {\n        nodes: [\n          {\n            id: '123',\n          },\n          {\n            id: '456',\n          },\n        ],\n      };\n      var results = writeVerbatimPayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n          '456': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n      expect(store.getRecordState('456')).toBe('EXISTENT');\n      expect(store.getField('456', 'id')).toBe('456');\n    });\n\n    it('requires arguments to `node()` root calls', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: null,\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayRecordStore.getDataID(): Argument to `node()` cannot be ' +\n        'null or undefined.'\n      );\n    });\n\n    it('is created and set to null when the response is null', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: null,\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('NONEXISTENT');\n    });\n\n    it('is deleted when a response returns null', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: null,\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getRecordState('123')).toBe('NONEXISTENT');\n    });\n\n    it('requires an array if root args is an array', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          nodes(ids:[\"123\", \"456\"]) {\n            id\n          }\n        }\n      `);\n      var payload = {\n        me: {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayOSSNodeInterface: Expected payload for root field `nodes` to ' +\n        'be an array with 2 results, instead received a single non-array ' +\n        'result.'\n      );\n    });\n\n    it('requires a single result if root args is a single value', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          me {\n            id\n          }\n        }\n      `);\n      var payload = {\n        me: [\n          {\n            __dataID__: '123',\n            id: '123',\n          },\n          {\n            __dataID__: '456',\n            id: '456',\n          },\n        ],\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayOSSNodeInterface: Expected payload for root field `me` to be a ' +\n        'single non-array result, instead received an array with 2 results.'\n      );\n    });\n\n    it('handles plural results for ref queries', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getRefNode(Relay.QL`\n        query {\n          nodes(ids:$ref_q0) {\n            id,\n            name\n          }\n        }\n      `, {path: '$.*.id'}); // This path is bogus.\n      var payload = {\n        nodes: [\n          {\n            __dataID__: '123',\n            id: '123',\n            name: 'Yuzhi',\n          },\n          {\n            __dataID__: '456',\n            id: '456',\n            name: 'Jing',\n          },\n        ],\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'name')).toBe('Yuzhi');\n      expect(store.getRecordState('456')).toBe('EXISTENT');\n      expect(store.getField('456', 'name')).toBe('Jing');\n    });\n\n    it('is not created when the response is undefined', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: undefined,\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayQueryWriter: Unexpectedly encountered `undefined` in payload. ' +\n        'Cannot set root record `123` to undefined.'\n      );\n      expect(store.getRecordState('123')).toBe('UNKNOWN');\n    });\n\n    it('is not deleted when the response is undefined', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: undefined,\n      };\n      expect(() => {\n        writePayload(store, writer, query, payload);\n      }).toFailInvariant(\n        'RelayQueryWriter: Unexpectedly encountered `undefined` in payload. ' +\n        'Cannot set root record `123` to undefined.'\n      );\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n    });\n\n    it('is created when a new record returns a value', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n    });\n\n    it('is not updated if the record exists and has no changes', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n    });\n\n    it('is updated if the record has changes', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            name\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joseph',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'name')).toBe('Joseph');\n    });\n\n    it('is not affected by non-requested fields', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joseph',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'name')).toBe(undefined);\n    });\n\n    it('records the concrete type if `__typename` is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            id,\n            __typename\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          __typename: 'User',\n          foo: 'bar',\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n    });\n\n    it('warns if the typename cannot be determined for a node', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      // No `id` or `__typename` fields\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            name\n          }\n        }\n      `);\n      // But the payload contains an `id` so the writer will attempt to store a\n      // `__typename`.\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      writeVerbatimPayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe(null);\n      expect([\n        'RelayQueryWriter: Could not find a type name for record `%s`.',\n        '123',\n      ]).toBeWarnedNTimes(1);\n    });\n\n    it('does not warn if the typename is already known', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      // Add the record to the store with a concrete type\n      writer.putRecord('123', 'User', null);\n      // No `id` or `__typename` fields\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            name\n          }\n        }\n      `);\n      // No typename in the payload; this will warn for new records, but\n      // shouldn't for existing ones with a known type.\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n        },\n      };\n      writeVerbatimPayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n      expect([\n        'RelayQueryWriter: Could not find a type name for record `%s`.',\n        '123',\n      ]).toBeWarnedNTimes(0);\n    });\n\n    it('stores types for client records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              name\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            name: 'Joe',\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('client:1')).toBe('Viewer');\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_rootRecord-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_pluralScalarField-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n  });\n\n  describe('plural scalar fields', () => {\n    it('updates elements in a plural field', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newEmail = 'user2@example.com';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [newEmail],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'emailAddresses')).toEqual([newEmail]);\n    });\n\n    it('prepends elements to a plural field', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newEmail = 'user2@example.com';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [newEmail, email],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'emailAddresses'))\n        .toEqual([newEmail, email]);\n    });\n\n    it('appends elements to a plural field', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newEmail = 'user2@example.com';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email, newEmail],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'emailAddresses'))\n        .toEqual([email, newEmail]);\n    });\n\n    it('does not update if a plural field is unchanged', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getField('123', 'emailAddresses')).toEqual([email]);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n  });\n\n  describe('plural scalar fields', () => {\n    it('updates elements in a plural field', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newEmail = 'user2@example.com';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [newEmail],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'emailAddresses')).toEqual([newEmail]);\n    });\n\n    it('prepends elements to a plural field', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newEmail = 'user2@example.com';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [newEmail, email],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'emailAddresses'))\n        .toEqual([newEmail, email]);\n    });\n\n    it('appends elements to a plural field', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newEmail = 'user2@example.com';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email, newEmail],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      expect(store.getField('123', 'emailAddresses'))\n        .toEqual([email, newEmail]);\n    });\n\n    it('does not update if a plural field is unchanged', () => {\n      var email = 'user@example.com';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            emailAddresses\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          emailAddresses: [email],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getField('123', 'emailAddresses')).toEqual([email]);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_pluralScalarField-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_pluralLinkedField-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n  });\n\n  describe('plural linked fields', () => {\n    it('creates empty linked records', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              phoneNumber {\n                displayNumber\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual([]);\n    });\n\n    it('creates linked records', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212', // directory assistance\n          countryCode: '1',\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          'client:2': true,\n        },\n        updated: {\n          '123': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n      var phoneID = phoneIDs[0];\n      expect(store.getRecordState(phoneID)).toBe('EXISTENT');\n      expect(store.getField(phoneID, 'id')).toBe(undefined);\n      expect(store.getField(phoneID, 'isVerified')).toBe(true);\n      var phoneNumberID = store.getLinkedRecordID(phoneID, 'phoneNumber');\n      expect(phoneNumberID).toBe('client:2');\n      expect(store.getField(phoneNumberID, 'displayNumber'))\n        .toBe(phone.phoneNumber.displayNumber);\n      expect(store.getField(phoneNumberID, 'countryCode'))\n        .toBe(phone.phoneNumber.countryCode);\n    });\n\n    it('updates if response changes', () => {\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212',\n          countryCode: '1',\n        },\n      };\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [\n            {__dataID__: 'client:1'},\n          ],\n        },\n        'client:1': {\n          isVerified: true,\n          phoneNumber: {\n            __dataID__: 'client:2',\n          },\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n          displayNumber: phone.phoneNumber.displayNumber,\n          countryCode: phone.phoneNumber.countryCode,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newPhone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212',\n          countryCode: '*',                 // *changed*\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [newPhone],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          // intermediate phone object has no changes\n          'client:2': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n      var phoneID = phoneIDs[0];\n      expect(store.getRecordState(phoneID)).toBe('EXISTENT');\n      expect(store.getField(phoneID, 'id')).toBe(undefined);\n      expect(store.getField(phoneID, 'isVerified')).toBe(true);\n      var phoneNumberID = store.getLinkedRecordID(phoneID, 'phoneNumber');\n      expect(phoneNumberID).toBe('client:2');\n      expect(store.getField(phoneNumberID, 'displayNumber'))\n        .toBe(phone.phoneNumber.displayNumber);\n      expect(store.getField(phoneNumberID, 'countryCode'))\n        .toBe(newPhone.phoneNumber.countryCode);\n    });\n\n    it('updates if length changes', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [\n            {__dataID__: 'client:1'},\n            {__dataID__: 'client:2'},\n          ],\n        },\n        'client:1': {\n          __dataID__: 'client:1',\n          displayNumber: '1-800-555-1212',\n          countryCode: '1',\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n          displayNumber: '1-800-555-1313',\n          countryCode: '2',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [{\n            displayNumber: '1-800-555-1212',\n            countryCode: '1',\n          }],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n    });\n\n    it('does not update if response does not change', () => {\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212',\n          countryCode: '1',\n        },\n      };\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [\n            {__dataID__: 'client:1'},\n          ],\n        },\n        'client:1': {\n          isVerified: true,\n          phoneNumber: {\n            __dataID__: 'client:2',\n          },\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n          displayNumber: phone.phoneNumber.displayNumber,\n          countryCode: phone.phoneNumber.countryCode,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n      var phoneID = phoneIDs[0];\n      expect(store.getRecordState(phoneID)).toBe('EXISTENT');\n      expect(store.getField(phoneID, 'id')).toBe(undefined);\n      expect(store.getField(phoneID, 'isVerified')).toBe(true);\n      var phoneNumberID = store.getLinkedRecordID(phoneID, 'phoneNumber');\n      expect(phoneNumberID).toBe('client:2');\n      expect(store.getField(phoneNumberID, 'displayNumber'))\n        .toBe(phone.phoneNumber.displayNumber);\n      expect(store.getField(phoneNumberID, 'countryCode'))\n        .toBe(phone.phoneNumber.countryCode);\n    });\n\n    it('does not update if response remains empty', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              phoneNumber {\n                displayNumber\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual([]);\n    });\n\n    it('records the concrete type if `__typename` is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id: \"1\") {\n            actors {\n              __typename\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '1',\n          actors: [{\n            __typename: 'User',\n            id: '123',\n          }],\n          __typename: 'Story',\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n  });\n\n  describe('plural linked fields', () => {\n    it('creates empty linked records', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              phoneNumber {\n                displayNumber\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual([]);\n    });\n\n    it('creates linked records', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212', // directory assistance\n          countryCode: '1',\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          'client:2': true,\n        },\n        updated: {\n          '123': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n      var phoneID = phoneIDs[0];\n      expect(store.getRecordState(phoneID)).toBe('EXISTENT');\n      expect(store.getField(phoneID, 'id')).toBe(undefined);\n      expect(store.getField(phoneID, 'isVerified')).toBe(true);\n      var phoneNumberID = store.getLinkedRecordID(phoneID, 'phoneNumber');\n      expect(phoneNumberID).toBe('client:2');\n      expect(store.getField(phoneNumberID, 'displayNumber'))\n        .toBe(phone.phoneNumber.displayNumber);\n      expect(store.getField(phoneNumberID, 'countryCode'))\n        .toBe(phone.phoneNumber.countryCode);\n    });\n\n    it('updates if response changes', () => {\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212',\n          countryCode: '1',\n        },\n      };\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [\n            {__dataID__: 'client:1'},\n          ],\n        },\n        'client:1': {\n          isVerified: true,\n          phoneNumber: {\n            __dataID__: 'client:2',\n          },\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n          displayNumber: phone.phoneNumber.displayNumber,\n          countryCode: phone.phoneNumber.countryCode,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var newPhone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212',\n          countryCode: '*',                 // *changed*\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [newPhone],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          // intermediate phone object has no changes\n          'client:2': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n      var phoneID = phoneIDs[0];\n      expect(store.getRecordState(phoneID)).toBe('EXISTENT');\n      expect(store.getField(phoneID, 'id')).toBe(undefined);\n      expect(store.getField(phoneID, 'isVerified')).toBe(true);\n      var phoneNumberID = store.getLinkedRecordID(phoneID, 'phoneNumber');\n      expect(phoneNumberID).toBe('client:2');\n      expect(store.getField(phoneNumberID, 'displayNumber'))\n        .toBe(phone.phoneNumber.displayNumber);\n      expect(store.getField(phoneNumberID, 'countryCode'))\n        .toBe(newPhone.phoneNumber.countryCode);\n    });\n\n    it('updates if length changes', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [\n            {__dataID__: 'client:1'},\n            {__dataID__: 'client:2'},\n          ],\n        },\n        'client:1': {\n          __dataID__: 'client:1',\n          displayNumber: '1-800-555-1212',\n          countryCode: '1',\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n          displayNumber: '1-800-555-1313',\n          countryCode: '2',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [{\n            displayNumber: '1-800-555-1212',\n            countryCode: '1',\n          }],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          '123': true,\n        },\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n    });\n\n    it('does not update if response does not change', () => {\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212',\n          countryCode: '1',\n        },\n      };\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [\n            {__dataID__: 'client:1'},\n          ],\n        },\n        'client:1': {\n          isVerified: true,\n          phoneNumber: {\n            __dataID__: 'client:2',\n          },\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n          displayNumber: phone.phoneNumber.displayNumber,\n          countryCode: phone.phoneNumber.countryCode,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual(['client:1']);\n      var phoneID = phoneIDs[0];\n      expect(store.getRecordState(phoneID)).toBe('EXISTENT');\n      expect(store.getField(phoneID, 'id')).toBe(undefined);\n      expect(store.getField(phoneID, 'isVerified')).toBe(true);\n      var phoneNumberID = store.getLinkedRecordID(phoneID, 'phoneNumber');\n      expect(phoneNumberID).toBe('client:2');\n      expect(store.getField(phoneNumberID, 'displayNumber'))\n        .toBe(phone.phoneNumber.displayNumber);\n      expect(store.getField(phoneNumberID, 'countryCode'))\n        .toBe(phone.phoneNumber.countryCode);\n    });\n\n    it('does not update if response remains empty', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n          allPhones: [],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              phoneNumber {\n                displayNumber\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [],\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      var phoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(phoneIDs).toEqual([]);\n    });\n\n    it('records the concrete type if `__typename` is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id: \"1\") {\n            actors {\n              __typename\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '1',\n          actors: [{\n            __typename: 'User',\n            id: '123',\n          }],\n          __typename: 'Story',\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_pluralLinkedField-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_paths-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst invariant = require('invariant');\n\ndescribe('writePayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {\n    getNode,\n    getVerbatimNode,\n    writeVerbatimPayload,\n    writePayload,\n  } = RelayTestUtils;\n\n  function getField(node, ...fieldNames) {\n    for (var ii = 0; ii < fieldNames.length; ii++) {\n      node = node.getFieldByStorageKey(fieldNames[ii]);\n      invariant(\n        node,\n        'getField(): Expected node to have field named `%s`.',\n        fieldNames[ii]\n      );\n    }\n    return node;\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('paths', () => {\n    it('writes path for id-less root records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            __typename: 'User',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          '123': true,\n        },\n        updated: {},\n      });\n\n      // viewer has a client id and must be refetched by the original root call\n      var path = new RelayQueryPath(query);\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getPathToRecord('client:1')).toMatchPath(path);\n\n      // actor is refetchable by ID\n      expect(store.getPathToRecord('123')).toBe(undefined);\n    });\n\n    it('does not write paths to refetchable root records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          __typename: 'User',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getPathToRecord('123')).toBe(undefined);\n    });\n\n    it('writes paths to non-refetchable linked records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              address {\n                city,\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            address: {\n              city: 'San Francisco',\n            },\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      // linked nodes use a minimal path from the nearest refetchable node\n      var addressID = 'client:2';  // The generated id *after* viewer\n      var pathQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            address {\n              city,\n            },\n          }\n        }\n      `);\n      var path = new RelayQueryPath(pathQuery)\n        .getPath(getField(pathQuery, 'address'), addressID);\n      expect(store.getPathToRecord(addressID)).toMatchPath(path);\n    });\n\n    it('writes paths to plural linked fields', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212', // directory assistance\n          countryCode: '1',\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      // plural fields must be refetched through the parent\n      // get linked records to verify the client id\n      var allPhoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(allPhoneIDs.length).toBe(1);\n      var path = new RelayQueryPath(query)\n        .getPath(getField(query, 'allPhones'), allPhoneIDs[0]);\n      expect(store.getPathToRecord(allPhoneIDs[0])).toMatchPath(path);\n\n      // plural items must be refetched through the parent plural field\n      // get field to verify the client id is correct\n      var phoneNoID = store.getLinkedRecordID(allPhoneIDs[0], 'phoneNumber');\n      path = new RelayQueryPath(query)\n        .getPath(getField(query, 'allPhones'), allPhoneIDs[0])\n        .getPath(getField(query, 'allPhones', 'phoneNumber'), phoneNoID);\n      expect(store.getPathToRecord(phoneNoID)).toMatchPath(path);\n    });\n\n    it('writes paths to connection records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id,\n                  address {\n                    city,\n                  },\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'cursor1',\n                node: {\n                  id: 'node1',\n                  address: {\n                    city: 'San Francisco',\n                  },\n                },\n              },\n            ],\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      // connections and edges must be refetched through the parent\n      var path = new RelayQueryPath(query)\n        .getPath(getField(query, 'friends'), 'client:1');\n      expect(store.getPathToRecord('client:1')).toMatchPath(path);\n      path = new RelayQueryPath(query)\n        .getPath(getField(query, 'friends'), 'client:1')\n        .getPath(getField(query, 'friends', 'edges'), 'client:client:1:node1');\n      expect(store.getPathToRecord('client:client:1:node1')).toMatchPath(path);\n\n      // connection nodes with an ID are refetchable\n      expect(store.getPathToRecord('node1')).toBe(undefined);\n\n      // linked nodes use a minimal path from the nearest refetchable node\n      var pathQuery = getNode(Relay.QL`query{node(id:\"node1\"){address{city}}}`);\n      path = new RelayQueryPath(pathQuery)\n        .getPath(getField(pathQuery, 'address'), 'client:2');\n      expect(store.getField('client:2', 'city')).toBe('San Francisco');\n      expect(store.getPathToRecord('client:2')).toMatchPath(path);\n    });\n\n    it('writes paths with fragments', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var fragment = Relay.QL`fragment on Viewer {\n        actor {\n          id\n          __typename\n          name\n        }\n      }`;\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          viewer {\n            ${fragment}\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            name: 'Joe',\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      var viewerID = store.getDataID('viewer');\n      var actorID = store.getLinkedRecordID(viewerID, 'actor');\n\n      var path = new RelayQueryPath(query)\n        .getPath(getNode(fragment), viewerID)\n        .getPath(getNode(fragment).getChildren()[0], actorID);\n      expect(store.getPathToRecord(actorID)).toMatchPath(path);\n    });\n  });\n\n  describe('query tracking', () => {\n    it('tracks new root records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var tracker = new RelayQueryTracker();\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            name,\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n          __typename: 'User',\n        },\n      };\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(1);\n      expect(trackedQueries[0][1]).toBe('123');\n      expect(trackedQueries[0][0]).toEqualQueryRoot(query);\n    });\n\n    it('tracks new records in fragments', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var tracker = new RelayQueryTracker();\n\n      // `address` will be encountered twice, both occurrences must be tracked\n      var fragment = Relay.QL`fragment on Node{address{city}}`;\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            ${fragment},\n            ${fragment},\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          address: {\n            city: 'San Francisco',\n          },\n          __typename: 'User',\n        },\n      };\n      var addressID = 'client:1';\n      var addressFragment = getNode(fragment).getChildren()[0];\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(3);\n      expect(trackedQueries[1][1]).toBe(addressID);\n      expect(trackedQueries[1][0]).toEqualQueryNode(addressFragment);\n      expect(trackedQueries[2][1]).toBe(addressID);\n      expect(trackedQueries[2][0]).toEqualQueryNode(addressFragment);\n    });\n\n    it('tracks new linked records', () => {\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              name,\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            name: 'Joe',\n            __typename: 'User',\n          },\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(1);\n      expect(trackedQueries[0][1]).toBe('123');\n      expect(trackedQueries[0][0]).toEqualQueryNode(query.getChildren()[0]);\n    });\n\n    it('tracks new plural linked records', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              },\n            },\n          }\n        }\n      `);\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212', // directory assistance\n          countryCode: '1',\n        },\n      };\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      // creates `allPhones` record and linked `phoneNumber` field\n      expect(trackedQueries.length).toBe(2);\n      expect(trackedQueries[0][1]).toBe('client:1');\n      expect(trackedQueries[0][0]).toEqualQueryNode(\n        getField(query, 'allPhones')\n      );\n      expect(trackedQueries[1][1]).toBe('client:2');\n      expect(trackedQueries[1][0]).toEqualQueryNode(\n        getField(query, 'allPhones', 'phoneNumber')\n      );\n    });\n\n    it('tracks new connections', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: '456',\n                  name: 'Greg',\n                },\n              },\n            ],\n          },\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(3);\n      // track range node\n      expect(trackedQueries[0][1]).toBe('client:1');\n      expect(trackedQueries[0][0]).toEqualQueryNode(\n        getField(query, 'friends')\n      );\n      // track first edge\n      expect(trackedQueries[1][1]).toBe('client:client:1:456');\n      expect(trackedQueries[1][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges')\n      );\n      // track node\n      expect(trackedQueries[2][1]).toBe('456');\n      expect(trackedQueries[2][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges', 'node')\n      );\n    });\n\n    it('tracks edges and nodes added to an existing connection', () => {\n      // write a range with first(1) edge\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: '456',\n                  name: 'Greg',\n                },\n              },\n            ],\n          },\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      expect(tracker.trackNodeForID.mock.calls.length).toBe(3);\n\n      // write an additional node and verify only the new edge and node are\n      // tracked\n      query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(after:\"c1\",first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'c2',\n                node: {\n                  id: '789',\n                  name: 'Jing',\n                },\n              },\n            ],\n          },\n        },\n      };\n      tracker = new RelayQueryTracker();\n      tracker.trackNodeForID.mockClear();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(2);\n      // track new edge\n      expect(trackedQueries[0][1]).toBe('client:client:1:789');\n      expect(trackedQueries[0][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges')\n      );\n      // track node\n      expect(trackedQueries[1][1]).toBe('789');\n      expect(trackedQueries[1][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges', 'node')\n      );\n    });\n\n    it('re-tracks all nodes if `updateTrackedQueries` is enabled', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name,\n            allPhones {\n              phoneNumber {\n                displayNumber,\n              },\n            },\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n          allPhones: [\n            {\n              phoneNumber: {\n                displayNumber: '1-800-555-1212', // directory assistance\n              },\n            },\n          ],\n          friends: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: '456',\n                  name: 'Tim',\n                },\n              },\n            ],\n          },\n          __typename: 'User',\n        },\n      };\n      // populate the store and record the original tracked queries\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var prevTracked = tracker.trackNodeForID.mock.calls.slice();\n      expect(prevTracked.length).toBe(6);\n\n      // rewriting the same payload by default does not track anything\n      tracker = new RelayQueryTracker();\n      tracker.trackNodeForID.mockClear();\n      writePayload(store, writer, query, payload, tracker);\n      expect(tracker.trackNodeForID.mock.calls.length).toBe(0);\n\n      // force-tracking should track the original nodes again\n      tracker = new RelayQueryTracker();\n      tracker.trackNodeForID.mockClear();\n      writePayload(store, writer, query, payload, tracker, {\n        updateTrackedQueries: true,\n      });\n      var nextTracked = tracker.trackNodeForID.mock.calls;\n      expect(nextTracked.length).toBe(prevTracked.length);\n      nextTracked.forEach((tracked, ii) => {\n        expect(tracked[1]).toBe(prevTracked[ii][1]); // dataID\n        expect(tracked[0]).toEqualQueryNode(prevTracked[ii][0]); // dataID\n      });\n    });\n  });\n\n  it('skips non-matching fragments', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          ...on User {\n            name\n          }\n          ...on Comment {\n            body {\n              text\n            }\n          }\n          ...on Node {\n            firstName\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n        name: 'Joe',\n        body: {\n          text: 'Skipped!',\n        },\n      },\n    };\n    writeVerbatimPayload(store, writer, query, payload);\n    expect(store.getField('123', 'firstName')).toBe('Joe');\n    expect(store.getField('123', 'name')).toBe('Joe');\n    // `body` only exists on `Comment` which does not match the record type\n    expect(store.getLinkedRecordID('123', 'body')).toBe(undefined);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQueryPath","RelayQueryTracker","RelayTestUtils","invariant","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst invariant = require('invariant');\n\ndescribe('writePayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {\n    getNode,\n    getVerbatimNode,\n    writeVerbatimPayload,\n    writePayload,\n  } = RelayTestUtils;\n\n  function getField(node, ...fieldNames) {\n    for (var ii = 0; ii < fieldNames.length; ii++) {\n      node = node.getFieldByStorageKey(fieldNames[ii]);\n      invariant(\n        node,\n        'getField(): Expected node to have field named `%s`.',\n        fieldNames[ii]\n      );\n    }\n    return node;\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('paths', () => {\n    it('writes path for id-less root records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            __typename: 'User',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          '123': true,\n        },\n        updated: {},\n      });\n\n      // viewer has a client id and must be refetched by the original root call\n      var path = new RelayQueryPath(query);\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getPathToRecord('client:1')).toMatchPath(path);\n\n      // actor is refetchable by ID\n      expect(store.getPathToRecord('123')).toBe(undefined);\n    });\n\n    it('does not write paths to refetchable root records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          __typename: 'User',\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n        },\n        updated: {},\n      });\n\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getPathToRecord('123')).toBe(undefined);\n    });\n\n    it('writes paths to non-refetchable linked records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              address {\n                city,\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            address: {\n              city: 'San Francisco',\n            },\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      // linked nodes use a minimal path from the nearest refetchable node\n      var addressID = 'client:2';  // The generated id *after* viewer\n      var pathQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            address {\n              city,\n            },\n          }\n        }\n      `);\n      var path = new RelayQueryPath(pathQuery)\n        .getPath(getField(pathQuery, 'address'), addressID);\n      expect(store.getPathToRecord(addressID)).toMatchPath(path);\n    });\n\n    it('writes paths to plural linked fields', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212', // directory assistance\n          countryCode: '1',\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      // plural fields must be refetched through the parent\n      // get linked records to verify the client id\n      var allPhoneIDs = store.getLinkedRecordIDs('123', 'allPhones');\n      expect(allPhoneIDs.length).toBe(1);\n      var path = new RelayQueryPath(query)\n        .getPath(getField(query, 'allPhones'), allPhoneIDs[0]);\n      expect(store.getPathToRecord(allPhoneIDs[0])).toMatchPath(path);\n\n      // plural items must be refetched through the parent plural field\n      // get field to verify the client id is correct\n      var phoneNoID = store.getLinkedRecordID(allPhoneIDs[0], 'phoneNumber');\n      path = new RelayQueryPath(query)\n        .getPath(getField(query, 'allPhones'), allPhoneIDs[0])\n        .getPath(getField(query, 'allPhones', 'phoneNumber'), phoneNoID);\n      expect(store.getPathToRecord(phoneNoID)).toMatchPath(path);\n    });\n\n    it('writes paths to connection records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id,\n                  address {\n                    city,\n                  },\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'cursor1',\n                node: {\n                  id: 'node1',\n                  address: {\n                    city: 'San Francisco',\n                  },\n                },\n              },\n            ],\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      // connections and edges must be refetched through the parent\n      var path = new RelayQueryPath(query)\n        .getPath(getField(query, 'friends'), 'client:1');\n      expect(store.getPathToRecord('client:1')).toMatchPath(path);\n      path = new RelayQueryPath(query)\n        .getPath(getField(query, 'friends'), 'client:1')\n        .getPath(getField(query, 'friends', 'edges'), 'client:client:1:node1');\n      expect(store.getPathToRecord('client:client:1:node1')).toMatchPath(path);\n\n      // connection nodes with an ID are refetchable\n      expect(store.getPathToRecord('node1')).toBe(undefined);\n\n      // linked nodes use a minimal path from the nearest refetchable node\n      var pathQuery = getNode(Relay.QL`query{node(id:\"node1\"){address{city}}}`);\n      path = new RelayQueryPath(pathQuery)\n        .getPath(getField(pathQuery, 'address'), 'client:2');\n      expect(store.getField('client:2', 'city')).toBe('San Francisco');\n      expect(store.getPathToRecord('client:2')).toMatchPath(path);\n    });\n\n    it('writes paths with fragments', () => {\n      var records = {};\n      var rootCallMap = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var fragment = Relay.QL`fragment on Viewer {\n        actor {\n          id\n          __typename\n          name\n        }\n      }`;\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          viewer {\n            ${fragment}\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            name: 'Joe',\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n\n      var viewerID = store.getDataID('viewer');\n      var actorID = store.getLinkedRecordID(viewerID, 'actor');\n\n      var path = new RelayQueryPath(query)\n        .getPath(getNode(fragment), viewerID)\n        .getPath(getNode(fragment).getChildren()[0], actorID);\n      expect(store.getPathToRecord(actorID)).toMatchPath(path);\n    });\n  });\n\n  describe('query tracking', () => {\n    it('tracks new root records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var tracker = new RelayQueryTracker();\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            name,\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n          __typename: 'User',\n        },\n      };\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(1);\n      expect(trackedQueries[0][1]).toBe('123');\n      expect(trackedQueries[0][0]).toEqualQueryRoot(query);\n    });\n\n    it('tracks new records in fragments', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var tracker = new RelayQueryTracker();\n\n      // `address` will be encountered twice, both occurrences must be tracked\n      var fragment = Relay.QL`fragment on Node{address{city}}`;\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            ${fragment},\n            ${fragment},\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          address: {\n            city: 'San Francisco',\n          },\n          __typename: 'User',\n        },\n      };\n      var addressID = 'client:1';\n      var addressFragment = getNode(fragment).getChildren()[0];\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(3);\n      expect(trackedQueries[1][1]).toBe(addressID);\n      expect(trackedQueries[1][0]).toEqualQueryNode(addressFragment);\n      expect(trackedQueries[2][1]).toBe(addressID);\n      expect(trackedQueries[2][0]).toEqualQueryNode(addressFragment);\n    });\n\n    it('tracks new linked records', () => {\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              name,\n            },\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            name: 'Joe',\n            __typename: 'User',\n          },\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(1);\n      expect(trackedQueries[0][1]).toBe('123');\n      expect(trackedQueries[0][0]).toEqualQueryNode(query.getChildren()[0]);\n    });\n\n    it('tracks new plural linked records', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            allPhones {\n              isVerified,\n              phoneNumber {\n                displayNumber,\n                countryCode,\n              },\n            },\n          }\n        }\n      `);\n      var phone = {\n        isVerified: true,\n        phoneNumber: {\n          displayNumber: '1-800-555-1212', // directory assistance\n          countryCode: '1',\n        },\n      };\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          allPhones: [phone],\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      // creates `allPhones` record and linked `phoneNumber` field\n      expect(trackedQueries.length).toBe(2);\n      expect(trackedQueries[0][1]).toBe('client:1');\n      expect(trackedQueries[0][0]).toEqualQueryNode(\n        getField(query, 'allPhones')\n      );\n      expect(trackedQueries[1][1]).toBe('client:2');\n      expect(trackedQueries[1][0]).toEqualQueryNode(\n        getField(query, 'allPhones', 'phoneNumber')\n      );\n    });\n\n    it('tracks new connections', () => {\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: '456',\n                  name: 'Greg',\n                },\n              },\n            ],\n          },\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(3);\n      // track range node\n      expect(trackedQueries[0][1]).toBe('client:1');\n      expect(trackedQueries[0][0]).toEqualQueryNode(\n        getField(query, 'friends')\n      );\n      // track first edge\n      expect(trackedQueries[1][1]).toBe('client:client:1:456');\n      expect(trackedQueries[1][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges')\n      );\n      // track node\n      expect(trackedQueries[2][1]).toBe('456');\n      expect(trackedQueries[2][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges', 'node')\n      );\n    });\n\n    it('tracks edges and nodes added to an existing connection', () => {\n      // write a range with first(1) edge\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          __typename: 'User',\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: '456',\n                  name: 'Greg',\n                },\n              },\n            ],\n          },\n        },\n      };\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      expect(tracker.trackNodeForID.mock.calls.length).toBe(3);\n\n      // write an additional node and verify only the new edge and node are\n      // tracked\n      query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(after:\"c1\",first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [\n              {\n                cursor: 'c2',\n                node: {\n                  id: '789',\n                  name: 'Jing',\n                },\n              },\n            ],\n          },\n        },\n      };\n      tracker = new RelayQueryTracker();\n      tracker.trackNodeForID.mockClear();\n      writePayload(store, writer, query, payload, tracker);\n      var trackedQueries = tracker.trackNodeForID.mock.calls;\n      expect(trackedQueries.length).toBe(2);\n      // track new edge\n      expect(trackedQueries[0][1]).toBe('client:client:1:789');\n      expect(trackedQueries[0][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges')\n      );\n      // track node\n      expect(trackedQueries[1][1]).toBe('789');\n      expect(trackedQueries[1][0]).toEqualQueryNode(\n        getField(query, 'friends', 'edges', 'node')\n      );\n    });\n\n    it('re-tracks all nodes if `updateTrackedQueries` is enabled', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name,\n            allPhones {\n              phoneNumber {\n                displayNumber,\n              },\n            },\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          name: 'Joe',\n          allPhones: [\n            {\n              phoneNumber: {\n                displayNumber: '1-800-555-1212', // directory assistance\n              },\n            },\n          ],\n          friends: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: '456',\n                  name: 'Tim',\n                },\n              },\n            ],\n          },\n          __typename: 'User',\n        },\n      };\n      // populate the store and record the original tracked queries\n      var tracker = new RelayQueryTracker();\n      writePayload(store, writer, query, payload, tracker);\n      var prevTracked = tracker.trackNodeForID.mock.calls.slice();\n      expect(prevTracked.length).toBe(6);\n\n      // rewriting the same payload by default does not track anything\n      tracker = new RelayQueryTracker();\n      tracker.trackNodeForID.mockClear();\n      writePayload(store, writer, query, payload, tracker);\n      expect(tracker.trackNodeForID.mock.calls.length).toBe(0);\n\n      // force-tracking should track the original nodes again\n      tracker = new RelayQueryTracker();\n      tracker.trackNodeForID.mockClear();\n      writePayload(store, writer, query, payload, tracker, {\n        updateTrackedQueries: true,\n      });\n      var nextTracked = tracker.trackNodeForID.mock.calls;\n      expect(nextTracked.length).toBe(prevTracked.length);\n      nextTracked.forEach((tracked, ii) => {\n        expect(tracked[1]).toBe(prevTracked[ii][1]); // dataID\n        expect(tracked[0]).toEqualQueryNode(prevTracked[ii][0]); // dataID\n      });\n    });\n  });\n\n  it('skips non-matching fragments', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          ...on User {\n            name\n          }\n          ...on Comment {\n            body {\n              text\n            }\n          }\n          ...on Node {\n            firstName\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n        name: 'Joe',\n        body: {\n          text: 'Skipped!',\n        },\n      },\n    };\n    writeVerbatimPayload(store, writer, query, payload);\n    expect(store.getField('123', 'firstName')).toBe('Joe');\n    expect(store.getField('123', 'name')).toBe('Joe');\n    // `body` only exists on `Comment` which does not match the record type\n    expect(store.getLinkedRecordID('123', 'body')).toBe(undefined);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_paths-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_linkedField-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {\n    getNode,\n    getVerbatimNode,\n    writePayload,\n    writeVerbatimPayload,\n  } = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('linked fields', () => {\n    it('are created and set to null when the response is null', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(null);\n    });\n\n    it('are deleted when the response is null', () => {\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n          actor: {\n            __dataID__: 'client:2',\n          },\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n        },\n        updated: {\n          'client:1': true,\n        },\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(null);\n    });\n\n    it('are not created when the response is undefined', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(undefined);\n    });\n\n    it('are not deleted when the response is undefined', () => {\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n          actor: {\n            __dataID__: '123',\n          },\n        },\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe('123');\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n    });\n\n    it('are created with the specified id', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var actorID = '123';\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: actorID,\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(actorID);\n      expect(store.getRecordState(actorID)).toBe('EXISTENT');\n    });\n\n    it('updates the parent if the id changes', () => {\n      var actorID = '123';\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n          actor: {\n            __dataID__: actorID,\n          },\n        },\n        '123': {\n          __dataID__: actorID,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var nextActorID = '456';\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: nextActorID,\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '456': true,\n        },\n        updated: {\n          'client:1': true,\n        },\n      });\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(nextActorID);\n      expect(store.getRecordState(nextActorID)).toBe('EXISTENT');\n      expect(store.getRecordState(actorID)).toBe('EXISTENT'); // unlinked only\n    });\n\n    it('are created with a generated id if none is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var addressID = 'client:1';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            address {\n              city\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          // address has no id and receives a generated client id\n          address: {\n            city: 'San Francisco',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n          'client:1': true,\n        },\n        updated: {},\n      });\n      expect(store.getLinkedRecordID('123', 'address')).toBe(addressID);\n      expect(store.getRecordState(addressID)).toBe('EXISTENT');\n      expect(store.getField(addressID, 'city')).toBe('San Francisco');\n    });\n\n    it('reuses existing generated ids', () => {\n      var addressID = 'client:1';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          address: {\n            __dataID__: addressID,\n          },\n        },\n        'client:1': {\n          __dataID__: addressID,\n          city: 'San Francisco',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            address {\n              city\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          // the address record has no id but should reuse the previously\n          // generated client id\n          address: {\n            city: 'San Francisco',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getLinkedRecordID('123', 'address')).toBe(addressID);\n      expect(store.getField(addressID, 'city')).toBe('San Francisco');\n    });\n\n    it('records an update on the parent if a linked field is created', () => {\n      var records = {\n        'user:1': {\n          __dataID__: 'user:1',\n          'hometown': {\n            __dataID__: 'hometown:1',\n          },\n          id: 'user:1',\n        },\n        'hometown:1': null,\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      store.removeRecord('hometown:1');\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"user:1\") {\n            hometown {\n              name\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: 'user:1',\n          'hometown': {\n            id: 'hometown:1',\n            name: 'World',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'hometown:1': true,\n        },\n        updated: {\n          'user:1': true,\n        },\n      });\n    });\n\n    it('records the concrete type if `__typename` is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n              __typename\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n    });\n\n    it('warns if the typename cannot be determined for a node', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      // No `id` or `__typename` fields or responses\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              name\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            name: 'Joe',\n          },\n        },\n      };\n      writeVerbatimPayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe(null);\n      expect([\n        'RelayQueryWriter: Could not find a type name for record `%s`.',\n        '123',\n      ]).toBeWarnedNTimes(1);\n    });\n\n    it('stores types for client records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          me {\n            id\n            __typename\n            ... on User {\n              address {\n                city\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        me: {\n          id: '123',\n          __typename: 'User',\n          address: {\n            city: 'Menlo Park',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      var addressID = store.getLinkedRecordID('123', 'address');\n      expect(store.getType('123')).toBe('User');\n      expect(store.getType(addressID)).toBe('StreetAddress');\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {\n    getNode,\n    getVerbatimNode,\n    writePayload,\n    writeVerbatimPayload,\n  } = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('linked fields', () => {\n    it('are created and set to null when the response is null', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n        },\n        updated: {},\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(null);\n    });\n\n    it('are deleted when the response is null', () => {\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n          actor: {\n            __dataID__: 'client:2',\n          },\n        },\n        'client:2': {\n          __dataID__: 'client:2',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: null,\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n        },\n        updated: {\n          'client:1': true,\n        },\n      });\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(null);\n    });\n\n    it('are not created when the response is undefined', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(undefined);\n    });\n\n    it('are not deleted when the response is undefined', () => {\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n          actor: {\n            __dataID__: '123',\n          },\n        },\n        '123': {\n          __dataID__: '123',\n          id: '123',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: undefined,\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getRecordState('client:1')).toBe('EXISTENT');\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe('123');\n      expect(store.getRecordState('123')).toBe('EXISTENT');\n      expect(store.getField('123', 'id')).toBe('123');\n    });\n\n    it('are created with the specified id', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var actorID = '123';\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: actorID,\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'client:1': true,\n          '123': true,\n        },\n        updated: {},\n      });\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(actorID);\n      expect(store.getRecordState(actorID)).toBe('EXISTENT');\n    });\n\n    it('updates the parent if the id changes', () => {\n      var actorID = '123';\n      var records = {\n        'client:1': {\n          __dataID__: 'client:1',\n          actor: {\n            __dataID__: actorID,\n          },\n        },\n        '123': {\n          __dataID__: actorID,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var nextActorID = '456';\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: nextActorID,\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '456': true,\n        },\n        updated: {\n          'client:1': true,\n        },\n      });\n      expect(store.getLinkedRecordID('client:1', 'actor')).toBe(nextActorID);\n      expect(store.getRecordState(nextActorID)).toBe('EXISTENT');\n      expect(store.getRecordState(actorID)).toBe('EXISTENT'); // unlinked only\n    });\n\n    it('are created with a generated id if none is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var addressID = 'client:1';\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            address {\n              city\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          // address has no id and receives a generated client id\n          address: {\n            city: 'San Francisco',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '123': true,\n          'client:1': true,\n        },\n        updated: {},\n      });\n      expect(store.getLinkedRecordID('123', 'address')).toBe(addressID);\n      expect(store.getRecordState(addressID)).toBe('EXISTENT');\n      expect(store.getField(addressID, 'city')).toBe('San Francisco');\n    });\n\n    it('reuses existing generated ids', () => {\n      var addressID = 'client:1';\n      var records = {\n        '123': {\n          __dataID__: '123',\n          id: '123',\n          address: {\n            __dataID__: addressID,\n          },\n        },\n        'client:1': {\n          __dataID__: addressID,\n          city: 'San Francisco',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            address {\n              city\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          // the address record has no id but should reuse the previously\n          // generated client id\n          address: {\n            city: 'San Francisco',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {},\n      });\n      expect(store.getLinkedRecordID('123', 'address')).toBe(addressID);\n      expect(store.getField(addressID, 'city')).toBe('San Francisco');\n    });\n\n    it('records an update on the parent if a linked field is created', () => {\n      var records = {\n        'user:1': {\n          __dataID__: 'user:1',\n          'hometown': {\n            __dataID__: 'hometown:1',\n          },\n          id: 'user:1',\n        },\n        'hometown:1': null,\n      };\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      store.removeRecord('hometown:1');\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"user:1\") {\n            hometown {\n              name\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: 'user:1',\n          'hometown': {\n            id: 'hometown:1',\n            name: 'World',\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'hometown:1': true,\n        },\n        updated: {\n          'user:1': true,\n        },\n      });\n    });\n\n    it('records the concrete type if `__typename` is present', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id,\n              __typename\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            __typename: 'User',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe('User');\n    });\n\n    it('warns if the typename cannot be determined for a node', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      // No `id` or `__typename` fields or responses\n      var query = getVerbatimNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              name\n            }\n          }\n        }\n      `);\n      var payload = {\n        viewer: {\n          actor: {\n            id: '123',\n            name: 'Joe',\n          },\n        },\n      };\n      writeVerbatimPayload(store, writer, query, payload);\n      expect(store.getType('123')).toBe(null);\n      expect([\n        'RelayQueryWriter: Could not find a type name for record `%s`.',\n        '123',\n      ]).toBeWarnedNTimes(1);\n    });\n\n    it('stores types for client records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          me {\n            id\n            __typename\n            ... on User {\n              address {\n                city\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        me: {\n          id: '123',\n          __typename: 'User',\n          address: {\n            city: 'Menlo Park',\n          },\n        },\n      };\n      writePayload(store, writer, query, payload);\n      var addressID = store.getLinkedRecordID('123', 'address');\n      expect(store.getType('123')).toBe('User');\n      expect(store.getType(addressID)).toBe('StreetAddress');\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_linkedField-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_connectionField-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n  var END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO, START_CURSOR;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    ({\n      END_CURSOR,\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n      START_CURSOR,\n    } = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates empty first() connection records', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"3\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n              source {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: false,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        '123': true,\n        'client:1': true, // `friends` connection\n      },\n      updated: {},\n    });\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 3},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: undefined,\n        [HAS_NEXT_PAGE]: false,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: undefined,\n      },\n      requestedEdgeIDs: [],\n      filteredEdges: [],\n    });\n  });\n\n  it('creates first() connection records', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"3\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n              source {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            {\n              cursor: 'friend1',\n              node: {\n                id: 'friend1ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n            {\n              cursor: 'friend2',\n              node: {\n                id: 'friend2ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n            {\n              cursor: 'friend3',\n              node: {\n                id: 'friend3ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        '123': true,\n        'client:1': true, // `friends` connection\n        'client:client:1:friend1ID': true,  // edges\n        'client:client:1:friend2ID': true,\n        'client:client:1:friend3ID': true,\n        'friend1ID': true, // nodes\n        'friend2ID': true,\n        'friend3ID': true,\n      },\n      updated: {},\n    });\n    expect(store.getField('friend1ID', 'id')).toBe('friend1ID');\n    expect(store.getField('friend2ID', 'id')).toBe('friend2ID');\n    expect(store.getField('friend3ID', 'id')).toBe('friend3ID');\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 3},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: 'friend3',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: 'friend1',\n      },\n      requestedEdgeIDs: [\n        'client:client:1:friend1ID',\n        'client:client:1:friend2ID',\n        'client:client:1:friend3ID',\n      ],\n      filteredEdges: [\n        {edgeID: 'client:client:1:friend1ID', nodeID: 'friend1ID'},\n        {edgeID: 'client:client:1:friend2ID', nodeID: 'friend2ID'},\n        {edgeID: 'client:client:1:friend3ID', nodeID: 'friend3ID'},\n      ],\n    });\n  });\n\n  it('skips over null edges and nodes', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"3\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            null,\n            {\n              cursor: 'friend2',\n              node: null,\n            },\n            {\n              cursor: 'friend3',\n              node: {\n                id: 'friend3ID',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        '123': true,\n        'client:1': true, // `friends` connection\n        'client:client:1:friend3ID': true, // edges\n        'friend3ID': true,\n      },\n      updated: {},\n    });\n    expect(store.getField('friend3ID', 'id')).toBe('friend3ID');\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 1},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: 'friend3',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: 'friend3',\n      },\n      requestedEdgeIDs: ['client:client:1:friend3ID'],\n      filteredEdges: [\n        {edgeID: 'client:client:1:friend3ID', nodeID: 'friend3ID'},\n      ],\n    });\n  });\n\n  it('creates range when a connection record already exists', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends {count}\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {count: 5},\n        __typename: 'User',\n      },\n    };\n    writePayload(store, writer, query, payload);\n\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"1\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n              source {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n    payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            {\n              cursor: 'friend1',\n              node: {\n                id: 'friend1ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        'client:client:1:friend1ID': true,  // edges\n        'friend1ID': true, // nodes\n      },\n      updated: {\n        'client:1': true,\n      },\n    });\n    expect(store.getField('friend1ID', 'id')).toBe('friend1ID');\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 1},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: 'friend1',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: 'friend1',\n      },\n      requestedEdgeIDs: ['client:client:1:friend1ID'],\n      filteredEdges: [\n        {edgeID: 'client:client:1:friend1ID', nodeID: 'friend1ID'},\n      ],\n    });\n  });\n\n  it('should throw when connection is missing required calls', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var edgesFragment = Relay.QL`\n      fragment on FriendsConnection {\n        edges {\n          cursor,\n          node {\n            id\n          },\n          source {\n            id\n          }\n        },\n        pageInfo {\n          hasNextPage,\n          hasPreviousPage,\n        }\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(isViewerFriend:true) {\n            ${edgesFragment}\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            {\n              cursor: 'friend1',\n              node: {\n                id: 'friend1ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n    expect(() => writePayload(store, writer, query, payload)).toFailInvariant(\n      'RelayQueryWriter: Cannot write edges for connection ' +\n      '`friends.isViewerFriend(true)` on record `client:1` without ' +\n      '`first`, `last`, or `find` argument.'\n    );\n  });\n\n  describe('first() connections with existing data', () => {\n    var store, writer;\n\n    beforeEach(() => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1',\n              },\n              cursor: 'cursor1',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n          __typename: 'User',\n        },\n      };\n      var records = {};\n      store = new RelayRecordStore({records});\n      writer = new RelayRecordWriter(records, {}, false);\n      writePayload(store, writer, query, payload);\n    });\n\n    it('appends new edges', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\",after:\"cursor1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node2',\n              },\n              cursor: 'cursor2',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: true,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'node2': true,\n          'client:client:1:node2': true, // 2nd edge\n        },\n        updated: {\n          'client:1': true, // range updated\n        },\n      });\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 2},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor2',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: [\n          'client:client:1:node1',\n          'client:client:1:node2',\n        ],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n          {edgeID: 'client:client:1:node2', nodeID: 'node2'},\n        ],\n      });\n    });\n\n    it('updates existing edges when ids match', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(find:\"node1\") {\n              edges {\n                node {\n                  id,\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1',\n                name: 'Tim', // added field\n              },\n              cursor: 'cursor1',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: true,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          'node1': true,    // `name` added\n          // range not updated, only the node changed\n        },\n      });\n      expect(store.getField('node1', 'name')).toBe('Tim');\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: ['client:client:1:node1'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n        ],\n      });\n    });\n\n    it('updates the range when edge data changes', () => {\n      // NOTE: Hack to preserve `source{id}` in all environments for now.\n      var query = RelayQuery.Root.create(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(find:\"node1\") {\n              edges {\n                node {\n                  id,\n                },\n                source {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `, RelayMetaRoute.get('$RelayTest'), {});\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1',\n              },\n              source: { // new edge field\n                id: '456',\n              },\n              cursor: 'cursor1',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: true,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '456': true, // `source` added\n        },\n        updated: {\n          'client:1': true, // range updated because an edge had a change\n          'client:client:1:node1': true, // `source` added to edge\n        },\n      });\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: ['client:client:1:node1'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n        ],\n      });\n      var sourceID = store.getLinkedRecordID('client:client:1:node1', 'source');\n      expect(sourceID).toBe('456');\n      expect(store.getField(sourceID, 'id')).toBe('456');\n    });\n\n    it('does not overwrite edges when ids conflict', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1b',\n              },\n              cursor: 'cursor1b',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'node1b': true,\n          'client:client:1:node1b': true,   // edge added but never referenced\n        },\n        updated: {\n          'client:1': true,     // range updated\n        },\n      });\n      expect(store.getField('node1b', 'id')).toBe('node1b');\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: ['client:client:1:node1'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n        ],\n      });\n    });\n\n    it('overwrites ranges when force index is set', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1b',\n              },\n              cursor: 'cursor1b',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      var results =\n        writePayload(store, writer, query, payload, null, {forceIndex: 1});\n      expect(results).toEqual({\n        created: {\n          'node1b': true,\n          'client:client:1:node1b': true,\n        },\n        updated: {\n          'client:1': true,     // range updated\n        },\n      });\n      expect(store.getField('node1b', 'id')).toBe('node1b');\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1b',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1b',\n        },\n        requestedEdgeIDs: ['client:client:1:node1b'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1b', nodeID: 'node1b'},\n        ],\n      });\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayMetaRoute","RelayQuery","RelayTestUtils","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('writeRelayQueryPayload()', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n  var END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO, START_CURSOR;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    ({\n      END_CURSOR,\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n      START_CURSOR,\n    } = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates empty first() connection records', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"3\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n              source {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: false,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        '123': true,\n        'client:1': true, // `friends` connection\n      },\n      updated: {},\n    });\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 3},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: undefined,\n        [HAS_NEXT_PAGE]: false,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: undefined,\n      },\n      requestedEdgeIDs: [],\n      filteredEdges: [],\n    });\n  });\n\n  it('creates first() connection records', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"3\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n              source {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            {\n              cursor: 'friend1',\n              node: {\n                id: 'friend1ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n            {\n              cursor: 'friend2',\n              node: {\n                id: 'friend2ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n            {\n              cursor: 'friend3',\n              node: {\n                id: 'friend3ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        '123': true,\n        'client:1': true, // `friends` connection\n        'client:client:1:friend1ID': true,  // edges\n        'client:client:1:friend2ID': true,\n        'client:client:1:friend3ID': true,\n        'friend1ID': true, // nodes\n        'friend2ID': true,\n        'friend3ID': true,\n      },\n      updated: {},\n    });\n    expect(store.getField('friend1ID', 'id')).toBe('friend1ID');\n    expect(store.getField('friend2ID', 'id')).toBe('friend2ID');\n    expect(store.getField('friend3ID', 'id')).toBe('friend3ID');\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 3},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: 'friend3',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: 'friend1',\n      },\n      requestedEdgeIDs: [\n        'client:client:1:friend1ID',\n        'client:client:1:friend2ID',\n        'client:client:1:friend3ID',\n      ],\n      filteredEdges: [\n        {edgeID: 'client:client:1:friend1ID', nodeID: 'friend1ID'},\n        {edgeID: 'client:client:1:friend2ID', nodeID: 'friend2ID'},\n        {edgeID: 'client:client:1:friend3ID', nodeID: 'friend3ID'},\n      ],\n    });\n  });\n\n  it('skips over null edges and nodes', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"3\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            null,\n            {\n              cursor: 'friend2',\n              node: null,\n            },\n            {\n              cursor: 'friend3',\n              node: {\n                id: 'friend3ID',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        '123': true,\n        'client:1': true, // `friends` connection\n        'client:client:1:friend3ID': true, // edges\n        'friend3ID': true,\n      },\n      updated: {},\n    });\n    expect(store.getField('friend3ID', 'id')).toBe('friend3ID');\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 1},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: 'friend3',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: 'friend3',\n      },\n      requestedEdgeIDs: ['client:client:1:friend3ID'],\n      filteredEdges: [\n        {edgeID: 'client:client:1:friend3ID', nodeID: 'friend3ID'},\n      ],\n    });\n  });\n\n  it('creates range when a connection record already exists', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends {count}\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {count: 5},\n        __typename: 'User',\n      },\n    };\n    writePayload(store, writer, query, payload);\n\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(first:\"1\") {\n            edges {\n              cursor,\n              node {\n                id\n              },\n              source {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage,\n            }\n          }\n        }\n      }\n    `);\n    payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            {\n              cursor: 'friend1',\n              node: {\n                id: 'friend1ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var results = writePayload(store, writer, query, payload);\n    expect(results).toEqual({\n      created: {\n        'client:client:1:friend1ID': true,  // edges\n        'friend1ID': true, // nodes\n      },\n      updated: {\n        'client:1': true,\n      },\n    });\n    expect(store.getField('friend1ID', 'id')).toBe('friend1ID');\n    expect(store.getRangeMetadata('client:1', [\n      {name: 'first', value: 1},\n    ])).toEqual({\n      diffCalls: [],\n      filterCalls: [],\n      pageInfo: {\n        [END_CURSOR]: 'friend1',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n        [START_CURSOR]: 'friend1',\n      },\n      requestedEdgeIDs: ['client:client:1:friend1ID'],\n      filteredEdges: [\n        {edgeID: 'client:client:1:friend1ID', nodeID: 'friend1ID'},\n      ],\n    });\n  });\n\n  it('should throw when connection is missing required calls', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var edgesFragment = Relay.QL`\n      fragment on FriendsConnection {\n        edges {\n          cursor,\n          node {\n            id\n          },\n          source {\n            id\n          }\n        },\n        pageInfo {\n          hasNextPage,\n          hasPreviousPage,\n        }\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          friends(isViewerFriend:true) {\n            ${edgesFragment}\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        friends: {\n          edges: [\n            {\n              cursor: 'friend1',\n              node: {\n                id: 'friend1ID',\n              },\n              source: {\n                id: '123',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n        __typename: 'User',\n      },\n    };\n    expect(() => writePayload(store, writer, query, payload)).toFailInvariant(\n      'RelayQueryWriter: Cannot write edges for connection ' +\n      '`friends.isViewerFriend(true)` on record `client:1` without ' +\n      '`first`, `last`, or `find` argument.'\n    );\n  });\n\n  describe('first() connections with existing data', () => {\n    var store, writer;\n\n    beforeEach(() => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1',\n              },\n              cursor: 'cursor1',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n          __typename: 'User',\n        },\n      };\n      var records = {};\n      store = new RelayRecordStore({records});\n      writer = new RelayRecordWriter(records, {}, false);\n      writePayload(store, writer, query, payload);\n    });\n\n    it('appends new edges', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\",after:\"cursor1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node2',\n              },\n              cursor: 'cursor2',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: true,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'node2': true,\n          'client:client:1:node2': true, // 2nd edge\n        },\n        updated: {\n          'client:1': true, // range updated\n        },\n      });\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 2},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor2',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: [\n          'client:client:1:node1',\n          'client:client:1:node2',\n        ],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n          {edgeID: 'client:client:1:node2', nodeID: 'node2'},\n        ],\n      });\n    });\n\n    it('updates existing edges when ids match', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(find:\"node1\") {\n              edges {\n                node {\n                  id,\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1',\n                name: 'Tim', // added field\n              },\n              cursor: 'cursor1',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: true,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {},\n        updated: {\n          'node1': true,    // `name` added\n          // range not updated, only the node changed\n        },\n      });\n      expect(store.getField('node1', 'name')).toBe('Tim');\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: ['client:client:1:node1'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n        ],\n      });\n    });\n\n    it('updates the range when edge data changes', () => {\n      // NOTE: Hack to preserve `source{id}` in all environments for now.\n      var query = RelayQuery.Root.create(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(find:\"node1\") {\n              edges {\n                node {\n                  id,\n                },\n                source {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `, RelayMetaRoute.get('$RelayTest'), {});\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1',\n              },\n              source: { // new edge field\n                id: '456',\n              },\n              cursor: 'cursor1',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: true,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          '456': true, // `source` added\n        },\n        updated: {\n          'client:1': true, // range updated because an edge had a change\n          'client:client:1:node1': true, // `source` added to edge\n        },\n      });\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: ['client:client:1:node1'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n        ],\n      });\n      var sourceID = store.getLinkedRecordID('client:client:1:node1', 'source');\n      expect(sourceID).toBe('456');\n      expect(store.getField(sourceID, 'id')).toBe('456');\n    });\n\n    it('does not overwrite edges when ids conflict', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1b',\n              },\n              cursor: 'cursor1b',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      var results = writePayload(store, writer, query, payload);\n      expect(results).toEqual({\n        created: {\n          'node1b': true,\n          'client:client:1:node1b': true,   // edge added but never referenced\n        },\n        updated: {\n          'client:1': true,     // range updated\n        },\n      });\n      expect(store.getField('node1b', 'id')).toBe('node1b');\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1',\n        },\n        requestedEdgeIDs: ['client:client:1:node1'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1', nodeID: 'node1'},\n        ],\n      });\n    });\n\n    it('overwrites ranges when force index is set', () => {\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          friends: {\n            edges: [{\n              node: {\n                id: 'node1b',\n              },\n              cursor: 'cursor1b',\n            }],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      var results =\n        writePayload(store, writer, query, payload, null, {forceIndex: 1});\n      expect(results).toEqual({\n        created: {\n          'node1b': true,\n          'client:client:1:node1b': true,\n        },\n        updated: {\n          'client:1': true,     // range updated\n        },\n      });\n      expect(store.getField('node1b', 'id')).toBe('node1b');\n      expect(store.getRangeMetadata('client:1', [\n        {name: 'first', value: 1},\n      ])).toEqual({\n        diffCalls: [],\n        filterCalls: [],\n        pageInfo: {\n          [END_CURSOR]: 'cursor1b',\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n          [START_CURSOR]: 'cursor1b',\n        },\n        requestedEdgeIDs: ['client:client:1:node1b'],\n        filteredEdges: [\n          {edgeID: 'client:client:1:node1b', nodeID: 'node1b'},\n        ],\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/writeRelayQueryPayload_connectionField-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/transformRelayQueryPayload-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('transformClientPayload()', () => {\n  const {getNode} = RelayTestUtils;\n\n  it('transforms singular root payloads', () => {\n    const query = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          friends(first:\"1\") {\n            count,\n            edges {\n              node {\n                id,\n                ... on User {\n                  profilePicture(size: \"32\") {\n                    uri,\n                  },\n                },\n              },\n            },\n          },\n        }\n      }\n    `);\n    const payload = {\n      node: {\n        id: '123',\n        friends: {\n          count: 1,\n          edges: [\n            {\n              cursor: 'friend:cursor',\n              node: {\n                id: 'client:1',\n                profilePicture: {\n                  uri: 'friend.jpg',\n                },\n              },\n            },\n          ],\n        },\n      },\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      node: {\n        __typename: undefined,\n        id: '123',\n        [generateRQLFieldAlias('friends.first(1)')]: {\n          count: 1,\n          edges: [\n            {\n              cursor: 'friend:cursor',\n              node: {\n                id: 'client:1',\n                [generateRQLFieldAlias('profilePicture.size(32)')]: {\n                  uri: 'friend.jpg',\n                },\n              },\n            },\n          ],\n          pageInfo: undefined,\n        },\n      },\n    });\n  });\n\n  it('transforms plural root payloads of arrays', () => {\n    const query = getNode(Relay.QL`\n      query {\n        nodes(ids: [\"123\", \"456\"]) {\n          ... on User {\n            profilePicture(size: \"32\") {\n              uri,\n            },\n          },\n        },\n      }\n    `);\n    const payload = {\n      123: {\n        id: '123',\n        profilePicture: {\n          uri: '123.jpg',\n        },\n      },\n      456: {\n        id: '456',\n        profilePicture: {\n          uri: '456.jpg',\n        },\n      },\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      123: {\n        __typename: undefined,\n        id: '123',\n        [generateRQLFieldAlias('profilePicture.size(32)')]: {\n          uri: '123.jpg',\n        },\n      },\n      456: {\n        __typename: undefined,\n        id: '456',\n        [generateRQLFieldAlias('profilePicture.size(32)')]: {\n          uri: '456.jpg',\n        },\n      },\n    });\n  });\n\n  it('transforms plural root payloads of objects (OSS)', () => {\n    const query = getNode(Relay.QL`\n      query {\n        nodes(ids: [\"123\", \"456\"]) {\n          ... on User {\n            profilePicture(size: \"32\") {\n              uri,\n            },\n          },\n        },\n      }\n    `);\n    const payload = {\n      nodes: [\n        {\n          id: '123',\n          profilePicture: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          id: '456',\n          profilePicture: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      nodes: [\n        {\n          __typename: undefined,\n          id: '123',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          __typename: undefined,\n          id: '456',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    });\n  });\n\n  it('transforms plural root payloads of objects (FB)', () => {\n    const query = getNode(Relay.QL`\n      query {\n        nodes(ids: [\"123\", \"456\"]) {\n          ... on User {\n            profilePicture(size: \"32\") {\n              uri,\n            },\n          },\n        },\n      }\n    `);\n    const payload = {\n      nodes: [\n        {\n          id: '123',\n          profilePicture: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          id: '456',\n          profilePicture: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      nodes: [\n        {\n          __typename: undefined,\n          id: '123',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          __typename: undefined,\n          id: '456',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    });\n  });\n\n  it('uses the query interface to construct keys', () => {\n    const queryInterface = {\n      getKeyForClientData: jest.genMockFunction().mockImplementation(\n        field => Array.from(field.getApplicationName()).reverse().join('')\n      ),\n      traverseChildren: jest.genMockFunction().mockImplementation(\n        (node, callback, context) => node.getChildren().reverse().forEach(\n          (...args) => callback.apply(context, args)\n        )\n      ),\n    };\n    const query = getNode(Relay.QL`\n      query {\n        me {\n          id\n          name\n          profilePicture {\n            uri\n          }\n        }\n      }\n    `);\n    const payload = {\n      me: {\n        erutciPeliforp: {\n          iru: 'abc.jpg',\n        },\n        eman: 'ABC',\n        di: '123',\n      },\n    };\n    expect(\n      transformRelayQueryPayload(query, payload, queryInterface)\n    ).toEqual({\n      me: {\n        id: '123',\n        name: 'ABC',\n        profilePicture: {\n          uri: 'abc.jpg',\n        },\n      },\n    });\n\n    // `getKeyForClientData` should be called on every field.\n    expect(\n      queryInterface.getKeyForClientData.mock.calls.map(\n        ([field]) => field.getApplicationName()\n      )\n    ).toEqual(['profilePicture', 'uri', 'name', 'id']);\n\n    // `traverseChildren` should be called on every field with children.\n    expect(\n      queryInterface.traverseChildren.mock.calls.map(\n        ([node]) => node instanceof RelayQuery.Root ?\n          node.getFieldName() :\n          node.getApplicationName()\n      )\n    ).toEqual(['me', 'profilePicture']);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayTestUtils","generateRQLFieldAlias","transformRelayQueryPayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('transformClientPayload()', () => {\n  const {getNode} = RelayTestUtils;\n\n  it('transforms singular root payloads', () => {\n    const query = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          friends(first:\"1\") {\n            count,\n            edges {\n              node {\n                id,\n                ... on User {\n                  profilePicture(size: \"32\") {\n                    uri,\n                  },\n                },\n              },\n            },\n          },\n        }\n      }\n    `);\n    const payload = {\n      node: {\n        id: '123',\n        friends: {\n          count: 1,\n          edges: [\n            {\n              cursor: 'friend:cursor',\n              node: {\n                id: 'client:1',\n                profilePicture: {\n                  uri: 'friend.jpg',\n                },\n              },\n            },\n          ],\n        },\n      },\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      node: {\n        __typename: undefined,\n        id: '123',\n        [generateRQLFieldAlias('friends.first(1)')]: {\n          count: 1,\n          edges: [\n            {\n              cursor: 'friend:cursor',\n              node: {\n                id: 'client:1',\n                [generateRQLFieldAlias('profilePicture.size(32)')]: {\n                  uri: 'friend.jpg',\n                },\n              },\n            },\n          ],\n          pageInfo: undefined,\n        },\n      },\n    });\n  });\n\n  it('transforms plural root payloads of arrays', () => {\n    const query = getNode(Relay.QL`\n      query {\n        nodes(ids: [\"123\", \"456\"]) {\n          ... on User {\n            profilePicture(size: \"32\") {\n              uri,\n            },\n          },\n        },\n      }\n    `);\n    const payload = {\n      123: {\n        id: '123',\n        profilePicture: {\n          uri: '123.jpg',\n        },\n      },\n      456: {\n        id: '456',\n        profilePicture: {\n          uri: '456.jpg',\n        },\n      },\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      123: {\n        __typename: undefined,\n        id: '123',\n        [generateRQLFieldAlias('profilePicture.size(32)')]: {\n          uri: '123.jpg',\n        },\n      },\n      456: {\n        __typename: undefined,\n        id: '456',\n        [generateRQLFieldAlias('profilePicture.size(32)')]: {\n          uri: '456.jpg',\n        },\n      },\n    });\n  });\n\n  it('transforms plural root payloads of objects (OSS)', () => {\n    const query = getNode(Relay.QL`\n      query {\n        nodes(ids: [\"123\", \"456\"]) {\n          ... on User {\n            profilePicture(size: \"32\") {\n              uri,\n            },\n          },\n        },\n      }\n    `);\n    const payload = {\n      nodes: [\n        {\n          id: '123',\n          profilePicture: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          id: '456',\n          profilePicture: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      nodes: [\n        {\n          __typename: undefined,\n          id: '123',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          __typename: undefined,\n          id: '456',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    });\n  });\n\n  it('transforms plural root payloads of objects (FB)', () => {\n    const query = getNode(Relay.QL`\n      query {\n        nodes(ids: [\"123\", \"456\"]) {\n          ... on User {\n            profilePicture(size: \"32\") {\n              uri,\n            },\n          },\n        },\n      }\n    `);\n    const payload = {\n      nodes: [\n        {\n          id: '123',\n          profilePicture: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          id: '456',\n          profilePicture: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    };\n    expect(transformRelayQueryPayload(query, payload)).toEqual({\n      nodes: [\n        {\n          __typename: undefined,\n          id: '123',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '123.jpg',\n          },\n        },\n        {\n          __typename: undefined,\n          id: '456',\n          [generateRQLFieldAlias('profilePicture.size(32)')]: {\n            uri: '456.jpg',\n          },\n        },\n      ],\n    });\n  });\n\n  it('uses the query interface to construct keys', () => {\n    const queryInterface = {\n      getKeyForClientData: jest.genMockFunction().mockImplementation(\n        field => Array.from(field.getApplicationName()).reverse().join('')\n      ),\n      traverseChildren: jest.genMockFunction().mockImplementation(\n        (node, callback, context) => node.getChildren().reverse().forEach(\n          (...args) => callback.apply(context, args)\n        )\n      ),\n    };\n    const query = getNode(Relay.QL`\n      query {\n        me {\n          id\n          name\n          profilePicture {\n            uri\n          }\n        }\n      }\n    `);\n    const payload = {\n      me: {\n        erutciPeliforp: {\n          iru: 'abc.jpg',\n        },\n        eman: 'ABC',\n        di: '123',\n      },\n    };\n    expect(\n      transformRelayQueryPayload(query, payload, queryInterface)\n    ).toEqual({\n      me: {\n        id: '123',\n        name: 'ABC',\n        profilePicture: {\n          uri: 'abc.jpg',\n        },\n      },\n    });\n\n    // `getKeyForClientData` should be called on every field.\n    expect(\n      queryInterface.getKeyForClientData.mock.calls.map(\n        ([field]) => field.getApplicationName()\n      )\n    ).toEqual(['profilePicture', 'uri', 'name', 'id']);\n\n    // `traverseChildren` should be called on every field with children.\n    expect(\n      queryInterface.traverseChildren.mock.calls.map(\n        ([node]) => node instanceof RelayQuery.Root ?\n          node.getFieldName() :\n          node.getApplicationName()\n      )\n    ).toEqual(['me', 'profilePicture']);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/transformRelayQueryPayload-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/subtractRelayQuery-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst subtractRelayQuery = require('subtractRelayQuery');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\n\ndescribe('subtractRelayQuery', () => {\n  var {defer, getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  function subtractQuery(min, sub) {\n    return subtractRelayQuery(min, flattenRelayQuery(sub));\n  }\n\n  it('persists query names', () => {\n    var minQuery = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          hometown {\n            id,\n            name,\n          },\n          name\n        }\n      }\n    `);\n    var subQuery = getNode(Relay.QL`\n      query {\n        node(id:\"4\"){name}\n      }\n    `);\n    var diffQuery = subtractQuery(minQuery, subQuery);\n    expect(diffQuery).not.toBe(minQuery);\n    expect(diffQuery.getName()).toBe(minQuery.getName());\n  });\n\n  describe('fields', () => {\n    it('subtracts top-level fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n            },\n            name\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){name}\n        }\n      `);\n      var expected = getNode(Relay.QL`query{node(id:\"4\"){id,hometown{id,name}}}`);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('returns null when the resulting query would be empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n            },\n            name\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){name}\n        }\n      `);\n      // this would subtract to node(4){id,hometown{id}}, which is \"empty\"\n      // because it contains no non-requisite, non-id scalar fields\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toBe(null);\n    });\n\n    it('returns null when the minuend query is empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){name}\n        }\n      `);\n      // this would subtract to node(4){id,hometown{id}}, which is \"empty\"\n      // because it contains no non-requisite, non-id scalar fields\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toBe(null);\n    });\n\n    it('does not consider requisite fields with aliases to be empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"10\") {\n              edges {\n                live_cursor: cursor,\n              },\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              count,\n            },\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"10\") {\n              edges {\n                live_cursor: cursor,\n              },\n            },\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('does not consider id fields with aliases to be empty', () => {\n      // the `id` here is a non-requisite id field\n      var minQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  special_id: id,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  actor {\n                    name,\n                  },\n                },\n              },\n            },\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(minQuery).toBe(diffQuery);\n    });\n\n    it('does not consider ref query dependencies to be empty', () => {\n      var fragment = Relay.QL`fragment on Feedback{canViewerLike}`;\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"UzpfSTU0MTUzNTg0MzoxMDE1Mjk3MDY0NjAzNTg0NA==\") {\n            feedback {\n              doesViewerLike,\n              ${defer(fragment)},\n            }\n          }\n        }\n      `);\n      var otherQuery = getNode(Relay.QL`\n        query {\n          node(id:\"UzpfSTU0MTUzNTg0MzoxMDE1Mjk3MDY0NjAzNTg0NA==\") {\n            feedback {\n              doesViewerLike\n            }\n          }\n        }\n      `);\n      var splitQueries = splitDeferredRelayQueries(query);\n      var required = splitQueries.required;\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"UzpfSTU0MTUzNTg0MzoxMDE1Mjk3MDY0NjAzNTg0NA==\") {\n            id,\n            feedback {\n              id,\n            },\n          }\n        }\n      `);\n\n      expect(subtractQuery(required, otherQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts nested fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            name,\n            birthdate {\n              day\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){birthdate{day}}\n        }\n      `);\n      var expected = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n\n      minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n              url\n            }\n          }\n        }\n      `);\n      subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{name}}\n        }\n      `);\n      expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              url\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts deeply nested fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              address {\n                country,\n                city\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{address{country}}}\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              address {\n                city\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('returns null for no difference', () => {\n      var minQuery = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      var subQuery = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      expect(subtractQuery(minQuery, subQuery)).toBeNull();\n    });\n\n    it('does not subtract when the root call arguments are different', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            name,\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"660361306\") {\n            id,\n            name,\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('ignores fields only in subtrahend query', () => {\n      var minQuery = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      var subQuery = getNode(Relay.QL`query{node(id:\"4\"){firstName}}`);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('preserves fields from fragments within a range', () => {\n      var fragment = Relay.QL`\n        fragment on User {\n          name,\n        }\n      `;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first: \"10\") {\n              edges {\n                node {\n                  id,\n                  ${fragment},\n                },\n              },\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first: \"10\") {\n              edges {\n                node {\n                  id,\n                  firstName\n                },\n              },\n            },\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(minQuery).toBe(diffQuery);\n    });\n\n    it('preserves fields from deferred fragments within a range', () => {\n      var fragment = Relay.QL`\n        fragment on User {\n          name,\n        }\n      `;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first: \"5\") {\n              edges {\n                node {\n                  id,\n                  firstName,\n                  ${defer(fragment)},\n                },\n              },\n            },\n          }\n        }\n      `);\n      var queries = splitDeferredRelayQueries(minQuery);\n\n      var {required, deferred} = queries;\n      expect(deferred.length).toBe(1); // sanity check\n      expect(subtractQuery(deferred[0].required, required))\n        .toBe(deferred[0].required);\n    });\n  });\n\n  describe('id', () => {\n    it('preserves `id` field if difference is non-empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n              url\n            },\n            name\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{id,url}}\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name\n            },\n            name\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('removes `id` fields if no non-requisite fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            hometown {\n              name\n            },\n            friends(first:\"5\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            hometown {\n              name\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('preserves exported `id` fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            },\n          }\n        }\n      `);\n      minQuery = minQuery.clone([\n        minQuery.getChildren()[0].clone([\n          minQuery.getChildren()[0].getChildren()[0]\n            .cloneAsRefQueryDependency(),\n        ]),\n      ]);\n      var subQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toBe(minQuery);\n    });\n  });\n\n  describe('fragments', () => {\n    it('returns null for no difference with fragments', () => {\n      var minFragment = Relay.QL`fragment on Node{name}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){id,${minFragment}}\n        }\n      `);\n      var subFragment = Relay.QL`fragment on Node{name}`;\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){id,${subFragment}}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('subtracts fields from minuend fragments', () => {\n      var minFragment = Relay.QL`fragment on Node{hometown{name},name}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${minFragment}\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{name}}\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${Relay.QL`fragment on Node{name}`}\n          }\n        }\n      `);\n\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts entire minuend fragments when empty', () => {\n      var minFragment = Relay.QL`fragment on Actor{birthdate{day},hometown{id}}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            name,\n            ${minFragment}\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){birthdate{day},hometown{id}}\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${Relay.QL`fragment on Actor{id}`},\n            id,\n            name\n          }\n        }\n      `);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts fields in subtrahend fragments', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n              url\n            },\n            name\n          }\n        }\n      `);\n      var subFragment = Relay.QL`fragment on Page{name}`;\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            hometown {\n              id,\n              ${subFragment}\n            }\n          }\n        }\n      `);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              url\n            },\n            name\n          }\n        }\n      `);\n\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts subtrahend fragments from minuend fragments', () => {\n      var minFragment = Relay.QL`fragment on Node{hometown{id,name,url},name}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            ${minFragment}\n          }\n        }\n      `);\n      var subFragmentNode = Relay.QL`fragment on Node{name}`;\n      var subFragmentPage = Relay.QL`fragment on Page{name}`;\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            hometown {\n              id,\n              ${subFragmentPage}\n            },\n            ${subFragmentNode}\n          }\n        }\n      `);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${Relay.QL`\n        fragment on Node {\n          hometown {\n            url\n          }\n        }\n      `},\n            id,\n          }\n        }\n      `);\n\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n  });\n\n  describe('calls', () => {\n    it('subtracts fields with matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            url(site:\"www\")\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){url(site:\"www\")}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('preserves fields with non-matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            url(site:\"www\")\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){url(site:\"mobile\")}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('subtracts nested fields with matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            profilePicture(size:\"32\") {\n              uri\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){profilePicture(size:\"32\"){uri}}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('preserves nested fields with non-matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            profilePicture(size:\"32\") {\n              uri\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){profilePicture(size:\"64\"){uri}}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n  });\n\n  describe('ranges', () => {\n    it('subtracts fields from range supersets', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  name,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('removes empty ranges', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            friends(first:\"5\") {\n              edges {\n                cursor,\n                node {\n                  id,\n                  name\n                }\n              },\n              pageInfo {\n                hasNextPage,\n                hasPreviousPage\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"5\") {\n              edges {\n                cursor,\n                node {\n                  id,\n                  name\n                }\n              },\n              pageInfo {\n                hasNextPage,\n                hasPreviousPage\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('preserves all fields from range subsets', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  name,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('preserves ranges with non-matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(orderby:\"importance\",first:\"3\") {\n              edges {\n                node {\n                  name,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","flattenRelayQuery","subtractRelayQuery","splitDeferredRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst subtractRelayQuery = require('subtractRelayQuery');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\n\ndescribe('subtractRelayQuery', () => {\n  var {defer, getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  function subtractQuery(min, sub) {\n    return subtractRelayQuery(min, flattenRelayQuery(sub));\n  }\n\n  it('persists query names', () => {\n    var minQuery = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          hometown {\n            id,\n            name,\n          },\n          name\n        }\n      }\n    `);\n    var subQuery = getNode(Relay.QL`\n      query {\n        node(id:\"4\"){name}\n      }\n    `);\n    var diffQuery = subtractQuery(minQuery, subQuery);\n    expect(diffQuery).not.toBe(minQuery);\n    expect(diffQuery.getName()).toBe(minQuery.getName());\n  });\n\n  describe('fields', () => {\n    it('subtracts top-level fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n            },\n            name\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){name}\n        }\n      `);\n      var expected = getNode(Relay.QL`query{node(id:\"4\"){id,hometown{id,name}}}`);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('returns null when the resulting query would be empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n            },\n            name\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){name}\n        }\n      `);\n      // this would subtract to node(4){id,hometown{id}}, which is \"empty\"\n      // because it contains no non-requisite, non-id scalar fields\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toBe(null);\n    });\n\n    it('returns null when the minuend query is empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){name}\n        }\n      `);\n      // this would subtract to node(4){id,hometown{id}}, which is \"empty\"\n      // because it contains no non-requisite, non-id scalar fields\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toBe(null);\n    });\n\n    it('does not consider requisite fields with aliases to be empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"10\") {\n              edges {\n                live_cursor: cursor,\n              },\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"1\") {\n              count,\n            },\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"10\") {\n              edges {\n                live_cursor: cursor,\n              },\n            },\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('does not consider id fields with aliases to be empty', () => {\n      // the `id` here is a non-requisite id field\n      var minQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  special_id: id,\n                },\n              },\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  actor {\n                    name,\n                  },\n                },\n              },\n            },\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(minQuery).toBe(diffQuery);\n    });\n\n    it('does not consider ref query dependencies to be empty', () => {\n      var fragment = Relay.QL`fragment on Feedback{canViewerLike}`;\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"UzpfSTU0MTUzNTg0MzoxMDE1Mjk3MDY0NjAzNTg0NA==\") {\n            feedback {\n              doesViewerLike,\n              ${defer(fragment)},\n            }\n          }\n        }\n      `);\n      var otherQuery = getNode(Relay.QL`\n        query {\n          node(id:\"UzpfSTU0MTUzNTg0MzoxMDE1Mjk3MDY0NjAzNTg0NA==\") {\n            feedback {\n              doesViewerLike\n            }\n          }\n        }\n      `);\n      var splitQueries = splitDeferredRelayQueries(query);\n      var required = splitQueries.required;\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"UzpfSTU0MTUzNTg0MzoxMDE1Mjk3MDY0NjAzNTg0NA==\") {\n            id,\n            feedback {\n              id,\n            },\n          }\n        }\n      `);\n\n      expect(subtractQuery(required, otherQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts nested fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            name,\n            birthdate {\n              day\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){birthdate{day}}\n        }\n      `);\n      var expected = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n\n      minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n              url\n            }\n          }\n        }\n      `);\n      subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{name}}\n        }\n      `);\n      expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              url\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts deeply nested fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              address {\n                country,\n                city\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{address{country}}}\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              address {\n                city\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('returns null for no difference', () => {\n      var minQuery = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      var subQuery = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      expect(subtractQuery(minQuery, subQuery)).toBeNull();\n    });\n\n    it('does not subtract when the root call arguments are different', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            name,\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"660361306\") {\n            id,\n            name,\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('ignores fields only in subtrahend query', () => {\n      var minQuery = getNode(Relay.QL`query{node(id:\"4\"){id,name}}`);\n      var subQuery = getNode(Relay.QL`query{node(id:\"4\"){firstName}}`);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('preserves fields from fragments within a range', () => {\n      var fragment = Relay.QL`\n        fragment on User {\n          name,\n        }\n      `;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first: \"10\") {\n              edges {\n                node {\n                  id,\n                  ${fragment},\n                },\n              },\n            },\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first: \"10\") {\n              edges {\n                node {\n                  id,\n                  firstName\n                },\n              },\n            },\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(minQuery).toBe(diffQuery);\n    });\n\n    it('preserves fields from deferred fragments within a range', () => {\n      var fragment = Relay.QL`\n        fragment on User {\n          name,\n        }\n      `;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first: \"5\") {\n              edges {\n                node {\n                  id,\n                  firstName,\n                  ${defer(fragment)},\n                },\n              },\n            },\n          }\n        }\n      `);\n      var queries = splitDeferredRelayQueries(minQuery);\n\n      var {required, deferred} = queries;\n      expect(deferred.length).toBe(1); // sanity check\n      expect(subtractQuery(deferred[0].required, required))\n        .toBe(deferred[0].required);\n    });\n  });\n\n  describe('id', () => {\n    it('preserves `id` field if difference is non-empty', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n              url\n            },\n            name\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{id,url}}\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name\n            },\n            name\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('removes `id` fields if no non-requisite fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            hometown {\n              name\n            },\n            friends(first:\"5\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            hometown {\n              name\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toEqualQueryRoot(expected);\n    });\n\n    it('preserves exported `id` fields', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            },\n          }\n        }\n      `);\n      minQuery = minQuery.clone([\n        minQuery.getChildren()[0].clone([\n          minQuery.getChildren()[0].getChildren()[0]\n            .cloneAsRefQueryDependency(),\n        ]),\n      ]);\n      var subQuery = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toBe(minQuery);\n    });\n  });\n\n  describe('fragments', () => {\n    it('returns null for no difference with fragments', () => {\n      var minFragment = Relay.QL`fragment on Node{name}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){id,${minFragment}}\n        }\n      `);\n      var subFragment = Relay.QL`fragment on Node{name}`;\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){id,${subFragment}}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('subtracts fields from minuend fragments', () => {\n      var minFragment = Relay.QL`fragment on Node{hometown{name},name}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${minFragment}\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){hometown{name}}\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${Relay.QL`fragment on Node{name}`}\n          }\n        }\n      `);\n\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts entire minuend fragments when empty', () => {\n      var minFragment = Relay.QL`fragment on Actor{birthdate{day},hometown{id}}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            name,\n            ${minFragment}\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){birthdate{day},hometown{id}}\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${Relay.QL`fragment on Actor{id}`},\n            id,\n            name\n          }\n        }\n      `);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts fields in subtrahend fragments', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              name,\n              url\n            },\n            name\n          }\n        }\n      `);\n      var subFragment = Relay.QL`fragment on Page{name}`;\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            hometown {\n              id,\n              ${subFragment}\n            }\n          }\n        }\n      `);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            hometown {\n              id,\n              url\n            },\n            name\n          }\n        }\n      `);\n\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('subtracts subtrahend fragments from minuend fragments', () => {\n      var minFragment = Relay.QL`fragment on Node{hometown{id,name,url},name}`;\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            ${minFragment}\n          }\n        }\n      `);\n      var subFragmentNode = Relay.QL`fragment on Node{name}`;\n      var subFragmentPage = Relay.QL`fragment on Page{name}`;\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            hometown {\n              id,\n              ${subFragmentPage}\n            },\n            ${subFragmentNode}\n          }\n        }\n      `);\n\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            ${Relay.QL`\n        fragment on Node {\n          hometown {\n            url\n          }\n        }\n      `},\n            id,\n          }\n        }\n      `);\n\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n  });\n\n  describe('calls', () => {\n    it('subtracts fields with matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            url(site:\"www\")\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){url(site:\"www\")}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('preserves fields with non-matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            url(site:\"www\")\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){url(site:\"mobile\")}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('subtracts nested fields with matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            profilePicture(size:\"32\") {\n              uri\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){profilePicture(size:\"32\"){uri}}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('preserves nested fields with non-matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            profilePicture(size:\"32\") {\n              uri\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\"){profilePicture(size:\"64\"){uri}}\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n  });\n\n  describe('ranges', () => {\n    it('subtracts fields from range supersets', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  name,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var diffQuery = subtractQuery(minQuery, subQuery);\n      expect(diffQuery).toEqualQueryRoot(expected);\n    });\n\n    it('removes empty ranges', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            id,\n            friends(first:\"5\") {\n              edges {\n                cursor,\n                node {\n                  id,\n                  name\n                }\n              },\n              pageInfo {\n                hasNextPage,\n                hasPreviousPage\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"5\") {\n              edges {\n                cursor,\n                node {\n                  id,\n                  name\n                }\n              },\n              pageInfo {\n                hasNextPage,\n                hasPreviousPage\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(null);\n    });\n\n    it('preserves all fields from range subsets', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  name,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n\n    it('preserves ranges with non-matching calls', () => {\n      var minQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(orderby:\"importance\",first:\"3\") {\n              edges {\n                node {\n                  name,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      `);\n      var subQuery = getNode(Relay.QL`\n        query {\n          node(id:\"4\") {\n            friends(first:\"3\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `);\n      expect(subtractQuery(minQuery, subQuery)).toBe(minQuery);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/subtractRelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/splitDeferredRelayQueries-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\n\ndescribe('splitDeferredRelayQueries()', () => {\n  // helper functions\n  var {defer, getNode, getRefNode} = RelayTestUtils;\n\n  // remove the root `id` field\n  function filterGeneratedRootFields(node) {\n    var children = node.getChildren().filter(node => !(\n      node instanceof RelayQuery.Field &&\n      node.isGenerated()\n    ));\n    return node.clone(children);\n  }\n\n  beforeEach(() => {\n    // Reset query numbers back to q0.\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns the original query when there are no fragments', () => {\n    var node = Relay.QL`query{node(id:\"4\"){id,name}}`;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    expect(required).toBe(queryNode);\n    expect(deferred).toEqual([]);\n  });\n\n  it('returns the original query when there are no deferred fragments', () => {\n    var fragment = Relay.QL`fragment on User{hometown{name}}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          ${fragment},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    expect(required).toBe(queryNode);\n    expect(deferred).toEqual([]);\n  });\n\n  it('splits a deferred fragment on the viewer root', () => {\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              id,\n              actorCount,\n            },\n          },\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n          },\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{viewer{actor{id}}}`));\n    expect(required.getID()).toBe('q3');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits a nested feed on the viewer root', () => {\n    var nestedFragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              id,\n              actorCount,\n            },\n          },\n        },\n      }\n    `;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          name,\n        },\n        ${defer(nestedFragment)},\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n          },\n          ${fragment},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n          },\n          ${Relay.QL`\n      fragment on Viewer {\n        actor {\n          name,\n        }\n      }\n    `}\n        }\n      }\n    `));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${nestedFragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits nested deferred fragments', () => {\n    var nestedFragment = Relay.QL`fragment on NonNodeStory{message{text}}`;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              tracking,\n              ${defer(nestedFragment)},\n            },\n          },\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            name,\n          },\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `));\n    expect(required.getID()).toBe('q5');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            cursor,\n            node {\n              id,\n              tracking\n            }\n          },\n          pageInfo {\n            hasNextPage,\n            hasPreviousPage\n          }\n        }\n      }\n    `}\n        }\n      }\n    `));\n    expect(deferred[0].required.getID()).toBe('q4');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n\n    // TODO (#7891872): test unflattened queries. The expected output's `edges`\n    // field has two `node` children:\n    // - the requisite `node{id}`\n    // - the nested deferred fragment\n    expect(flattenRelayQuery(deferred[0].deferred[0].required)).\n      toEqualQueryRoot(flattenRelayQuery(getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"10\") {\n            edges {\n              cursor,\n              node {\n                ${nestedFragment},\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `)));\n    expect(deferred[0].deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits deferred fragments using ref queries', () => {\n    var fragment = Relay.QL`fragment on Page{profilePicture{uri}}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          hometown {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(\n      getNode(Relay.QL`query{node(id:\"4\"){hometown{id},id,name}}`)\n    );\n    expect(required.getID()).toBe('q1');\n    expect(\n      required\n        .getFieldByStorageKey('hometown')\n        .getFieldByStorageKey('id')\n        .isRefQueryDependency()\n    ).toBe(true);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits a nested deferred fragments as a ref queries', () => {\n    var nestedFragment = Relay.QL`fragment on Page{profilePicture{uri}}`;\n    var fragment = Relay.QL`\n      fragment on User {\n        hometown {\n          name,\n          ${defer(nestedFragment)},\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{node(id:\"4\"){id,name}}`));\n    expect(required.getID()).toBe('q3');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${Relay.QL`fragment on User{hometown{name}}`},\n          id\n        }\n      }\n    `));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n    expect(\n      deferred[0]\n        .required\n        .getChildren()[0] // node(4){hometown} (fragment)\n        .getChildren()[0] // node(4){hometown} (field)\n        .getChildren()[0] // node(4){hometown{id}} (field)\n        .isRefQueryDependency()\n    ).toBe(true);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q2) {\n              ${nestedFragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].deferred[0].required.getID()).toBe('q4');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits a deferred fragment nested inside a ref query', () => {\n    // this time, going to defer something inside the ref\n    var nestedFragment = Relay.QL`fragment on Page{address{city}}`;\n    var fragment = Relay.QL`\n      fragment on Page {\n        profilePicture {\n          uri\n        },\n        ${defer(nestedFragment)}\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          hometown {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(\n      getNode(Relay.QL`query{node(id:\"4\"){hometown{id},id,name}}`)\n    );\n    expect(\n      required\n        .getFieldByStorageKey('hometown')\n        .getFieldByStorageKey('id')\n        .isRefQueryDependency()\n    ).toBe(true);\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${Relay.QL`fragment on Page{id,profilePicture{uri}}`}\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q2) {\n              ${nestedFragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].deferred[0].required.getID()).toBe('q3');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('drops the required portion if it is empty', () => {\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              id,\n              actorCount,\n            },\n          },\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required).toBe(null);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferred part\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles a nested defer with no required part', () => {\n    var nestedFragment = Relay.QL`fragment on Viewer{primaryEmail}`;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        ${defer(nestedFragment)},\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          isFbEmployee,\n          ${defer(fragment)}\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{isFbEmployee}\n      }\n    `));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toBe(null);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${nestedFragment},\n        }\n      }\n    `));\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles a nested ref query defer with no required part', () => {\n    var nestedFragment = Relay.QL`fragment on Actor{hometown{name}}`;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        ${defer(nestedFragment)},\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            name,\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n    expect(\n      required\n        .getFieldByStorageKey('actor')\n        .getFieldByStorageKey('id')\n        .isRefQueryDependency()\n    ).toBe(true);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toBe(null);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${nestedFragment},\n            }\n          }\n        `,\n        {path: '$.*.actor.id'}\n      ))\n    );\n    expect(deferred[0].deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles paths with plural fields', () => {\n    var fragment = Relay.QL`fragment on Actor{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"123\") {\n          actors {\n            id,\n            ${defer(fragment)},\n          }\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          actors {\n            id,\n          }\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(filterGeneratedRootFields(\n      getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.actors.*.id'}\n      )\n    ));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('works with nested node ancestors', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            hometown {\n              ${defer(fragment)},\n            },\n          },\n        }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            hometown {\n              id,\n            },\n          },\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.actor.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('uses the auto-generated alias in ref query paths', () => {\n    var fragment = Relay.QL`fragment on User{firstName}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"5\") {\n            edges {\n              node {\n                name,\n                ${defer(fragment)},\n              },\n            },\n          },\n        }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name,\n              },\n            },\n          },\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    var alias = generateRQLFieldAlias('friends.first(5)');\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].required).toEqualQueryRoot(filterGeneratedRootFields(\n      getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.' + alias + '.edges.*.node.id'}\n      )\n    ));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('correctly produces multi-level JSONPaths in ref queries', () => {\n    var fragment = Relay.QL`fragment on Actor{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first: \"5\") {\n            edges {\n              node {\n                ${defer(fragment)},\n              },\n            },\n          },\n        }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first: \"5\") {\n            edges {\n              node {\n                id,\n              },\n            },\n          },\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    var alias = generateRQLFieldAlias('friends.first(5)');\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].required).toEqualQueryRoot(filterGeneratedRootFields(\n      getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.' + alias + '.edges.*.node.id'}\n      )\n    ));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles fragments that are not nodes', () => {\n    var fragment = Relay.QL`fragment on Image{uri}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          profilePicture(size:\"100\") {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{node(id:\"4\"){id}}`));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"100\") {\n            ${fragment},\n          },\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('omits required queries with only generated `id` fields', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n              ${defer(fragment)},\n            }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required).toBe(null);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n          node(id:\"4\") {\n            ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('does not omit \"empty\" required ref query dependencies', () => {\n    // It isn't possible to produce an \"empty\" ref query dependency with\n    // `Relay.QL`, but in order to be future-proof against this possible edge\n    // case, we create such a query by hand.\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var id = RelayQuery.Field.build({\n      fieldName: 'id',\n      metadata: {isRequisite: true},\n      type: 'String',\n    });\n    var typename = RelayQuery.Field.build({\n      fieldName: '__typename',\n      metadata: {isRequisite: true},\n      type: 'String',\n    });\n    var queryNode = RelayQuery.Root.build(\n      'splitDeferredRelayQueries',\n      'node',\n      '4',\n      [\n        id,\n        typename,\n        RelayQuery.Field.build({\n          fieldName: 'hometown',\n          children: [id, getNode(defer(fragment))],\n          metadata: {\n            canHaveSubselections: true,\n            isGenerated: true,\n            inferredPrimaryKey: 'id',\n            inferredRootCallName: 'node',\n          },\n          type: 'Page',\n        }),\n      ],\n      {\n        identifyingArgName: 'id',\n      }\n    );\n    queryNode = queryNode.clone(\n      queryNode.getChildren().map((outerChild, ii) => {\n        if (ii === 1) {\n          return outerChild.clone(\n            outerChild.getChildren().map((innerChild, jj) => {\n              if (jj === 0) {\n                return innerChild.cloneAsRefQueryDependency();\n              } else {\n                return innerChild;\n              }\n            })\n          );\n        } else {\n          return outerChild;\n        }\n      })\n    );\n\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\"){hometown{id},id}\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('preserves required queries with only a non-generated `id` field', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n              id,\n              ${defer(fragment)},\n            }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{node(id:\"4\"){id}}`));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('does not split empty fragments', () => {\n    // null fragment could be caused by an `if`/`unless` call + a GK\n    var nullFragment = Relay.QL`fragment on Viewer{${null}}`;\n    var fragment = Relay.QL`fragment on Viewer{${nullFragment}}`;\n    var node = Relay.QL`\n      query {\n        viewer {\n              primaryEmail,\n              ${defer(fragment)},\n            }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{primaryEmail}\n      }\n    `));\n    expect(deferred.length).toBe(0);\n  });\n\n  it('does not flatten fragments when splitting root queries', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${defer(fragment)},\n        }\n      }\n    `);\n    var {deferred} = splitDeferredRelayQueries(query);\n\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toContainQueryNode(getNode(fragment));\n  });\n\n  it('does not flatten fragments when splitting ref queries', () => {\n    var fragment = Relay.QL`fragment on Feedback{likers{count}}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"STORY_ID\") {\n          feedback {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `);\n    var {deferred} = splitDeferredRelayQueries(query);\n\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toContainQueryNode(getNode(fragment));\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayTestUtils","flattenRelayQuery","generateRQLFieldAlias","splitDeferredRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\n\ndescribe('splitDeferredRelayQueries()', () => {\n  // helper functions\n  var {defer, getNode, getRefNode} = RelayTestUtils;\n\n  // remove the root `id` field\n  function filterGeneratedRootFields(node) {\n    var children = node.getChildren().filter(node => !(\n      node instanceof RelayQuery.Field &&\n      node.isGenerated()\n    ));\n    return node.clone(children);\n  }\n\n  beforeEach(() => {\n    // Reset query numbers back to q0.\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns the original query when there are no fragments', () => {\n    var node = Relay.QL`query{node(id:\"4\"){id,name}}`;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    expect(required).toBe(queryNode);\n    expect(deferred).toEqual([]);\n  });\n\n  it('returns the original query when there are no deferred fragments', () => {\n    var fragment = Relay.QL`fragment on User{hometown{name}}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          ${fragment},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    expect(required).toBe(queryNode);\n    expect(deferred).toEqual([]);\n  });\n\n  it('splits a deferred fragment on the viewer root', () => {\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              id,\n              actorCount,\n            },\n          },\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n          },\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{viewer{actor{id}}}`));\n    expect(required.getID()).toBe('q3');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits a nested feed on the viewer root', () => {\n    var nestedFragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              id,\n              actorCount,\n            },\n          },\n        },\n      }\n    `;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          name,\n        },\n        ${defer(nestedFragment)},\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n          },\n          ${fragment},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n          },\n          ${Relay.QL`\n      fragment on Viewer {\n        actor {\n          name,\n        }\n      }\n    `}\n        }\n      }\n    `));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${nestedFragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits nested deferred fragments', () => {\n    var nestedFragment = Relay.QL`fragment on NonNodeStory{message{text}}`;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              tracking,\n              ${defer(nestedFragment)},\n            },\n          },\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            name,\n          },\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `));\n    expect(required.getID()).toBe('q5');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            cursor,\n            node {\n              id,\n              tracking\n            }\n          },\n          pageInfo {\n            hasNextPage,\n            hasPreviousPage\n          }\n        }\n      }\n    `}\n        }\n      }\n    `));\n    expect(deferred[0].required.getID()).toBe('q4');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n\n    // TODO (#7891872): test unflattened queries. The expected output's `edges`\n    // field has two `node` children:\n    // - the requisite `node{id}`\n    // - the nested deferred fragment\n    expect(flattenRelayQuery(deferred[0].deferred[0].required)).\n      toEqualQueryRoot(flattenRelayQuery(getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"10\") {\n            edges {\n              cursor,\n              node {\n                ${nestedFragment},\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `)));\n    expect(deferred[0].deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits deferred fragments using ref queries', () => {\n    var fragment = Relay.QL`fragment on Page{profilePicture{uri}}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          hometown {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(\n      getNode(Relay.QL`query{node(id:\"4\"){hometown{id},id,name}}`)\n    );\n    expect(required.getID()).toBe('q1');\n    expect(\n      required\n        .getFieldByStorageKey('hometown')\n        .getFieldByStorageKey('id')\n        .isRefQueryDependency()\n    ).toBe(true);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits a nested deferred fragments as a ref queries', () => {\n    var nestedFragment = Relay.QL`fragment on Page{profilePicture{uri}}`;\n    var fragment = Relay.QL`\n      fragment on User {\n        hometown {\n          name,\n          ${defer(nestedFragment)},\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{node(id:\"4\"){id,name}}`));\n    expect(required.getID()).toBe('q3');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${Relay.QL`fragment on User{hometown{name}}`},\n          id\n        }\n      }\n    `));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n    expect(\n      deferred[0]\n        .required\n        .getChildren()[0] // node(4){hometown} (fragment)\n        .getChildren()[0] // node(4){hometown} (field)\n        .getChildren()[0] // node(4){hometown{id}} (field)\n        .isRefQueryDependency()\n    ).toBe(true);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q2) {\n              ${nestedFragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].deferred[0].required.getID()).toBe('q4');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('splits a deferred fragment nested inside a ref query', () => {\n    // this time, going to defer something inside the ref\n    var nestedFragment = Relay.QL`fragment on Page{address{city}}`;\n    var fragment = Relay.QL`\n      fragment on Page {\n        profilePicture {\n          uri\n        },\n        ${defer(nestedFragment)}\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          hometown {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(\n      getNode(Relay.QL`query{node(id:\"4\"){hometown{id},id,name}}`)\n    );\n    expect(\n      required\n        .getFieldByStorageKey('hometown')\n        .getFieldByStorageKey('id')\n        .isRefQueryDependency()\n    ).toBe(true);\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${Relay.QL`fragment on Page{id,profilePicture{uri}}`}\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q2) {\n              ${nestedFragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].deferred[0].required.getID()).toBe('q3');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('drops the required portion if it is empty', () => {\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        newsFeed(first: \"10\") {\n          edges {\n            node {\n              id,\n              actorCount,\n            },\n          },\n        },\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          ${defer(fragment)},\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required).toBe(null);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferred part\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles a nested defer with no required part', () => {\n    var nestedFragment = Relay.QL`fragment on Viewer{primaryEmail}`;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        ${defer(nestedFragment)},\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          isFbEmployee,\n          ${defer(fragment)}\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{isFbEmployee}\n      }\n    `));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toBe(null);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${nestedFragment},\n        }\n      }\n    `));\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles a nested ref query defer with no required part', () => {\n    var nestedFragment = Relay.QL`fragment on Actor{hometown{name}}`;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        ${defer(nestedFragment)},\n      }\n    `;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            name,\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n    expect(\n      required\n        .getFieldByStorageKey('actor')\n        .getFieldByStorageKey('id')\n        .isRefQueryDependency()\n    ).toBe(true);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toBe(null);\n\n    // nested deferred part\n    expect(deferred[0].deferred.length).toBe(1);\n    expect(deferred[0].deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${nestedFragment},\n            }\n          }\n        `,\n        {path: '$.*.actor.id'}\n      ))\n    );\n    expect(deferred[0].deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested nested deferreds\n    expect(deferred[0].deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles paths with plural fields', () => {\n    var fragment = Relay.QL`fragment on Actor{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"123\") {\n          actors {\n            id,\n            ${defer(fragment)},\n          }\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          actors {\n            id,\n          }\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(filterGeneratedRootFields(\n      getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.actors.*.id'}\n      )\n    ));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('works with nested node ancestors', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var node = Relay.QL`\n      query {\n        viewer {\n          actor {\n            hometown {\n              ${defer(fragment)},\n            },\n          },\n        }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            hometown {\n              id,\n            },\n          },\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.actor.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('uses the auto-generated alias in ref query paths', () => {\n    var fragment = Relay.QL`fragment on User{firstName}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"5\") {\n            edges {\n              node {\n                name,\n                ${defer(fragment)},\n              },\n            },\n          },\n        }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name,\n              },\n            },\n          },\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    var alias = generateRQLFieldAlias('friends.first(5)');\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].required).toEqualQueryRoot(filterGeneratedRootFields(\n      getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.' + alias + '.edges.*.node.id'}\n      )\n    ));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('correctly produces multi-level JSONPaths in ref queries', () => {\n    var fragment = Relay.QL`fragment on Actor{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first: \"5\") {\n            edges {\n              node {\n                ${defer(fragment)},\n              },\n            },\n          },\n        }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first: \"5\") {\n            edges {\n              node {\n                id,\n              },\n            },\n          },\n        }\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    var alias = generateRQLFieldAlias('friends.first(5)');\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(\n      queryNode.getName()\n    );\n    expect(deferred[0].required).toEqualQueryRoot(filterGeneratedRootFields(\n      getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.' + alias + '.edges.*.node.id'}\n      )\n    ));\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('handles fragments that are not nodes', () => {\n    var fragment = Relay.QL`fragment on Image{uri}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          profilePicture(size:\"100\") {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{node(id:\"4\"){id}}`));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"100\") {\n            ${fragment},\n          },\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('omits required queries with only generated `id` fields', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n              ${defer(fragment)},\n            }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(required).toBe(null);\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n          node(id:\"4\") {\n            ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('does not omit \"empty\" required ref query dependencies', () => {\n    // It isn't possible to produce an \"empty\" ref query dependency with\n    // `Relay.QL`, but in order to be future-proof against this possible edge\n    // case, we create such a query by hand.\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var id = RelayQuery.Field.build({\n      fieldName: 'id',\n      metadata: {isRequisite: true},\n      type: 'String',\n    });\n    var typename = RelayQuery.Field.build({\n      fieldName: '__typename',\n      metadata: {isRequisite: true},\n      type: 'String',\n    });\n    var queryNode = RelayQuery.Root.build(\n      'splitDeferredRelayQueries',\n      'node',\n      '4',\n      [\n        id,\n        typename,\n        RelayQuery.Field.build({\n          fieldName: 'hometown',\n          children: [id, getNode(defer(fragment))],\n          metadata: {\n            canHaveSubselections: true,\n            isGenerated: true,\n            inferredPrimaryKey: 'id',\n            inferredRootCallName: 'node',\n          },\n          type: 'Page',\n        }),\n      ],\n      {\n        identifyingArgName: 'id',\n      }\n    );\n    queryNode = queryNode.clone(\n      queryNode.getChildren().map((outerChild, ii) => {\n        if (ii === 1) {\n          return outerChild.clone(\n            outerChild.getChildren().map((innerChild, jj) => {\n              if (jj === 0) {\n                return innerChild.cloneAsRefQueryDependency();\n              } else {\n                return innerChild;\n              }\n            })\n          );\n        } else {\n          return outerChild;\n        }\n      })\n    );\n\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\"){hometown{id},id}\n      }\n    `));\n    expect(required.getID()).toBe('q1');\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(\n      filterGeneratedRootFields(getRefNode(\n        Relay.QL`\n          query {\n            nodes(ids:$ref_q1) {\n              ${fragment},\n            }\n          }\n        `,\n        {path: '$.*.hometown.id'}\n      ))\n    );\n    expect(deferred[0].required.getID()).toBe('q2');\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('preserves required queries with only a non-generated `id` field', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var node = Relay.QL`\n      query {\n        node(id:\"4\") {\n              id,\n              ${defer(fragment)},\n            }\n      }\n    `;\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    // required part\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`query{node(id:\"4\"){id}}`));\n\n    // deferred part\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required.getName()).toBe(queryNode.getName());\n    expect(deferred[0].required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment},\n        }\n      }\n    `));\n    expect(deferred[0].required.isDeferred()).toBe(true);\n\n    // no nested deferreds\n    expect(deferred[0].deferred).toEqual([]);\n  });\n\n  it('does not split empty fragments', () => {\n    // null fragment could be caused by an `if`/`unless` call + a GK\n    var nullFragment = Relay.QL`fragment on Viewer{${null}}`;\n    var fragment = Relay.QL`fragment on Viewer{${nullFragment}}`;\n    var node = Relay.QL`\n      query {\n        viewer {\n              primaryEmail,\n              ${defer(fragment)},\n            }\n      }\n    `;\n\n    var queryNode = getNode(node);\n    var {required, deferred} = splitDeferredRelayQueries(queryNode);\n\n    expect(required.getName()).toBe(queryNode.getName());\n    expect(required).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer{primaryEmail}\n      }\n    `));\n    expect(deferred.length).toBe(0);\n  });\n\n  it('does not flatten fragments when splitting root queries', () => {\n    var fragment = Relay.QL`fragment on Node{name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${defer(fragment)},\n        }\n      }\n    `);\n    var {deferred} = splitDeferredRelayQueries(query);\n\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toContainQueryNode(getNode(fragment));\n  });\n\n  it('does not flatten fragments when splitting ref queries', () => {\n    var fragment = Relay.QL`fragment on Feedback{likers{count}}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"STORY_ID\") {\n          feedback {\n            ${defer(fragment)},\n          },\n        }\n      }\n    `);\n    var {deferred} = splitDeferredRelayQueries(query);\n\n    expect(deferred.length).toBe(1);\n    expect(deferred[0].required).toContainQueryNode(getNode(fragment));\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/splitDeferredRelayQueries-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/sortTypeFirst-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst sortTypeFirst = require('sortTypeFirst');\n\ndescribe('sortTypeFirst', () => {\n  it('considers `__type__` to be the smallest', () => {\n    expect(sortTypeFirst('__type__', '_')).toBe(-1);\n    expect(sortTypeFirst('_', '__type__')).toBe(1);\n    expect(sortTypeFirst('__type__', '__type__')).toBe(0);\n  });\n\n  it('does not compare non-`__type__` strings', () => {\n    expect(sortTypeFirst('a', 'b')).toBe(0);\n    expect(sortTypeFirst('b', 'a')).toBe(0);\n    expect(sortTypeFirst('a', 'a')).toBe(0);\n  });\n});\n","dependencies":["sortTypeFirst"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst sortTypeFirst = require('sortTypeFirst');\n\ndescribe('sortTypeFirst', () => {\n  it('considers `__type__` to be the smallest', () => {\n    expect(sortTypeFirst('__type__', '_')).toBe(-1);\n    expect(sortTypeFirst('_', '__type__')).toBe(1);\n    expect(sortTypeFirst('__type__', '__type__')).toBe(0);\n  });\n\n  it('does not compare non-`__type__` strings', () => {\n    expect(sortTypeFirst('a', 'b')).toBe(0);\n    expect(sortTypeFirst('b', 'a')).toBe(0);\n    expect(sortTypeFirst('a', 'a')).toBe(0);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/sortTypeFirst-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/printRelayOSSQuery-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst printRelayOSSQuery = require('printRelayOSSQuery');\n\ndescribe('printRelayOSSQuery', () => {\n  const {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('roots', () => {\n    it('prints a query with no root arguments', () => {\n      const query = getNode(Relay.QL`\n        query {\n          me {\n            firstName,\n            lastName,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery {\n          me {\n            firstName,\n            lastName,\n            id\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a generated query with one root argument', () => {\n      const query = RelayQuery.Root.build(\n        'FooQuery',\n        'node',\n        '123',\n        [\n          RelayQuery.Field.build({\n            fieldName: 'id',\n            type: 'String',\n          }),\n        ],\n        {\n          identifyingArgName: RelayNodeInterface.ID,\n          identifyingArgType: RelayNodeInterface.ID_TYPE,\n          isAbstract: true,\n          isDeferred: false,\n          isPlural: false,\n        },\n        'Node'\n      );\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($id_0: ID!) {\n          node(id: $id_0) {\n            id\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        id_0: '123',\n      });\n    });\n\n    it('prints a query with one root argument', () => {\n      const query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery {\n          node(id:\"123\") {\n            name,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a query with one root numeric argument', () => {\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          node(id: 123) {\n            name,\n            id,\n          },\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery {\n          node(id:123) {\n            name,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a query with multiple root arguments', () => {\n      const query = getNode(Relay.QL`\n        query {\n          usernames(names:[\"a\",\"b\",\"c\"]) {\n            firstName,\n            lastName,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery {\n          usernames(names:[\"a\",\"b\",\"c\"]) {\n            firstName,\n            lastName,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a query with multiple numeric arguments', () => {\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          nodes(ids: [123, 456]) {\n            name,\n            id,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery {\n          nodes(ids:[123,456]) {\n            name,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints enum call values', () => {\n      const enumValue = 'WEB';\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          settings(environment: $env) {\n            notificationSounds,\n          },\n        }\n      `, {\n        env: enumValue,\n      });\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($environment_0: Environment!) {\n          settings(environment: $environment_0) {\n            notificationSounds\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        environment_0: enumValue,\n      });\n    });\n\n    it('prints object call values', () => {\n      const objectValue = {query: 'Menlo Park'};\n      const query = getNode(Relay.QL`\n        query {\n          checkinSearchQuery(query: $q) {\n            query,\n          }\n        }\n      `, {\n        q: objectValue,\n      });\n\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery($query_0: CheckinSearchInput!) {\n          checkinSearchQuery(query: $query_0) {\n            query\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        query_0: objectValue,\n      });\n    });\n\n    it('dedupes enum variables', () => {\n      const enumValue = 'WEB';\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          defaultSettings {\n            web: notifications(environment: WEB)\n            foo: notifications(environment: $env)\n          }\n        }\n      `, {\n        env: enumValue,\n      });\n      const alias = generateRQLFieldAlias('notifications.environment(WEB)');\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($environment_0: Environment!) {\n          defaultSettings {\n            ${alias}: notifications(environment: $environment_0),\n            ${alias}: notifications(environment: $environment_0)\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        environment_0: enumValue,\n      });\n    });\n\n    it('dedupes object variables', () => {\n      const query1 = {query: 'foo'};\n      const query2 = {query: 'foo'};\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          node(id: \"123\") {\n            ... on User {\n              foo: storySearch(query: $query1) {\n                id\n              }\n              bar: storySearch(query: $query2) {\n                id\n              }\n            }\n          }\n        }\n      `, {\n        query1,\n        query2,\n      });\n      const alias = generateRQLFieldAlias('storySearch.query({\"query\":\"foo\"})');\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($query_0: StorySearchInput!) {\n          node(id: \"123\") {\n            id,\n            __typename,\n            ...F0\n          }\n        }\n        fragment F0 on User {\n          ${alias}: storySearch(query: $query_0) {\n            id\n          },\n          ${alias}: storySearch(query: $query_0) {\n            id\n          },\n          id\n        }\n      `);\n      expect(variables).toEqual({\n        query_0: query1,\n      });\n    });\n\n    it('throws for ref queries', () => {\n      const query = RelayQuery.Root.build(\n        'RefQueryName',\n        RelayNodeInterface.NODE,\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id'),\n        [\n          RelayQuery.Field.build({fieldName: 'id', type: 'String'}),\n          RelayQuery.Field.build({fieldName: 'name', type: 'String'}),\n        ],\n        {\n          isDeferred: true,\n          identifyingArgName: RelayNodeInterface.ID,\n          type: RelayNodeInterface.NODE_TYPE,\n        }\n      );\n      expect(() => printRelayOSSQuery(query)).toFailInvariant(\n        'printRelayOSSQuery(): Deferred queries are not supported.'\n      );\n    });\n  });\n\n  describe('fragments', () => {\n    it('prints fragments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id,\n          },\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints inline fragments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id\n            ... on User {\n              name\n            }\n            ... on User {\n              profilePicture {\n                uri\n              }\n            }\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename,\n            ...F0,\n            ...F1\n          }\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n        fragment F1 on User {\n          profilePicture {\n            uri\n          },\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with incrementing names', () => {\n      const fragmentA = Relay.QL`fragment on User { firstName }`;\n      const fragmentB = Relay.QL`fragment on User { lastName }`;\n      const fragment = getNode(Relay.QL`\n        fragment on Node {\n          ${fragmentA},\n          ${fragmentB},\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Node {\n          id,\n          __typename,\n          ...F0,\n          ...F1\n        }\n        fragment F0 on User {\n          firstName,\n          id\n        }\n        fragment F1 on User {\n          lastName,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with identical children only once', () => {\n      const fragmentA = Relay.QL`fragment on User { name }`;\n      const fragmentB = Relay.QL`fragment on User { name }`;\n      const fragment = getNode(Relay.QL`\n        fragment on Node {\n          ${fragmentA},\n          ${fragmentB},\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Node {\n          id,\n          __typename,\n          ...F0\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with different variables separately', () => {\n      const concreteFragment = Relay.QL`\n        fragment on User {\n          profilePicture(size: [$width, $height]) {\n            uri\n          }\n        }\n      `;\n      const fragment = getNode(Relay.QL`fragment on User { id }`).clone([\n        getNode(concreteFragment, {width: 32, height: 32}),\n        getNode(concreteFragment, {width: 64, height: 64}),\n      ]);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on User {\n          ...F0,\n          ...F1\n        }\n        fragment F0 on User {\n          ${generateRQLFieldAlias('profilePicture.size(32,32)')}:\n              profilePicture(size: [32, 32]) {\n            uri\n          },\n          id\n        }\n        fragment F1 on User {\n          ${generateRQLFieldAlias('profilePicture.size(64,64)')}:\n              profilePicture(size: [64, 64]) {\n            uri\n          },\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with different runtime children separately', () => {\n      let child;\n      child = Relay.QL`fragment on User { name }`;\n      const fragmentA = Relay.QL`fragment on User { ${child} }`;\n      child = Relay.QL`fragment on User { profilePicture { uri } }`;\n      const fragmentB = Relay.QL`fragment on User { ${child} }`;\n\n      const fragment = getNode(Relay.QL`\n        fragment on Node {\n          ${fragmentA},\n          ${fragmentB},\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Node {\n          id,\n          __typename,\n          ...F1,\n          ...F3\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n        fragment F1 on User {\n          id,\n          ...F0\n        }\n        fragment F2 on User {\n          profilePicture {\n            uri\n          },\n          id\n        }\n        fragment F3 on User {\n          id,\n          ...F2\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with different IDs but identical output once', () => {\n      const concreteFragment = Relay.QL`fragment on User { name }`;\n      const fragment = getNode(Relay.QL`fragment on User { id }`).clone([\n        getNode(concreteFragment, {value: 123}),\n        getNode(concreteFragment, {value: 456}),\n      ]);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on User {\n          ...F0\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('omits empty fragments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id\n          }\n          ... on Viewer {\n            actor @include(if: $false) {\n              name\n            }\n          }\n        }\n      `, {false: false});\n      const {text} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename\n          }\n        }\n      `);\n    });\n  });\n\n  describe('fields', () => {\n    it('prints a field with one argument', () => {\n      const alias = generateRQLFieldAlias('newsFeed.first(10)');\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          newsFeed(first:$first) {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      `, {first: 10});\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          ${alias}:newsFeed(first:10) {\n            edges {\n              node {\n                id,\n                __typename\n              },\n              cursor\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a field with multiple arguments', () => {\n      const alias = generateRQLFieldAlias('profilePicture.size(32,64)');\n      const fragment = getNode(Relay.QL`\n        fragment on Actor {\n          profilePicture(size:[\"32\",\"64\"]) {\n            uri\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Actor {\n          ${alias}:profilePicture(size:[\"32\",\"64\"]) {\n            uri\n          },\n          id,\n          __typename\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a field with multiple variable arguments', () => {\n      const alias = generateRQLFieldAlias('profilePicture.size(32,64)');\n      const fragment = getNode(Relay.QL`\n        fragment on Actor {\n          profilePicture(size:[$width,$height]) {\n            uri\n          }\n        }\n      `, {\n        height: 64,\n        width: 32,\n      });\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Actor {\n          ${alias}:profilePicture(size:[32,64]) {\n            uri\n          },\n          id,\n          __typename\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints scalar arguments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Actor {\n          friends(\n            first: $first,\n            orderby: $orderby,\n            isViewerFriend: $isViewerFriend,\n          ) {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      `, {\n        first: 10,\n        orderby: ['name'],\n        isViewerFriend: false,\n      });\n      const alias = fragment.getChildren()[0].getSerializationKey();\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Actor {\n          ${alias}:friends(first:10,orderby:[\"name\"],isViewerFriend:false) {\n            edges {\n              node {\n                id\n              },\n              cursor\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          },\n          id,\n          __typename\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints object call values', () => {\n      const enumValue = 'WEB';\n      const fragment = Relay.QL`\n        fragment on Settings {\n          notifications(environment: $env)\n        }\n      `;\n      const query = getNode(Relay.QL`\n        query {\n          defaultSettings {\n            ${fragment},\n          }\n        }\n      `, {\n        env: enumValue,\n      });\n      const alias = generateRQLFieldAlias('notifications.environment(WEB)');\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery($environment_0: Environment!) {\n          defaultSettings {\n            ...F0\n          }\n        }\n        fragment F0 on Settings {\n          ${alias}:notifications(environment: $environment_0)\n        }\n      `);\n      expect(variables).toEqual({\n        environment_0: enumValue,\n      });\n    });\n\n    it('prints inline fragments as references', () => {\n      // these fragments have different types and cannot be flattened\n      const nestedFragment = Relay.QL`fragment on User { name }`;\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id,\n            ${nestedFragment},\n            ${nestedFragment},\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename,\n            ...F0\n          }\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n  });\n\n  it('prints a mutation', () => {\n    const inputValue = {\n      clientMutationId: '123',\n      foo: 'bar',\n    };\n    const mutation = getNode(Relay.QL`\n      mutation {\n        feedbackLike(input: $input) {\n          clientMutationId,\n          feedback {\n            id,\n            actor {\n              profilePicture(preset: SMALL) {\n                uri,\n              },\n            },\n            likeSentence,\n            likers,\n          },\n        },\n      }\n    `, {input: inputValue});\n\n    const alias = generateRQLFieldAlias('profilePicture.preset(SMALL)');\n    const {text, variables} = printRelayOSSQuery(mutation);\n    expect(text).toEqualPrintedQuery(`\n      mutation PrintRelayOSSQuery(\n        $input_0: FeedbackLikeInput!,\n        $preset_1: PhotoSize!\n      ) {\n        feedbackLike(input: $input_0) {\n          clientMutationId,\n          feedback {\n            id,\n            actor {\n              ${alias}: profilePicture(preset: $preset_1) {\n                uri\n              },\n              id,\n              __typename\n            },\n            likeSentence,\n            likers\n          }\n        }\n      }\n    `);\n    expect(variables).toEqual({\n      input_0: inputValue,\n      preset_1: 'SMALL',\n    });\n  });\n\n  it('prints directives', () => {\n    const params = {cond: true};\n    const nestedFragment = Relay.QL`\n      fragment on User @include(if: $cond) {\n        name @skip(if: $cond)\n      }\n    `;\n    const query = getNode(Relay.QL`\n      query {\n        node(id: 123) @skip(if: true) {\n          ${nestedFragment}\n        }\n      }\n    `, params);\n    const {text, variables} = printRelayOSSQuery(query);\n    expect(text).toEqualPrintedQuery(`\n      query PrintRelayOSSQuery {\n        node(id: 123) @skip(if: true) {\n          id,\n          __typename,\n          ...F0\n        }\n      }\n      fragment F0 on User @include(if: true) {\n        id\n      }\n    `);\n    expect(variables).toEqual({});\n  });\n\n  it('throws for directives with complex values', () => {\n    const params = {data: {foo: 'bar'}};\n    const query = getNode(Relay.QL`\n      query {\n        node(id: 123) @include(if: $data) {\n          id\n        }\n      }\n    `, params);\n    expect(() => printRelayOSSQuery(query)).toFailInvariant(\n      'printRelayOSSQuery(): Relay only supports directives with scalar ' +\n      'values (boolean, number, or string), got `if: [object Object]`.'\n    );\n  });\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","Relay","RelayNodeInterface","RelayQuery","RelayTestUtils","generateRQLFieldAlias","printRelayOSSQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst printRelayOSSQuery = require('printRelayOSSQuery');\n\ndescribe('printRelayOSSQuery', () => {\n  const {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('roots', () => {\n    it('prints a query with no root arguments', () => {\n      const query = getNode(Relay.QL`\n        query {\n          me {\n            firstName,\n            lastName,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery {\n          me {\n            firstName,\n            lastName,\n            id\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a generated query with one root argument', () => {\n      const query = RelayQuery.Root.build(\n        'FooQuery',\n        'node',\n        '123',\n        [\n          RelayQuery.Field.build({\n            fieldName: 'id',\n            type: 'String',\n          }),\n        ],\n        {\n          identifyingArgName: RelayNodeInterface.ID,\n          identifyingArgType: RelayNodeInterface.ID_TYPE,\n          isAbstract: true,\n          isDeferred: false,\n          isPlural: false,\n        },\n        'Node'\n      );\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($id_0: ID!) {\n          node(id: $id_0) {\n            id\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        id_0: '123',\n      });\n    });\n\n    it('prints a query with one root argument', () => {\n      const query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            name,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery {\n          node(id:\"123\") {\n            name,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a query with one root numeric argument', () => {\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          node(id: 123) {\n            name,\n            id,\n          },\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery {\n          node(id:123) {\n            name,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a query with multiple root arguments', () => {\n      const query = getNode(Relay.QL`\n        query {\n          usernames(names:[\"a\",\"b\",\"c\"]) {\n            firstName,\n            lastName,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery {\n          usernames(names:[\"a\",\"b\",\"c\"]) {\n            firstName,\n            lastName,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a query with multiple numeric arguments', () => {\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          nodes(ids: [123, 456]) {\n            name,\n            id,\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery {\n          nodes(ids:[123,456]) {\n            name,\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints enum call values', () => {\n      const enumValue = 'WEB';\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          settings(environment: $env) {\n            notificationSounds,\n          },\n        }\n      `, {\n        env: enumValue,\n      });\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($environment_0: Environment!) {\n          settings(environment: $environment_0) {\n            notificationSounds\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        environment_0: enumValue,\n      });\n    });\n\n    it('prints object call values', () => {\n      const objectValue = {query: 'Menlo Park'};\n      const query = getNode(Relay.QL`\n        query {\n          checkinSearchQuery(query: $q) {\n            query,\n          }\n        }\n      `, {\n        q: objectValue,\n      });\n\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery($query_0: CheckinSearchInput!) {\n          checkinSearchQuery(query: $query_0) {\n            query\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        query_0: objectValue,\n      });\n    });\n\n    it('dedupes enum variables', () => {\n      const enumValue = 'WEB';\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          defaultSettings {\n            web: notifications(environment: WEB)\n            foo: notifications(environment: $env)\n          }\n        }\n      `, {\n        env: enumValue,\n      });\n      const alias = generateRQLFieldAlias('notifications.environment(WEB)');\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($environment_0: Environment!) {\n          defaultSettings {\n            ${alias}: notifications(environment: $environment_0),\n            ${alias}: notifications(environment: $environment_0)\n          }\n        }\n      `);\n      expect(variables).toEqual({\n        environment_0: enumValue,\n      });\n    });\n\n    it('dedupes object variables', () => {\n      const query1 = {query: 'foo'};\n      const query2 = {query: 'foo'};\n      const query = getNode(Relay.QL`\n        query FooQuery {\n          node(id: \"123\") {\n            ... on User {\n              foo: storySearch(query: $query1) {\n                id\n              }\n              bar: storySearch(query: $query2) {\n                id\n              }\n            }\n          }\n        }\n      `, {\n        query1,\n        query2,\n      });\n      const alias = generateRQLFieldAlias('storySearch.query({\"query\":\"foo\"})');\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query FooQuery($query_0: StorySearchInput!) {\n          node(id: \"123\") {\n            id,\n            __typename,\n            ...F0\n          }\n        }\n        fragment F0 on User {\n          ${alias}: storySearch(query: $query_0) {\n            id\n          },\n          ${alias}: storySearch(query: $query_0) {\n            id\n          },\n          id\n        }\n      `);\n      expect(variables).toEqual({\n        query_0: query1,\n      });\n    });\n\n    it('throws for ref queries', () => {\n      const query = RelayQuery.Root.build(\n        'RefQueryName',\n        RelayNodeInterface.NODE,\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id'),\n        [\n          RelayQuery.Field.build({fieldName: 'id', type: 'String'}),\n          RelayQuery.Field.build({fieldName: 'name', type: 'String'}),\n        ],\n        {\n          isDeferred: true,\n          identifyingArgName: RelayNodeInterface.ID,\n          type: RelayNodeInterface.NODE_TYPE,\n        }\n      );\n      expect(() => printRelayOSSQuery(query)).toFailInvariant(\n        'printRelayOSSQuery(): Deferred queries are not supported.'\n      );\n    });\n  });\n\n  describe('fragments', () => {\n    it('prints fragments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id,\n          },\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints inline fragments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id\n            ... on User {\n              name\n            }\n            ... on User {\n              profilePicture {\n                uri\n              }\n            }\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename,\n            ...F0,\n            ...F1\n          }\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n        fragment F1 on User {\n          profilePicture {\n            uri\n          },\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with incrementing names', () => {\n      const fragmentA = Relay.QL`fragment on User { firstName }`;\n      const fragmentB = Relay.QL`fragment on User { lastName }`;\n      const fragment = getNode(Relay.QL`\n        fragment on Node {\n          ${fragmentA},\n          ${fragmentB},\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Node {\n          id,\n          __typename,\n          ...F0,\n          ...F1\n        }\n        fragment F0 on User {\n          firstName,\n          id\n        }\n        fragment F1 on User {\n          lastName,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with identical children only once', () => {\n      const fragmentA = Relay.QL`fragment on User { name }`;\n      const fragmentB = Relay.QL`fragment on User { name }`;\n      const fragment = getNode(Relay.QL`\n        fragment on Node {\n          ${fragmentA},\n          ${fragmentB},\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Node {\n          id,\n          __typename,\n          ...F0\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with different variables separately', () => {\n      const concreteFragment = Relay.QL`\n        fragment on User {\n          profilePicture(size: [$width, $height]) {\n            uri\n          }\n        }\n      `;\n      const fragment = getNode(Relay.QL`fragment on User { id }`).clone([\n        getNode(concreteFragment, {width: 32, height: 32}),\n        getNode(concreteFragment, {width: 64, height: 64}),\n      ]);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on User {\n          ...F0,\n          ...F1\n        }\n        fragment F0 on User {\n          ${generateRQLFieldAlias('profilePicture.size(32,32)')}:\n              profilePicture(size: [32, 32]) {\n            uri\n          },\n          id\n        }\n        fragment F1 on User {\n          ${generateRQLFieldAlias('profilePicture.size(64,64)')}:\n              profilePicture(size: [64, 64]) {\n            uri\n          },\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with different runtime children separately', () => {\n      let child;\n      child = Relay.QL`fragment on User { name }`;\n      const fragmentA = Relay.QL`fragment on User { ${child} }`;\n      child = Relay.QL`fragment on User { profilePicture { uri } }`;\n      const fragmentB = Relay.QL`fragment on User { ${child} }`;\n\n      const fragment = getNode(Relay.QL`\n        fragment on Node {\n          ${fragmentA},\n          ${fragmentB},\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Node {\n          id,\n          __typename,\n          ...F1,\n          ...F3\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n        fragment F1 on User {\n          id,\n          ...F0\n        }\n        fragment F2 on User {\n          profilePicture {\n            uri\n          },\n          id\n        }\n        fragment F3 on User {\n          id,\n          ...F2\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints fragments with different IDs but identical output once', () => {\n      const concreteFragment = Relay.QL`fragment on User { name }`;\n      const fragment = getNode(Relay.QL`fragment on User { id }`).clone([\n        getNode(concreteFragment, {value: 123}),\n        getNode(concreteFragment, {value: 456}),\n      ]);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on User {\n          ...F0\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('omits empty fragments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id\n          }\n          ... on Viewer {\n            actor @include(if: $false) {\n              name\n            }\n          }\n        }\n      `, {false: false});\n      const {text} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename\n          }\n        }\n      `);\n    });\n  });\n\n  describe('fields', () => {\n    it('prints a field with one argument', () => {\n      const alias = generateRQLFieldAlias('newsFeed.first(10)');\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          newsFeed(first:$first) {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      `, {first: 10});\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          ${alias}:newsFeed(first:10) {\n            edges {\n              node {\n                id,\n                __typename\n              },\n              cursor\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a field with multiple arguments', () => {\n      const alias = generateRQLFieldAlias('profilePicture.size(32,64)');\n      const fragment = getNode(Relay.QL`\n        fragment on Actor {\n          profilePicture(size:[\"32\",\"64\"]) {\n            uri\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Actor {\n          ${alias}:profilePicture(size:[\"32\",\"64\"]) {\n            uri\n          },\n          id,\n          __typename\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints a field with multiple variable arguments', () => {\n      const alias = generateRQLFieldAlias('profilePicture.size(32,64)');\n      const fragment = getNode(Relay.QL`\n        fragment on Actor {\n          profilePicture(size:[$width,$height]) {\n            uri\n          }\n        }\n      `, {\n        height: 64,\n        width: 32,\n      });\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Actor {\n          ${alias}:profilePicture(size:[32,64]) {\n            uri\n          },\n          id,\n          __typename\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints scalar arguments', () => {\n      const fragment = getNode(Relay.QL`\n        fragment on Actor {\n          friends(\n            first: $first,\n            orderby: $orderby,\n            isViewerFriend: $isViewerFriend,\n          ) {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      `, {\n        first: 10,\n        orderby: ['name'],\n        isViewerFriend: false,\n      });\n      const alias = fragment.getChildren()[0].getSerializationKey();\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Actor {\n          ${alias}:friends(first:10,orderby:[\"name\"],isViewerFriend:false) {\n            edges {\n              node {\n                id\n              },\n              cursor\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          },\n          id,\n          __typename\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n\n    it('prints object call values', () => {\n      const enumValue = 'WEB';\n      const fragment = Relay.QL`\n        fragment on Settings {\n          notifications(environment: $env)\n        }\n      `;\n      const query = getNode(Relay.QL`\n        query {\n          defaultSettings {\n            ${fragment},\n          }\n        }\n      `, {\n        env: enumValue,\n      });\n      const alias = generateRQLFieldAlias('notifications.environment(WEB)');\n      const {text, variables} = printRelayOSSQuery(query);\n      expect(text).toEqualPrintedQuery(`\n        query PrintRelayOSSQuery($environment_0: Environment!) {\n          defaultSettings {\n            ...F0\n          }\n        }\n        fragment F0 on Settings {\n          ${alias}:notifications(environment: $environment_0)\n        }\n      `);\n      expect(variables).toEqual({\n        environment_0: enumValue,\n      });\n    });\n\n    it('prints inline fragments as references', () => {\n      // these fragments have different types and cannot be flattened\n      const nestedFragment = Relay.QL`fragment on User { name }`;\n      const fragment = getNode(Relay.QL`\n        fragment on Viewer {\n          actor {\n            id,\n            ${nestedFragment},\n            ${nestedFragment},\n          }\n        }\n      `);\n      const {text, variables} = printRelayOSSQuery(fragment);\n      expect(text).toEqualPrintedQuery(`\n        fragment PrintRelayOSSQueryRelayQL on Viewer {\n          actor {\n            id,\n            __typename,\n            ...F0\n          }\n        }\n        fragment F0 on User {\n          name,\n          id\n        }\n      `);\n      expect(variables).toEqual({});\n    });\n  });\n\n  it('prints a mutation', () => {\n    const inputValue = {\n      clientMutationId: '123',\n      foo: 'bar',\n    };\n    const mutation = getNode(Relay.QL`\n      mutation {\n        feedbackLike(input: $input) {\n          clientMutationId,\n          feedback {\n            id,\n            actor {\n              profilePicture(preset: SMALL) {\n                uri,\n              },\n            },\n            likeSentence,\n            likers,\n          },\n        },\n      }\n    `, {input: inputValue});\n\n    const alias = generateRQLFieldAlias('profilePicture.preset(SMALL)');\n    const {text, variables} = printRelayOSSQuery(mutation);\n    expect(text).toEqualPrintedQuery(`\n      mutation PrintRelayOSSQuery(\n        $input_0: FeedbackLikeInput!,\n        $preset_1: PhotoSize!\n      ) {\n        feedbackLike(input: $input_0) {\n          clientMutationId,\n          feedback {\n            id,\n            actor {\n              ${alias}: profilePicture(preset: $preset_1) {\n                uri\n              },\n              id,\n              __typename\n            },\n            likeSentence,\n            likers\n          }\n        }\n      }\n    `);\n    expect(variables).toEqual({\n      input_0: inputValue,\n      preset_1: 'SMALL',\n    });\n  });\n\n  it('prints directives', () => {\n    const params = {cond: true};\n    const nestedFragment = Relay.QL`\n      fragment on User @include(if: $cond) {\n        name @skip(if: $cond)\n      }\n    `;\n    const query = getNode(Relay.QL`\n      query {\n        node(id: 123) @skip(if: true) {\n          ${nestedFragment}\n        }\n      }\n    `, params);\n    const {text, variables} = printRelayOSSQuery(query);\n    expect(text).toEqualPrintedQuery(`\n      query PrintRelayOSSQuery {\n        node(id: 123) @skip(if: true) {\n          id,\n          __typename,\n          ...F0\n        }\n      }\n      fragment F0 on User @include(if: true) {\n        id\n      }\n    `);\n    expect(variables).toEqual({});\n  });\n\n  it('throws for directives with complex values', () => {\n    const params = {data: {foo: 'bar'}};\n    const query = getNode(Relay.QL`\n      query {\n        node(id: 123) @include(if: $data) {\n          id\n        }\n      }\n    `, params);\n    expect(() => printRelayOSSQuery(query)).toFailInvariant(\n      'printRelayOSSQuery(): Relay only supports directives with scalar ' +\n      'values (boolean, number, or string), got `if: [object Object]`.'\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/printRelayOSSQuery-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/intersectRelayQuery-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst intersectRelayQuery = require('intersectRelayQuery');\n\ndescribe('intersectRelayQuery', () => {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('fields', () => {\n    it('returns null for mutually exclusive nodes', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Date {\n          day,\n          month,\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Date {\n          year,\n        }\n      `);\n      expect(intersectRelayQuery(subjectNode, patternNode)).toBe(null);\n    });\n\n    it('intersects shallow fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          firstName,\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          lastName,\n          name,\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('intersects nested fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          birthdate {\n            day,\n            month,\n            year,\n          },\n          hometown {\n            name,\n            url,\n          },\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name,\n          },\n          screennames {\n            service,\n          },\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name\n          },\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('includes fields with different arguments', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          url(site:\"www\")\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          url\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          url(site:\"www\")\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('intersects aliased fields by storage key', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          firstName,\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          name: firstName,\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          firstName,\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('includes all fields of fields without sub-fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name,\n            url,\n          },\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          hometown,\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name,\n            url,\n          },\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n  });\n\n  describe('ranges', () => {\n    it('includes range fields for connections without sub-fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('includes non-range connection fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                friends,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor @relay(pattern: true) {\n          friends {\n            count\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count\n          }\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('excludes filtered unterminated ranges', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count\n          }\n        }\n      `);\n      var filterUnterminatedRange = function(node) {\n        return node.getSchemaName() === 'friends';\n      };\n      expect(\n        intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('excludes filtered unterminated ranges with different arguments', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(orderby:\"name\",first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(orderby:\"name\",first: \"10\") {\n            count\n          }\n        }\n      `);\n      var filterUnterminatedRange = function(node) {\n        return node.getSchemaName() === 'friends';\n      };\n      expect(\n        intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('does not exclude ranges from connections with sub-fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor @relay(pattern: true) {\n          friends {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var filterUnterminatedRange = jest.genMockFunction();\n      expect(\n        intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange)\n      ).toEqualQueryNode(expected);\n      expect(filterUnterminatedRange).not.toBeCalled();\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","intersectRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst intersectRelayQuery = require('intersectRelayQuery');\n\ndescribe('intersectRelayQuery', () => {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('fields', () => {\n    it('returns null for mutually exclusive nodes', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Date {\n          day,\n          month,\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Date {\n          year,\n        }\n      `);\n      expect(intersectRelayQuery(subjectNode, patternNode)).toBe(null);\n    });\n\n    it('intersects shallow fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          firstName,\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          lastName,\n          name,\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('intersects nested fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          birthdate {\n            day,\n            month,\n            year,\n          },\n          hometown {\n            name,\n            url,\n          },\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name,\n          },\n          screennames {\n            service,\n          },\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name\n          },\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('includes fields with different arguments', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          url(site:\"www\")\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          url\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          url(site:\"www\")\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('intersects aliased fields by storage key', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          firstName,\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          name: firstName,\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          name,\n          firstName,\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('includes all fields of fields without sub-fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name,\n            url,\n          },\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          hometown,\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          hometown {\n            name,\n            url,\n          },\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n  });\n\n  describe('ranges', () => {\n    it('includes range fields for connections without sub-fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('includes non-range connection fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                friends,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor @relay(pattern: true) {\n          friends {\n            count\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count\n          }\n        }\n      `);\n      expect(\n        intersectRelayQuery(subjectNode, patternNode)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('excludes filtered unterminated ranges', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count\n          }\n        }\n      `);\n      var filterUnterminatedRange = function(node) {\n        return node.getSchemaName() === 'friends';\n      };\n      expect(\n        intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('excludes filtered unterminated ranges with different arguments', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(orderby:\"name\",first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(orderby:\"name\",first: \"10\") {\n            count\n          }\n        }\n      `);\n      var filterUnterminatedRange = function(node) {\n        return node.getSchemaName() === 'friends';\n      };\n      expect(\n        intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange)\n      ).toEqualQueryNode(expected);\n    });\n\n    it('does not exclude ranges from connections with sub-fields', () => {\n      var subjectNode = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var patternNode = getNode(Relay.QL`\n        fragment on Actor @relay(pattern: true) {\n          friends {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var expected = getNode(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            count,\n            edges {\n              node {\n                id,\n                name,\n              }\n            }\n          }\n        }\n      `);\n      var filterUnterminatedRange = jest.genMockFunction();\n      expect(\n        intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange)\n      ).toEqualQueryNode(expected);\n      expect(filterUnterminatedRange).not.toBeCalled();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/intersectRelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/inferRelayFieldsFromData-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst inferRelayFieldsFromData = require('inferRelayFieldsFromData');\n\ndescribe('inferRelayFieldsFromData', () => {\n  const {getVerbatimNode, matchers} = RelayTestUtils;\n  let HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n    } = RelayConnectionInterface);\n\n    jasmine.addMatchers({\n      ...RelayTestUtils.matchers,\n      toEqualFields() {\n        return {\n          compare(actual, expected) {\n            expected = flattenRelayQuery(getVerbatimNode(expected));\n            actual = flattenRelayQuery(expected.clone(actual));\n            // NOTE: Generated fields might get in the way.\n            return matchers.toEqualQueryNode().compare(actual, expected);\n          },\n        };\n      },\n    });\n  });\n\n  it('generates metadata for fields', () => {\n    const query = inferRelayFieldsFromData({\n      id: '123',\n    });\n    expect(query).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n      }\n    `);\n    expect(query[0].isPlural()).toBe(false);\n  });\n\n  it('infers scalar fields from scalars', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      name: 'Alice',\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        name,\n      }\n    `);\n  });\n\n  it('infers nested fields from objects', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      address: {\n        city: 'Menlo Park',\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        address {\n          city,\n        },\n      }\n    `);\n  });\n\n  it('infers unterminated fields from null', () => {\n    const inferredFields = inferRelayFieldsFromData({\n      id: '123',\n      address: null,\n    });\n\n    expect(inferredFields[0] instanceof RelayQuery.Field).toBe(true);\n    expect(inferredFields[0].canHaveSubselections()).toBe(false);\n    expect(inferredFields[0].getSchemaName()).toBe('id');\n\n    expect(inferredFields[1] instanceof RelayQuery.Field).toBe(true);\n    // Though this field can have subselections, there is no way we can infer\n    // this from `address: null`. Defaults to false.\n    expect(inferredFields[1].canHaveSubselections()).toBe(false);\n    expect(inferredFields[1].getSchemaName()).toBe('address');\n  });\n\n  it('infers plural fields from arrays of scalars', () => {\n    const fields = inferRelayFieldsFromData({\n      id: '123',\n      websites: [\n        'facebook.com',\n        'google.com',\n      ],\n    });\n    expect(fields).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        websites,\n      }\n    `);\n    expect(fields[1].isPlural()).toBe(true);\n  });\n\n  it('infers plural nested fields from arrays of objects', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      screennames: [\n        {service: 'GTALK'},\n        {service: 'TWITTER'},\n      ],\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        screennames {\n          service,\n        },\n      }\n    `);\n  });\n\n  it('infers unterminated fields from empty arrays', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      websites: [],\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        websites,\n      }\n    `);\n  });\n\n  it('infers unterminated fields from null elements in arrays', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      websites: [null],\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        websites,\n      }\n    `);\n  });\n\n  it('infers String field arguments from keys', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      'url(site: \"www\")': 'https://...',\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        url(site: \"www\"),\n      }\n    `);\n  });\n\n  it('infers Boolean field arguments from keys', () => {\n    expect(inferRelayFieldsFromData({\n      'url(relative: true)': '//...',\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        url(relative: true),\n      }\n    `);\n  });\n\n  it('infers Int field arguments from keys', () => {\n    expect(inferRelayFieldsFromData({\n      'comments(last: 10)': {\n        count: 20,\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on Comment {\n        comments(last: 10) {\n          count,\n        }\n      }\n    `);\n  });\n\n  it('throws for keys with invalid call encodings', () => {\n    expect(() => {\n      inferRelayFieldsFromData({\n        'url.site': 'https://...',\n      });\n    }).toFailInvariant(\n      'inferRelayFieldsFromData(): Malformed data key, `url.site`.'\n    );\n\n    expect(() => {\n      inferRelayFieldsFromData({\n        'url(site)': 'https://...',\n      });\n    }).toFailInvariant(\n      'inferRelayFieldsFromData(): Malformed or unsupported data key, ' +\n      '`url(site)`. Only booleans, strings, and numbers are currenly ' +\n      'supported, and commas are required. Parse failure reason was ' +\n      '`Unexpected token s`.'\n    );\n  });\n\n  it('infers `id` and `cursor` fields for `node` data', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      'friends(first: \"2\")': {\n        edges: [\n          {node: {name: 'Alice'}},\n          {node: {name: 'Bob'}},\n        ],\n        [PAGE_INFO]: {\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n        },\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        friends(first: \"2\") {\n          edges {\n            node {\n              id,\n              name,\n            },\n            cursor,\n          },\n          pageInfo {\n            hasNextPage,\n            hasPreviousPage,\n          },\n        },\n      }\n    `);\n  });\n\n  it('infers field for mutation field named `node`', () => {\n    expect(inferRelayFieldsFromData({\n      node: {\n        id: '123',\n        name: 'name',\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on NodeSavedStateResponsePayload {\n        node {\n          id,\n          name\n        }\n      }\n    `);\n  });\n\n  it('ignores metadata fields', () => {\n    expect(inferRelayFieldsFromData({\n      __dataID__: '123',\n      __range__: null,\n      __status__: 0,\n      id: '123',\n      name: 'Alice',\n    })).toEqualFields(Relay.QL`\n      fragment on Node {\n        id,\n        name,\n      }\n    `);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayQuery","RelayTestUtils","flattenRelayQuery","inferRelayFieldsFromData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst inferRelayFieldsFromData = require('inferRelayFieldsFromData');\n\ndescribe('inferRelayFieldsFromData', () => {\n  const {getVerbatimNode, matchers} = RelayTestUtils;\n  let HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n    } = RelayConnectionInterface);\n\n    jasmine.addMatchers({\n      ...RelayTestUtils.matchers,\n      toEqualFields() {\n        return {\n          compare(actual, expected) {\n            expected = flattenRelayQuery(getVerbatimNode(expected));\n            actual = flattenRelayQuery(expected.clone(actual));\n            // NOTE: Generated fields might get in the way.\n            return matchers.toEqualQueryNode().compare(actual, expected);\n          },\n        };\n      },\n    });\n  });\n\n  it('generates metadata for fields', () => {\n    const query = inferRelayFieldsFromData({\n      id: '123',\n    });\n    expect(query).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n      }\n    `);\n    expect(query[0].isPlural()).toBe(false);\n  });\n\n  it('infers scalar fields from scalars', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      name: 'Alice',\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        name,\n      }\n    `);\n  });\n\n  it('infers nested fields from objects', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      address: {\n        city: 'Menlo Park',\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        address {\n          city,\n        },\n      }\n    `);\n  });\n\n  it('infers unterminated fields from null', () => {\n    const inferredFields = inferRelayFieldsFromData({\n      id: '123',\n      address: null,\n    });\n\n    expect(inferredFields[0] instanceof RelayQuery.Field).toBe(true);\n    expect(inferredFields[0].canHaveSubselections()).toBe(false);\n    expect(inferredFields[0].getSchemaName()).toBe('id');\n\n    expect(inferredFields[1] instanceof RelayQuery.Field).toBe(true);\n    // Though this field can have subselections, there is no way we can infer\n    // this from `address: null`. Defaults to false.\n    expect(inferredFields[1].canHaveSubselections()).toBe(false);\n    expect(inferredFields[1].getSchemaName()).toBe('address');\n  });\n\n  it('infers plural fields from arrays of scalars', () => {\n    const fields = inferRelayFieldsFromData({\n      id: '123',\n      websites: [\n        'facebook.com',\n        'google.com',\n      ],\n    });\n    expect(fields).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        websites,\n      }\n    `);\n    expect(fields[1].isPlural()).toBe(true);\n  });\n\n  it('infers plural nested fields from arrays of objects', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      screennames: [\n        {service: 'GTALK'},\n        {service: 'TWITTER'},\n      ],\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        screennames {\n          service,\n        },\n      }\n    `);\n  });\n\n  it('infers unterminated fields from empty arrays', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      websites: [],\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        websites,\n      }\n    `);\n  });\n\n  it('infers unterminated fields from null elements in arrays', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      websites: [null],\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        websites,\n      }\n    `);\n  });\n\n  it('infers String field arguments from keys', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      'url(site: \"www\")': 'https://...',\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        url(site: \"www\"),\n      }\n    `);\n  });\n\n  it('infers Boolean field arguments from keys', () => {\n    expect(inferRelayFieldsFromData({\n      'url(relative: true)': '//...',\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        url(relative: true),\n      }\n    `);\n  });\n\n  it('infers Int field arguments from keys', () => {\n    expect(inferRelayFieldsFromData({\n      'comments(last: 10)': {\n        count: 20,\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on Comment {\n        comments(last: 10) {\n          count,\n        }\n      }\n    `);\n  });\n\n  it('throws for keys with invalid call encodings', () => {\n    expect(() => {\n      inferRelayFieldsFromData({\n        'url.site': 'https://...',\n      });\n    }).toFailInvariant(\n      'inferRelayFieldsFromData(): Malformed data key, `url.site`.'\n    );\n\n    expect(() => {\n      inferRelayFieldsFromData({\n        'url(site)': 'https://...',\n      });\n    }).toFailInvariant(\n      'inferRelayFieldsFromData(): Malformed or unsupported data key, ' +\n      '`url(site)`. Only booleans, strings, and numbers are currenly ' +\n      'supported, and commas are required. Parse failure reason was ' +\n      '`Unexpected token s`.'\n    );\n  });\n\n  it('infers `id` and `cursor` fields for `node` data', () => {\n    expect(inferRelayFieldsFromData({\n      id: '123',\n      'friends(first: \"2\")': {\n        edges: [\n          {node: {name: 'Alice'}},\n          {node: {name: 'Bob'}},\n        ],\n        [PAGE_INFO]: {\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n        },\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on Actor {\n        id,\n        friends(first: \"2\") {\n          edges {\n            node {\n              id,\n              name,\n            },\n            cursor,\n          },\n          pageInfo {\n            hasNextPage,\n            hasPreviousPage,\n          },\n        },\n      }\n    `);\n  });\n\n  it('infers field for mutation field named `node`', () => {\n    expect(inferRelayFieldsFromData({\n      node: {\n        id: '123',\n        name: 'name',\n      },\n    })).toEqualFields(Relay.QL`\n      fragment on NodeSavedStateResponsePayload {\n        node {\n          id,\n          name\n        }\n      }\n    `);\n  });\n\n  it('ignores metadata fields', () => {\n    expect(inferRelayFieldsFromData({\n      __dataID__: '123',\n      __range__: null,\n      __status__: 0,\n      id: '123',\n      name: 'Alice',\n    })).toEqualFields(Relay.QL`\n      fragment on Node {\n        id,\n        name,\n      }\n    `);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/inferRelayFieldsFromData-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/flattenSplitRelayQueries-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenSplitRelayQueries = require('flattenSplitRelayQueries');\n\ndescribe('flattenSplitRelayQueries', () => {\n  function getQuery() {\n    return RelayTestUtils.getNode(Relay.QL`query{node(id:\"4\"){id}}`);\n  }\n\n  it('returns an empty array when there are no queries', () => {\n    var split = {\n      required: null,\n      deferred: [],\n    };\n    expect(flattenSplitRelayQueries(split)).toEqual([]);\n  });\n\n  it('returns a single required query', () => {\n    var split = {\n      required: getQuery(),\n      deferred: [],\n    };\n    expect(flattenSplitRelayQueries(split)).toEqual([split.required]);\n  });\n\n  it('returns a single deferred query', () => {\n    var split = {\n      required: null,\n      deferred: [{\n        required: getQuery(),\n        deferred: [],\n      }],\n    };\n    expect(flattenSplitRelayQueries(split))\n      .toEqual([split.deferred[0].required]);\n  });\n\n  it('returns required then deferred queries', () => {\n    var split = {\n      required: getQuery(),\n      deferred: [\n        {\n          required: getQuery(),\n          deferred: [],\n        },\n        {\n          required: getQuery(),\n          deferred: [],\n        },\n      ],\n    };\n    expect(flattenSplitRelayQueries(split))\n      .toEqual([\n        split.required,\n        split.deferred[0].required,\n        split.deferred[1].required,\n      ]);\n  });\n\n  it('handles nested deferreds', () => {\n    var split = {\n      required: getQuery(),\n      deferred: [\n        {\n          required: getQuery(),\n          deferred: [{\n            required: getQuery(),\n            deferred: [],\n          }],\n        },\n      ],\n    };\n    expect(flattenSplitRelayQueries(split))\n      .toEqual([\n        split.required,\n        split.deferred[0].required,\n        split.deferred[0].deferred[0].required,\n      ]);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","flattenSplitRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenSplitRelayQueries = require('flattenSplitRelayQueries');\n\ndescribe('flattenSplitRelayQueries', () => {\n  function getQuery() {\n    return RelayTestUtils.getNode(Relay.QL`query{node(id:\"4\"){id}}`);\n  }\n\n  it('returns an empty array when there are no queries', () => {\n    var split = {\n      required: null,\n      deferred: [],\n    };\n    expect(flattenSplitRelayQueries(split)).toEqual([]);\n  });\n\n  it('returns a single required query', () => {\n    var split = {\n      required: getQuery(),\n      deferred: [],\n    };\n    expect(flattenSplitRelayQueries(split)).toEqual([split.required]);\n  });\n\n  it('returns a single deferred query', () => {\n    var split = {\n      required: null,\n      deferred: [{\n        required: getQuery(),\n        deferred: [],\n      }],\n    };\n    expect(flattenSplitRelayQueries(split))\n      .toEqual([split.deferred[0].required]);\n  });\n\n  it('returns required then deferred queries', () => {\n    var split = {\n      required: getQuery(),\n      deferred: [\n        {\n          required: getQuery(),\n          deferred: [],\n        },\n        {\n          required: getQuery(),\n          deferred: [],\n        },\n      ],\n    };\n    expect(flattenSplitRelayQueries(split))\n      .toEqual([\n        split.required,\n        split.deferred[0].required,\n        split.deferred[1].required,\n      ]);\n  });\n\n  it('handles nested deferreds', () => {\n    var split = {\n      required: getQuery(),\n      deferred: [\n        {\n          required: getQuery(),\n          deferred: [{\n            required: getQuery(),\n            deferred: [],\n          }],\n        },\n      ],\n    };\n    expect(flattenSplitRelayQueries(split))\n      .toEqual([\n        split.required,\n        split.deferred[0].required,\n        split.deferred[0].deferred[0].required,\n      ]);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/flattenSplitRelayQueries-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/flattenRelayQuery-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\n\ndescribe('flattenRelayQuery', () => {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('flattens roots', () => {\n    var node = getNode(Relay.QL`\n      query {\n        viewer {\n          ... on Viewer {\n            actor {\n              name\n            }\n          }\n          actor {\n            firstName,\n            ... on Actor {\n              lastName\n            }\n          }\n        }\n      }\n    `);\n    var expected = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name,\n            lastName\n          }\n        }\n      }\n    `);\n    expect(flattenRelayQuery(node)).toEqualQueryRoot(expected);\n  });\n\n  it('flattens fragments', () => {\n    var node = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          firstName,\n          ... on Actor {\n            lastName\n            ... on Actor {\n              name\n              ... on User {\n                username\n              }\n            }\n          }\n        }\n      }\n    `);\n    var expected = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          firstName,\n          lastName,\n          name,\n          ... on User {\n            username\n          }\n        }\n      }\n    `);\n    expect(flattenRelayQuery(node)).toEqualQueryNode(expected);\n  });\n\n  it('flattens fields', () => {\n    var node = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name,\n            ... on Actor {\n              name,\n              lastName\n            }\n          }\n        }\n      }\n    `).getFieldByStorageKey('actor');\n    var expected = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name,\n            lastName\n          }\n        }\n      }\n    `).getFieldByStorageKey('actor');\n    expect(flattenRelayQuery(node)).toEqualQueryNode(expected);\n  });\n\n  it('flattens empty fragments', () => {\n    var emptyFragment = Relay.QL`\n      fragment on TimezoneInfo {\n        ${null}\n      }\n    `;\n\n    var fragmentNode = getNode(emptyFragment);\n    var rootNode = getNode(Relay.QL`\n      query {\n        viewer {\n          timezoneEstimate {\n            ${emptyFragment}\n          }\n        }\n      }\n    `);\n    var fieldNode = rootNode.getFieldByStorageKey('timezoneEstimate');\n\n    expect(flattenRelayQuery(fragmentNode)).toBe(null);\n    expect(flattenRelayQuery(rootNode)).toBe(null);\n    expect(flattenRelayQuery(fieldNode)).toBe(null);\n  });\n\n  it('optionally removes fragments', () => {\n    var node = getNode(Relay.QL`\n      query {\n        viewer {\n          ... on Viewer {\n            actor {\n              ... on User {\n                firstName\n              }\n              ... on Page {\n                name\n              }\n            }\n          }\n        }\n      }\n    `);\n    var expected = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name\n          }\n        }\n      }\n    `);\n    expect(flattenRelayQuery(node, {\n      shouldRemoveFragments: true,\n    })).toEqualQueryNode(expected);\n  });\n\n  it('optionally preserves empty non-leaf nodes', () => {\n    var node = getNode(Relay.QL`\n      fragment on Comment {\n        likers # can have sub-selections, normally is removed\n        doesViewerLike\n      }\n    `);\n    const flattened = flattenRelayQuery(node, {\n      preserveEmptyNodes: true,\n    });\n    expect(flattened.getChildren().length).toBe(3);\n    expect(flattened.getChildren()[0].getSchemaName()).toBe('likers');\n    expect(flattened.getChildren()[1].getSchemaName()).toBe('doesViewerLike');\n    expect(flattened.getChildren()[2].getSchemaName()).toBe('id');\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","flattenRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\n\ndescribe('flattenRelayQuery', () => {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('flattens roots', () => {\n    var node = getNode(Relay.QL`\n      query {\n        viewer {\n          ... on Viewer {\n            actor {\n              name\n            }\n          }\n          actor {\n            firstName,\n            ... on Actor {\n              lastName\n            }\n          }\n        }\n      }\n    `);\n    var expected = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name,\n            lastName\n          }\n        }\n      }\n    `);\n    expect(flattenRelayQuery(node)).toEqualQueryRoot(expected);\n  });\n\n  it('flattens fragments', () => {\n    var node = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          firstName,\n          ... on Actor {\n            lastName\n            ... on Actor {\n              name\n              ... on User {\n                username\n              }\n            }\n          }\n        }\n      }\n    `);\n    var expected = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          firstName,\n          lastName,\n          name,\n          ... on User {\n            username\n          }\n        }\n      }\n    `);\n    expect(flattenRelayQuery(node)).toEqualQueryNode(expected);\n  });\n\n  it('flattens fields', () => {\n    var node = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name,\n            ... on Actor {\n              name,\n              lastName\n            }\n          }\n        }\n      }\n    `).getFieldByStorageKey('actor');\n    var expected = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name,\n            lastName\n          }\n        }\n      }\n    `).getFieldByStorageKey('actor');\n    expect(flattenRelayQuery(node)).toEqualQueryNode(expected);\n  });\n\n  it('flattens empty fragments', () => {\n    var emptyFragment = Relay.QL`\n      fragment on TimezoneInfo {\n        ${null}\n      }\n    `;\n\n    var fragmentNode = getNode(emptyFragment);\n    var rootNode = getNode(Relay.QL`\n      query {\n        viewer {\n          timezoneEstimate {\n            ${emptyFragment}\n          }\n        }\n      }\n    `);\n    var fieldNode = rootNode.getFieldByStorageKey('timezoneEstimate');\n\n    expect(flattenRelayQuery(fragmentNode)).toBe(null);\n    expect(flattenRelayQuery(rootNode)).toBe(null);\n    expect(flattenRelayQuery(fieldNode)).toBe(null);\n  });\n\n  it('optionally removes fragments', () => {\n    var node = getNode(Relay.QL`\n      query {\n        viewer {\n          ... on Viewer {\n            actor {\n              ... on User {\n                firstName\n              }\n              ... on Page {\n                name\n              }\n            }\n          }\n        }\n      }\n    `);\n    var expected = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            firstName,\n            name\n          }\n        }\n      }\n    `);\n    expect(flattenRelayQuery(node, {\n      shouldRemoveFragments: true,\n    })).toEqualQueryNode(expected);\n  });\n\n  it('optionally preserves empty non-leaf nodes', () => {\n    var node = getNode(Relay.QL`\n      fragment on Comment {\n        likers # can have sub-selections, normally is removed\n        doesViewerLike\n      }\n    `);\n    const flattened = flattenRelayQuery(node, {\n      preserveEmptyNodes: true,\n    });\n    expect(flattened.getChildren().length).toBe(3);\n    expect(flattened.getChildren()[0].getSchemaName()).toBe('likers');\n    expect(flattened.getChildren()[1].getSchemaName()).toBe('doesViewerLike');\n    expect(flattened.getChildren()[2].getSchemaName()).toBe('id');\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/flattenRelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/findRelayQueryLeaves-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst findRelayQueryLeaves = require('findRelayQueryLeaves');\nconst mapObject = require('mapObject');\n\ndescribe('findRelayQueryLeaves', () => {\n  var {getNode} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  var dummyPath;\n\n  function findLeaves(\n    queryNode,\n    dataID,\n    path,\n    records,\n    cachedRecords,\n    calls,\n  ) {\n    var store = new RelayRecordStore({\n      records: records || {},\n      cachedRecords: cachedRecords || {},\n    });\n    return findRelayQueryLeaves(\n      store,\n      cachedRecords,\n      queryNode,\n      dataID,\n      path,\n      calls\n    );\n  }\n\n  function encode(node) {\n    // Eliminates unnessary unique query ids in RelayQueryPath\n    function filter(obj) {\n      return mapObject(obj, (value, key) => {\n        if (typeof value === 'object' && value !== null) {\n          return filter(value);\n        } else if (key === '__id__') {\n          // ignore query ids\n          return null;\n        } else {\n          return value;\n        }\n      });\n    }\n    return filter(JSON.parse(JSON.stringify(node)));\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n\n    dummyPath = new RelayQueryPath(getNode(Relay.QL`\n      query {\n        node(id:\"dummy\") {\n          id\n        }\n      }\n    `));\n\n    jasmine.addMatchers({\n      toMatchPendingNodes() {\n        return {\n          compare(actual, pendingNodes) {\n            expect(encode(actual)).toEqual(encode(pendingNodes));\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('returns pendingNodes when node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n    );\n\n    var pendingItems =[{\n      node: queryNode,\n      path: dummyPath,\n      rangeCalls: undefined,\n    }];\n\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': pendingItems}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      {'1055790163': undefined}\n    );\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when node is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {'1055790163': null},\n      {}\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when node is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      {'1055790163': null}\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when field is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': [{\n        node: queryNode.getFieldByStorageKey('firstName'),\n        path: dummyPath,\n        rangeCalls: undefined,\n      }]}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when field is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when field is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        firstName: 'Yuzhi',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when field is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        firstName: 'Yuzhi',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when linked node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n    var friendsField =  queryNode.getFieldByStorageKey('friends');\n    var countField = friendsField.getFieldByStorageKey('count');\n    expect(result.pendingNodes).toMatchPendingNodes({'friends_id': [{\n      node: countField,\n      path: dummyPath.getPath(friendsField, 'friends_id'),\n      rangeCalls: [],\n    }]});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when linked node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n      'friends_id': undefined,\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when linked node is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        count: 500,\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when linked node is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        count: 500,\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when plural node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    var screennamesField = queryNode.getFieldByStorageKey('screennames');\n    var serviceField = screennamesField.getFieldByStorageKey('service');\n    var pendingItems = [{\n      node: serviceField,\n      path: dummyPath.getPath(screennamesField, 'client:screenname'),\n      rangeCalls: undefined,\n    }];\n    expect(result.pendingNodes).toMatchPendingNodes({\n      'client:screenname1': pendingItems,\n      'client:screenname2': pendingItems,\n    });\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when plural node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n      'client:screenname1': undefined,\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when plural node is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n        service: true,\n      },\n      'client:screenname2': {\n        __dataID__: 'client:screenname2',\n        service: true,\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when plural node is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n        service: true,\n      },\n      'client:screenname2': {\n        __dataID__: 'client:screenname2',\n        service: true,\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n\n  it('returns pendingNodes when range node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    var rangeField = queryNode.getFieldByStorageKey('friends');\n    var calls = rangeField.getCallsWithValues();\n\n\n    var pendingItems = rangeField.getChildren().map(node => {\n      return {\n        node,\n        path: dummyPath.getPath(rangeField, 'friends_id'),\n        rangeCalls: calls,\n      };\n    });\n\n    expect(result.pendingNodes)\n      .toMatchPendingNodes({'friends_id': pendingItems});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when range node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      'friends_id': undefined,\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns pendingNodes when range field is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    var friendField = queryNode.getFieldByStorageKey('friends');\n    var calls = friendField.getCallsWithValues();\n    var pendingItems = friendField.getChildren().map(node => {\n      return {\n        node,\n        path: dummyPath.getPath(friendField, 'friends_id'),\n        rangeCalls: calls,\n      };\n    });\n    expect(result.pendingNodes).toMatchPendingNodes({\n      'friends_id': pendingItems,\n    });\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when range field is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns missingData when range has diffQuery in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [RelayTestUtils.createCall('first', 10)],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns missingData when range has diffQuery in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [RelayTestUtils.createCall('first', 10)],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns pendingNodes when edge node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      records,\n      {},\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n\n    var edgeFields = queryNode\n      .getFieldByStorageKey('edges')\n      .getChildren();\n    var pendingItems = edgeFields.map(node => {\n      return {\n        node,\n        path: dummyPath.getPath(edgeFields, 'edge_id'),\n        rangeCalls: undefined,\n      };\n    });\n    expect(result.pendingNodes).toMatchPendingNodes({'edge_id': pendingItems});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when edge node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: undefined,\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      {},\n      records,\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when the range and edges are is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__: 'node_id'},\n        cursor: 'cursor',\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        id: 'node_id,',\n      },\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      records,\n      {},\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when the range and edges are is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__: 'node_id'},\n        cursor: 'cursor',\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        id: 'node_id,',\n      },\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      {},\n      records,\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when root node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      query {\n        node(id:\"1055790163\") {\n          id\n        }\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n    );\n\n    var pendingItems = queryNode.getChildren().map(node => {\n      return {\n        node,\n        path: dummyPath,\n        rangeCalls: undefined,\n      };\n    });\n\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': pendingItems}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when root node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      query {\n        node(id:\"1055790163\") {\n          id\n        }\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      {'1055790163': undefined}\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns pendingNodes when matched fragment is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on User {\n          firstName\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n    var userFragment = queryNode.getChildren().filter(\n      item => item instanceof RelayQuery.Fragment\n    )[0];\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': [{\n        node: userFragment.getFieldByStorageKey('firstName'),\n        path: dummyPath,\n        rangeCalls: undefined,\n      }]}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when matched fragment is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on User {\n          firstName\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data in store when ignoring unmatched fragment', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on Page {\n          name\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data in cache when ignoring unmatched fragment', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on Page {\n          name\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLRange","Relay","RelayConnectionInterface","RelayQuery","RelayQueryPath","RelayRecordStore","RelayTestUtils","findRelayQueryLeaves","mapObject"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst findRelayQueryLeaves = require('findRelayQueryLeaves');\nconst mapObject = require('mapObject');\n\ndescribe('findRelayQueryLeaves', () => {\n  var {getNode} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  var dummyPath;\n\n  function findLeaves(\n    queryNode,\n    dataID,\n    path,\n    records,\n    cachedRecords,\n    calls,\n  ) {\n    var store = new RelayRecordStore({\n      records: records || {},\n      cachedRecords: cachedRecords || {},\n    });\n    return findRelayQueryLeaves(\n      store,\n      cachedRecords,\n      queryNode,\n      dataID,\n      path,\n      calls\n    );\n  }\n\n  function encode(node) {\n    // Eliminates unnessary unique query ids in RelayQueryPath\n    function filter(obj) {\n      return mapObject(obj, (value, key) => {\n        if (typeof value === 'object' && value !== null) {\n          return filter(value);\n        } else if (key === '__id__') {\n          // ignore query ids\n          return null;\n        } else {\n          return value;\n        }\n      });\n    }\n    return filter(JSON.parse(JSON.stringify(node)));\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n\n    dummyPath = new RelayQueryPath(getNode(Relay.QL`\n      query {\n        node(id:\"dummy\") {\n          id\n        }\n      }\n    `));\n\n    jasmine.addMatchers({\n      toMatchPendingNodes() {\n        return {\n          compare(actual, pendingNodes) {\n            expect(encode(actual)).toEqual(encode(pendingNodes));\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('returns pendingNodes when node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n    );\n\n    var pendingItems =[{\n      node: queryNode,\n      path: dummyPath,\n      rangeCalls: undefined,\n    }];\n\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': pendingItems}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      {'1055790163': undefined}\n    );\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when node is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {'1055790163': null},\n      {}\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when node is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      {'1055790163': null}\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when field is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': [{\n        node: queryNode.getFieldByStorageKey('firstName'),\n        path: dummyPath,\n        rangeCalls: undefined,\n      }]}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when field is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when field is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        firstName: 'Yuzhi',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when field is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        firstName\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        firstName: 'Yuzhi',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when linked node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n    var friendsField =  queryNode.getFieldByStorageKey('friends');\n    var countField = friendsField.getFieldByStorageKey('count');\n    expect(result.pendingNodes).toMatchPendingNodes({'friends_id': [{\n      node: countField,\n      path: dummyPath.getPath(friendsField, 'friends_id'),\n      rangeCalls: [],\n    }]});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when linked node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n      'friends_id': undefined,\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when linked node is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        count: 500,\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when linked node is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends {count}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        count: 500,\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when plural node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    var screennamesField = queryNode.getFieldByStorageKey('screennames');\n    var serviceField = screennamesField.getFieldByStorageKey('service');\n    var pendingItems = [{\n      node: serviceField,\n      path: dummyPath.getPath(screennamesField, 'client:screenname'),\n      rangeCalls: undefined,\n    }];\n    expect(result.pendingNodes).toMatchPendingNodes({\n      'client:screenname1': pendingItems,\n      'client:screenname2': pendingItems,\n    });\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when plural node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n      'client:screenname1': undefined,\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when plural node is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n        service: true,\n      },\n      'client:screenname2': {\n        __dataID__: 'client:screenname2',\n        service: true,\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when plural node is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        screennames {service}\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [\n          {__dataID__: 'client:screenname1'},\n          {__dataID__: 'client:screenname2'},\n        ],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n        service: true,\n      },\n      'client:screenname2': {\n        __dataID__: 'client:screenname2',\n        service: true,\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n\n  it('returns pendingNodes when range node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    var rangeField = queryNode.getFieldByStorageKey('friends');\n    var calls = rangeField.getCallsWithValues();\n\n\n    var pendingItems = rangeField.getChildren().map(node => {\n      return {\n        node,\n        path: dummyPath.getPath(rangeField, 'friends_id'),\n        rangeCalls: calls,\n      };\n    });\n\n    expect(result.pendingNodes)\n      .toMatchPendingNodes({'friends_id': pendingItems});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when range node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      'friends_id': undefined,\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns pendingNodes when range field is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    var friendField = queryNode.getFieldByStorageKey('friends');\n    var calls = friendField.getCallsWithValues();\n    var pendingItems = friendField.getChildren().map(node => {\n      return {\n        node,\n        path: dummyPath.getPath(friendField, 'friends_id'),\n        rangeCalls: calls,\n      };\n    });\n    expect(result.pendingNodes).toMatchPendingNodes({\n      'friends_id': pendingItems,\n    });\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when range field is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns missingData when range has diffQuery in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [RelayTestUtils.createCall('first', 10)],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns missingData when range has diffQuery in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        friends(first:\"10\") {\n          edges { node {id}}\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [RelayTestUtils.createCall('first', 10)],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns pendingNodes when edge node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      records,\n      {},\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n\n    var edgeFields = queryNode\n      .getFieldByStorageKey('edges')\n      .getChildren();\n    var pendingItems = edgeFields.map(node => {\n      return {\n        node,\n        path: dummyPath.getPath(edgeFields, 'edge_id'),\n        rangeCalls: undefined,\n      };\n    });\n    expect(result.pendingNodes).toMatchPendingNodes({'edge_id': pendingItems});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when edge node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: undefined,\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      {},\n      records,\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data when the range and edges are is in store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__: 'node_id'},\n        cursor: 'cursor',\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        id: 'node_id,',\n      },\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      records,\n      {},\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data when the range and edges are is in cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        edges { node {id}}\n      }\n    `);\n\n    var records = {\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__: 'node_id'},\n        cursor: 'cursor',\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        id: 'node_id,',\n      },\n    };\n\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var rangeCalls = [RelayTestUtils.createCall('first', 10)];\n    var result = findLeaves(\n      queryNode,\n      'friends_id',\n      dummyPath,\n      {},\n      records,\n      rangeCalls\n    );\n\n    var mockRetrieveRange =\n      records.friends_id.__range__.retrieveRangeInfoForQuery.mock;\n    expect(mockRetrieveRange.calls.length).toBe(1);\n    expect(mockRetrieveRange.calls[0][0]).toBe(rangeCalls);\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns pendingNodes when root node is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      query {\n        node(id:\"1055790163\") {\n          id\n        }\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n    );\n\n    var pendingItems = queryNode.getChildren().map(node => {\n      return {\n        node,\n        path: dummyPath,\n        rangeCalls: undefined,\n      };\n    });\n\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': pendingItems}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when root node is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      query {\n        node(id:\"1055790163\") {\n          id\n        }\n      }\n    `);\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      {'1055790163': undefined}\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('returns pendingNodes when matched fragment is not in the store', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on User {\n          firstName\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n    var userFragment = queryNode.getChildren().filter(\n      item => item instanceof RelayQuery.Fragment\n    )[0];\n    expect(result.pendingNodes).toMatchPendingNodes(\n      {'1055790163': [{\n        node: userFragment.getFieldByStorageKey('firstName'),\n        path: dummyPath,\n        rangeCalls: undefined,\n      }]}\n    );\n    expect(result.missingData).toBe(false);\n  });\n\n  it('returns missingData when matched fragment is not in the cache', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on User {\n          firstName\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(true);\n  });\n\n  it('has all required data in store when ignoring unmatched fragment', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on Page {\n          name\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      records,\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n\n  it('has all required data in cache when ignoring unmatched fragment', () => {\n    var queryNode = getNode(Relay.QL`\n      fragment on Node {\n        id,\n        ... on Page {\n          name\n        }\n      }\n    `);\n    var records = {\n      '1055790163': {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n    var result = findLeaves(\n      queryNode,\n      '1055790163',\n      dummyPath,\n      {},\n      records\n    );\n\n    expect(result.pendingNodes).toMatchPendingNodes({});\n    expect(result.missingData).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/findRelayQueryLeaves-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/filterRelayQuery-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst filterRelayQuery = require('filterRelayQuery');\n\ndescribe('filterRelayQuery()', () => {\n  var query;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"10\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns the original query if nothing is filtered out', () => {\n    expect(filterRelayQuery(query, () => true)).toBe(query);\n  });\n\n  it('returns null if all nodes are filterout out', () => {\n    expect(filterRelayQuery(query, () => false)).toBe(null);\n  });\n\n  it('filters specific nodes', () => {\n    var filter = function(node) {\n      return !(\n        node instanceof RelayQuery.Field &&\n        node.getSchemaName() === 'text'\n      );\n    };\n    expect(filterRelayQuery(query, filter)).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"10\") {\n            edges {\n              cursor,\n              node {\n                id,\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `));\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayTestUtils","filterRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst filterRelayQuery = require('filterRelayQuery');\n\ndescribe('filterRelayQuery()', () => {\n  var query;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"10\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns the original query if nothing is filtered out', () => {\n    expect(filterRelayQuery(query, () => true)).toBe(query);\n  });\n\n  it('returns null if all nodes are filterout out', () => {\n    expect(filterRelayQuery(query, () => false)).toBe(null);\n  });\n\n  it('filters specific nodes', () => {\n    var filter = function(node) {\n      return !(\n        node instanceof RelayQuery.Field &&\n        node.getSchemaName() === 'text'\n      );\n    };\n    expect(filterRelayQuery(query, filter)).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"10\") {\n            edges {\n              cursor,\n              node {\n                id,\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `));\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/filterRelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery_scalar-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('keeps queries if the root dataID is unknown', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        username(name:\"joe\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('returns original query if all fields unfetched', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('keeps unfetched scalar fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var writeQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          firstName\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        firstName: 'Joe',\n        __typename: 'User',\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          lastName\n        }\n      }\n    `));\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQueryTracker","RelayTestUtils","diffRelayQuery","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('keeps queries if the root dataID is unknown', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        username(name:\"joe\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('returns original query if all fields unfetched', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('keeps unfetched scalar fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var writeQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          firstName\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        firstName: 'Joe',\n        __typename: 'User',\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          lastName\n        }\n      }\n    `));\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery_scalar-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery_fragments-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery - fragments', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  var rootCallMap = {\n    'viewer': {'': 'client:1'},\n  };\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO} = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('removes matching fragments with fetched fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('tracks fragments for null linked fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a linked field.\n    var firstQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            address {\n              country\n            }\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n        address: null,\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('123');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the null\n    // linked field.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, linked field is null.\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `address { city }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('123');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n  it('refetches matching fragments with missing fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n            lastName\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe', // missing `lastName`\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            lastName\n          }\n        }\n      }\n    `));\n  });\n\n  it('removes non-matching fragments if other fields are fetched', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n          }\n          ... on Page {\n            name\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('refetches non-matching fragments if other fields are missing', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n            lastName\n          }\n          ... on Page {\n            name\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe', // missing `lastName`\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            lastName\n          }\n          ... on Page {\n            name\n          }\n        }\n      }\n    `));\n  });\n\n  it('removes non-matching fragments if connection fields are fetched', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                ... on Story {\n                  message {\n                    text\n                  }\n                }\n                ... on PhotoStory {\n                  photo {\n                    uri\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it(\n    'refetches non-matching fragments if connection fields are missing',\n    () => {\n      var records = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var tracker = new RelayQueryTracker();\n\n      var payload = {\n        viewer: {\n          newsFeed: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: 's1',\n                  __typename: 'Story',\n                  message: {\n                    text: 's1', // missing `ranges`\n                  },\n                },\n              },\n            ],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  ... on Story {\n                    message {\n                      text\n                      ranges\n                    }\n                  }\n                  ... on PhotoStory {\n                    photo {\n                      uri\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      `);\n      writePayload(store, writer, query, payload, tracker);\n\n      var diffQueries = diffRelayQuery(query, store, tracker);\n      expect(diffQueries.length).toBe(1);\n      expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          ... on Story {\n            message {\n              ranges\n            }\n          }\n          ... on PhotoStory {\n            photo {\n              uri\n            }\n          }\n          ... on FeedUnit {\n            id\n            __typename\n          }\n        }\n      }\n    `));\n    }\n  );\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayQueryTracker","RelayTestUtils","diffRelayQuery","RelayRecordStore","RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery - fragments', () => {\n  var RelayRecordStore;\n  var RelayRecordWriter;\n\n  var {getNode, writePayload} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  var rootCallMap = {\n    'viewer': {'': 'client:1'},\n  };\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n    RelayRecordWriter = require('RelayRecordWriter');\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO} = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('removes matching fragments with fetched fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('tracks fragments for null linked fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a linked field.\n    var firstQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            address {\n              country\n            }\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n        address: null,\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('123');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the null\n    // linked field.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, linked field is null.\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `address { city }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('123');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n  it('refetches matching fragments with missing fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n            lastName\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe', // missing `lastName`\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            lastName\n          }\n        }\n      }\n    `));\n  });\n\n  it('removes non-matching fragments if other fields are fetched', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n          }\n          ... on Page {\n            name\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe',\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('refetches non-matching fragments if other fields are missing', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var writer = new RelayRecordWriter(records, {}, false);\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            firstName\n            lastName\n          }\n          ... on Page {\n            name\n          }\n        }\n      }\n    `);\n    var payload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        firstName: 'Joe', // missing `lastName`\n      },\n    };\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            lastName\n          }\n          ... on Page {\n            name\n          }\n        }\n      }\n    `));\n  });\n\n  it('removes non-matching fragments if connection fields are fetched', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                ... on Story {\n                  message {\n                    text\n                  }\n                }\n                ... on PhotoStory {\n                  photo {\n                    uri\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, query, payload, tracker);\n\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it(\n    'refetches non-matching fragments if connection fields are missing',\n    () => {\n      var records = {};\n      var store = new RelayRecordStore({records}, {rootCallMap});\n      var writer = new RelayRecordWriter(records, rootCallMap, false);\n      var tracker = new RelayQueryTracker();\n\n      var payload = {\n        viewer: {\n          newsFeed: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id: 's1',\n                  __typename: 'Story',\n                  message: {\n                    text: 's1', // missing `ranges`\n                  },\n                },\n              },\n            ],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  ... on Story {\n                    message {\n                      text\n                      ranges\n                    }\n                  }\n                  ... on PhotoStory {\n                    photo {\n                      uri\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      `);\n      writePayload(store, writer, query, payload, tracker);\n\n      var diffQueries = diffRelayQuery(query, store, tracker);\n      expect(diffQueries.length).toBe(1);\n      expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          ... on Story {\n            message {\n              ranges\n            }\n          }\n          ... on PhotoStory {\n            photo {\n              uri\n            }\n          }\n          ... on FeedUnit {\n            id\n            __typename\n          }\n        }\n      }\n    `));\n    }\n  );\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery_fragments-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery_connection-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery', () => {\n  var {getNode, getVerbatimNode, writePayload} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  var rootCallMap;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO} = RelayConnectionInterface);\n\n    rootCallMap = {\n      'viewer': {'': 'client:1'},\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns unfetched connections as-is', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('removes completely fetched connections', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {cursor: 'c1', node: {id: 's1'}},\n            {cursor: 'c2', node: {id: 's2'}},\n            {cursor: 'c3', node: {id: 's3'}},\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n    // Write full data for all 3 items\n    writePayload(store, writer, query, payload, tracker);\n\n    // Everything can be diffed out\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('returns range extensions for partially fetched connections', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Write full data for 3 of 5 records, nothing for edges 4-5\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"5\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, query, payload, tracker);\n\n    // Nothing to fetch for records 1-3, fetch extension of range for 4-5\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(after:\"c3\",first:$count) {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `, {\n      count: 2,\n    }));\n  });\n\n  it('does not fetch missing `edges` data for generated `node` ids', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Provide empty IDs to simulate non-refetchable nodes\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // @relay(isConnectionWithoutNodeID: true) should silence the warning.\n    var fetchQueryA = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"3\") @relay(isConnectionWithoutNodeID: true) {\n            edges {\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQueryA, store, tracker);\n    expect(diffQueries.length).toBe(0);\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(0);\n\n    // `feedback{id}` is missing but there is no way to refetch it\n    // Warn that data cannot be refetched\n    var fetchQueryB = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    diffRelayQuery(fetchQueryB, store, tracker);\n\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(3);\n  });\n\n  it('does not warn about unrefetchable `edges` when there is no missing data', () => {\n    const records = {};\n    const store = new RelayRecordStore({records}, {rootCallMap});\n    const writer = new RelayRecordWriter(records, rootCallMap, false);\n    const tracker = new RelayQueryTracker();\n\n    // Provide empty IDs to simulate non-refetchable nodes\n    const writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    const payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // `message{text}` available in the store.\n    // Does not warn that data cannot be refetched sine no data is missing.\n    const fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    const diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(0);\n  });\n\n  it('fetches split queries under unrefetchable `edges`', () => {\n    const records = {};\n    const store = new RelayRecordStore({records}, {rootCallMap});\n    const writer = new RelayRecordWriter(records, rootCallMap, false);\n    const tracker = new RelayQueryTracker();\n\n    // Provide empty IDs to simulate non-refetchable nodes\n    const writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                feedback {\n                  id,\n                  comments(first:\"1\") {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    const payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                __typename: 'Story',\n                feedback: {\n                  __typename: 'Feedback',\n                  id: 'feedbackid',\n                  comments: {\n                    edges: [\n                      {\n                        cursor: 'commentcurser1',\n                        node: {\n                          __typename: 'Comment',\n                          id: 'commentid',\n                        },\n                      },\n                    ],\n                    [PAGE_INFO]: {\n                      [HAS_NEXT_PAGE]: true,\n                      [HAS_PREV_PAGE]: false,\n                    },\n                  },\n                },\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // Missing the `body{text}` on comment.\n    const fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                feedback {\n                  id,\n                  comments(first:\"1\") {\n                    edges {\n                      node {\n                        id,\n                        body {text}\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    const diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"commentid\"){\n          __typename,\n          ... on Comment {id, body {text}}\n        }\n      }\n    `));\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(0);\n  });\n\n  it('fetches missing `node` data via a `node()` query', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // Split one `node()` query per edge to fetch missing `feedback{id}`\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(3);\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s2\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[2]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s3\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n  });\n\n  it('fetches missing `node` data via a `node()` query and missing `edges` ' +\n     'data via a `connection.find()` query if connection is findable', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // node: `feedback{id}` is missing (fetch via node() query)\n    // edges: `sortKey` is missing (fetch via .find() query)\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              sortKey,\n              node {\n                id,\n                __typename,\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(6);\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(find:\"s1\") {\n            edges {\n              cursor,\n              node {\n                id\n                __typename,\n              },\n              sortKey,\n            }\n          }\n        }\n      }\n    `));\n    expect(diffQueries[2]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s2\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[3]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(find:\"s2\") {\n            edges {\n              cursor,\n              node {\n                id\n                __typename,\n              },\n              sortKey,\n            }\n          }\n        }\n      }\n    `));\n    expect(diffQueries[4]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s3\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[5]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(find:\"s3\") {\n            edges {\n              cursor,\n              node {\n                id,\n                __typename,\n              },\n              sortKey,\n            }\n          }\n        }\n      }\n    `));\n\n    // Ensure that a `__typename` field is generated\n    var typeField = diffQueries[5]\n      .getFieldByStorageKey('newsFeed')\n      .getFieldByStorageKey('edges')\n      .getFieldByStorageKey('node')\n      .getFieldByStorageKey('__typename');\n    expect(typeField).toBeTruthy();\n  });\n\n  it('fetches missing `node` data via a `node()` query and warns about ' +\n     'unfetchable `edges` data if connection is not findable', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        notificationStories: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          notificationStories(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // node: `feedback{id}` is missing (fetch via node() query)\n    // edges: `showBeeper` is missing but cannot be refetched because\n    // `notificationStories` does not support `.find()`\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          notificationStories(first:\"3\") {\n            edges {\n              showBeeper,\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(3);\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s2\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[2]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s3\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect([\n      'RelayDiffQueryBuilder: connection `edges{*}` fields can only be ' +\n      'refetched if the connection supports the `find` call. Cannot ' +\n      'refetch data for field `%s`.',\n      'notificationStories',\n    ]).toBeWarnedNTimes(3);\n  });\n\n  it('does not flatten fragments when creating new root queries', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {cursor: 'c1', node: {id:'s1', message:{text:'s1'}}},\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // node: `feedback{id}` is missing (fetch via node() query)\n    // edges: `sortKey` is missing (fetch via .find() query)\n    var edgeFragment = Relay.QL`fragment on NewsFeedEdge{sortKey}`;\n    var nodeFragment = Relay.QL`fragment on FeedUnit{feedback{id}}`;\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              ${edgeFragment},\n              node {\n                ${nodeFragment},\n              },\n            }\n          }\n        }\n      }\n    `);\n    // skip flattening to check fragment structure\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries[0]).toContainQueryNode(getNode(nodeFragment));\n    expect(diffQueries[1]).toContainQueryNode(getNode(edgeFragment));\n  });\n\n  it('tracks fragments for null connections', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a connection.\n    var firstQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                id\n                actor {\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      viewer: {\n        newsFeed: null,\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('client:1');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the null\n    // connection.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, connection is null.\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `message { text }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('client:1');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayQueryTracker","RelayRecordStore","RelayRecordWriter","RelayTestUtils","diffRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .mock('warning');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery', () => {\n  var {getNode, getVerbatimNode, writePayload} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  var rootCallMap;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO} = RelayConnectionInterface);\n\n    rootCallMap = {\n      'viewer': {'': 'client:1'},\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns unfetched connections as-is', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var tracker = new RelayQueryTracker();\n\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('removes completely fetched connections', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {cursor: 'c1', node: {id: 's1'}},\n            {cursor: 'c2', node: {id: 's2'}},\n            {cursor: 'c3', node: {id: 's3'}},\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n    // Write full data for all 3 items\n    writePayload(store, writer, query, payload, tracker);\n\n    // Everything can be diffed out\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('returns range extensions for partially fetched connections', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Write full data for 3 of 5 records, nothing for edges 4-5\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"5\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, query, payload, tracker);\n\n    // Nothing to fetch for records 1-3, fetch extension of range for 4-5\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(after:\"c3\",first:$count) {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `, {\n      count: 2,\n    }));\n  });\n\n  it('does not fetch missing `edges` data for generated `node` ids', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Provide empty IDs to simulate non-refetchable nodes\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // @relay(isConnectionWithoutNodeID: true) should silence the warning.\n    var fetchQueryA = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first: \"3\") @relay(isConnectionWithoutNodeID: true) {\n            edges {\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQueryA, store, tracker);\n    expect(diffQueries.length).toBe(0);\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(0);\n\n    // `feedback{id}` is missing but there is no way to refetch it\n    // Warn that data cannot be refetched\n    var fetchQueryB = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    diffRelayQuery(fetchQueryB, store, tracker);\n\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(3);\n  });\n\n  it('does not warn about unrefetchable `edges` when there is no missing data', () => {\n    const records = {};\n    const store = new RelayRecordStore({records}, {rootCallMap});\n    const writer = new RelayRecordWriter(records, rootCallMap, false);\n    const tracker = new RelayQueryTracker();\n\n    // Provide empty IDs to simulate non-refetchable nodes\n    const writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    const payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // `message{text}` available in the store.\n    // Does not warn that data cannot be refetched sine no data is missing.\n    const fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    const diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(0);\n  });\n\n  it('fetches split queries under unrefetchable `edges`', () => {\n    const records = {};\n    const store = new RelayRecordStore({records}, {rootCallMap});\n    const writer = new RelayRecordWriter(records, rootCallMap, false);\n    const tracker = new RelayQueryTracker();\n\n    // Provide empty IDs to simulate non-refetchable nodes\n    const writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                feedback {\n                  id,\n                  comments(first:\"1\") {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    const payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                __typename: 'Story',\n                feedback: {\n                  __typename: 'Feedback',\n                  id: 'feedbackid',\n                  comments: {\n                    edges: [\n                      {\n                        cursor: 'commentcurser1',\n                        node: {\n                          __typename: 'Comment',\n                          id: 'commentid',\n                        },\n                      },\n                    ],\n                    [PAGE_INFO]: {\n                      [HAS_NEXT_PAGE]: true,\n                      [HAS_PREV_PAGE]: false,\n                    },\n                  },\n                },\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // Missing the `body{text}` on comment.\n    const fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                feedback {\n                  id,\n                  comments(first:\"1\") {\n                    edges {\n                      node {\n                        id,\n                        body {text}\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    const diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"commentid\"){\n          __typename,\n          ... on Comment {id, body {text}}\n        }\n      }\n    `));\n    expect([\n      'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n      'retrieved if it does not have an `id` field. If you expect fields ' +\n      'to be retrieved on this field, add an `id` field in the schema. ' +\n      'If you choose to ignore this warning, you can silence it by ' +\n      'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n      'connection field.',\n      'newsFeed',\n    ]).toBeWarnedNTimes(0);\n  });\n\n  it('fetches missing `node` data via a `node()` query', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // Split one `node()` query per edge to fetch missing `feedback{id}`\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(3);\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s2\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[2]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s3\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n  });\n\n  it('fetches missing `node` data via a `node()` query and missing `edges` ' +\n     'data via a `connection.find()` query if connection is findable', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // node: `feedback{id}` is missing (fetch via node() query)\n    // edges: `sortKey` is missing (fetch via .find() query)\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              sortKey,\n              node {\n                id,\n                __typename,\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(6);\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(find:\"s1\") {\n            edges {\n              cursor,\n              node {\n                id\n                __typename,\n              },\n              sortKey,\n            }\n          }\n        }\n      }\n    `));\n    expect(diffQueries[2]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s2\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[3]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(find:\"s2\") {\n            edges {\n              cursor,\n              node {\n                id\n                __typename,\n              },\n              sortKey,\n            }\n          }\n        }\n      }\n    `));\n    expect(diffQueries[4]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s3\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[5]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(find:\"s3\") {\n            edges {\n              cursor,\n              node {\n                id,\n                __typename,\n              },\n              sortKey,\n            }\n          }\n        }\n      }\n    `));\n\n    // Ensure that a `__typename` field is generated\n    var typeField = diffQueries[5]\n      .getFieldByStorageKey('newsFeed')\n      .getFieldByStorageKey('edges')\n      .getFieldByStorageKey('node')\n      .getFieldByStorageKey('__typename');\n    expect(typeField).toBeTruthy();\n  });\n\n  it('fetches missing `node` data via a `node()` query and warns about ' +\n     'unfetchable `edges` data if connection is not findable', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        notificationStories: {\n          edges: [\n            {\n              cursor: 'c1',\n              node: {\n                id: 's1',\n                __typename: 'Story',\n                message: {text: 's1'},\n              },\n            },\n            {\n              cursor: 'c2',\n              node: {\n                id: 's2',\n                __typename: 'Story',\n                message: {text: 's2'},\n              },\n            },\n            {\n              cursor: 'c3',\n              node: {\n                id: 's3',\n                __typename: 'Story',\n                message: {text: 's3'},\n              },\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          notificationStories(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // node: `feedback{id}` is missing (fetch via node() query)\n    // edges: `showBeeper` is missing but cannot be refetched because\n    // `notificationStories` does not support `.find()`\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          notificationStories(first:\"3\") {\n            edges {\n              showBeeper,\n              node {\n                feedback {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries.length).toBe(3);\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s1\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s2\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[2]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"s3\") {\n          id,\n          __typename,\n          ... on FeedUnit {\n            feedback {\n              id,\n            },\n            id,\n            __typename,\n          },\n        }\n      }\n    `));\n    expect([\n      'RelayDiffQueryBuilder: connection `edges{*}` fields can only be ' +\n      'refetched if the connection supports the `find` call. Cannot ' +\n      'refetch data for field `%s`.',\n      'notificationStories',\n    ]).toBeWarnedNTimes(3);\n  });\n\n  it('does not flatten fragments when creating new root queries', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    var payload = {\n      viewer: {\n        newsFeed: {\n          edges: [\n            {cursor: 'c1', node: {id:'s1', message:{text:'s1'}}},\n          ],\n          [PAGE_INFO]: {\n            [HAS_NEXT_PAGE]: true,\n            [HAS_PREV_PAGE]: false,\n          },\n        },\n      },\n    };\n    var writeQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    writePayload(store, writer, writeQuery, payload, tracker);\n\n    // node: `feedback{id}` is missing (fetch via node() query)\n    // edges: `sortKey` is missing (fetch via .find() query)\n    var edgeFragment = Relay.QL`fragment on NewsFeedEdge{sortKey}`;\n    var nodeFragment = Relay.QL`fragment on FeedUnit{feedback{id}}`;\n    var fetchQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"1\") {\n            edges {\n              ${edgeFragment},\n              node {\n                ${nodeFragment},\n              },\n            }\n          }\n        }\n      }\n    `);\n    // skip flattening to check fragment structure\n    var diffQueries = diffRelayQuery(fetchQuery, store, tracker);\n    expect(diffQueries[0]).toContainQueryNode(getNode(nodeFragment));\n    expect(diffQueries[1]).toContainQueryNode(getNode(edgeFragment));\n  });\n\n  it('tracks fragments for null connections', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a connection.\n    var firstQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                id\n                actor {\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      viewer: {\n        newsFeed: null,\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('client:1');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the null\n    // connection.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          newsFeed(first:\"3\") {\n            edges {\n              node {\n                message {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, connection is null.\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `message { text }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('client:1');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery_connection-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery', () => {\n  var RelayRecordStore;\n\n  var {defer, getNode, getVerbatimNode, writePayload} = RelayTestUtils;\n\n  var rootCallMap;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n\n    rootCallMap = {\n      viewer: {'': 'client:1'},\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns the same query with an empty store', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name\n        }\n      }\n    `);\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('removes requisite fields if fetched', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('removes fetched scalar fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('removes fetched fields with the same calls', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          profilePicture(size:\"32\") { uri }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        uri: 'https://facebook.com',\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        'profilePicture{size:\"32\"}': {__dataID__: 'client:1'},\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('keeps fetched fields with different calls', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          profilePicture(size:\"64\") { uri }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        uri: 'https://facebook.com',\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        'profilePicture{size:\"32\"}': {__dataID__: 'client:1'},\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('removes fetched fragments', () => {\n    var fragment = Relay.QL`\n      fragment on Actor {\n        id,\n        name\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            ${fragment}\n          }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {__dataID__: '4808495'},\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        name: 'Joe',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('does not fetch known connection metadata for unfetched ranges', () => {\n    // `topLevelComments.count` is already fetched and should be diffed out,\n    // `edges` is not fetched and should be retained\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              count,\n              edges {\n                node {\n                  id,\n                  body {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        count: 5,\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.count` but keeps other\n    // range fields\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              edges {\n                node {\n                  id,\n                  body {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `));\n\n    var body = Relay.QL`\n      fragment on Comment {\n        body {\n          text\n        }\n      }\n    `;\n    var fragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        count,\n        edges {\n          node {\n            id,\n            ${body},\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${fragment},\n            }\n          }\n        }\n      }\n    `);\n    store = new RelayRecordStore({records});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.count` but keeps other\n    // range fields\n    expect(diffQueries.length).toBe(1);\n    var edgesFragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        edges {\n          node {\n            ${body},\n          },\n        },\n      }\n    `;\n    var expectedQuery = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${edgesFragment},\n            }\n          }\n        }\n      }\n    `);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expectedQuery);\n  });\n\n  it('diffs connection metadata when edges are unfetched', () => {\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        count: 5,\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments {\n              count,\n              totalCount,\n            }\n          }\n        }\n      }\n    `);\n\n    // `topLevelComments.totalCount` is not fetched and should be retained\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments {\n              totalCount\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('keeps connection `edges` when only metadata is fetched', () => {\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        count: 5,\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    // `edges` have not been fetched, should be kept\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first: \"10\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('fetches missing connection metadata without fetched edges', () => {\n    var mockRange = new GraphQLRange();\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      diffCalls: [],\n      filteredEdges: [],\n    });\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        __range__: mockRange,\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              count,\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    // `topLevelComments.count` is not fetched and should be retained,\n    // `edges` is fetched and should be diffed out\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.edges` but keeps `count`\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              count\n            }\n          }\n        }\n      }\n    `));\n\n    var fragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        count,\n        edges {\n          node {\n            id\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${fragment},\n            }\n          }\n        }\n      }\n    `);\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.count` but keeps other\n    // range fields\n    var edgesFragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        count\n      }\n    `;\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${edgesFragment},\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('returns an id-only query if the id is unfetched', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id\n        }\n      }\n    `);\n    var store = new RelayRecordStore({records: {}});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n\n    query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: 'actor',\n        },\n      },\n      'actor': {\n        __dataID__: 'actor',\n        // `id` should always be fetched, but should work correctly regardless\n      },\n    };\n    store = new RelayRecordStore({records}, {rootCallMap});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('fetches a known id if a sibling field is missing', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n\n    query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            name\n          }\n        }\n      }\n    `);\n    records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: 'actor',\n        },\n      },\n      'actor': {\n        __dataID__: 'actor',\n        id: 'actor',\n      },\n    };\n    store = new RelayRecordStore({records}, {rootCallMap});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('returns nothing for an empty query', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${null}\n        }\n      }\n    `);\n    var store = new RelayRecordStore({records: {}});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n      },\n    };\n    store = new RelayRecordStore({records});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('returns nothing if a range field is null', () => {\n    // `friends` is null, should not refetch it. This broke when refactoring\n    // `diffConnectionEdge` to work around flow; adding it as a regression test.\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends {\n            count\n          }\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        friends: null,\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('splits multiple IDs into separate queries', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\",\"4808495\"]) {\n          id,\n          name\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\"]) {\n          id\n          __typename\n          name\n        }\n      }\n    `));\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4808495\"]) {\n          id\n          __typename\n          name\n        }\n      }\n    `));\n  });\n\n  it('splits viewer-rooted queries', () => {\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {__dataID__: '4808495'},\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          },\n          primaryEmail,\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(\n      Relay.QL`query{viewer{primaryEmail}}`\n    ));\n  });\n\n  it('does not split refetchable fields', () => {\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '123',\n        },\n      },\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        name: 'Name',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            name,\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    // TODO: split lone-refetchable fields into node queries #6917343\n    var field = query.getFieldByStorageKey('actor');\n    expect(field.getInferredRootCallName()).toBe('node');\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          actor{\n            address{\n              city\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('reuses fields and fragments if both unchanged', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var frag = Relay.QL`fragment on Node {name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName,\n          ${frag},\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('reuses fields if unchanged', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var frag = Relay.QL`fragment on Node {name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName,\n          ${frag},\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName\n        }\n      }\n    `));\n  });\n\n  it('reuses fragments if unchanged', () => {\n    var fragment = Relay.QL`fragment on Node {name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName,\n          ${fragment},\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        firstName: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment},\n        }\n      }\n    `));\n  });\n\n  it('returns no queries if everything exists', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        firstName: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          firstName,\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n        }\n      }\n    `);\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('removes fields that have data, except id', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        firstName: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          lastName\n        }\n      }\n    `));\n  });\n\n  it('recurses into subfields', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        hometown: {\n          __dataID__: '1234',\n        },\n      },\n      '1234': {\n        __dataID__: '1234',\n        id: '1234',\n        name: 'Palo Alto, California',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          hometown {\n            id,\n            name,\n            websites,\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          hometown {\n            id,\n            websites,\n          }\n        }\n      }\n    `));\n  });\n\n  it('handles arrays containing Nodes', () => {\n    var records = {\n      '12345': {\n        __dataID__: '12345',\n        id: '12345',\n        actors: [\n          {__dataID__: '4'},\n          {__dataID__: '4808495'},\n          {__dataID__: '1023896548'},\n        ],\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n        firstName: 'Mark',\n        lastName: 'Zuckerberg',\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        firstName: 'Marshall',\n      },\n      '1023896548': {\n        __dataID__: '1023896548',\n        id: '1023896548',\n        name: 'Laney Kuenzel',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          actors {\n            id,\n            name,\n            firstName,\n            lastName,\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          __typename,\n          id,\n          ... on Actor {\n            __typename,\n            id,\n            lastName,\n            name,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"1023896548\") {\n          __typename,\n          id,\n          ... on Actor {\n            __typename,\n            firstName,\n            id,\n            lastName,\n          },\n        }\n      }\n    `));\n\n    var trackedQuery = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          actors {\n            id,\n            firstName,\n            lastName,\n            name,\n          }\n        }\n      }\n    `);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('12345');\n    expect(trackedQueries[0][0]).toEqualQueryNode(trackedQuery);\n  });\n\n  it('handles arrays containing non-Nodes', () => {\n    var records = {\n      '12345': {\n        __dataID__: '12345',\n        id: '12345',\n        screennames: [\n          {__dataID__: 'client:1'},\n          {__dataID__: 'client:2'},\n        ],\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        service: 'GTALK',\n      },\n      'client:2': {\n        __dataID__: 'client:2',\n        service: 'TWITTER',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var expected = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          screennames {\n            name,\n          },\n        }\n      }\n    `);\n\n    // Assume node(12345) is a Story\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          screennames {\n            name,\n            service\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n  });\n\n  it('handles missing fields in fragments', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n        lastName: 'Zuckerberg',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var firstNameFrag = Relay.QL`\n      fragment on Node {\n        firstName\n      }\n    `;\n    var lastNameFrag = Relay.QL`\n      fragment on Node {\n        lastName\n      }\n    `;\n    var nestingFrag = Relay.QL`\n      fragment on Node {\n        ${firstNameFrag},\n        ${lastNameFrag}\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\",\"4808495\"]) {\n          id,\n          name,\n          ${defer(firstNameFrag)},\n          ${lastNameFrag},\n          ${defer(nestingFrag)},\n        }\n      }\n    `);\n    var expectedFragment = Relay.QL`\n      fragment on Node {\n        ${firstNameFrag},\n      }\n    `;\n    var expected0 = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\"]) {\n          id,\n          ${firstNameFrag},\n          ${expectedFragment},\n        }\n      }\n    `);\n    var expected1 = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4808495\"]) {\n          id,\n          name,\n          ${defer(firstNameFrag)},\n          ${lastNameFrag},\n          ${defer(nestingFrag)}\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(2);\n\n    var query0 = diffQueries[0];\n    var query0Fragments = query0.getChildren().filter(\n      child => child instanceof RelayQuery.Fragment\n    );\n    expect(query0.getName()).toBe(query.getName());\n    expect(query0).toEqualQueryRoot(expected0);\n    expect(query0Fragments.length).toBe(2);\n    expect(query0Fragments[0].isDeferred()).toBeTruthy();\n    expect(query0Fragments[0].isDeferred()).toBeTruthy();\n\n    var query1 = diffQueries[1];\n    var query1Fragments = query1.getChildren().filter(\n      child => child instanceof RelayQuery.Fragment\n    );\n    expect(query1.getName()).toBe(query.getName());\n    expect(query1).toEqualQueryRoot(expected1);\n    expect(query1Fragments.length).toBe(3);\n    expect(query1Fragments[0].isDeferred()).toBeTruthy();\n    expect(query1Fragments[1].isDeferred()).toBeFalsy();\n    expect(query1Fragments[2].isDeferred()).toBeTruthy();\n  });\n\n  it('fetches the whole range if it is missing', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var expected = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id\n              },\n              cursor\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n  });\n\n  it('fetches an extension of a range', () => {\n    var mockRange = new GraphQLRange();\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': {\n        __dataID__: 'client:4:4808495',\n        node: {__dataID__: '4808495'},\n        cursor: 'cursor1',\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: [\n        {name: 'after', value: 'cursor1'},\n        {name: 'first', value: '4'},\n      ],\n    });\n\n    var expected = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(after:\"cursor1\",first:\"4\") {\n            edges {\n              cursor,\n              node {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n  });\n\n  it('fetches missing parts of a range and diffs nodes it has', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdge = {\n      __dataID__: 'client:4:4808495',\n      node: {__dataID__: '4808495'},\n      cursor: 'cursor1',\n    };\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: [\n        {name: 'after', value: 'cursor1'},\n        {name: 'first', value: '4'},\n      ],\n    });\n\n    var expected1 = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(after:\"cursor1\",first:\"4\") {\n            edges{\n              cursor,\n              node {\n                id,\n                name\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n\n    var expected2 = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            name,\n          },\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected1);\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(expected2);\n\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('skips known-deleted nodes from ranges', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdges = [\n      {\n        __dataID__: 'client:4:4808495',\n        node: {__dataID__: '4808495'},\n        cursor: 'cursor1',\n      },\n      {\n        __dataID__: 'client:4:660361306',\n        node: {__dataID__: '660361306'},\n        cursor: 'cursor1',\n      },\n    ];\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdges[0],\n      '4808495': null,\n      'client:4:660361306': mockEdges[1],\n      '660361306': {\n        __dataID__: '660361306',\n        id: '660361306',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495', 'client:4:660361306'],\n      diffCalls: [\n        {name: 'after', value: 'cursor1'},\n        {name: 'first', value: '4'},\n      ],\n    });\n\n    var expected1 = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(after:\"cursor1\",first:\"4\") {\n            edges{\n              cursor,\n              node {\n                id,\n                name\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n    var expected2 = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"660361306\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            name,\n          },\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected1);\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(expected2);\n\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('splits out node() queries inside viewer-rooted queries', () => {\n    var mockEdge = {\n      __dataID__: 'client:1:4808495',\n      node: {__dataID__: '4808495'},\n      cursor: 'cursor1',\n    };\n\n    var mockRange = new GraphQLRange();\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:1:4808495'],\n      diffCalls: null,\n    });\n\n    var records = {\n      'client:1': {  // viewer\n        __dataID__: 'client:1',\n        actor: {__dataID__: '4'},\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:2'},\n      },\n      'client:2': {  // friends\n        __dataID__: 'client:2',\n        __range__: mockRange,\n      },\n      'client:1:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        firstName: 'Marshall',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          },\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\"){\n          id,\n          __typename,\n          ... on User {\n            id,\n            name,\n          },\n        }\n      }\n    `));\n\n    var trackedQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id,\n                  name,\n                },\n              },\n            },\n          },\n        }\n      }\n    `);\n    var innerTrackedQuery = trackedQuery.getFieldByStorageKey('actor');\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(3);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(innerTrackedQuery);\n    expect(trackedQueries[2][1]).toBe('client:1');\n    expect(trackedQueries[2][0]).toEqualQueryNode(trackedQuery);\n  });\n\n  it('splits out node() queries inside fragments', () => {\n    var mockRange = new GraphQLRange();\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': {\n        __dataID__: 'client:4:4808495',\n        node: {__dataID__: '4808495'},\n        cursor: 'cursor1',\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        firstName: 'Marshall',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: null,\n    });\n\n    var expected = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            lastName,\n          },\n        }\n      }\n    `);\n\n    var fragment = Relay.QL`\n      fragment on User {\n        friends(first:\"1\") {\n          edges {\n            node {\n              firstName,\n              lastName,\n            }\n          }\n        }\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment}\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n\n    var trackedQuery = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          ${fragment},\n        }\n      }\n    `);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(trackedQuery);\n  });\n\n  it('creates a find() query for edges', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdge = {\n      __dataID__: 'client:4:4808495',\n      node: {__dataID__: '4808495'},\n      source: {__dataID__: '4'},\n      cursor: 'cursor1',\n    };\n    var records = {\n      '4': {\n        __dataID__: '4',\n        __typename: 'User',\n        id: '4',\n        name: 'Mark Zuckerberg',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: null,\n    });\n\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          id,\n          friends(first:\"1\") {\n            edges {\n              node {\n                id\n              },\n              source {\n                id,\n                name,\n                firstName\n              }\n            }\n          }\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          ... on User {\n            id,\n            __typename,\n            friends(find:\"4808495\") {\n              edges {\n                cursor,\n                node {\n                  id,\n                  __typename, # not strictly required here\n                },\n                source {\n                  id,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('supports diff queries inside find() queries', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdge = {\n      __dataID__: 'client:4:4808495',\n      node: {__dataID__: '4808495'},\n      source: {__dataID__: '4'},\n      cursor: 'cursor1',\n    };\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        name: 'Marshall Roch',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: null,\n    });\n\n    var expected = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            lastName,\n          },\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          id,\n          friends(first:\"1\") {\n            edges {\n              node {\n                id,\n              },\n              source {\n                id,\n                friends(first:\"1\") {\n                  edges {\n                    node {\n                      id,\n                      name,\n                      lastName\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(5);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(getNode(Relay.QL`\n      fragment on FriendsEdge {\n        source {\n          id,\n          friends(first:\"1\") {\n            edges {\n              node {\n                id,\n                name,\n                lastName,\n              }\n            }\n          }\n        }\n      }\n    `).getChildren()[0]);\n\n    expect(trackedQueries[4][1]).toBe('4');\n    expect(trackedQueries[4][0]).toEqualQueryNode(getNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          id,\n          friends(first:\"1\") {\n            edges {\n              source {\n                id,\n                friends(first:\"1\") {\n                  edges {\n                    node {\n                      id,\n                      name,\n                      lastName\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('tracks fragments on null plural fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a plural field.\n    var firstQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          id\n          __typename\n          actors {\n            id\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        actors: null,\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('123');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the null\n    // plural field.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          actors {\n            name\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, plural field is null\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `actors { name }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('123');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n  it('tracks fragments on empty plural fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a plural field\n    var firstQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          id\n          __typename\n          actors {\n            id\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        actors: [],\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('123');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the empty\n    // plural field.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          actors {\n            name\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, plural field is empty.\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `actors { name }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('123');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n});\n","dependencies":["configureForRelayOSS","GraphQLRange","Relay","RelayQuery","RelayQueryTracker","RelayRecordWriter","RelayTestUtils","diffRelayQuery","RelayRecordStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst diffRelayQuery = require('diffRelayQuery');\n\ndescribe('diffRelayQuery', () => {\n  var RelayRecordStore;\n\n  var {defer, getNode, getVerbatimNode, writePayload} = RelayTestUtils;\n\n  var rootCallMap;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n\n    rootCallMap = {\n      viewer: {'': 'client:1'},\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns the same query with an empty store', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name\n        }\n      }\n    `);\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('removes requisite fields if fetched', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('removes fetched scalar fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('removes fetched fields with the same calls', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          profilePicture(size:\"32\") { uri }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        uri: 'https://facebook.com',\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        'profilePicture{size:\"32\"}': {__dataID__: 'client:1'},\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('keeps fetched fields with different calls', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          profilePicture(size:\"64\") { uri }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        uri: 'https://facebook.com',\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        'profilePicture{size:\"32\"}': {__dataID__: 'client:1'},\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('removes fetched fragments', () => {\n    var fragment = Relay.QL`\n      fragment on Actor {\n        id,\n        name\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            ${fragment}\n          }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {__dataID__: '4808495'},\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        name: 'Joe',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('does not fetch known connection metadata for unfetched ranges', () => {\n    // `topLevelComments.count` is already fetched and should be diffed out,\n    // `edges` is not fetched and should be retained\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              count,\n              edges {\n                node {\n                  id,\n                  body {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        count: 5,\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.count` but keeps other\n    // range fields\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              edges {\n                node {\n                  id,\n                  body {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `));\n\n    var body = Relay.QL`\n      fragment on Comment {\n        body {\n          text\n        }\n      }\n    `;\n    var fragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        count,\n        edges {\n          node {\n            id,\n            ${body},\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${fragment},\n            }\n          }\n        }\n      }\n    `);\n    store = new RelayRecordStore({records});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.count` but keeps other\n    // range fields\n    expect(diffQueries.length).toBe(1);\n    var edgesFragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        edges {\n          node {\n            ${body},\n          },\n        },\n      }\n    `;\n    var expectedQuery = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${edgesFragment},\n            }\n          }\n        }\n      }\n    `);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expectedQuery);\n  });\n\n  it('diffs connection metadata when edges are unfetched', () => {\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        count: 5,\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments {\n              count,\n              totalCount,\n            }\n          }\n        }\n      }\n    `);\n\n    // `topLevelComments.totalCount` is not fetched and should be retained\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments {\n              totalCount\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('keeps connection `edges` when only metadata is fetched', () => {\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        count: 5,\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    // `edges` have not been fetched, should be kept\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first: \"10\") {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('fetches missing connection metadata without fetched edges', () => {\n    var mockRange = new GraphQLRange();\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      diffCalls: [],\n      filteredEdges: [],\n    });\n    var records = {\n      story: {\n        __dataID__: 'story',\n        id: 'story',\n        feedback: {\n          __dataID__: 'story:feedback',\n        },\n      },\n      'story:feedback': {\n        __dataID__: 'story:feedback',\n        topLevelComments: {\n          __dataID__: 'story:feedback:comments',\n        },\n      },\n      'story:feedback:comments': {\n        __dataID__: 'story:feedback:comments',\n        __range__: mockRange,\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              count,\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    // `topLevelComments.count` is not fetched and should be retained,\n    // `edges` is fetched and should be diffed out\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.edges` but keeps `count`\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              count\n            }\n          }\n        }\n      }\n    `));\n\n    var fragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        count,\n        edges {\n          node {\n            id\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${fragment},\n            }\n          }\n        }\n      }\n    `);\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    // does not refetch `feedback.topLevelComments.count` but keeps other\n    // range fields\n    var edgesFragment = Relay.QL`\n      fragment on TopLevelCommentsConnection {\n        count\n      }\n    `;\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"story\") {\n          feedback {\n            topLevelComments(first:\"10\") {\n              ${edgesFragment},\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('returns an id-only query if the id is unfetched', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id\n        }\n      }\n    `);\n    var store = new RelayRecordStore({records: {}});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n\n    query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: 'actor',\n        },\n      },\n      'actor': {\n        __dataID__: 'actor',\n        // `id` should always be fetched, but should work correctly regardless\n      },\n    };\n    store = new RelayRecordStore({records}, {rootCallMap});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('fetches a known id if a sibling field is missing', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n\n    query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            name\n          }\n        }\n      }\n    `);\n    records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: 'actor',\n        },\n      },\n      'actor': {\n        __dataID__: 'actor',\n        id: 'actor',\n      },\n    };\n    store = new RelayRecordStore({records}, {rootCallMap});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('returns nothing for an empty query', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${null}\n        }\n      }\n    `);\n    var store = new RelayRecordStore({records: {}});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n      },\n    };\n    store = new RelayRecordStore({records});\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('returns nothing if a range field is null', () => {\n    // `friends` is null, should not refetch it. This broke when refactoring\n    // `diffConnectionEdge` to work around flow; adding it as a regression test.\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends {\n            count\n          }\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        friends: null,\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('splits multiple IDs into separate queries', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\",\"4808495\"]) {\n          id,\n          name\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\"]) {\n          id\n          __typename\n          name\n        }\n      }\n    `));\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4808495\"]) {\n          id\n          __typename\n          name\n        }\n      }\n    `));\n  });\n\n  it('splits viewer-rooted queries', () => {\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {__dataID__: '4808495'},\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          },\n          primaryEmail,\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(\n      Relay.QL`query{viewer{primaryEmail}}`\n    ));\n  });\n\n  it('does not split refetchable fields', () => {\n    var records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '123',\n        },\n      },\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        name: 'Name',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            name,\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    // TODO: split lone-refetchable fields into node queries #6917343\n    var field = query.getFieldByStorageKey('actor');\n    expect(field.getInferredRootCallName()).toBe('node');\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          actor{\n            address{\n              city\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('reuses fields and fragments if both unchanged', () => {\n    var records = {};\n    var store = new RelayRecordStore({records});\n    var frag = Relay.QL`fragment on Node {name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName,\n          ${frag},\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0]).toBeQueryRoot(query);\n  });\n\n  it('reuses fields if unchanged', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var frag = Relay.QL`fragment on Node {name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName,\n          ${frag},\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName\n        }\n      }\n    `));\n  });\n\n  it('reuses fragments if unchanged', () => {\n    var fragment = Relay.QL`fragment on Node {name}`;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          firstName,\n          ${fragment},\n        }\n      }\n    `);\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        firstName: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment},\n        }\n      }\n    `));\n  });\n\n  it('returns no queries if everything exists', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        firstName: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          firstName,\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n        }\n      }\n    `);\n    tracker = new RelayQueryTracker();\n    diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(0);\n  });\n\n  it('removes fields that have data, except id', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        firstName: 'Mark',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          firstName,\n          lastName,\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          lastName\n        }\n      }\n    `));\n  });\n\n  it('recurses into subfields', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        hometown: {\n          __dataID__: '1234',\n        },\n      },\n      '1234': {\n        __dataID__: '1234',\n        id: '1234',\n        name: 'Palo Alto, California',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          hometown {\n            id,\n            name,\n            websites,\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          hometown {\n            id,\n            websites,\n          }\n        }\n      }\n    `));\n  });\n\n  it('handles arrays containing Nodes', () => {\n    var records = {\n      '12345': {\n        __dataID__: '12345',\n        id: '12345',\n        actors: [\n          {__dataID__: '4'},\n          {__dataID__: '4808495'},\n          {__dataID__: '1023896548'},\n        ],\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n        firstName: 'Mark',\n        lastName: 'Zuckerberg',\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        firstName: 'Marshall',\n      },\n      '1023896548': {\n        __dataID__: '1023896548',\n        id: '1023896548',\n        name: 'Laney Kuenzel',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          actors {\n            id,\n            name,\n            firstName,\n            lastName,\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          __typename,\n          id,\n          ... on Actor {\n            __typename,\n            id,\n            lastName,\n            name,\n          },\n        }\n      }\n    `));\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"1023896548\") {\n          __typename,\n          id,\n          ... on Actor {\n            __typename,\n            firstName,\n            id,\n            lastName,\n          },\n        }\n      }\n    `));\n\n    var trackedQuery = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          actors {\n            id,\n            firstName,\n            lastName,\n            name,\n          }\n        }\n      }\n    `);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('12345');\n    expect(trackedQueries[0][0]).toEqualQueryNode(trackedQuery);\n  });\n\n  it('handles arrays containing non-Nodes', () => {\n    var records = {\n      '12345': {\n        __dataID__: '12345',\n        id: '12345',\n        screennames: [\n          {__dataID__: 'client:1'},\n          {__dataID__: 'client:2'},\n        ],\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        service: 'GTALK',\n      },\n      'client:2': {\n        __dataID__: 'client:2',\n        service: 'TWITTER',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var expected = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          screennames {\n            name,\n          },\n        }\n      }\n    `);\n\n    // Assume node(12345) is a Story\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"12345\") {\n          id,\n          screennames {\n            name,\n            service\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n  });\n\n  it('handles missing fields in fragments', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n        lastName: 'Zuckerberg',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    var firstNameFrag = Relay.QL`\n      fragment on Node {\n        firstName\n      }\n    `;\n    var lastNameFrag = Relay.QL`\n      fragment on Node {\n        lastName\n      }\n    `;\n    var nestingFrag = Relay.QL`\n      fragment on Node {\n        ${firstNameFrag},\n        ${lastNameFrag}\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\",\"4808495\"]) {\n          id,\n          name,\n          ${defer(firstNameFrag)},\n          ${lastNameFrag},\n          ${defer(nestingFrag)},\n        }\n      }\n    `);\n    var expectedFragment = Relay.QL`\n      fragment on Node {\n        ${firstNameFrag},\n      }\n    `;\n    var expected0 = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4\"]) {\n          id,\n          ${firstNameFrag},\n          ${expectedFragment},\n        }\n      }\n    `);\n    var expected1 = getNode(Relay.QL`\n      query {\n        nodes(ids:[\"4808495\"]) {\n          id,\n          name,\n          ${defer(firstNameFrag)},\n          ${lastNameFrag},\n          ${defer(nestingFrag)}\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(2);\n\n    var query0 = diffQueries[0];\n    var query0Fragments = query0.getChildren().filter(\n      child => child instanceof RelayQuery.Fragment\n    );\n    expect(query0.getName()).toBe(query.getName());\n    expect(query0).toEqualQueryRoot(expected0);\n    expect(query0Fragments.length).toBe(2);\n    expect(query0Fragments[0].isDeferred()).toBeTruthy();\n    expect(query0Fragments[0].isDeferred()).toBeTruthy();\n\n    var query1 = diffQueries[1];\n    var query1Fragments = query1.getChildren().filter(\n      child => child instanceof RelayQuery.Fragment\n    );\n    expect(query1.getName()).toBe(query.getName());\n    expect(query1).toEqualQueryRoot(expected1);\n    expect(query1Fragments.length).toBe(3);\n    expect(query1Fragments[0].isDeferred()).toBeTruthy();\n    expect(query1Fragments[1].isDeferred()).toBeFalsy();\n    expect(query1Fragments[2].isDeferred()).toBeTruthy();\n  });\n\n  it('fetches the whole range if it is missing', () => {\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        name: 'Mark Zuckerberg',\n      },\n    };\n    var store = new RelayRecordStore({records});\n\n    var expected = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id\n              },\n              cursor\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          name,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n  });\n\n  it('fetches an extension of a range', () => {\n    var mockRange = new GraphQLRange();\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': {\n        __dataID__: 'client:4:4808495',\n        node: {__dataID__: '4808495'},\n        cursor: 'cursor1',\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: [\n        {name: 'after', value: 'cursor1'},\n        {name: 'first', value: '4'},\n      ],\n    });\n\n    var expected = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(after:\"cursor1\",first:\"4\") {\n            edges {\n              cursor,\n              node {\n                id\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n  });\n\n  it('fetches missing parts of a range and diffs nodes it has', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdge = {\n      __dataID__: 'client:4:4808495',\n      node: {__dataID__: '4808495'},\n      cursor: 'cursor1',\n    };\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: [\n        {name: 'after', value: 'cursor1'},\n        {name: 'first', value: '4'},\n      ],\n    });\n\n    var expected1 = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(after:\"cursor1\",first:\"4\") {\n            edges{\n              cursor,\n              node {\n                id,\n                name\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n\n    var expected2 = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            name,\n          },\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected1);\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(expected2);\n\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('skips known-deleted nodes from ranges', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdges = [\n      {\n        __dataID__: 'client:4:4808495',\n        node: {__dataID__: '4808495'},\n        cursor: 'cursor1',\n      },\n      {\n        __dataID__: 'client:4:660361306',\n        node: {__dataID__: '660361306'},\n        cursor: 'cursor1',\n      },\n    ];\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdges[0],\n      '4808495': null,\n      'client:4:660361306': mockEdges[1],\n      '660361306': {\n        __dataID__: '660361306',\n        id: '660361306',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495', 'client:4:660361306'],\n      diffCalls: [\n        {name: 'after', value: 'cursor1'},\n        {name: 'first', value: '4'},\n      ],\n    });\n\n    var expected1 = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(after:\"cursor1\",first:\"4\") {\n            edges{\n              cursor,\n              node {\n                id,\n                name\n              }\n            },\n            pageInfo {\n              hasNextPage,\n              hasPreviousPage\n            }\n          }\n        }\n      }\n    `);\n    var expected2 = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"660361306\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            name,\n          },\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(2);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected1);\n    expect(diffQueries[1].getName()).toBe(query.getName());\n    expect(diffQueries[1]).toEqualQueryRoot(expected2);\n\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          friends(first:\"5\") {\n            edges {\n              node {\n                id,\n                name\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('splits out node() queries inside viewer-rooted queries', () => {\n    var mockEdge = {\n      __dataID__: 'client:1:4808495',\n      node: {__dataID__: '4808495'},\n      cursor: 'cursor1',\n    };\n\n    var mockRange = new GraphQLRange();\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:1:4808495'],\n      diffCalls: null,\n    });\n\n    var records = {\n      'client:1': {  // viewer\n        __dataID__: 'client:1',\n        actor: {__dataID__: '4'},\n      },\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:2'},\n      },\n      'client:2': {  // friends\n        __dataID__: 'client:2',\n        __range__: mockRange,\n      },\n      'client:1:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        firstName: 'Marshall',\n      },\n    };\n    var store = new RelayRecordStore({records}, {rootCallMap});\n\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            friends(first:\"1\") {\n              edges {\n                node {\n                  name,\n                },\n              },\n            },\n          },\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\"){\n          id,\n          __typename,\n          ... on User {\n            id,\n            name,\n          },\n        }\n      }\n    `));\n\n    var trackedQuery = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            friends(first:\"1\") {\n              edges {\n                node {\n                  id,\n                  name,\n                },\n              },\n            },\n          },\n        }\n      }\n    `);\n    var innerTrackedQuery = trackedQuery.getFieldByStorageKey('actor');\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(3);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(innerTrackedQuery);\n    expect(trackedQueries[2][1]).toBe('client:1');\n    expect(trackedQueries[2][0]).toEqualQueryNode(trackedQuery);\n  });\n\n  it('splits out node() queries inside fragments', () => {\n    var mockRange = new GraphQLRange();\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': {\n        __dataID__: 'client:4:4808495',\n        node: {__dataID__: '4808495'},\n        cursor: 'cursor1',\n      },\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        firstName: 'Marshall',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: null,\n    });\n\n    var expected = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            lastName,\n          },\n        }\n      }\n    `);\n\n    var fragment = Relay.QL`\n      fragment on User {\n        friends(first:\"1\") {\n          edges {\n            node {\n              firstName,\n              lastName,\n            }\n          }\n        }\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment}\n        }\n      }\n    `);\n\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n\n    var trackedQuery = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          ${fragment},\n        }\n      }\n    `);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(trackedQuery);\n  });\n\n  it('creates a find() query for edges', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdge = {\n      __dataID__: 'client:4:4808495',\n      node: {__dataID__: '4808495'},\n      source: {__dataID__: '4'},\n      cursor: 'cursor1',\n    };\n    var records = {\n      '4': {\n        __dataID__: '4',\n        __typename: 'User',\n        id: '4',\n        name: 'Mark Zuckerberg',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: null,\n    });\n\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          id,\n          friends(first:\"1\") {\n            edges {\n              node {\n                id\n              },\n              source {\n                id,\n                name,\n                firstName\n              }\n            }\n          }\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          ... on User {\n            id,\n            __typename,\n            friends(find:\"4808495\") {\n              edges {\n                cursor,\n                node {\n                  id,\n                  __typename, # not strictly required here\n                },\n                source {\n                  id,\n                  firstName\n                }\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('supports diff queries inside find() queries', () => {\n    var mockRange = new GraphQLRange();\n    var mockEdge = {\n      __dataID__: 'client:4:4808495',\n      node: {__dataID__: '4808495'},\n      source: {__dataID__: '4'},\n      cursor: 'cursor1',\n    };\n    var records = {\n      '4': {\n        __dataID__: '4',\n        id: '4',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: mockRange,\n      },\n      'client:4:4808495': mockEdge,\n      '4808495': {\n        __dataID__: '4808495',\n        id: '4808495',\n        name: 'Marshall Roch',\n      },\n    };\n    var store = new RelayRecordStore({records});\n    mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['client:4:4808495'],\n      diffCalls: null,\n    });\n\n    var expected = getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"4808495\") {\n          id,\n          __typename,\n          ... on User {\n            id,\n            lastName,\n          },\n        }\n      }\n    `);\n\n    var query = getNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          id,\n          friends(first:\"1\") {\n            edges {\n              node {\n                id,\n              },\n              source {\n                id,\n                friends(first:\"1\") {\n                  edges {\n                    node {\n                      id,\n                      name,\n                      lastName\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n    var tracker = new RelayQueryTracker();\n    var diffQueries = diffRelayQuery(query, store, tracker);\n    expect(diffQueries.length).toBe(1);\n    expect(diffQueries[0].getName()).toBe(query.getName());\n    expect(diffQueries[0]).toEqualQueryRoot(expected);\n\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(5);\n    expect(trackedQueries[1][1]).toBe('4');\n    expect(trackedQueries[1][0]).toEqualQueryNode(getNode(Relay.QL`\n      fragment on FriendsEdge {\n        source {\n          id,\n          friends(first:\"1\") {\n            edges {\n              node {\n                id,\n                name,\n                lastName,\n              }\n            }\n          }\n        }\n      }\n    `).getChildren()[0]);\n\n    expect(trackedQueries[4][1]).toBe('4');\n    expect(trackedQueries[4][0]).toEqualQueryNode(getNode(Relay.QL`\n      query {\n        nodes(ids:\"4\") {\n          id,\n          friends(first:\"1\") {\n            edges {\n              source {\n                id,\n                friends(first:\"1\") {\n                  edges {\n                    node {\n                      id,\n                      name,\n                      lastName\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `));\n  });\n\n  it('tracks fragments on null plural fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a plural field.\n    var firstQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          id\n          __typename\n          actors {\n            id\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        actors: null,\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('123');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the null\n    // plural field.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          actors {\n            name\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, plural field is null\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `actors { name }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('123');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n  it('tracks fragments on empty plural fields', () => {\n    var records = {};\n    var store = new RelayRecordStore({records}, {rootCallMap});\n    var writer = new RelayRecordWriter(records, rootCallMap, false);\n    var tracker = new RelayQueryTracker();\n\n    // Create the first query with a selection on a plural field\n    var firstQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          id\n          __typename\n          actors {\n            id\n          }\n        }\n      }\n    `);\n\n    var firstPayload = {\n      node: {\n        id: '123',\n        __typename: 'User',\n        actors: [],\n      },\n    };\n    writePayload(store, writer, firstQuery, firstPayload, tracker);\n    var trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(1);\n    expect(trackedQueries[0][1]).toBe('123');\n    expect(trackedQueries[0][0]).toEqualQueryRoot(firstQuery);\n\n    // Create a second query that requests a different selection on the empty\n    // plural field.\n    var secondQuery = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          actors {\n            name\n          }\n        }\n      }\n    `);\n\n    // Everything can be diffed out, plural field is empty.\n    var diffQueries = diffRelayQuery(secondQuery, store, tracker);\n    expect(diffQueries.length).toBe(0);\n\n    // Ensure the new `actors { name }` field is tracked.\n    trackedQueries = tracker.trackNodeForID.mock.calls;\n    expect(trackedQueries.length).toBe(2);\n    expect(trackedQueries[1][1]).toBe('123');\n    expect(trackedQueries[1][0]).toEqualQueryRoot(secondQuery);\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/diffRelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/containsRelayQueryRootCall-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst containsRelayQueryRootCall = require('containsRelayQueryRootCall');\n\ndescribe('containsRelayQueryRootCall', function() {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(function() {\n    jasmine.addMatchers({\n      toContainRootCall() {\n        return {\n          compare(thisQuery, thatQuery) {\n            var pass = containsRelayQueryRootCall(\n              getNode(thisQuery),\n              getNode(thatQuery)\n            );\n            var notText = pass ? 'not ' : '';\n            return {\n              pass,\n              message: 'Expected `' + thisQuery + '` ' + notText +\n                'to contain root call of `' + thatQuery + '`.',\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('compares root calls without arguments', () => {\n    expect(\n      Relay.QL`query{viewer{actor{id}}}`\n    ).toContainRootCall(\n      Relay.QL`query{viewer{actor{id}}}`\n    );\n    expect(\n      Relay.QL`query{me{id}}`\n    ).toContainRootCall(\n      Relay.QL`query{me{id}}`\n    );\n    expect(\n      Relay.QL`query{me{id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{viewer{actor{id}}}`\n    );\n  });\n\n  it('compares root calls with single arguments', () => {\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{node(id:\"4808495\"){id}}`\n    );\n  });\n\n  it('compares root calls with variable arguments', () => {\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"1819001144\"]){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\"]){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\"]){id}}`\n    );\n    // Hypothetical queries.\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes{id}}`\n    );\n    expect(\n      Relay.QL`query{nodes{id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    );\n  });\n\n  it('compares root calls sharing a canonical name', () => {\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:\"4808495\"){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{node(id:\"4808495\"){id}}`\n    );\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","containsRelayQueryRootCall"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst containsRelayQueryRootCall = require('containsRelayQueryRootCall');\n\ndescribe('containsRelayQueryRootCall', function() {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(function() {\n    jasmine.addMatchers({\n      toContainRootCall() {\n        return {\n          compare(thisQuery, thatQuery) {\n            var pass = containsRelayQueryRootCall(\n              getNode(thisQuery),\n              getNode(thatQuery)\n            );\n            var notText = pass ? 'not ' : '';\n            return {\n              pass,\n              message: 'Expected `' + thisQuery + '` ' + notText +\n                'to contain root call of `' + thatQuery + '`.',\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('compares root calls without arguments', () => {\n    expect(\n      Relay.QL`query{viewer{actor{id}}}`\n    ).toContainRootCall(\n      Relay.QL`query{viewer{actor{id}}}`\n    );\n    expect(\n      Relay.QL`query{me{id}}`\n    ).toContainRootCall(\n      Relay.QL`query{me{id}}`\n    );\n    expect(\n      Relay.QL`query{me{id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{viewer{actor{id}}}`\n    );\n  });\n\n  it('compares root calls with single arguments', () => {\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{node(id:\"4808495\"){id}}`\n    );\n  });\n\n  it('compares root calls with variable arguments', () => {\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"1819001144\"]){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\"]){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\",\"1819001144\"]){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:[\"1038750002\",\"4808495\"]){id}}`\n    );\n    // Hypothetical queries.\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes{id}}`\n    );\n    expect(\n      Relay.QL`query{nodes{id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    );\n  });\n\n  it('compares root calls sharing a canonical name', () => {\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).toContainRootCall(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    );\n    expect(\n      Relay.QL`query{node(id:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{nodes(ids:\"4808495\"){id}}`\n    );\n    expect(\n      Relay.QL`query{nodes(ids:\"1038750002\"){id}}`\n    ).not.toContainRootCall(\n      Relay.QL`query{node(id:\"4808495\"){id}}`\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/containsRelayQueryRootCall-test.js"}},"/Users/cpojer/Projects/relay/src/traversal/__tests__/checkRelayQueryData-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst checkRelayQueryData = require('checkRelayQueryData');\n\ndescribe('checkRelayQueryData', () => {\n  var RelayRecordStore;\n\n  var {getNode} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  function hasData(\n    query,\n    records,\n    rootCallMap,\n    fragmentFilter\n  ) {\n    var store = new RelayRecordStore(\n      {records: records || {}},\n      {rootCallMap: rootCallMap || {}}\n    );\n    return checkRelayQueryData(store, query, fragmentFilter);\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n  });\n\n  it('returns false when node is not in the store', () => {\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id}\n        }\n      `,\n    ));\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when node is null', () => {\n    var records = {\n      1055790163: null,\n    };\n\n    var result = hasData(getNode(\n     Relay.QL`\n       query {\n         node(id:\"1055790163\") {id}\n       }\n     `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns true when checking basic id query', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when a part of the node query is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          nodes(ids:[\"1055790163\",\"4\"]) {id}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when data is available for custom root calls', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          username(name:\"yuzhi\") {id}\n        }\n      `),\n      records,\n      {username: {yuzhi: '1055790163'}}\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns true when scalar field is available', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        firstName: 'Yuzhi',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            firstName\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when scalar field is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            firstName\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when nested fields are available', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        count: 500,\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends {count}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when missing nested field node', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends {count}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns false when missing nested field', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__: 'friends_id',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends {count}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when checking nested plural field', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [{__dataID__: 'client:screenname1'}],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n        service: true,\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            screennames {service}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when nested plural field node is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [{__dataID__: 'client:screenname1'}],\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            screennames {service}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns false when nested plural field is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [{__dataID__: 'client:screenname1'}],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            screennames {service}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when range is available', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when range field has diff calls', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [RelayTestUtils.createCall('first', 10)],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when `edges` is available on non-connections', () => {\n    var records = {\n      viewer_id: {\n        '__configs__{named:\"some_gk\"}': {__dataID__:'configs_id'},\n        __dataID__: 'viewer_id',\n      },\n      configs_id: {\n        __dataID__: 'configs_id',\n        edges: [{__dataID__: 'edge_id'}],\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__:'node_id'},\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        name: 'some_gk',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          viewer {\n            __configs__(named:\"some_gk\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n           }\n        }\n      `),\n      records,\n      {viewer: {'': 'viewer_id'}}\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when missing fields on edge in a range', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__:'node_id'},\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        __typename: 'User',\n        id: 'node_id',\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}, cursor}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(false);\n  });\n\n  it('returns false when missing fields on node in an edge', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__:'node_id'},\n        cursor: 'cursor',\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        __typename: 'User',\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}, cursor}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(false);\n  });\n\n  it('checks fragment when there are no fragment filters', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        username: 'yuzhi',\n      },\n    };\n\n    var fragment1 = Relay.QL`\n      fragment on Node {username}\n    `;\n    var fragment2 = Relay.QL`\n      fragment on Node {name}\n    `;\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id, ${fragment1}}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n    result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id, ${fragment2}}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true if matching fragment data is available', () => {\n    var records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        __typename: 'User',\n        id: '1055790163',\n        name: 'Yuzhi',\n      },\n    };\n    var result = hasData(\n      getNode(Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            ... on User {\n              name\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toBe(true);\n  });\n\n  it('returns false if matching fragment data is unfetched', () => {\n    var records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        __typename: 'User',\n        id: '1055790163',\n      },\n    };\n    var result = hasData(\n      getNode(Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            ... on User {\n              name #unfetched\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toBe(false);\n  });\n\n  it('returns true if non-matching fragment data is missing', () => {\n    var records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        __typename: 'User',\n        id: '1055790163',\n      },\n    };\n    var result = hasData(\n      getNode(Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            # non-matching type - should not count as missing data\n            ... on Page {\n              name\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(true);\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLRange","Relay","RelayConnectionInterface","RelayTestUtils","checkRelayQueryData","RelayRecordStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst checkRelayQueryData = require('checkRelayQueryData');\n\ndescribe('checkRelayQueryData', () => {\n  var RelayRecordStore;\n\n  var {getNode} = RelayTestUtils;\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  function hasData(\n    query,\n    records,\n    rootCallMap,\n    fragmentFilter\n  ) {\n    var store = new RelayRecordStore(\n      {records: records || {}},\n      {rootCallMap: rootCallMap || {}}\n    );\n    return checkRelayQueryData(store, query, fragmentFilter);\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n  });\n\n  it('returns false when node is not in the store', () => {\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id}\n        }\n      `,\n    ));\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when node is null', () => {\n    var records = {\n      1055790163: null,\n    };\n\n    var result = hasData(getNode(\n     Relay.QL`\n       query {\n         node(id:\"1055790163\") {id}\n       }\n     `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns true when checking basic id query', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when a part of the node query is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          nodes(ids:[\"1055790163\",\"4\"]) {id}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when data is available for custom root calls', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          username(name:\"yuzhi\") {id}\n        }\n      `),\n      records,\n      {username: {yuzhi: '1055790163'}}\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns true when scalar field is available', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        firstName: 'Yuzhi',\n        __dataID__: '1055790163',\n        __typename: 'User',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            firstName\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when scalar field is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            firstName\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when nested fields are available', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        count: 500,\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends {count}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when missing nested field node', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends {count}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns false when missing nested field', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__: 'friends_id',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends {count}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when checking nested plural field', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [{__dataID__: 'client:screenname1'}],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n        service: true,\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            screennames {service}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when nested plural field node is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [{__dataID__: 'client:screenname1'}],\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            screennames {service}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns false when nested plural field is missing', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        screennames: [{__dataID__: 'client:screenname1'}],\n      },\n      'client:screenname1': {\n        __dataID__: 'client:screenname1',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            screennames {service}\n          }\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when range is available', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when range field has diff calls', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [RelayTestUtils.createCall('first', 10)],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(false);\n  });\n\n  it('returns true when `edges` is available on non-connections', () => {\n    var records = {\n      viewer_id: {\n        '__configs__{named:\"some_gk\"}': {__dataID__:'configs_id'},\n        __dataID__: 'viewer_id',\n      },\n      configs_id: {\n        __dataID__: 'configs_id',\n        edges: [{__dataID__: 'edge_id'}],\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__:'node_id'},\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        name: 'some_gk',\n      },\n    };\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          viewer {\n            __configs__(named:\"some_gk\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n           }\n        }\n      `),\n      records,\n      {viewer: {'': 'viewer_id'}}\n    );\n\n    expect(result).toEqual(true);\n  });\n\n  it('returns false when missing fields on edge in a range', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__:'node_id'},\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        __typename: 'User',\n        id: 'node_id',\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}, cursor}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(false);\n  });\n\n  it('returns false when missing fields on node in an edge', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        friends: { __dataID__: 'friends_id'},\n      },\n      friends_id: {\n        __dataID__:'friends_id',\n        __range__: new GraphQLRange(),\n      },\n      edge_id: {\n        __dataID__: 'edge_id',\n        node: {__dataID__:'node_id'},\n        cursor: 'cursor',\n      },\n      node_id: {\n        __dataID__: 'node_id',\n        __typename: 'User',\n      },\n    };\n    records.friends_id.__range__.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edge_id'],\n      diffCalls: [],\n      pageInfo: {[HAS_NEXT_PAGE]: false, [HAS_PREV_PAGE]: false },\n    });\n\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            friends(first:\"10\") {\n              edges { node {id}, cursor}\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(false);\n  });\n\n  it('checks fragment when there are no fragment filters', () => {\n    var records = {\n      1055790163: {\n        id: '1055790163',\n        __dataID__: '1055790163',\n        __typename: 'User',\n        username: 'yuzhi',\n      },\n    };\n\n    var fragment1 = Relay.QL`\n      fragment on Node {username}\n    `;\n    var fragment2 = Relay.QL`\n      fragment on Node {name}\n    `;\n    var result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id, ${fragment1}}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(true);\n    result = hasData(getNode(\n      Relay.QL`\n        query {\n          node(id:\"1055790163\") {id, ${fragment2}}\n        }\n      `),\n      records\n    );\n\n    expect(result).toEqual(false);\n  });\n\n  it('returns true if matching fragment data is available', () => {\n    var records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        __typename: 'User',\n        id: '1055790163',\n        name: 'Yuzhi',\n      },\n    };\n    var result = hasData(\n      getNode(Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            ... on User {\n              name\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toBe(true);\n  });\n\n  it('returns false if matching fragment data is unfetched', () => {\n    var records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        __typename: 'User',\n        id: '1055790163',\n      },\n    };\n    var result = hasData(\n      getNode(Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            ... on User {\n              name #unfetched\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toBe(false);\n  });\n\n  it('returns true if non-matching fragment data is missing', () => {\n    var records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        __typename: 'User',\n        id: '1055790163',\n      },\n    };\n    var result = hasData(\n      getNode(Relay.QL`\n        query {\n          node(id:\"1055790163\") {\n            id,\n            # non-matching type - should not count as missing data\n            ... on Page {\n              name\n            }\n          }\n        }\n      `),\n      records\n    );\n    expect(result).toEqual(true);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/traversal/__tests__/checkRelayQueryData-test.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/testEditDistance.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('testEditDistance');\n","dependencies":["testEditDistance"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('testEditDistance');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/testEditDistance.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/relayUnstableBatchedUpdates.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('relayUnstableBatchedUpdates');\n","dependencies":["relayUnstableBatchedUpdates"],"source":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('relayUnstableBatchedUpdates');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/relayUnstableBatchedUpdates.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayTestUtils.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst Map = require('Map');\n\n/**\n * Utility methods (eg. for unmocking Relay internals) and custom Jasmine\n * matchers.\n */\nvar RelayTestUtils = {\n  /**\n   * Returns true if `query` contains a node that equals the `target` node\n   */\n  containsNode(query, target) {\n    function find(node) {\n      if (node.equals(target)) {\n        return true;\n      }\n      var children = node.getChildren();\n      return children.length > 0 && children.some(find);\n    }\n    return find(query);\n  },\n\n  createRenderer(container) {\n    const React = require('React');\n    const ReactDOM = require('ReactDOM');\n    const RelayContext = require('RelayContext');\n    const RelayPropTypes = require('RelayPropTypes');\n    const RelayRoute = require('RelayRoute');\n    const invariant = require('invariant');\n\n    class ContextSetter extends React.Component {\n      getChildContext() {\n        return this.props.context;\n      }\n      render() {\n        return this.props.render();\n      }\n    }\n    ContextSetter.childContextTypes = {\n      relay: RelayPropTypes.Context,\n      route: RelayPropTypes.QueryConfig.isRequired,\n    };\n\n    class MockPointer {\n      constructor(dataID) {\n        this.dataID = dataID;\n      }\n    }\n\n    container = container || document.createElement('div');\n\n    return {\n      render(render, relay, route) {\n        invariant(\n          relay == null || relay instanceof RelayContext,\n          'render(): Expected an instance of `RelayContext`.'\n        );\n        relay = relay || new RelayContext();\n        route = route || RelayRoute.genMockInstance();\n\n        var result;\n        function ref(component) {\n          result = component;\n        }\n        ReactDOM.render(\n          <ContextSetter\n            context={{relay, route}}\n            render={() => {\n              var element = render(dataID => new MockPointer(dataID));\n              var pointers = {};\n              for (var propName in element.props) {\n                var propValue = element.props[propName];\n                if (propValue instanceof MockPointer) {\n                  var fragmentReference = element.type.getFragment(propName);\n                  if (fragmentReference == null) {\n                    throw new Error(\n                      'Query not found, `' + element.type.displayName + '.' +\n                      propName + '`.'\n                    );\n                  }\n                  pointers[propName] = RelayTestUtils.getPointer(\n                    propValue.dataID,\n                    RelayTestUtils.getNode(fragmentReference.getFragment({}))\n                  );\n                }\n              }\n              return React.cloneElement(element, {...pointers, ref});\n            }}\n          />,\n          container\n        );\n        return result;\n      },\n    };\n  },\n\n  conditionOnType(fragment) {\n    const QueryBuilder = require('QueryBuilder');\n    const RelayFragmentReference = require('RelayFragmentReference');\n    const invariant = require('invariant');\n\n    invariant(\n      !!QueryBuilder.getFragment(fragment),\n      'conditionOnType(): Argument must be a GraphQL.QueryFragment.'\n    );\n    var reference = new RelayFragmentReference(\n      () => fragment,\n      {}\n    );\n    reference.conditionOnType();\n    return reference;\n  },\n\n  createCall(name, value) {\n    const QueryBuilder = require('QueryBuilder');\n\n    if (Array.isArray(value)) {\n      value = value.map(QueryBuilder.createCallValue);\n    } else if (value != null) {\n      value = QueryBuilder.createCallValue(value);\n    }\n    return QueryBuilder.createCall(name, value);\n  },\n\n  createContainerFragment(fragment) {\n    const RelayFragmentReference = require('RelayFragmentReference');\n    return RelayFragmentReference.createForContainer(\n      () => fragment,\n      {}\n    );\n  },\n\n  defer(fragment) {\n    const QueryBuilder = require('QueryBuilder');\n    const RelayFragmentReference = require('RelayFragmentReference');\n    const invariant = require('invariant');\n\n    invariant(\n      !!QueryBuilder.getFragment(fragment),\n      'defer(): Argument must be a GraphQL.QueryFragment.'\n    );\n    var reference = new RelayFragmentReference(\n      () => fragment,\n      {}\n    );\n    reference.defer();\n    return reference;\n  },\n\n  getNode(node, variables) {\n    const RelayMetaRoute = require('RelayMetaRoute');\n    const RelayQuery = require('RelayQuery');\n\n    var route = RelayMetaRoute.get('$RelayTestUtils');\n    return RelayQuery.Node.create(node, route, variables || {});\n  },\n\n  getPointer(dataID, fragment) {\n    const RelayFragmentPointer = require('RelayFragmentPointer');\n    const RelayQuery = require('RelayQuery');\n    const invariant = require('invariant');\n\n    invariant(\n      fragment instanceof RelayQuery.Fragment,\n      'getPointer(): expected a `RelayQueryFragment`, got `%s`.',\n      fragment.constructor.name\n    );\n\n    return RelayFragmentPointer.create(dataID, fragment);\n  },\n\n  /**\n   * Convenience method for turning `node` into a properly formed ref query. We\n   * can't produce one of these solely with `Relay.QL`, so we use a node from\n   * `Relay.QL` as a basis and attach the appropriate args and ref params.\n   */\n  getRefNode(node, refParam) {\n    const QueryBuilder = require('QueryBuilder');\n    const RelayQuery = require('RelayQuery');\n    const RelayMetaRoute = require('RelayMetaRoute');\n\n    const invariant = require('invariant');\n\n    invariant(\n      node.fieldName === 'nodes',\n     'getRefNode(): Ref queries require `nodes()` roots.'\n    );\n    var callValue = Array.isArray(node.calls[0].value) ?\n      node.calls[0].value[0] :\n      node.calls[0].value;\n    invariant(\n      !!QueryBuilder.getCallVariable(callValue),\n      'getRefNode(): Expected a batch call variable, got `%s`.',\n      JSON.stringify(callValue)\n    );\n    var name = callValue.callVariableName;\n    var match = name.match(/^ref_(q\\d+)$/);\n    invariant(\n      match,\n      'getRefNode(): Expected call variable of the form `<ref_q\\\\d+>`.'\n    );\n    // e.g. `q0`\n    var id = match[1];\n    // e.g. `{ref_q0: '<ref_q0>'}`\n    var variables = {[name]: '<' + callValue.callVariableName + '>'};\n\n    return RelayQuery.Root.create(\n      {\n        ...node,\n        calls: [QueryBuilder.createCall(\n          'id',\n          QueryBuilder.createBatchCallVariable(id, refParam.path)\n        )],\n        isDeferred: true,\n      },\n      RelayMetaRoute.get('$RelayTestUtils'),\n      variables\n    );\n  },\n\n  getVerbatimNode(node, variables) {\n    return RelayTestUtils.filterGeneratedFields(\n      RelayTestUtils.getNode(node, variables)\n    );\n  },\n\n  filterGeneratedFields(query) {\n    const RelayQuery = require('RelayQuery');\n    const filterRelayQuery = require('filterRelayQuery');\n\n    return filterRelayQuery(\n      query,\n      node => !(node instanceof RelayQuery.Field && node.isGenerated())\n    );\n  },\n\n  matchers: {\n\n    /**\n     * Checks if a RelayQuery.Root is `===` to another.\n     */\n    toBeQueryRoot() {\n      return {\n        compare(actual, expected) {\n          const RelayQuery = require('RelayQuery');\n          var queryType = checkQueryType(actual, expected, RelayQuery.Root);\n          if (!queryType.pass) {\n            return queryType;\n          }\n          return checkQueryEquality(actual, expected, true);\n        },\n      };\n    },\n\n    /**\n     * Checks that `warning` was invoked with a falsey condition with expected\n     * arguments the supplied number of times. Example usage:\n     *\n     *   warning(false, \"format\", \"x\", \"y\");\n     *   warning(false, \"format\", \"x\", \"z\");\n     *\n     *   expect([\"format\", \"x\", \"y\"]).toBeWarnedNTimes(1);\n     *   expect([\"format\", \"x\", \"z\"]).toBeWarnedNTimes(1);\n     *   expect([\"format\", \"x\"]).toBeWarnedNTimes(2);\n     *\n     *   warning(false, \"format\", \"y\");\n     *\n     *   expect([\"format\", \"y\"]).toBeWarnedNTimes(1);\n     *\n     *   warning(true, \"format\", \"z\");\n     *\n     *   expect([\"format\", \"z\"]).toBeWarnedNTimes(0);\n     *\n     *   expect([\"format\"]).toBeWarnedNTimes(3);\n     *\n     */\n    toBeWarnedNTimes() {\n      return {\n        compare(actual, expectedCount) {\n          const warning = require('warning');\n          if (!warning.mock) {\n            throw new Error(\n              'expect(...).toBeWarnedNTimes(): Requires ' +\n              '`jest.mock(\\'warning\\');`.'\n            );\n          }\n          var expectedArgs = actual;\n          if (!Array.isArray(expectedArgs)) {\n            throw new Error(\n              'expect(...).toBeWarnedNTimes(): Requires an array of ' +\n              'warning args.'\n            );\n          }\n          var [format, ...values] = expectedArgs;\n          if (!format) {\n            throw new Error(\n              'expect(...).toBeWarnedNTimes(): Requires a format string.'\n            );\n          }\n\n          var callsWithExpectedFormatButArgs = [];\n          var callsWithExpectedArgs = warning.mock.calls.filter(args => {\n            if (args[0] ||\n                args[1] !== format) {\n              return false;\n            }\n            if (values.some((value, ii) => value !== args[ii + 2])) {\n              callsWithExpectedFormatButArgs.push(args.slice(1));\n              return false;\n            }\n            return true;\n          });\n\n          var message =\n            'Expected to warn ' + expectedCount + ' time' +\n            (expectedCount === 1 ? '' : 's') + ' with arguments: ' +\n            JSON.stringify(expectedArgs) + '.';\n          var unexpectedCount = callsWithExpectedFormatButArgs.length;\n          if (unexpectedCount) {\n            message += ' Instead, called ' + unexpectedCount +\n            ' time' + (unexpectedCount === 1 ? '' : 's') + ' with arguments: ' +\n            JSON.stringify(callsWithExpectedFormatButArgs) + '.';\n          }\n\n          return {\n            pass: callsWithExpectedArgs.length === expectedCount,\n            message,\n          };\n        },\n      };\n    },\n\n    /**\n     * Checks if a query node contains a node that `equals()` another.\n     */\n    toContainQueryNode() {\n      return {\n        compare(actual, expected) {\n          if (!RelayTestUtils.containsNode(actual, expected)) {\n            return {\n              pass: false,\n              message: printQueryComparison(\n                actual,\n                expected,\n                'to contain query node'\n              ),\n            };\n          }\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n\n    toEqualPrintedQuery() {\n      return {\n        compare(actual, expected) {\n          var minifiedActual = RelayTestUtils.minifyQueryText(actual);\n          var minifiedExpected = RelayTestUtils.minifyQueryText(expected);\n\n          if (minifiedActual !== minifiedExpected) {\n            return {\n              pass: false,\n              message: [\n                minifiedActual,\n                'to equal',\n                minifiedExpected,\n              ].join('\\n'),\n            };\n          }\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n\n    /**\n     * Checks if a RelayQuery.Node is `equals()` to another.\n     */\n    toEqualQueryNode() {\n      return {\n        compare(actual, expected) {\n          const RelayQuery = require('RelayQuery');\n          var queryType = checkQueryType(actual, expected, RelayQuery.Node);\n          if (!queryType.pass) {\n            return queryType;\n          }\n          return checkQueryEquality(actual, expected, false);\n        },\n      };\n    },\n\n    /**\n     * Checks if a RelayQuery.Root is `equals()` to another.\n     */\n    toEqualQueryRoot() {\n      return {\n        compare(actual, expected) {\n          const RelayQuery = require('RelayQuery');\n          var queryType = checkQueryType(actual, expected, RelayQuery.Root);\n          if (!queryType.pass) {\n            return queryType;\n          }\n          return checkQueryEquality(actual, expected, false);\n        },\n      };\n    },\n\n    toFailInvariant() {\n      return {\n        compare(actual, expected) {\n          expect(actual).toThrowError(expected);\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n\n    /**\n     * Compares a query path with another path. Succeeds when the paths are of\n     * the same length have equivalent (shallow-equal) roots and fields.\n     */\n    toMatchPath() {\n      return {\n        compare(actual, expected) {\n          const QueryBuilder = require('QueryBuilder');\n          const RelayMetaRoute = require('RelayMetaRoute');\n          const RelayNodeInterface = require('RelayNodeInterface');\n          const RelayQuery = require('RelayQuery');\n          const RelayQueryPath = require('RelayQueryPath');\n\n          const invariant = require('invariant');\n          const printRelayQuery = require('printRelayQuery');\n\n          invariant(\n            expected && expected instanceof RelayQueryPath,\n            'expect(...).toMatchPath(): Argument must be a RelayQueryPath.'\n          );\n          if (!(actual instanceof RelayQueryPath)) {\n            var name = actual ? actual.constructor.name : actual;\n            return {\n              pass: false,\n              message: `expected instance of RelayQueryPath but got [${name}]`,\n            };\n          }\n          var fragment = RelayQuery.Fragment.create(\n            QueryBuilder.createFragment({\n              children: [QueryBuilder.createField({\n                fieldName: '__test__',\n              })],\n              name: 'Test',\n              type: 'Node',\n            }),\n            RelayMetaRoute.get('$RelayTestUtils'),\n            {}\n          );\n          const mockStore = {\n            getDataID(fieldName: string, id: string): string {\n              invariant(\n                fieldName === RelayNodeInterface.NODE,\n                'RelayTestUtils: Cannot `getDataID` for non-node root call ' +\n                '`%s`.',\n                fieldName\n              );\n              return id;\n            },\n            getType() {\n              return 'RelayTestUtils';\n            },\n          };\n\n          var actualQuery = actual.getQuery(mockStore, fragment);\n          var expectedQuery = expected.getQuery(mockStore, fragment);\n\n          if (!actualQuery.equals(expectedQuery)) {\n            return {\n              pass: false,\n              message: [\n                'Expected:',\n                '  ' + printRelayQuery(actualQuery).text,\n                '\\ntoMatchPath:',\n                '  ' + printRelayQuery(expectedQuery).text,\n              ].filter(token => token).join('\\n'),\n            };\n          }\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n  },\n\n  /**\n   * Returns a version of the query text with extraneous whitespace removed.\n   */\n  minifyQueryText(queryText) {\n    return queryText\n      .replace(/\\n+/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .replace(/\\s*([\\{\\}\\(\\):,])\\s*/g, '$1')\n      .trim();\n  },\n\n  /**\n   * Helper to write the result payload of a (root) query into a store,\n   * returning created/updated ID sets. The payload is transformed before\n   * writing; property keys are rewritten from application names into\n   * serialization keys matching the fields in the query.\n   */\n  writePayload(store, writer, query, payload, tracker, options) {\n    const transformRelayQueryPayload = require('transformRelayQueryPayload');\n\n    return RelayTestUtils.writeVerbatimPayload(\n      store,\n      writer,\n      query,\n      transformRelayQueryPayload(query, payload),\n      tracker,\n      options\n    );\n  },\n\n  /**\n   * Helper to write the result payload into a store. Unlike `writePayload`,\n   * the payload is not transformed first.\n   */\n  writeVerbatimPayload(store, writer, query, payload, tracker, options) {\n    const RelayChangeTracker = require('RelayChangeTracker');\n    const RelayQueryTracker = require('RelayQueryTracker');\n    const RelayQueryWriter = require('RelayQueryWriter');\n    const writeRelayQueryPayload = require('writeRelayQueryPayload');\n\n    tracker = tracker || new RelayQueryTracker();\n    options = options || {};\n    var changeTracker = new RelayChangeTracker();\n    var queryWriter = new RelayQueryWriter(\n      store,\n      writer,\n      tracker,\n      changeTracker,\n      options\n    );\n    writeRelayQueryPayload(\n      queryWriter,\n      query,\n      payload,\n    );\n    return changeTracker.getChangeSet();\n  },\n};\n\n/**\n * @private\n */\nfunction checkQueryType(actual, expected, ExpectedClass) {\n  var expectedType = ExpectedClass.name;\n  if (!(expected && expected instanceof ExpectedClass)) {\n    throw new Error('expect(...): Requires a `' + expectedType + '`.');\n  }\n  if (!(actual instanceof ExpectedClass)) {\n    var actualType = actual;\n    if (actual && actual.constructor) {\n      actualType = actual.constructor.name;\n    }\n    return {\n      pass: false,\n      message: 'Expected a `' + expectedType + '`, got `' + actualType + '`.',\n    };\n  }\n  return {\n    pass: true,\n  };\n}\n\n/**\n * @private\n */\nfunction checkQueryEquality(actual, expected, toBe) {\n  var flatActual = sortRelayQuery(actual);\n  var flatExpected = sortRelayQuery(expected);\n\n  if (toBe ? (actual !== expected) : (!flatActual.equals(flatExpected))) {\n    return {\n      pass: false,\n      message: printQueryComparison(\n        actual,\n        expected,\n        toBe ? 'to be query' : 'to equal query'\n      ),\n    };\n  }\n\n  return {\n    pass: true,\n  };\n}\n\n/**\n * @private\n */\nfunction printQueryComparison(actual, expected, message) {\n  const printRelayQuery = require('printRelayQuery');\n\n  var formatRefParam = node => node.hasRefParam && node.hasRefParam() ?\n      '  [ref param: ' + JSON.stringify(node.getRefParam()) + ']' :\n      null;\n\n  return [\n    'Expected:',\n    '  ' + printRelayQuery(actual).text,\n    formatRefParam(actual),\n    message + ':',\n    '  ' + printRelayQuery(expected).text,\n    formatRefParam(expected),\n  ].filter(line => !!line).join('\\n');\n}\n\n/**\n * @private\n *\n * Simulates sort key that existed when `getConcreteFragmentID` used to exist.\n */\nconst concreteFragmentSortKeys = new Map();\nfunction createFragmentSortKey(node) {\n  const stableStringify = require('stableStringify');\n  const concreteNode = node.__concreteNode__;\n  if (!concreteFragmentSortKeys.has(concreteNode)) {\n    concreteFragmentSortKeys.set(concreteNode, concreteFragmentSortKeys.size);\n  }\n  return [\n    concreteFragmentSortKeys.get(concreteNode),\n    node.getRoute().name,\n    stableStringify(node.getVariables()),\n  ].join('.');\n}\n\n/**\n * @private\n */\nfunction sortRelayQuery(node) {\n  const RelayQuery = require('RelayQuery');\n\n  function getSortableKey(node) {\n    return node instanceof RelayQuery.Fragment ?\n      createFragmentSortKey(node) :\n      node.getShallowHash();\n  }\n  function compare(a, b) {\n    if (a === b) {\n      return 0;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n\n  return node.clone(node.getChildren().sort((a, b) => {\n    var aKey = getSortableKey(a);\n    var bKey = getSortableKey(b);\n    return compare(aKey, bKey);\n  }).map(sortRelayQuery));\n}\n\nmodule.exports = RelayTestUtils;\n","dependencies":["Map","React","ReactDOM","RelayContext","RelayPropTypes","RelayRoute","invariant","QueryBuilder","RelayFragmentReference","RelayMetaRoute","RelayQuery","RelayFragmentPointer","filterRelayQuery","warning","RelayNodeInterface","RelayQueryPath","printRelayQuery","transformRelayQueryPayload","RelayChangeTracker","RelayQueryTracker","RelayQueryWriter","writeRelayQueryPayload","stableStringify"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst Map = require('Map');\n\n/**\n * Utility methods (eg. for unmocking Relay internals) and custom Jasmine\n * matchers.\n */\nvar RelayTestUtils = {\n  /**\n   * Returns true if `query` contains a node that equals the `target` node\n   */\n  containsNode(query, target) {\n    function find(node) {\n      if (node.equals(target)) {\n        return true;\n      }\n      var children = node.getChildren();\n      return children.length > 0 && children.some(find);\n    }\n    return find(query);\n  },\n\n  createRenderer(container) {\n    const React = require('React');\n    const ReactDOM = require('ReactDOM');\n    const RelayContext = require('RelayContext');\n    const RelayPropTypes = require('RelayPropTypes');\n    const RelayRoute = require('RelayRoute');\n    const invariant = require('invariant');\n\n    class ContextSetter extends React.Component {\n      getChildContext() {\n        return this.props.context;\n      }\n      render() {\n        return this.props.render();\n      }\n    }\n    ContextSetter.childContextTypes = {\n      relay: RelayPropTypes.Context,\n      route: RelayPropTypes.QueryConfig.isRequired,\n    };\n\n    class MockPointer {\n      constructor(dataID) {\n        this.dataID = dataID;\n      }\n    }\n\n    container = container || document.createElement('div');\n\n    return {\n      render(render, relay, route) {\n        invariant(\n          relay == null || relay instanceof RelayContext,\n          'render(): Expected an instance of `RelayContext`.'\n        );\n        relay = relay || new RelayContext();\n        route = route || RelayRoute.genMockInstance();\n\n        var result;\n        function ref(component) {\n          result = component;\n        }\n        ReactDOM.render(\n          <ContextSetter\n            context={{relay, route}}\n            render={() => {\n              var element = render(dataID => new MockPointer(dataID));\n              var pointers = {};\n              for (var propName in element.props) {\n                var propValue = element.props[propName];\n                if (propValue instanceof MockPointer) {\n                  var fragmentReference = element.type.getFragment(propName);\n                  if (fragmentReference == null) {\n                    throw new Error(\n                      'Query not found, `' + element.type.displayName + '.' +\n                      propName + '`.'\n                    );\n                  }\n                  pointers[propName] = RelayTestUtils.getPointer(\n                    propValue.dataID,\n                    RelayTestUtils.getNode(fragmentReference.getFragment({}))\n                  );\n                }\n              }\n              return React.cloneElement(element, {...pointers, ref});\n            }}\n          />,\n          container\n        );\n        return result;\n      },\n    };\n  },\n\n  conditionOnType(fragment) {\n    const QueryBuilder = require('QueryBuilder');\n    const RelayFragmentReference = require('RelayFragmentReference');\n    const invariant = require('invariant');\n\n    invariant(\n      !!QueryBuilder.getFragment(fragment),\n      'conditionOnType(): Argument must be a GraphQL.QueryFragment.'\n    );\n    var reference = new RelayFragmentReference(\n      () => fragment,\n      {}\n    );\n    reference.conditionOnType();\n    return reference;\n  },\n\n  createCall(name, value) {\n    const QueryBuilder = require('QueryBuilder');\n\n    if (Array.isArray(value)) {\n      value = value.map(QueryBuilder.createCallValue);\n    } else if (value != null) {\n      value = QueryBuilder.createCallValue(value);\n    }\n    return QueryBuilder.createCall(name, value);\n  },\n\n  createContainerFragment(fragment) {\n    const RelayFragmentReference = require('RelayFragmentReference');\n    return RelayFragmentReference.createForContainer(\n      () => fragment,\n      {}\n    );\n  },\n\n  defer(fragment) {\n    const QueryBuilder = require('QueryBuilder');\n    const RelayFragmentReference = require('RelayFragmentReference');\n    const invariant = require('invariant');\n\n    invariant(\n      !!QueryBuilder.getFragment(fragment),\n      'defer(): Argument must be a GraphQL.QueryFragment.'\n    );\n    var reference = new RelayFragmentReference(\n      () => fragment,\n      {}\n    );\n    reference.defer();\n    return reference;\n  },\n\n  getNode(node, variables) {\n    const RelayMetaRoute = require('RelayMetaRoute');\n    const RelayQuery = require('RelayQuery');\n\n    var route = RelayMetaRoute.get('$RelayTestUtils');\n    return RelayQuery.Node.create(node, route, variables || {});\n  },\n\n  getPointer(dataID, fragment) {\n    const RelayFragmentPointer = require('RelayFragmentPointer');\n    const RelayQuery = require('RelayQuery');\n    const invariant = require('invariant');\n\n    invariant(\n      fragment instanceof RelayQuery.Fragment,\n      'getPointer(): expected a `RelayQueryFragment`, got `%s`.',\n      fragment.constructor.name\n    );\n\n    return RelayFragmentPointer.create(dataID, fragment);\n  },\n\n  /**\n   * Convenience method for turning `node` into a properly formed ref query. We\n   * can't produce one of these solely with `Relay.QL`, so we use a node from\n   * `Relay.QL` as a basis and attach the appropriate args and ref params.\n   */\n  getRefNode(node, refParam) {\n    const QueryBuilder = require('QueryBuilder');\n    const RelayQuery = require('RelayQuery');\n    const RelayMetaRoute = require('RelayMetaRoute');\n\n    const invariant = require('invariant');\n\n    invariant(\n      node.fieldName === 'nodes',\n     'getRefNode(): Ref queries require `nodes()` roots.'\n    );\n    var callValue = Array.isArray(node.calls[0].value) ?\n      node.calls[0].value[0] :\n      node.calls[0].value;\n    invariant(\n      !!QueryBuilder.getCallVariable(callValue),\n      'getRefNode(): Expected a batch call variable, got `%s`.',\n      JSON.stringify(callValue)\n    );\n    var name = callValue.callVariableName;\n    var match = name.match(/^ref_(q\\d+)$/);\n    invariant(\n      match,\n      'getRefNode(): Expected call variable of the form `<ref_q\\\\d+>`.'\n    );\n    // e.g. `q0`\n    var id = match[1];\n    // e.g. `{ref_q0: '<ref_q0>'}`\n    var variables = {[name]: '<' + callValue.callVariableName + '>'};\n\n    return RelayQuery.Root.create(\n      {\n        ...node,\n        calls: [QueryBuilder.createCall(\n          'id',\n          QueryBuilder.createBatchCallVariable(id, refParam.path)\n        )],\n        isDeferred: true,\n      },\n      RelayMetaRoute.get('$RelayTestUtils'),\n      variables\n    );\n  },\n\n  getVerbatimNode(node, variables) {\n    return RelayTestUtils.filterGeneratedFields(\n      RelayTestUtils.getNode(node, variables)\n    );\n  },\n\n  filterGeneratedFields(query) {\n    const RelayQuery = require('RelayQuery');\n    const filterRelayQuery = require('filterRelayQuery');\n\n    return filterRelayQuery(\n      query,\n      node => !(node instanceof RelayQuery.Field && node.isGenerated())\n    );\n  },\n\n  matchers: {\n\n    /**\n     * Checks if a RelayQuery.Root is `===` to another.\n     */\n    toBeQueryRoot() {\n      return {\n        compare(actual, expected) {\n          const RelayQuery = require('RelayQuery');\n          var queryType = checkQueryType(actual, expected, RelayQuery.Root);\n          if (!queryType.pass) {\n            return queryType;\n          }\n          return checkQueryEquality(actual, expected, true);\n        },\n      };\n    },\n\n    /**\n     * Checks that `warning` was invoked with a falsey condition with expected\n     * arguments the supplied number of times. Example usage:\n     *\n     *   warning(false, \"format\", \"x\", \"y\");\n     *   warning(false, \"format\", \"x\", \"z\");\n     *\n     *   expect([\"format\", \"x\", \"y\"]).toBeWarnedNTimes(1);\n     *   expect([\"format\", \"x\", \"z\"]).toBeWarnedNTimes(1);\n     *   expect([\"format\", \"x\"]).toBeWarnedNTimes(2);\n     *\n     *   warning(false, \"format\", \"y\");\n     *\n     *   expect([\"format\", \"y\"]).toBeWarnedNTimes(1);\n     *\n     *   warning(true, \"format\", \"z\");\n     *\n     *   expect([\"format\", \"z\"]).toBeWarnedNTimes(0);\n     *\n     *   expect([\"format\"]).toBeWarnedNTimes(3);\n     *\n     */\n    toBeWarnedNTimes() {\n      return {\n        compare(actual, expectedCount) {\n          const warning = require('warning');\n          if (!warning.mock) {\n            throw new Error(\n              'expect(...).toBeWarnedNTimes(): Requires ' +\n              '`jest.mock(\\'warning\\');`.'\n            );\n          }\n          var expectedArgs = actual;\n          if (!Array.isArray(expectedArgs)) {\n            throw new Error(\n              'expect(...).toBeWarnedNTimes(): Requires an array of ' +\n              'warning args.'\n            );\n          }\n          var [format, ...values] = expectedArgs;\n          if (!format) {\n            throw new Error(\n              'expect(...).toBeWarnedNTimes(): Requires a format string.'\n            );\n          }\n\n          var callsWithExpectedFormatButArgs = [];\n          var callsWithExpectedArgs = warning.mock.calls.filter(args => {\n            if (args[0] ||\n                args[1] !== format) {\n              return false;\n            }\n            if (values.some((value, ii) => value !== args[ii + 2])) {\n              callsWithExpectedFormatButArgs.push(args.slice(1));\n              return false;\n            }\n            return true;\n          });\n\n          var message =\n            'Expected to warn ' + expectedCount + ' time' +\n            (expectedCount === 1 ? '' : 's') + ' with arguments: ' +\n            JSON.stringify(expectedArgs) + '.';\n          var unexpectedCount = callsWithExpectedFormatButArgs.length;\n          if (unexpectedCount) {\n            message += ' Instead, called ' + unexpectedCount +\n            ' time' + (unexpectedCount === 1 ? '' : 's') + ' with arguments: ' +\n            JSON.stringify(callsWithExpectedFormatButArgs) + '.';\n          }\n\n          return {\n            pass: callsWithExpectedArgs.length === expectedCount,\n            message,\n          };\n        },\n      };\n    },\n\n    /**\n     * Checks if a query node contains a node that `equals()` another.\n     */\n    toContainQueryNode() {\n      return {\n        compare(actual, expected) {\n          if (!RelayTestUtils.containsNode(actual, expected)) {\n            return {\n              pass: false,\n              message: printQueryComparison(\n                actual,\n                expected,\n                'to contain query node'\n              ),\n            };\n          }\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n\n    toEqualPrintedQuery() {\n      return {\n        compare(actual, expected) {\n          var minifiedActual = RelayTestUtils.minifyQueryText(actual);\n          var minifiedExpected = RelayTestUtils.minifyQueryText(expected);\n\n          if (minifiedActual !== minifiedExpected) {\n            return {\n              pass: false,\n              message: [\n                minifiedActual,\n                'to equal',\n                minifiedExpected,\n              ].join('\\n'),\n            };\n          }\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n\n    /**\n     * Checks if a RelayQuery.Node is `equals()` to another.\n     */\n    toEqualQueryNode() {\n      return {\n        compare(actual, expected) {\n          const RelayQuery = require('RelayQuery');\n          var queryType = checkQueryType(actual, expected, RelayQuery.Node);\n          if (!queryType.pass) {\n            return queryType;\n          }\n          return checkQueryEquality(actual, expected, false);\n        },\n      };\n    },\n\n    /**\n     * Checks if a RelayQuery.Root is `equals()` to another.\n     */\n    toEqualQueryRoot() {\n      return {\n        compare(actual, expected) {\n          const RelayQuery = require('RelayQuery');\n          var queryType = checkQueryType(actual, expected, RelayQuery.Root);\n          if (!queryType.pass) {\n            return queryType;\n          }\n          return checkQueryEquality(actual, expected, false);\n        },\n      };\n    },\n\n    toFailInvariant() {\n      return {\n        compare(actual, expected) {\n          expect(actual).toThrowError(expected);\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n\n    /**\n     * Compares a query path with another path. Succeeds when the paths are of\n     * the same length have equivalent (shallow-equal) roots and fields.\n     */\n    toMatchPath() {\n      return {\n        compare(actual, expected) {\n          const QueryBuilder = require('QueryBuilder');\n          const RelayMetaRoute = require('RelayMetaRoute');\n          const RelayNodeInterface = require('RelayNodeInterface');\n          const RelayQuery = require('RelayQuery');\n          const RelayQueryPath = require('RelayQueryPath');\n\n          const invariant = require('invariant');\n          const printRelayQuery = require('printRelayQuery');\n\n          invariant(\n            expected && expected instanceof RelayQueryPath,\n            'expect(...).toMatchPath(): Argument must be a RelayQueryPath.'\n          );\n          if (!(actual instanceof RelayQueryPath)) {\n            var name = actual ? actual.constructor.name : actual;\n            return {\n              pass: false,\n              message: `expected instance of RelayQueryPath but got [${name}]`,\n            };\n          }\n          var fragment = RelayQuery.Fragment.create(\n            QueryBuilder.createFragment({\n              children: [QueryBuilder.createField({\n                fieldName: '__test__',\n              })],\n              name: 'Test',\n              type: 'Node',\n            }),\n            RelayMetaRoute.get('$RelayTestUtils'),\n            {}\n          );\n          const mockStore = {\n            getDataID(fieldName: string, id: string): string {\n              invariant(\n                fieldName === RelayNodeInterface.NODE,\n                'RelayTestUtils: Cannot `getDataID` for non-node root call ' +\n                '`%s`.',\n                fieldName\n              );\n              return id;\n            },\n            getType() {\n              return 'RelayTestUtils';\n            },\n          };\n\n          var actualQuery = actual.getQuery(mockStore, fragment);\n          var expectedQuery = expected.getQuery(mockStore, fragment);\n\n          if (!actualQuery.equals(expectedQuery)) {\n            return {\n              pass: false,\n              message: [\n                'Expected:',\n                '  ' + printRelayQuery(actualQuery).text,\n                '\\ntoMatchPath:',\n                '  ' + printRelayQuery(expectedQuery).text,\n              ].filter(token => token).join('\\n'),\n            };\n          }\n          return {\n            pass: true,\n          };\n        },\n      };\n    },\n  },\n\n  /**\n   * Returns a version of the query text with extraneous whitespace removed.\n   */\n  minifyQueryText(queryText) {\n    return queryText\n      .replace(/\\n+/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .replace(/\\s*([\\{\\}\\(\\):,])\\s*/g, '$1')\n      .trim();\n  },\n\n  /**\n   * Helper to write the result payload of a (root) query into a store,\n   * returning created/updated ID sets. The payload is transformed before\n   * writing; property keys are rewritten from application names into\n   * serialization keys matching the fields in the query.\n   */\n  writePayload(store, writer, query, payload, tracker, options) {\n    const transformRelayQueryPayload = require('transformRelayQueryPayload');\n\n    return RelayTestUtils.writeVerbatimPayload(\n      store,\n      writer,\n      query,\n      transformRelayQueryPayload(query, payload),\n      tracker,\n      options\n    );\n  },\n\n  /**\n   * Helper to write the result payload into a store. Unlike `writePayload`,\n   * the payload is not transformed first.\n   */\n  writeVerbatimPayload(store, writer, query, payload, tracker, options) {\n    const RelayChangeTracker = require('RelayChangeTracker');\n    const RelayQueryTracker = require('RelayQueryTracker');\n    const RelayQueryWriter = require('RelayQueryWriter');\n    const writeRelayQueryPayload = require('writeRelayQueryPayload');\n\n    tracker = tracker || new RelayQueryTracker();\n    options = options || {};\n    var changeTracker = new RelayChangeTracker();\n    var queryWriter = new RelayQueryWriter(\n      store,\n      writer,\n      tracker,\n      changeTracker,\n      options\n    );\n    writeRelayQueryPayload(\n      queryWriter,\n      query,\n      payload,\n    );\n    return changeTracker.getChangeSet();\n  },\n};\n\n/**\n * @private\n */\nfunction checkQueryType(actual, expected, ExpectedClass) {\n  var expectedType = ExpectedClass.name;\n  if (!(expected && expected instanceof ExpectedClass)) {\n    throw new Error('expect(...): Requires a `' + expectedType + '`.');\n  }\n  if (!(actual instanceof ExpectedClass)) {\n    var actualType = actual;\n    if (actual && actual.constructor) {\n      actualType = actual.constructor.name;\n    }\n    return {\n      pass: false,\n      message: 'Expected a `' + expectedType + '`, got `' + actualType + '`.',\n    };\n  }\n  return {\n    pass: true,\n  };\n}\n\n/**\n * @private\n */\nfunction checkQueryEquality(actual, expected, toBe) {\n  var flatActual = sortRelayQuery(actual);\n  var flatExpected = sortRelayQuery(expected);\n\n  if (toBe ? (actual !== expected) : (!flatActual.equals(flatExpected))) {\n    return {\n      pass: false,\n      message: printQueryComparison(\n        actual,\n        expected,\n        toBe ? 'to be query' : 'to equal query'\n      ),\n    };\n  }\n\n  return {\n    pass: true,\n  };\n}\n\n/**\n * @private\n */\nfunction printQueryComparison(actual, expected, message) {\n  const printRelayQuery = require('printRelayQuery');\n\n  var formatRefParam = node => node.hasRefParam && node.hasRefParam() ?\n      '  [ref param: ' + JSON.stringify(node.getRefParam()) + ']' :\n      null;\n\n  return [\n    'Expected:',\n    '  ' + printRelayQuery(actual).text,\n    formatRefParam(actual),\n    message + ':',\n    '  ' + printRelayQuery(expected).text,\n    formatRefParam(expected),\n  ].filter(line => !!line).join('\\n');\n}\n\n/**\n * @private\n *\n * Simulates sort key that existed when `getConcreteFragmentID` used to exist.\n */\nconst concreteFragmentSortKeys = new Map();\nfunction createFragmentSortKey(node) {\n  const stableStringify = require('stableStringify');\n  const concreteNode = node.__concreteNode__;\n  if (!concreteFragmentSortKeys.has(concreteNode)) {\n    concreteFragmentSortKeys.set(concreteNode, concreteFragmentSortKeys.size);\n  }\n  return [\n    concreteFragmentSortKeys.get(concreteNode),\n    node.getRoute().name,\n    stableStringify(node.getVariables()),\n  ].join('.');\n}\n\n/**\n * @private\n */\nfunction sortRelayQuery(node) {\n  const RelayQuery = require('RelayQuery');\n\n  function getSortableKey(node) {\n    return node instanceof RelayQuery.Fragment ?\n      createFragmentSortKey(node) :\n      node.getShallowHash();\n  }\n  function compare(a, b) {\n    if (a === b) {\n      return 0;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n\n  return node.clone(node.getChildren().sort((a, b) => {\n    var aKey = getSortableKey(a);\n    var bKey = getSortableKey(b);\n    return compare(aKey, bKey);\n  }).map(sortRelayQuery));\n}\n\nmodule.exports = RelayTestUtils;\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayTestUtils.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayTaskScheduler.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayTaskScheduler');\n","dependencies":["RelayTaskScheduler"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayTaskScheduler');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayTaskScheduler.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayProfiler.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst emptyFunction = require('emptyFunction');\nconst forEachObject = require('forEachObject');\n\nvar RelayProfiler = {\n  instrumentMethods: jest.genMockFunction().mockImplementation(\n    (object, names) => {\n      forEachObject(names, (name, key) => {\n        object[key] = RelayProfiler.instrument(name, object[key]);\n      });\n    }\n  ),\n  instrument: jest.genMockFunction().mockImplementation(\n    (name, handler) => {\n      handler.attachHandler = emptyFunction;\n      handler.detachHandler = emptyFunction;\n      return handler;\n    }\n  ),\n  attachAggregateHandler: jest.genMockFunction(),\n  detachAggregateHandler: jest.genMockFunction(),\n  profile: jest.genMockFunction().mockImplementation(() => {\n    return {\n      stop: jest.genMockFunction(),\n    };\n  }),\n  attachProfileHandler: jest.genMockFunction(),\n  detachProfileHandler: jest.genMockFunction(),\n};\n\nmodule.exports = RelayProfiler;\n","dependencies":["emptyFunction","forEachObject"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst emptyFunction = require('emptyFunction');\nconst forEachObject = require('forEachObject');\n\nvar RelayProfiler = {\n  instrumentMethods: jest.genMockFunction().mockImplementation(\n    (object, names) => {\n      forEachObject(names, (name, key) => {\n        object[key] = RelayProfiler.instrument(name, object[key]);\n      });\n    }\n  ),\n  instrument: jest.genMockFunction().mockImplementation(\n    (name, handler) => {\n      handler.attachHandler = emptyFunction;\n      handler.detachHandler = emptyFunction;\n      return handler;\n    }\n  ),\n  attachAggregateHandler: jest.genMockFunction(),\n  detachAggregateHandler: jest.genMockFunction(),\n  profile: jest.genMockFunction().mockImplementation(() => {\n    return {\n      stop: jest.genMockFunction(),\n    };\n  }),\n  attachProfileHandler: jest.genMockFunction(),\n  detachProfileHandler: jest.genMockFunction(),\n};\n\nmodule.exports = RelayProfiler;\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayProfiler.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayMetricsRecorder.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMetricsRecorder');\n","dependencies":["RelayMetricsRecorder"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMetricsRecorder');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayMetricsRecorder.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayError.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayError');\n","dependencies":["RelayError"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayError');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayError.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayDeprecated.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayDeprecated');\n","dependencies":["RelayDeprecated"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayDeprecated');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/RelayDeprecated.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/matchRecord.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\ntype Result = {\n  isMatched: boolean;\n  message: ?string;\n  path: ?Array<string>;\n};\n\nconst METADATA_KEYS = {\n  '__dataID__': true,\n  '__range__': true,\n  '__resolvedFragmentMap__': true,\n  '__resolvedFragmentMapGeneration__': true,\n  '__status__': true,\n};\n\nfunction match(\n  actual: any,\n  expected: any,\n  path: Array<string>\n): Result {\n  if (typeof actual !== 'object') {\n    return {\n      isMatched: actual === expected,\n      message: 'be ' + expected + ', but got ' + actual,\n      path,\n    };\n  }\n\n  // all properties (lest __dataID__s) of `actual` should be in `expected`\n  for (const key in actual) {\n    if (expected.hasOwnProperty(key) !== actual.hasOwnProperty(key) &&\n        !(key in METADATA_KEYS)) {\n      return {\n        isMatched: false,\n        message: 'not have key ' + key,\n        path,\n      };\n    }\n  }\n  // all properties in `expected` should be in `actual`\n  for (const k in expected) {\n    if (expected.hasOwnProperty(k) !== actual.hasOwnProperty(k)) {\n      return {\n        isMatched: false,\n        message: 'have key ' + k,\n        path,\n      };\n    }\n    if (k in METADATA_KEYS) {\n      continue;\n    }\n    const value = expected[k];\n    if (Array.isArray(value)) {\n      for (let jj = 0; jj < value.length; jj++) {\n        path.push(k + '[' + jj + ']');\n        const result = match(actual[k][jj], value[jj], path);\n        if (!result.isMatched) {\n          return result;\n        } else {\n          path.pop();\n        }\n      }\n    } else {\n      path.push(k);\n      const result = match(actual[k], value, path);\n      if (!result.isMatched) {\n        return result;\n      } else {\n        path.pop();\n      }\n    }\n  }\n  return {\n    isMatched: true,\n    message: null,\n    path: null,\n  };\n}\n\nfunction matchRecord(actual: any, expected: any): Result {\n  const {isMatched, path, message} = match(actual, expected, []);\n  return {\n    pass: isMatched,\n    message: isMatched ?\n      null :\n      'Expected ' + path.join('.') + ' to '  + message,\n  };\n}\n\nmodule.exports = matchRecord;\n","dependencies":[],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\ntype Result = {\n  isMatched: boolean;\n  message: ?string;\n  path: ?Array<string>;\n};\n\nconst METADATA_KEYS = {\n  '__dataID__': true,\n  '__range__': true,\n  '__resolvedFragmentMap__': true,\n  '__resolvedFragmentMapGeneration__': true,\n  '__status__': true,\n};\n\nfunction match(\n  actual: any,\n  expected: any,\n  path: Array<string>\n): Result {\n  if (typeof actual !== 'object') {\n    return {\n      isMatched: actual === expected,\n      message: 'be ' + expected + ', but got ' + actual,\n      path,\n    };\n  }\n\n  // all properties (lest __dataID__s) of `actual` should be in `expected`\n  for (const key in actual) {\n    if (expected.hasOwnProperty(key) !== actual.hasOwnProperty(key) &&\n        !(key in METADATA_KEYS)) {\n      return {\n        isMatched: false,\n        message: 'not have key ' + key,\n        path,\n      };\n    }\n  }\n  // all properties in `expected` should be in `actual`\n  for (const k in expected) {\n    if (expected.hasOwnProperty(k) !== actual.hasOwnProperty(k)) {\n      return {\n        isMatched: false,\n        message: 'have key ' + k,\n        path,\n      };\n    }\n    if (k in METADATA_KEYS) {\n      continue;\n    }\n    const value = expected[k];\n    if (Array.isArray(value)) {\n      for (let jj = 0; jj < value.length; jj++) {\n        path.push(k + '[' + jj + ']');\n        const result = match(actual[k][jj], value[jj], path);\n        if (!result.isMatched) {\n          return result;\n        } else {\n          path.pop();\n        }\n      }\n    } else {\n      path.push(k);\n      const result = match(actual[k], value, path);\n      if (!result.isMatched) {\n        return result;\n      } else {\n        path.pop();\n      }\n    }\n  }\n  return {\n    isMatched: true,\n    message: null,\n    path: null,\n  };\n}\n\nfunction matchRecord(actual: any, expected: any): Result {\n  const {isMatched, path, message} = match(actual, expected, []);\n  return {\n    pass: isMatched,\n    message: isMatched ?\n      null :\n      'Expected ' + path.join('.') + ' to '  + message,\n  };\n}\n\nmodule.exports = matchRecord;\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/matchRecord.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/isCompatibleRelayFragmentType.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isCompatibleRelayFragmentType');\n","dependencies":["isCompatibleRelayFragmentType"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isCompatibleRelayFragmentType');\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/isCompatibleRelayFragmentType.js"}},"/Users/cpojer/Projects/relay/src/tools/__mocks__/configureForRelayOSS.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nglobal.__RELAYOSS__ = true;\n","dependencies":[],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nglobal.__RELAYOSS__ = true;\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__mocks__/configureForRelayOSS.js"}},"/Users/cpojer/Projects/relay/src/tools/__tests__/testEditDistance-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst testEditDistance = require('testEditDistance');\n\ndescribe('testEditDistance()', () => {\n  it('considers empty strings to be identical', () => {\n    expect(testEditDistance('', '', 0)).toBe(true);\n  });\n\n  it('detects non-empty identical strings', () => {\n    expect(testEditDistance('foo', 'foo', 0)).toBe(true);\n  });\n\n  it('works with one empty and one non-empty string', () => {\n    expect(testEditDistance('', 'foo', 2)).toBe(false);\n    expect(testEditDistance('', 'foo', 3)).toBe(true);\n    expect(testEditDistance('foo', '', 2)).toBe(false);\n    expect(testEditDistance('foo', '', 3)).toBe(true);\n  });\n\n  it('detects deletions', () => {\n    expect(testEditDistance('foobar', 'fbar', 1)).toBe(false);\n    expect(testEditDistance('foobar', 'fbar', 2)).toBe(true);\n  });\n\n  it('detects insertions', () => {\n    expect(testEditDistance('foo', '<foo>', 1)).toBe(false);\n    expect(testEditDistance('foo', '<foo>', 2)).toBe(true);\n  });\n\n  it('detects substitutions', () => {\n    expect(testEditDistance('foobar', 'FooBar', 1)).toBe(false);\n    expect(testEditDistance('foobar', 'FooBar', 2)).toBe(true);\n  });\n\n  it('detects adjacent transpositions', () => {\n    expect(testEditDistance('foobar', 'foboar', 0)).toBe(false);\n    expect(testEditDistance('foobar', 'foboar', 1)).toBe(true);\n  });\n\n  it('treats non-adjacent transposition as unrelated operations', () => {\n    expect(testEditDistance('foobar', 'boofar', 1)).toBe(false);\n    expect(testEditDistance('foobar', 'boofar', 2)).toBe(true);\n  });\n\n  it('detects distances involving multiple edit operations', () => {\n    expect(\n      testEditDistance(\n        'String involving multiple changes.',\n        'strni ginvolvinG mmultiple cangs!',\n        7\n      )\n    ).toBe(false);\n    expect(\n      testEditDistance(\n        'String involving multiple changes.',\n        'strni ginvolvinG mmultiple cangs!',\n        8\n      )\n    ).toBe(true);\n  });\n});\n","dependencies":["testEditDistance"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst testEditDistance = require('testEditDistance');\n\ndescribe('testEditDistance()', () => {\n  it('considers empty strings to be identical', () => {\n    expect(testEditDistance('', '', 0)).toBe(true);\n  });\n\n  it('detects non-empty identical strings', () => {\n    expect(testEditDistance('foo', 'foo', 0)).toBe(true);\n  });\n\n  it('works with one empty and one non-empty string', () => {\n    expect(testEditDistance('', 'foo', 2)).toBe(false);\n    expect(testEditDistance('', 'foo', 3)).toBe(true);\n    expect(testEditDistance('foo', '', 2)).toBe(false);\n    expect(testEditDistance('foo', '', 3)).toBe(true);\n  });\n\n  it('detects deletions', () => {\n    expect(testEditDistance('foobar', 'fbar', 1)).toBe(false);\n    expect(testEditDistance('foobar', 'fbar', 2)).toBe(true);\n  });\n\n  it('detects insertions', () => {\n    expect(testEditDistance('foo', '<foo>', 1)).toBe(false);\n    expect(testEditDistance('foo', '<foo>', 2)).toBe(true);\n  });\n\n  it('detects substitutions', () => {\n    expect(testEditDistance('foobar', 'FooBar', 1)).toBe(false);\n    expect(testEditDistance('foobar', 'FooBar', 2)).toBe(true);\n  });\n\n  it('detects adjacent transpositions', () => {\n    expect(testEditDistance('foobar', 'foboar', 0)).toBe(false);\n    expect(testEditDistance('foobar', 'foboar', 1)).toBe(true);\n  });\n\n  it('treats non-adjacent transposition as unrelated operations', () => {\n    expect(testEditDistance('foobar', 'boofar', 1)).toBe(false);\n    expect(testEditDistance('foobar', 'boofar', 2)).toBe(true);\n  });\n\n  it('detects distances involving multiple edit operations', () => {\n    expect(\n      testEditDistance(\n        'String involving multiple changes.',\n        'strni ginvolvinG mmultiple cangs!',\n        7\n      )\n    ).toBe(false);\n    expect(\n      testEditDistance(\n        'String involving multiple changes.',\n        'strni ginvolvinG mmultiple cangs!',\n        8\n      )\n    ).toBe(true);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__tests__/testEditDistance-test.js"}},"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayTaskScheduler-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayTaskScheduler');\n\nconst RelayTaskQueue = require('RelayTaskQueue');\nconst RelayTaskScheduler = require('RelayTaskScheduler');\n\ndescribe('RelayTaskScheduler', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  describe('enqueue()', () => {\n    describe('having had no scheduler injected', () => {\n      it('causes a queue to be created the first time it\\'s used', () => {\n        expect(RelayTaskQueue.mock.instances.length).toBe(0);\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n        expect(RelayTaskQueue.prototype.constructor).toBeCalledWith(undefined);\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n      });\n    });\n\n    describe('having had a scheduler injected', () => {\n      let mockScheduler;\n\n      beforeEach(() => {\n        mockScheduler = jest.genMockFunction();\n        RelayTaskScheduler.injectScheduler(mockScheduler);\n      });\n\n      it('causes a queue to be created the first time it\\'s used', () => {\n        expect(RelayTaskQueue.mock.instances.length).toBe(0);\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n        expect(RelayTaskQueue.prototype.constructor).toBeCalledWith(\n          mockScheduler\n        );\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n      });\n\n      it('uses the injected scheduler to schedule tasks', () => {\n        jest.dontMock('RelayTaskQueue');\n        const mockTask = () => {};\n        RelayTaskScheduler.enqueue(mockTask);\n        expect(mockScheduler).toBeCalled();\n      });\n    });\n  });\n});\n","dependencies":["RelayTaskQueue","RelayTaskScheduler"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayTaskScheduler');\n\nconst RelayTaskQueue = require('RelayTaskQueue');\nconst RelayTaskScheduler = require('RelayTaskScheduler');\n\ndescribe('RelayTaskScheduler', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  describe('enqueue()', () => {\n    describe('having had no scheduler injected', () => {\n      it('causes a queue to be created the first time it\\'s used', () => {\n        expect(RelayTaskQueue.mock.instances.length).toBe(0);\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n        expect(RelayTaskQueue.prototype.constructor).toBeCalledWith(undefined);\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n      });\n    });\n\n    describe('having had a scheduler injected', () => {\n      let mockScheduler;\n\n      beforeEach(() => {\n        mockScheduler = jest.genMockFunction();\n        RelayTaskScheduler.injectScheduler(mockScheduler);\n      });\n\n      it('causes a queue to be created the first time it\\'s used', () => {\n        expect(RelayTaskQueue.mock.instances.length).toBe(0);\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n        expect(RelayTaskQueue.prototype.constructor).toBeCalledWith(\n          mockScheduler\n        );\n        RelayTaskScheduler.enqueue(() => {});\n        expect(RelayTaskQueue.mock.instances.length).toBe(1);\n      });\n\n      it('uses the injected scheduler to schedule tasks', () => {\n        jest.dontMock('RelayTaskQueue');\n        const mockTask = () => {};\n        RelayTaskScheduler.enqueue(mockTask);\n        expect(mockScheduler).toBeCalled();\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayTaskScheduler-test.js"}},"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayTaskQueue-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayTaskQueue');\n\nconst RelayTaskQueue = require('RelayTaskQueue');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst resolveImmediate = require('resolveImmediate');\n\ndescribe('RelayTaskQueue', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('default scheduler', () => {\n    let taskQueue;\n\n    beforeEach(() => {\n      taskQueue = new RelayTaskQueue();\n    });\n\n    it('resolves to undefined when no callbacks are supplied', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue().done(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).toBeCalledWith(undefined);\n    });\n\n    it('immediately invokes tasks', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).toBeCalled();\n    });\n\n    it('invokes multiple enqueued tasks in order', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(() => mockOrdering.push('foo'));\n      taskQueue.enqueue(() => mockOrdering.push('bar'));\n      taskQueue.enqueue(() => mockOrdering.push('baz'));\n      jest.runAllTimers();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('enqueues tasks enqueued by other tasks contiguously', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(() => {\n        mockOrdering.push('foo');\n        taskQueue.enqueue(() => mockOrdering.push('bar'));\n      });\n      // Although `baz` is enqueued before `bar`, `bar` should execute first.\n      taskQueue.enqueue(() => mockOrdering.push('baz'));\n      jest.runAllTimers();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('resolves to the task\\'s return value', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(() => 42).done(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).toBeCalledWith(42);\n    });\n\n    it('forwards return values for multiple callbacks', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(\n        () => {\n          mockOrdering.push('foo');\n          return 'bar';\n        },\n        prevValue => {\n          mockOrdering.push(prevValue);\n          return 'baz';\n        }\n      ).done(\n        returnValue => {\n          mockOrdering.push(returnValue);\n        }\n      );\n      jest.runAllTimers();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('aborts and rejects if a callback throws', () => {\n      const mockError = new Error('Expected error.');\n      const mockCallback = jest.genMockFunction();\n      const mockFailureCallback = jest.genMockFunction();\n      taskQueue.enqueue(\n        () => 'foo',\n        () => { throw mockError; },\n        mockCallback,\n      ).catch(mockFailureCallback);\n      jest.runAllTimers();\n      expect(mockCallback).not.toBeCalled();\n      expect(mockFailureCallback).toBeCalledWith(mockError);\n    });\n\n    it('does not affect next chain of callbacks after rejection', () => {\n      const mockError = new Error('Expected error.');\n      const mockCallback = jest.genMockFunction();\n      const mockFailureCallback = jest.genMockFunction();\n      const mockSuccessCallback = jest.genMockFunction();\n      taskQueue.enqueue(\n        () => { throw mockError; },\n      ).catch(mockFailureCallback);\n      taskQueue.enqueue(\n        mockCallback,\n      ).done(mockSuccessCallback);\n      jest.runAllTimers();\n      expect(mockFailureCallback).toBeCalledWith(mockError);\n      expect(mockCallback).toBeCalled();\n      expect(mockSuccessCallback).toBeCalled();\n    });\n  });\n\n  describe('injected scheduler', () => {\n    let mockScheduler;\n    let mockTasks;\n    let taskQueue;\n\n    beforeEach(() => {\n      mockTasks = [];\n      mockScheduler = (executeTask) => {\n        resolveImmediate(() => mockTasks.push(executeTask));\n      };\n      taskQueue = new RelayTaskQueue(mockScheduler);\n    });\n\n    it('allows injection of a scheduler to defer task execution', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).not.toBeCalled();\n      expect(mockTasks.length).toBe(1);\n      // Execute the task, which should not return anything.\n      expect(mockTasks[0]()).toBe(undefined);\n      expect(mockFunction).toBeCalled();\n    });\n\n    it('allows an injected scheduler to defer multiple tasks', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(() => {\n        mockOrdering.push('foo');\n        taskQueue.enqueue(() => mockOrdering.push('bar'));\n      });\n      taskQueue.enqueue(() => mockOrdering.push('baz'));\n      jest.runAllTimers();\n      // Scheduler only sees one task at a time.\n      expect(mockTasks.length).toBe(1);\n      mockTasks[0]();\n      expect(mockOrdering).toEqual(['foo']);\n      // Scheduler only sees the next task after `resolveImmediate`.\n      expect(mockTasks.length).toBe(1);\n      jest.runAllTimers();\n      expect(mockTasks.length).toBe(2);\n      mockTasks[1]();\n      expect(mockOrdering).toEqual(['foo', 'bar']);\n      jest.runAllTimers();\n      expect(mockTasks.length).toBe(3);\n      mockTasks[2]();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('throws if the same task is executed more than once', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(mockFunction);\n      jest.runAllTimers();\n      mockTasks[0]();\n      expect(() => {\n        mockTasks[0]();\n      }).toFailInvariant(\n        'RelayTaskQueue: Tasks can only be executed once.'\n      );\n    });\n\n    it('preserves execution order despite scheduler changes', () => {\n      const mockOrdering = [];\n      // This task is enqueued with a scheduler that defers the work\n      taskQueue.injectScheduler(resolveImmediate);\n      taskQueue.enqueue(() => mockOrdering.push('foo'));\n      // This task is enqueued with no scheduler\n      taskQueue.injectScheduler(undefined);\n      taskQueue.enqueue(() => mockOrdering.push('bar'));\n      jest.runAllTimers();\n      // Make sure the work units get done in order\n      expect(mockOrdering).toEqual(['foo', 'bar']);\n    });\n  });\n\n});\n","dependencies":["RelayTaskQueue","RelayTestUtils","resolveImmediate"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayTaskQueue');\n\nconst RelayTaskQueue = require('RelayTaskQueue');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst resolveImmediate = require('resolveImmediate');\n\ndescribe('RelayTaskQueue', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('default scheduler', () => {\n    let taskQueue;\n\n    beforeEach(() => {\n      taskQueue = new RelayTaskQueue();\n    });\n\n    it('resolves to undefined when no callbacks are supplied', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue().done(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).toBeCalledWith(undefined);\n    });\n\n    it('immediately invokes tasks', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).toBeCalled();\n    });\n\n    it('invokes multiple enqueued tasks in order', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(() => mockOrdering.push('foo'));\n      taskQueue.enqueue(() => mockOrdering.push('bar'));\n      taskQueue.enqueue(() => mockOrdering.push('baz'));\n      jest.runAllTimers();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('enqueues tasks enqueued by other tasks contiguously', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(() => {\n        mockOrdering.push('foo');\n        taskQueue.enqueue(() => mockOrdering.push('bar'));\n      });\n      // Although `baz` is enqueued before `bar`, `bar` should execute first.\n      taskQueue.enqueue(() => mockOrdering.push('baz'));\n      jest.runAllTimers();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('resolves to the task\\'s return value', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(() => 42).done(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).toBeCalledWith(42);\n    });\n\n    it('forwards return values for multiple callbacks', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(\n        () => {\n          mockOrdering.push('foo');\n          return 'bar';\n        },\n        prevValue => {\n          mockOrdering.push(prevValue);\n          return 'baz';\n        }\n      ).done(\n        returnValue => {\n          mockOrdering.push(returnValue);\n        }\n      );\n      jest.runAllTimers();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('aborts and rejects if a callback throws', () => {\n      const mockError = new Error('Expected error.');\n      const mockCallback = jest.genMockFunction();\n      const mockFailureCallback = jest.genMockFunction();\n      taskQueue.enqueue(\n        () => 'foo',\n        () => { throw mockError; },\n        mockCallback,\n      ).catch(mockFailureCallback);\n      jest.runAllTimers();\n      expect(mockCallback).not.toBeCalled();\n      expect(mockFailureCallback).toBeCalledWith(mockError);\n    });\n\n    it('does not affect next chain of callbacks after rejection', () => {\n      const mockError = new Error('Expected error.');\n      const mockCallback = jest.genMockFunction();\n      const mockFailureCallback = jest.genMockFunction();\n      const mockSuccessCallback = jest.genMockFunction();\n      taskQueue.enqueue(\n        () => { throw mockError; },\n      ).catch(mockFailureCallback);\n      taskQueue.enqueue(\n        mockCallback,\n      ).done(mockSuccessCallback);\n      jest.runAllTimers();\n      expect(mockFailureCallback).toBeCalledWith(mockError);\n      expect(mockCallback).toBeCalled();\n      expect(mockSuccessCallback).toBeCalled();\n    });\n  });\n\n  describe('injected scheduler', () => {\n    let mockScheduler;\n    let mockTasks;\n    let taskQueue;\n\n    beforeEach(() => {\n      mockTasks = [];\n      mockScheduler = (executeTask) => {\n        resolveImmediate(() => mockTasks.push(executeTask));\n      };\n      taskQueue = new RelayTaskQueue(mockScheduler);\n    });\n\n    it('allows injection of a scheduler to defer task execution', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(mockFunction);\n      jest.runAllTimers();\n      expect(mockFunction).not.toBeCalled();\n      expect(mockTasks.length).toBe(1);\n      // Execute the task, which should not return anything.\n      expect(mockTasks[0]()).toBe(undefined);\n      expect(mockFunction).toBeCalled();\n    });\n\n    it('allows an injected scheduler to defer multiple tasks', () => {\n      const mockOrdering = [];\n      taskQueue.enqueue(() => {\n        mockOrdering.push('foo');\n        taskQueue.enqueue(() => mockOrdering.push('bar'));\n      });\n      taskQueue.enqueue(() => mockOrdering.push('baz'));\n      jest.runAllTimers();\n      // Scheduler only sees one task at a time.\n      expect(mockTasks.length).toBe(1);\n      mockTasks[0]();\n      expect(mockOrdering).toEqual(['foo']);\n      // Scheduler only sees the next task after `resolveImmediate`.\n      expect(mockTasks.length).toBe(1);\n      jest.runAllTimers();\n      expect(mockTasks.length).toBe(2);\n      mockTasks[1]();\n      expect(mockOrdering).toEqual(['foo', 'bar']);\n      jest.runAllTimers();\n      expect(mockTasks.length).toBe(3);\n      mockTasks[2]();\n      expect(mockOrdering).toEqual(['foo', 'bar', 'baz']);\n    });\n\n    it('throws if the same task is executed more than once', () => {\n      const mockFunction = jest.genMockFunction();\n      taskQueue.enqueue(mockFunction);\n      jest.runAllTimers();\n      mockTasks[0]();\n      expect(() => {\n        mockTasks[0]();\n      }).toFailInvariant(\n        'RelayTaskQueue: Tasks can only be executed once.'\n      );\n    });\n\n    it('preserves execution order despite scheduler changes', () => {\n      const mockOrdering = [];\n      // This task is enqueued with a scheduler that defers the work\n      taskQueue.injectScheduler(resolveImmediate);\n      taskQueue.enqueue(() => mockOrdering.push('foo'));\n      // This task is enqueued with no scheduler\n      taskQueue.injectScheduler(undefined);\n      taskQueue.enqueue(() => mockOrdering.push('bar'));\n      jest.runAllTimers();\n      // Make sure the work units get done in order\n      expect(mockOrdering).toEqual(['foo', 'bar']);\n    });\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayTaskQueue-test.js"}},"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayProfiler-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayProfiler');\n\nconst RelayProfiler = require('RelayProfiler');\n\ndescribe('RelayProfiler', function() {\n  var DEV = __DEV__;\n\n  var mockMethod;\n  var mockMethod2;\n  var mockObject;\n  var mockDisableDEV = () => {\n    window.__DEV__ = 0;\n  };\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    mockMethod = jest.genMockFunction();\n    mockMethod2 = jest.genMockFunction();\n    mockObject = {\n      mockMethod: RelayProfiler.instrument('mock', mockMethod),\n      mockMethod2: RelayProfiler.instrument('mock2', mockMethod2),\n    };\n  });\n\n  afterEach(() => {\n    window.__DEV__ = DEV;\n  });\n\n  describe('instance', () => {\n    it('preserves context, arguments, and return value', () => {\n      var expectedArgument = {};\n      var expectedContext = mockObject;\n      var expectedReturnValue = {};\n\n      mockMethod.mockImplementation(function(actualArgument) {\n        expect(actualArgument).toBe(expectedArgument);\n        expect(this).toBe(expectedContext);\n        return expectedReturnValue;\n      });\n\n      var actualReturnValue = mockObject.mockMethod(expectedArgument);\n\n      expect(actualReturnValue).toBe(expectedReturnValue);\n    });\n\n    it('invokes attached handlers', () => {\n      var actualOrdering = [];\n\n      mockMethod.mockImplementation(() => {\n        actualOrdering.push('mockMethod');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('beforeCallback');\n        callback();\n        actualOrdering.push('afterCallback');\n      });\n\n      mockObject.mockMethod();\n\n      expect(actualOrdering).toEqual([\n        'beforeCallback',\n        'mockMethod',\n        'afterCallback',\n      ]);\n    });\n\n    it('invokes nested attached handlers', () => {\n      var actualOrdering = [];\n\n      mockMethod.mockImplementation(() => {\n        actualOrdering.push('0: mockMethod');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('1: beforeCallback');\n        callback();\n        actualOrdering.push('1: afterCallback');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('2: beforeCallback');\n        callback();\n        actualOrdering.push('2: afterCallback');\n      });\n\n      mockObject.mockMethod();\n\n      expect(actualOrdering).toEqual([\n        '2: beforeCallback',\n        '1: beforeCallback',\n        '0: mockMethod',\n        '1: afterCallback',\n        '2: afterCallback',\n      ]);\n    });\n\n    it('does not invoke detached handlers', () => {\n      var mockHandler = jest.genMockFunction()\n        .mockImplementation((name, callback) => {\n          callback();\n        });\n\n      mockObject.mockMethod.attachHandler(mockHandler);\n      mockObject.mockMethod.detachHandler(mockHandler);\n      mockObject.mockMethod();\n\n      expect(mockHandler).not.toBeCalled();\n    });\n\n    it('throws if callback is not invoked by handler', () => {\n      mockObject.mockMethod.attachHandler(jest.genMockFunction());\n\n      expect(() => {\n        mockObject.mockMethod();\n      }).toThrowError(\n        'RelayProfiler: Handler did not invoke original function.'\n      );\n    });\n\n    it('ignores names starting with \"@\" unless __DEV__', () => {\n      mockDisableDEV();\n\n      mockMethod = jest.genMockFunction();\n      mockObject = {mockMethod: RelayProfiler.instrument('@mock', mockMethod)};\n\n      expect(mockObject.mockMethod).toBe(mockMethod);\n      expect(() => {\n        mockObject.mockMethod.attachHandler();\n        mockObject.mockMethod.detachHandler();\n      }).not.toThrow();\n    });\n\n    it('instruments names without \"@\" when not in __DEV__', () => {\n      mockDisableDEV();\n\n      mockMethod = jest.genMockFunction();\n      mockObject = {mockMethod: RelayProfiler.instrument('mock', mockMethod)};\n\n      expect(mockObject.mockMethod).not.toBe(mockMethod);\n    });\n  });\n\n  describe('aggregate', () => {\n    it('invokes aggregate handlers first', () => {\n      var actualOrdering = [];\n\n      mockMethod.mockImplementation(() => {\n        actualOrdering.push('0: mockMethod');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        actualOrdering.push('1: beforeCallback');\n        callback();\n        actualOrdering.push('1: afterCallback');\n      });\n\n      RelayProfiler.attachAggregateHandler('mock', (name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('3: beforeCallback (aggregate)');\n        callback();\n        actualOrdering.push('3: afterCallback (aggregate)');\n      });\n\n      RelayProfiler.attachAggregateHandler('*', (name, callback) => {\n        actualOrdering.push('5: beforeCallback (aggregate *): ' + name);\n        callback();\n        actualOrdering.push('5: afterCallback (aggregate *): ' + name);\n      });\n\n      RelayProfiler.attachAggregateHandler('mock', (name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('4: beforeCallback (aggregate)');\n        callback();\n        actualOrdering.push('4: afterCallback (aggregate)');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        actualOrdering.push('2: beforeCallback');\n        callback();\n        actualOrdering.push('2: afterCallback');\n      });\n\n      mockObject.mockMethod();\n      mockObject.mockMethod2();\n\n      expect(actualOrdering).toEqual([\n        '5: beforeCallback (aggregate *): mock',\n        '4: beforeCallback (aggregate)',\n        '3: beforeCallback (aggregate)',\n        '2: beforeCallback',\n        '1: beforeCallback',\n        '0: mockMethod',\n        '1: afterCallback',\n        '2: afterCallback',\n        '3: afterCallback (aggregate)',\n        '4: afterCallback (aggregate)',\n        '5: afterCallback (aggregate *): mock',\n        '5: beforeCallback (aggregate *): mock2',\n        '5: afterCallback (aggregate *): mock2',\n      ]);\n    });\n\n    it('aggregates methods instrumented after being attached', () => {\n      var mockHandler = jest.genMockFunction()\n        .mockImplementation((name, callback) => {\n          callback();\n        });\n      RelayProfiler.attachAggregateHandler('mockFuture', mockHandler);\n\n      var mockFutureMethod = RelayProfiler.instrument('mockFuture', mockMethod);\n\n      expect(mockHandler).not.toBeCalled();\n      mockFutureMethod();\n      expect(mockHandler).toBeCalled();\n    });\n\n    it('detaches aggregate handlers', () => {\n      var mockHandler = jest.genMockFunction()\n        .mockImplementation((name, callback) => {\n          callback();\n        });\n\n      RelayProfiler.attachAggregateHandler('mock', mockHandler);\n      RelayProfiler.detachAggregateHandler('mock', mockHandler);\n      mockObject.mockMethod();\n\n      expect(mockHandler).not.toBeCalled();\n    });\n  });\n\n  describe('profile', () => {\n    it('invokes attached profile handlers', () => {\n      var actualOrdering = [];\n\n      RelayProfiler.attachProfileHandler('mockBehavior', (name) => {\n        expect(name).toBe('mockBehavior');\n        actualOrdering.push('1: beforeEnd');\n        return () => {\n          actualOrdering.push('1: afterEnd');\n        };\n      });\n\n      RelayProfiler.attachProfileHandler('mockBehavior', (name) => {\n        expect(name).toBe('mockBehavior');\n        actualOrdering.push('2: beforeEnd');\n        return () => {\n          actualOrdering.push('2: afterEnd');\n        };\n      });\n\n      var profiler = RelayProfiler.profile('mockBehavior');\n\n      expect(actualOrdering).toEqual([\n        '2: beforeEnd',\n        '1: beforeEnd',\n      ]);\n\n      profiler.stop();\n\n      expect(actualOrdering).toEqual([\n        '2: beforeEnd',\n        '1: beforeEnd',\n        '1: afterEnd',\n        '2: afterEnd',\n      ]);\n    });\n\n    it('does not invoke detached profile handlers', () => {\n      var mockStop = jest.genMockFunction();\n      var mockStart = jest.genMockFunction().mockReturnValue(mockStop);\n\n      RelayProfiler.attachProfileHandler('mockBehavior', mockStart);\n      RelayProfiler.detachProfileHandler('mockBehavior', mockStart);\n      RelayProfiler.profile('mockBehavior');\n\n      expect(mockStop).not.toBeCalled();\n      expect(mockStart).not.toBeCalled();\n    });\n\n    it('passes state to each profile handler', () => {\n      var mockStop = jest.genMockFunction();\n      var mockStart = jest.genMockFunction().mockReturnValue(mockStop);\n      var state = {};\n\n      RelayProfiler.attachProfileHandler('mockBehavior', mockStart);\n      var profiler = RelayProfiler.profile('mockBehavior', state);\n      profiler.stop();\n\n      expect(mockStart).toBeCalledWith('mockBehavior', state);\n      expect(mockStop).toBeCalled();\n      expect(mockStop.mock.calls[0].length).toBe(0);\n    });\n  });\n});\n","dependencies":["RelayProfiler"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayProfiler');\n\nconst RelayProfiler = require('RelayProfiler');\n\ndescribe('RelayProfiler', function() {\n  var DEV = __DEV__;\n\n  var mockMethod;\n  var mockMethod2;\n  var mockObject;\n  var mockDisableDEV = () => {\n    window.__DEV__ = 0;\n  };\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    mockMethod = jest.genMockFunction();\n    mockMethod2 = jest.genMockFunction();\n    mockObject = {\n      mockMethod: RelayProfiler.instrument('mock', mockMethod),\n      mockMethod2: RelayProfiler.instrument('mock2', mockMethod2),\n    };\n  });\n\n  afterEach(() => {\n    window.__DEV__ = DEV;\n  });\n\n  describe('instance', () => {\n    it('preserves context, arguments, and return value', () => {\n      var expectedArgument = {};\n      var expectedContext = mockObject;\n      var expectedReturnValue = {};\n\n      mockMethod.mockImplementation(function(actualArgument) {\n        expect(actualArgument).toBe(expectedArgument);\n        expect(this).toBe(expectedContext);\n        return expectedReturnValue;\n      });\n\n      var actualReturnValue = mockObject.mockMethod(expectedArgument);\n\n      expect(actualReturnValue).toBe(expectedReturnValue);\n    });\n\n    it('invokes attached handlers', () => {\n      var actualOrdering = [];\n\n      mockMethod.mockImplementation(() => {\n        actualOrdering.push('mockMethod');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('beforeCallback');\n        callback();\n        actualOrdering.push('afterCallback');\n      });\n\n      mockObject.mockMethod();\n\n      expect(actualOrdering).toEqual([\n        'beforeCallback',\n        'mockMethod',\n        'afterCallback',\n      ]);\n    });\n\n    it('invokes nested attached handlers', () => {\n      var actualOrdering = [];\n\n      mockMethod.mockImplementation(() => {\n        actualOrdering.push('0: mockMethod');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('1: beforeCallback');\n        callback();\n        actualOrdering.push('1: afterCallback');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('2: beforeCallback');\n        callback();\n        actualOrdering.push('2: afterCallback');\n      });\n\n      mockObject.mockMethod();\n\n      expect(actualOrdering).toEqual([\n        '2: beforeCallback',\n        '1: beforeCallback',\n        '0: mockMethod',\n        '1: afterCallback',\n        '2: afterCallback',\n      ]);\n    });\n\n    it('does not invoke detached handlers', () => {\n      var mockHandler = jest.genMockFunction()\n        .mockImplementation((name, callback) => {\n          callback();\n        });\n\n      mockObject.mockMethod.attachHandler(mockHandler);\n      mockObject.mockMethod.detachHandler(mockHandler);\n      mockObject.mockMethod();\n\n      expect(mockHandler).not.toBeCalled();\n    });\n\n    it('throws if callback is not invoked by handler', () => {\n      mockObject.mockMethod.attachHandler(jest.genMockFunction());\n\n      expect(() => {\n        mockObject.mockMethod();\n      }).toThrowError(\n        'RelayProfiler: Handler did not invoke original function.'\n      );\n    });\n\n    it('ignores names starting with \"@\" unless __DEV__', () => {\n      mockDisableDEV();\n\n      mockMethod = jest.genMockFunction();\n      mockObject = {mockMethod: RelayProfiler.instrument('@mock', mockMethod)};\n\n      expect(mockObject.mockMethod).toBe(mockMethod);\n      expect(() => {\n        mockObject.mockMethod.attachHandler();\n        mockObject.mockMethod.detachHandler();\n      }).not.toThrow();\n    });\n\n    it('instruments names without \"@\" when not in __DEV__', () => {\n      mockDisableDEV();\n\n      mockMethod = jest.genMockFunction();\n      mockObject = {mockMethod: RelayProfiler.instrument('mock', mockMethod)};\n\n      expect(mockObject.mockMethod).not.toBe(mockMethod);\n    });\n  });\n\n  describe('aggregate', () => {\n    it('invokes aggregate handlers first', () => {\n      var actualOrdering = [];\n\n      mockMethod.mockImplementation(() => {\n        actualOrdering.push('0: mockMethod');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        actualOrdering.push('1: beforeCallback');\n        callback();\n        actualOrdering.push('1: afterCallback');\n      });\n\n      RelayProfiler.attachAggregateHandler('mock', (name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('3: beforeCallback (aggregate)');\n        callback();\n        actualOrdering.push('3: afterCallback (aggregate)');\n      });\n\n      RelayProfiler.attachAggregateHandler('*', (name, callback) => {\n        actualOrdering.push('5: beforeCallback (aggregate *): ' + name);\n        callback();\n        actualOrdering.push('5: afterCallback (aggregate *): ' + name);\n      });\n\n      RelayProfiler.attachAggregateHandler('mock', (name, callback) => {\n        expect(name).toBe('mock');\n        actualOrdering.push('4: beforeCallback (aggregate)');\n        callback();\n        actualOrdering.push('4: afterCallback (aggregate)');\n      });\n\n      mockObject.mockMethod.attachHandler((name, callback) => {\n        actualOrdering.push('2: beforeCallback');\n        callback();\n        actualOrdering.push('2: afterCallback');\n      });\n\n      mockObject.mockMethod();\n      mockObject.mockMethod2();\n\n      expect(actualOrdering).toEqual([\n        '5: beforeCallback (aggregate *): mock',\n        '4: beforeCallback (aggregate)',\n        '3: beforeCallback (aggregate)',\n        '2: beforeCallback',\n        '1: beforeCallback',\n        '0: mockMethod',\n        '1: afterCallback',\n        '2: afterCallback',\n        '3: afterCallback (aggregate)',\n        '4: afterCallback (aggregate)',\n        '5: afterCallback (aggregate *): mock',\n        '5: beforeCallback (aggregate *): mock2',\n        '5: afterCallback (aggregate *): mock2',\n      ]);\n    });\n\n    it('aggregates methods instrumented after being attached', () => {\n      var mockHandler = jest.genMockFunction()\n        .mockImplementation((name, callback) => {\n          callback();\n        });\n      RelayProfiler.attachAggregateHandler('mockFuture', mockHandler);\n\n      var mockFutureMethod = RelayProfiler.instrument('mockFuture', mockMethod);\n\n      expect(mockHandler).not.toBeCalled();\n      mockFutureMethod();\n      expect(mockHandler).toBeCalled();\n    });\n\n    it('detaches aggregate handlers', () => {\n      var mockHandler = jest.genMockFunction()\n        .mockImplementation((name, callback) => {\n          callback();\n        });\n\n      RelayProfiler.attachAggregateHandler('mock', mockHandler);\n      RelayProfiler.detachAggregateHandler('mock', mockHandler);\n      mockObject.mockMethod();\n\n      expect(mockHandler).not.toBeCalled();\n    });\n  });\n\n  describe('profile', () => {\n    it('invokes attached profile handlers', () => {\n      var actualOrdering = [];\n\n      RelayProfiler.attachProfileHandler('mockBehavior', (name) => {\n        expect(name).toBe('mockBehavior');\n        actualOrdering.push('1: beforeEnd');\n        return () => {\n          actualOrdering.push('1: afterEnd');\n        };\n      });\n\n      RelayProfiler.attachProfileHandler('mockBehavior', (name) => {\n        expect(name).toBe('mockBehavior');\n        actualOrdering.push('2: beforeEnd');\n        return () => {\n          actualOrdering.push('2: afterEnd');\n        };\n      });\n\n      var profiler = RelayProfiler.profile('mockBehavior');\n\n      expect(actualOrdering).toEqual([\n        '2: beforeEnd',\n        '1: beforeEnd',\n      ]);\n\n      profiler.stop();\n\n      expect(actualOrdering).toEqual([\n        '2: beforeEnd',\n        '1: beforeEnd',\n        '1: afterEnd',\n        '2: afterEnd',\n      ]);\n    });\n\n    it('does not invoke detached profile handlers', () => {\n      var mockStop = jest.genMockFunction();\n      var mockStart = jest.genMockFunction().mockReturnValue(mockStop);\n\n      RelayProfiler.attachProfileHandler('mockBehavior', mockStart);\n      RelayProfiler.detachProfileHandler('mockBehavior', mockStart);\n      RelayProfiler.profile('mockBehavior');\n\n      expect(mockStop).not.toBeCalled();\n      expect(mockStart).not.toBeCalled();\n    });\n\n    it('passes state to each profile handler', () => {\n      var mockStop = jest.genMockFunction();\n      var mockStart = jest.genMockFunction().mockReturnValue(mockStop);\n      var state = {};\n\n      RelayProfiler.attachProfileHandler('mockBehavior', mockStart);\n      var profiler = RelayProfiler.profile('mockBehavior', state);\n      profiler.stop();\n\n      expect(mockStart).toBeCalledWith('mockBehavior', state);\n      expect(mockStop).toBeCalled();\n      expect(mockStop.mock.calls[0].length).toBe(0);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayProfiler-test.js"}},"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayMetricsRecorder-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest\n  .autoMockOff()\n  .mock('performanceNow');\n\nconst Relay = require('Relay');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayMetricsRecorder = require('RelayMetricsRecorder');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst performanceNow = require('performanceNow');\n\ndescribe('RelayMetricsRecorder', () => {\n  var query;\n\n  beforeEach(() => {\n    window.__DEV__ = true;\n    jest.resetModuleRegistry();\n\n    var {getNode} = RelayTestUtils;\n    query = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          ... on User {\n            name\n          }\n        }\n      }\n    `);\n  });\n\n  function mockPerformanceNowSequence(times) {\n    var index = 0;\n    performanceNow.mockImplementation(() => {\n      var time = times[index++];\n      expect(time).not.toBe(undefined);\n      return time;\n    });\n  }\n\n  it('returns empty metrics until methods are called', () => {\n    var recorder = new RelayMetricsRecorder();\n    performanceNow.mockReturnValue(0);\n    recorder.start();\n    performanceNow.mockReturnValue(1000);\n    recorder.stop();\n    expect(recorder.getMetrics()).toEqual({\n      measurements: {},\n      profiles: [],\n      recordingTime: 1000,\n      totalTime: 0,\n    });\n  });\n\n  it('returns timing for synchronous methods', () => {\n    var recorder = new RelayMetricsRecorder();\n    performanceNow.mockReturnValue(0);\n    recorder.start();\n    mockPerformanceNowSequence([1, 101]);\n    query.getChildren();\n    performanceNow.mockReturnValue(3000);\n    recorder.stop();\n\n    expect(recorder.getMetrics()).toEqual({\n      measurements: {\n        '@RelayQueryNode.prototype.getChildren': {\n          aggregateTime: 100,\n          callCount: 1,\n        },\n      },\n      profiles: [],\n      recordingTime: 3000,\n      totalTime: 100,\n    });\n  });\n\n  it('returns timing for asynchronous events', () => {\n    var recorder = new RelayMetricsRecorder();\n    performanceNow.mockReturnValue(0);\n    recorder.start();\n\n    performanceNow.mockReturnValue(1);\n    var {stop} = RelayProfiler.profile('fetchRelayQuery');\n    performanceNow.mockReturnValue(1001);\n    stop();\n    performanceNow.mockReturnValue(2000);\n    recorder.stop();\n\n    expect(recorder.getMetrics()).toEqual({\n      measurements: {},\n      profiles: [\n        {\n          endTime: 1001,\n          name: 'fetchRelayQuery',\n          startTime: 1,\n        },\n      ],\n      recordingTime: 2000,\n      totalTime: 0,\n    });\n  });\n\n  describe('__DEV__ false', () => {\n    beforeEach(() => {\n      window.__DEV__ = false;\n      jest.resetModuleRegistry();\n    });\n\n    it('records profiles only', () => {\n      var recorder = new RelayMetricsRecorder();\n      performanceNow.mockReturnValue(0);\n      recorder.start();\n      query.getChildren(); // not recorded\n      performanceNow.mockReturnValue(1);\n      var {stop} = RelayProfiler.profile('fetchRelayQuery');\n      performanceNow.mockReturnValue(11);\n      stop();\n      performanceNow.mockReturnValue(1000);\n      recorder.stop();\n\n      expect(recorder.getMetrics()).toEqual({\n        measurements: {},\n        profiles: [\n          {\n            endTime: 11,\n            name: 'fetchRelayQuery',\n            startTime: 1,\n          },\n        ],\n        recordingTime: 1000,\n        totalTime: 0,\n      });\n    });\n  });\n});\n","dependencies":["Relay","RelayProfiler","RelayMetricsRecorder","RelayTestUtils","performanceNow"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest\n  .autoMockOff()\n  .mock('performanceNow');\n\nconst Relay = require('Relay');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayMetricsRecorder = require('RelayMetricsRecorder');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst performanceNow = require('performanceNow');\n\ndescribe('RelayMetricsRecorder', () => {\n  var query;\n\n  beforeEach(() => {\n    window.__DEV__ = true;\n    jest.resetModuleRegistry();\n\n    var {getNode} = RelayTestUtils;\n    query = getNode(Relay.QL`\n      query {\n        node(id: \"123\") {\n          ... on User {\n            name\n          }\n        }\n      }\n    `);\n  });\n\n  function mockPerformanceNowSequence(times) {\n    var index = 0;\n    performanceNow.mockImplementation(() => {\n      var time = times[index++];\n      expect(time).not.toBe(undefined);\n      return time;\n    });\n  }\n\n  it('returns empty metrics until methods are called', () => {\n    var recorder = new RelayMetricsRecorder();\n    performanceNow.mockReturnValue(0);\n    recorder.start();\n    performanceNow.mockReturnValue(1000);\n    recorder.stop();\n    expect(recorder.getMetrics()).toEqual({\n      measurements: {},\n      profiles: [],\n      recordingTime: 1000,\n      totalTime: 0,\n    });\n  });\n\n  it('returns timing for synchronous methods', () => {\n    var recorder = new RelayMetricsRecorder();\n    performanceNow.mockReturnValue(0);\n    recorder.start();\n    mockPerformanceNowSequence([1, 101]);\n    query.getChildren();\n    performanceNow.mockReturnValue(3000);\n    recorder.stop();\n\n    expect(recorder.getMetrics()).toEqual({\n      measurements: {\n        '@RelayQueryNode.prototype.getChildren': {\n          aggregateTime: 100,\n          callCount: 1,\n        },\n      },\n      profiles: [],\n      recordingTime: 3000,\n      totalTime: 100,\n    });\n  });\n\n  it('returns timing for asynchronous events', () => {\n    var recorder = new RelayMetricsRecorder();\n    performanceNow.mockReturnValue(0);\n    recorder.start();\n\n    performanceNow.mockReturnValue(1);\n    var {stop} = RelayProfiler.profile('fetchRelayQuery');\n    performanceNow.mockReturnValue(1001);\n    stop();\n    performanceNow.mockReturnValue(2000);\n    recorder.stop();\n\n    expect(recorder.getMetrics()).toEqual({\n      measurements: {},\n      profiles: [\n        {\n          endTime: 1001,\n          name: 'fetchRelayQuery',\n          startTime: 1,\n        },\n      ],\n      recordingTime: 2000,\n      totalTime: 0,\n    });\n  });\n\n  describe('__DEV__ false', () => {\n    beforeEach(() => {\n      window.__DEV__ = false;\n      jest.resetModuleRegistry();\n    });\n\n    it('records profiles only', () => {\n      var recorder = new RelayMetricsRecorder();\n      performanceNow.mockReturnValue(0);\n      recorder.start();\n      query.getChildren(); // not recorded\n      performanceNow.mockReturnValue(1);\n      var {stop} = RelayProfiler.profile('fetchRelayQuery');\n      performanceNow.mockReturnValue(11);\n      stop();\n      performanceNow.mockReturnValue(1000);\n      recorder.stop();\n\n      expect(recorder.getMetrics()).toEqual({\n        measurements: {},\n        profiles: [\n          {\n            endTime: 11,\n            name: 'fetchRelayQuery',\n            startTime: 1,\n          },\n        ],\n        recordingTime: 1000,\n        totalTime: 0,\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__tests__/RelayMetricsRecorder-test.js"}},"/Users/cpojer/Projects/relay/src/tools/__tests__/isCompatibleRelayFragmentType-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\n\ndescribe('isCompatibleRelayFragmentType', () => {\n  const {getNode} = RelayTestUtils;\n\n  it('returns false for different concrete types', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on User{id}`),\n      'Page'\n    )).toBe(false);\n  });\n\n  it('returns true for equal concrete types', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on User{id}`),\n      'User'\n    )).toBe(true);\n  });\n\n  it('returns true for abstract fragments', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on Node{id}`),\n      'User'\n    )).toBe(true);\n  });\n\n  it('returns true for client records', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on User{id}`),\n      null\n    )).toBe(true);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","isCompatibleRelayFragmentType"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\n\ndescribe('isCompatibleRelayFragmentType', () => {\n  const {getNode} = RelayTestUtils;\n\n  it('returns false for different concrete types', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on User{id}`),\n      'Page'\n    )).toBe(false);\n  });\n\n  it('returns true for equal concrete types', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on User{id}`),\n      'User'\n    )).toBe(true);\n  });\n\n  it('returns true for abstract fragments', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on Node{id}`),\n      'User'\n    )).toBe(true);\n  });\n\n  it('returns true for client records', () => {\n    expect(isCompatibleRelayFragmentType(\n      getNode(Relay.QL`fragment on User{id}`),\n      null\n    )).toBe(true);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/tools/__tests__/isCompatibleRelayFragmentType-test.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/validateRelayReadQuery.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar validateRelayReadQuery = require.requireActual('validateRelayReadQuery');\nmodule.exports = validateRelayReadQuery;\n","dependencies":["validateRelayReadQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar validateRelayReadQuery = require.requireActual('validateRelayReadQuery');\nmodule.exports = validateRelayReadQuery;\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/validateRelayReadQuery.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayStoreData.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayStoreData');\n","dependencies":["RelayStoreData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayStoreData');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayStoreData.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayStore.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayStore');\n","dependencies":["RelayStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayStore');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayStore.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordWriter.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordWriter');\n","dependencies":["RelayRecordWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordWriter');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordWriter.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordStore.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordStore');\n","dependencies":["RelayRecordStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordStore');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordStore.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordStatusMap.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordStatusMap');\n","dependencies":["RelayRecordStatusMap"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordStatusMap');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordStatusMap.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordState.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordState');\n","dependencies":["RelayRecordState"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRecordState');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecordState.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecord.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst RelayRecord = require.requireActual('RelayRecord');\n\nObject.keys(RelayRecord).forEach(name => {\n  const method = RelayRecord[name];\n  if (typeof method === 'function') {\n    RelayRecord[name] = jest.genMockFunction().mockImplementation(method);\n  }\n});\n\nmodule.exports = RelayRecord;\n","dependencies":["RelayRecord"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst RelayRecord = require.requireActual('RelayRecord');\n\nObject.keys(RelayRecord).forEach(name => {\n  const method = RelayRecord[name];\n  if (typeof method === 'function') {\n    RelayRecord[name] = jest.genMockFunction().mockImplementation(method);\n  }\n});\n\nmodule.exports = RelayRecord;\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayRecord.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayReadyState.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayReadyState');\n","dependencies":["RelayReadyState"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayReadyState');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayReadyState.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayQueryWriter.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryWriter');\n","dependencies":["RelayQueryWriter"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryWriter');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayQueryWriter.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayQueryResultObservable.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryResultObservable');\n","dependencies":["RelayQueryResultObservable"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryResultObservable');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayQueryResultObservable.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayPendingQueryTracker.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayPendingQueryTracker =\n  jest.genMockFromModule('RelayPendingQueryTracker');\n\nclass MockPendingFetch {\n  constructor(query) {\n    this._query = query;\n    this._resolvable = false;\n    this._promise = new Promise((resolve, reject) => {\n      this.resolve = (...args) => {\n        this._resolvable = true;\n        return resolve.apply(this, args);\n      };\n      this.reject = reject;\n    });\n  }\n  getID() {\n    return this._query.getQuery().getID();\n  }\n  getQuery() {\n    return this._query;\n  }\n  getResolvedPromise() {\n    return this._promise;\n  }\n  isResolvable() {\n    return this._resolvable;\n  }\n}\n\nRelayPendingQueryTracker.mockImplementation(function() {\n  this.add.mock.fetches = [];\n  this.add.mockImplementation(params => {\n    var mockFetch = new MockPendingFetch(params.query);\n    this.add.mock.fetches.push(mockFetch);\n    return mockFetch;\n  });\n\n  return this;\n});\n\nmodule.exports = RelayPendingQueryTracker;\n","dependencies":["RelayPendingQueryTracker"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayPendingQueryTracker =\n  jest.genMockFromModule('RelayPendingQueryTracker');\n\nclass MockPendingFetch {\n  constructor(query) {\n    this._query = query;\n    this._resolvable = false;\n    this._promise = new Promise((resolve, reject) => {\n      this.resolve = (...args) => {\n        this._resolvable = true;\n        return resolve.apply(this, args);\n      };\n      this.reject = reject;\n    });\n  }\n  getID() {\n    return this._query.getQuery().getID();\n  }\n  getQuery() {\n    return this._query;\n  }\n  getResolvedPromise() {\n    return this._promise;\n  }\n  isResolvable() {\n    return this._resolvable;\n  }\n}\n\nRelayPendingQueryTracker.mockImplementation(function() {\n  this.add.mock.fetches = [];\n  this.add.mockImplementation(params => {\n    var mockFetch = new MockPendingFetch(params.query);\n    this.add.mock.fetches.push(mockFetch);\n    return mockFetch;\n  });\n\n  return this;\n});\n\nmodule.exports = RelayPendingQueryTracker;\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayPendingQueryTracker.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayMutationTracker.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationTracker');\n","dependencies":["RelayMutationTracker"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationTracker');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayMutationTracker.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayMockCacheManager.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayMockCacheManager = {\n  genCacheManager: function() {\n    var mutationWriter = genMockWriter();\n    var queryWriter = genMockWriter();\n    return {\n      mocks: {\n        mutationWriter,\n        queryWriter,\n      },\n      getMutationWriter:\n        jest.genMockFunction().mockReturnValue(mutationWriter),\n      getQueryWriter:\n        jest.genMockFunction().mockReturnValue(queryWriter),\n    };\n  },\n};\n\nfunction genMockWriter() {\n  return {\n    writeField: jest.genMockFunction(),\n    writeNode: jest.genMockFunction(),\n    writeRootCall: jest.genMockFunction(),\n  };\n}\n\nmodule.exports = RelayMockCacheManager;\n","dependencies":[],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayMockCacheManager = {\n  genCacheManager: function() {\n    var mutationWriter = genMockWriter();\n    var queryWriter = genMockWriter();\n    return {\n      mocks: {\n        mutationWriter,\n        queryWriter,\n      },\n      getMutationWriter:\n        jest.genMockFunction().mockReturnValue(mutationWriter),\n      getQueryWriter:\n        jest.genMockFunction().mockReturnValue(queryWriter),\n    };\n  },\n};\n\nfunction genMockWriter() {\n  return {\n    writeField: jest.genMockFunction(),\n    writeNode: jest.genMockFunction(),\n    writeRootCall: jest.genMockFunction(),\n  };\n}\n\nmodule.exports = RelayMockCacheManager;\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayMockCacheManager.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayGarbageCollector.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayGarbageCollector');\n","dependencies":["RelayGarbageCollector"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayGarbageCollector');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayGarbageCollector.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayFetchMode.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayFetchMode');\n","dependencies":["RelayFetchMode"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayFetchMode');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayFetchMode.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayDiskCacheReader.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayDiskCacheReader');\n","dependencies":["RelayDiskCacheReader"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayDiskCacheReader');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayDiskCacheReader.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayContext.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst RelayContext = require.requireActual('RelayContext');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayStoreData = require('RelayStoreData');\n\nconst resolveImmediate = require('resolveImmediate');\n\n/**\n * Mock object to simulate the behavior of a request. Example usage:\n *\n *   RelayStore.primeCache(...);\n *   RelayStore.primeCache.mock.requests[0].block();\n *   RelayStore.primeCache.mock.requests[0].fail(new Error());\n *\n * A normal request should follow one of the following behaviors:\n *\n *   block? -> resolve* -> succeed\n *   block? -> resolve* -> fail\n *\n */\nfunction genMockRequest(args) {\n  var ready = false;\n  return {\n    abort() {\n      args[1]({aborted: true, done: false, error: null, ready, stale: false});\n    },\n    block() {\n      args[1]({aborted: false, done: false, error: null, ready, stale: false});\n    },\n    resolve(config) {\n      var stale = config ? !!config.stale : false;\n      ready = true;\n      args[1]({aborted: false, done: false, error: null, ready, stale});\n    },\n    succeed() {\n      ready = true;\n      args[1]({aborted: false, done: true, error: null, ready, stale: false});\n    },\n    fail(error) {\n      args[1]({aborted: false, done: false, error, ready, stale: false});\n    },\n  };\n}\n\nclass MockRelayContext extends RelayContext {\n  constructor() {\n    super();\n\n    for (const method of ['getFragmentResolver', 'read']) {\n      this[method] = jest.genMockFn().mockImplementation(\n        RelayContext.prototype[method]\n      );\n    }\n\n    this.primeCache = jest.genMockFunction();\n    this.primeCache.mock.abort = [];\n    this.primeCache.mock.requests = [];\n    this.primeCache.mockImplementation((...args) => {\n      const request = genMockRequest(args);\n      const returnValue = {\n        abort: jest.genMockFunction().mockImplementation(() => {\n          resolveImmediate(request.abort);\n        }),\n      };\n      this.primeCache.mock.abort.push(returnValue.abort);\n      this.primeCache.mock.requests.push(request);\n      return returnValue;\n    });\n\n    this.forceFetch = jest.genMockFunction();\n    this.forceFetch.mock.abort = [];\n    this.forceFetch.mock.requests = [];\n    this.forceFetch.mockImplementation((...args) => {\n      const request = genMockRequest(args);\n      const returnValue = {\n        abort: jest.genMockFunction().mockImplementation(() => {\n          resolveImmediate(request.abort);\n        }),\n      };\n      this.forceFetch.mock.abort.push(returnValue.abort);\n      this.forceFetch.mock.requests.push(request);\n      return returnValue;\n    });\n\n    this.mock = {\n      setMockRecords: records => {\n        this.mock.recordStore = new RelayRecordStore({records});\n      },\n      recordStore: null,\n    };\n  }\n}\n\nmodule.exports = MockRelayContext;\n","dependencies":["RelayRecordStore","RelayStoreData","resolveImmediate","RelayContext"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nconst RelayContext = require.requireActual('RelayContext');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayStoreData = require('RelayStoreData');\n\nconst resolveImmediate = require('resolveImmediate');\n\n/**\n * Mock object to simulate the behavior of a request. Example usage:\n *\n *   RelayStore.primeCache(...);\n *   RelayStore.primeCache.mock.requests[0].block();\n *   RelayStore.primeCache.mock.requests[0].fail(new Error());\n *\n * A normal request should follow one of the following behaviors:\n *\n *   block? -> resolve* -> succeed\n *   block? -> resolve* -> fail\n *\n */\nfunction genMockRequest(args) {\n  var ready = false;\n  return {\n    abort() {\n      args[1]({aborted: true, done: false, error: null, ready, stale: false});\n    },\n    block() {\n      args[1]({aborted: false, done: false, error: null, ready, stale: false});\n    },\n    resolve(config) {\n      var stale = config ? !!config.stale : false;\n      ready = true;\n      args[1]({aborted: false, done: false, error: null, ready, stale});\n    },\n    succeed() {\n      ready = true;\n      args[1]({aborted: false, done: true, error: null, ready, stale: false});\n    },\n    fail(error) {\n      args[1]({aborted: false, done: false, error, ready, stale: false});\n    },\n  };\n}\n\nclass MockRelayContext extends RelayContext {\n  constructor() {\n    super();\n\n    for (const method of ['getFragmentResolver', 'read']) {\n      this[method] = jest.genMockFn().mockImplementation(\n        RelayContext.prototype[method]\n      );\n    }\n\n    this.primeCache = jest.genMockFunction();\n    this.primeCache.mock.abort = [];\n    this.primeCache.mock.requests = [];\n    this.primeCache.mockImplementation((...args) => {\n      const request = genMockRequest(args);\n      const returnValue = {\n        abort: jest.genMockFunction().mockImplementation(() => {\n          resolveImmediate(request.abort);\n        }),\n      };\n      this.primeCache.mock.abort.push(returnValue.abort);\n      this.primeCache.mock.requests.push(request);\n      return returnValue;\n    });\n\n    this.forceFetch = jest.genMockFunction();\n    this.forceFetch.mock.abort = [];\n    this.forceFetch.mock.requests = [];\n    this.forceFetch.mockImplementation((...args) => {\n      const request = genMockRequest(args);\n      const returnValue = {\n        abort: jest.genMockFunction().mockImplementation(() => {\n          resolveImmediate(request.abort);\n        }),\n      };\n      this.forceFetch.mock.abort.push(returnValue.abort);\n      this.forceFetch.mock.requests.push(request);\n      return returnValue;\n    });\n\n    this.mock = {\n      setMockRecords: records => {\n        this.mock.recordStore = new RelayRecordStore({records});\n      },\n      recordStore: null,\n    };\n  }\n}\n\nmodule.exports = MockRelayContext;\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayContext.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayChangeTracker.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayChangeTracker');\n","dependencies":["RelayChangeTracker"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayChangeTracker');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/RelayChangeTracker.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/readRelayQueryData.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar readRelayQueryData = require.requireActual('readRelayQueryData');\nmodule.exports = jest.genMockFunction().mockImplementation(readRelayQueryData);\n","dependencies":["readRelayQueryData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar readRelayQueryData = require.requireActual('readRelayQueryData');\nmodule.exports = jest.genMockFunction().mockImplementation(readRelayQueryData);\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/readRelayQueryData.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/isRelayContext.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isRelayContext');\n","dependencies":["isRelayContext"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isRelayContext');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/isRelayContext.js"}},"/Users/cpojer/Projects/relay/src/store/__mocks__/filterExclusiveKeys.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('filterExclusiveKeys');\n","dependencies":["filterExclusiveKeys"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('filterExclusiveKeys');\n"},"name":"/Users/cpojer/Projects/relay/src/store/__mocks__/filterExclusiveKeys.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/validateRelayReadQuery-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst validateRelayReadQuery = require('validateRelayReadQuery');\n\ndescribe('validateRelayReadQuery', () => {\n  // Helper functions.\n  var {getNode} = RelayTestUtils;\n\n  // Other variables.\n  var mockConsoleError;\n  var realConsoleError;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    realConsoleError = console.error;\n    mockConsoleError = console.error = jest.genMockFunction();\n\n    jasmine.addMatchers({\n      toLogErrorFor() {\n        return {\n          compare(actual, alias) {\n            expect(actual).toBeCalledWith(\n              '`%s` is used as an alias more than once. Please use unique ' +\n              'aliases.',\n              alias\n            );\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  afterEach(() => {\n    console.error = realConsoleError;\n  });\n\n  it('logs an error if fragment and containing query have no aliases', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error for two local fragments without aliases', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var otherFragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"50\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment},\n          ${otherFragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error for local fragments containing linked fields', () => {\n    var nestedFragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          profilePicture(size:\"100\") {\n            height,\n          },\n        },\n      }\n    `;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          profilePicture(size:\"50\") {\n            height,\n          },\n        },\n        ${nestedFragment},\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error for colliding fields within the same query', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"50\") {\n            height,\n          },\n          profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error if both fields have aliases but they collide', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          pic: profilePicture(size:\"50\") {\n            height,\n          },\n          pic: profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('pic');\n  });\n\n  it('logs an error for two different fields with colliding aliases', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          special: profilePicture(size:\"50\") {\n            height,\n          },\n          special: name,\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('special');\n  });\n\n  it('logs an error when a collision occurs within pageInfo', () => {\n    // We test this separately because we traverse pageInfo as though it were a\n    // linked field.\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"1\") {\n            pageInfo {\n              my_cursor: startCursor,\n              my_cursor: endCursor,\n            },\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('my_cursor');\n  });\n\n  it('logs no error when alias is the same as a connection subfield', () => {\n    var query = getNode(Relay.QL`\n      fragment on User {\n        count: friends {\n          count,\n        },\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error if containing query has a distinguishing alias ', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error if fragment has a distinguishing alias', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        large_profile: profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error when both fragment and query have aliases', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        large_profile: profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error when one of two fields in a query has an alias', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error when two fields in a query both have aliases', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          large_profile: profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error for a non-local fragment which would collide', () => {\n    var fragment = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on User {profilePicture(size:\"100\"){height}}`,\n      {}\n    );\n    var query = getNode(Relay.QL`\n      fragment on User {\n        profilePicture(size:\"50\") {\n          height,\n        },\n        ${fragment},\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error for fields at different levels', () => {\n    var query = getNode(Relay.QL`\n      fragment on User {\n        profilePicture(size:\"50\") {\n          height,\n        },\n        friends(first:\"1\") {\n          edges {\n            node {\n              profilePicture(size:\"100\") {\n                height,\n              },\n            },\n          },\n        },\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayFragmentReference","RelayTestUtils","validateRelayReadQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst validateRelayReadQuery = require('validateRelayReadQuery');\n\ndescribe('validateRelayReadQuery', () => {\n  // Helper functions.\n  var {getNode} = RelayTestUtils;\n\n  // Other variables.\n  var mockConsoleError;\n  var realConsoleError;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    realConsoleError = console.error;\n    mockConsoleError = console.error = jest.genMockFunction();\n\n    jasmine.addMatchers({\n      toLogErrorFor() {\n        return {\n          compare(actual, alias) {\n            expect(actual).toBeCalledWith(\n              '`%s` is used as an alias more than once. Please use unique ' +\n              'aliases.',\n              alias\n            );\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  afterEach(() => {\n    console.error = realConsoleError;\n  });\n\n  it('logs an error if fragment and containing query have no aliases', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error for two local fragments without aliases', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var otherFragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"50\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          ${fragment},\n          ${otherFragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error for local fragments containing linked fields', () => {\n    var nestedFragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          profilePicture(size:\"100\") {\n            height,\n          },\n        },\n      }\n    `;\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          profilePicture(size:\"50\") {\n            height,\n          },\n        },\n        ${nestedFragment},\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error for colliding fields within the same query', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"50\") {\n            height,\n          },\n          profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('profilePicture');\n  });\n\n  it('logs an error if both fields have aliases but they collide', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          pic: profilePicture(size:\"50\") {\n            height,\n          },\n          pic: profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('pic');\n  });\n\n  it('logs an error for two different fields with colliding aliases', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          special: profilePicture(size:\"50\") {\n            height,\n          },\n          special: name,\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('special');\n  });\n\n  it('logs an error when a collision occurs within pageInfo', () => {\n    // We test this separately because we traverse pageInfo as though it were a\n    // linked field.\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"1\") {\n            pageInfo {\n              my_cursor: startCursor,\n              my_cursor: endCursor,\n            },\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).toLogErrorFor('my_cursor');\n  });\n\n  it('logs no error when alias is the same as a connection subfield', () => {\n    var query = getNode(Relay.QL`\n      fragment on User {\n        count: friends {\n          count,\n        },\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error if containing query has a distinguishing alias ', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error if fragment has a distinguishing alias', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        large_profile: profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error when both fragment and query have aliases', () => {\n    var fragment = Relay.QL`\n      fragment on Node {\n        large_profile: profilePicture(size:\"100\") {\n          height,\n        },\n      }\n    `;\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          ${fragment},\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error when one of two fields in a query has an alias', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error when two fields in a query both have aliases', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          medium_profile: profilePicture(size:\"50\") {\n            height,\n          },\n          large_profile: profilePicture(size:\"100\") {\n            height,\n          },\n        }\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error for a non-local fragment which would collide', () => {\n    var fragment = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on User {profilePicture(size:\"100\"){height}}`,\n      {}\n    );\n    var query = getNode(Relay.QL`\n      fragment on User {\n        profilePicture(size:\"50\") {\n          height,\n        },\n        ${fragment},\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n\n  it('logs no error for fields at different levels', () => {\n    var query = getNode(Relay.QL`\n      fragment on User {\n        profilePicture(size:\"50\") {\n          height,\n        },\n        friends(first:\"1\") {\n          edges {\n            node {\n              profilePicture(size:\"100\") {\n                height,\n              },\n            },\n          },\n        },\n      }\n    `);\n    validateRelayReadQuery(query);\n    expect(mockConsoleError).not.toBeCalled();\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/validateRelayReadQuery-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayStoreData_cacheManager-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMockCacheManager = require('RelayMockCacheManager');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('RelayStoreData', function() {\n  var cacheManager;\n  var storeData;\n\n  var {getNode} = RelayTestUtils;\n  var CLIENT_MUTATION_ID, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  function getPathToRecord(dataID) {\n    return storeData.getRecordStore().getPathToRecord(dataID);\n  }\n\n  function getRangeForRecord(dataID) {\n    var nodeData = storeData.getNodeData();\n    expect(Object.keys(nodeData)).toContain(dataID);\n    return nodeData[dataID].__range__;\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({\n      CLIENT_MUTATION_ID,\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n    } = RelayConnectionInterface);\n\n    cacheManager = RelayMockCacheManager.genCacheManager();\n    storeData = new RelayStoreData();\n    storeData.injectCacheManager(cacheManager);\n\n    jasmine.addMatchers({\n      toContainCalledMethods: () => ({\n        compare: (actual, calls) => {\n          let message;\n          const pass = Object.keys(calls).every(methodName => {\n            const expected = calls[methodName];\n            const value = actual[methodName].mock.calls.length;\n            const pass = expected === value;\n\n            const expTimes = expected + ' time' + (expected === 1 ? '' : 's');\n            const actTimes = value + ' time' + (value === 1 ? '' : 's');\n            const not = pass ? 'not ' : '';\n            message = 'Expected `' + methodName + '` ' + not + 'to be called ' +\n              expTimes + ', was called ' + actTimes + '.';\n            return pass;\n          });\n          return {pass, message};\n        },\n      }),\n      toBeCalledWithNodeFields: (util, customEqualityTesters) => ({\n        compare: (actual, nodeFields) => {\n          let message;\n          const pass = Object.keys(nodeFields).every(\n            expectedID => Object.keys(nodeFields[expectedID]).every(\n              expectedFieldName => {\n                message =\n                  'Expected function to be called with (' +\n                  expectedID + ', ' +\n                  expectedFieldName + ', ' +\n                  nodeFields[expectedID][expectedFieldName] + ').';\n                return actual.mock.calls.some(\n                  ([actualID, actualFieldName, actualFieldValue]) => (\n                    actualID === expectedID &&\n                    actualFieldName === expectedFieldName &&\n                    util.equals(\n                      actualFieldValue,\n                      nodeFields[expectedID][actualFieldName],\n                      customEqualityTesters\n                    )\n                  )\n                );\n              }\n            )\n          );\n          return {pass, message};\n        },\n      }),\n    });\n  });\n\n  it('caches node metadata', () => {\n    var query = getNode(Relay.QL`query{node(id:\"123\"){id}}`);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 3,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        __typename: 'User',\n        id: '123',\n      },\n    });\n  });\n\n  it('caches custom root calls', () => {\n    var query = getNode(Relay.QL`query{username(name:\"yuzhi\"){id}}`);\n    var response = {\n      username: {\n        __typename: 'User',\n        id: '123',\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 3,\n      writeRootCall: 1,\n    });\n    expect(queryWriter.writeRootCall).toBeCalledWith(\n      'username',\n      'yuzhi',\n      '123'\n    );\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        __typename: 'User',\n        id: '123',\n      },\n    });\n  });\n\n  it('caches nodes with client IDs', () => {\n    var query = getNode(Relay.QL`query{viewer{isFbEmployee}}`);\n    var response = {\n      viewer: {\n        __typename: 'User',\n        isFbEmployee: true,\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 2,\n      writeRootCall: 1,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      'client:1': {\n        __dataID__: 'client:1',\n        isFbEmployee: true,\n      },\n    });\n  });\n\n  it('caches linked records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          hometown {\n            id,\n            url,\n          },\n        }\n      }\n    `);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n        hometown: {\n          __typename: 'Page',\n          id: '456',\n          url: 'http://...',\n        },\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 7,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        hometown: {__dataID__: '456'},\n      },\n      '456': {\n        __dataID__: '456',\n        id: '456',\n        url: 'http://...',\n      },\n    });\n  });\n\n  it('caches plural fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          screennames {\n            service,\n          },\n        }\n      }\n    `);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n        screennames: [\n          {service: 'GTALK'},\n          {service: 'TWITTER'},\n        ],\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(getPathToRecord('client:1')).toEqual(getPathToRecord('client:2'));\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 8,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        __typename: 'User',\n        id: '123',\n        screennames: [\n          {__dataID__: 'client:1'},\n          {__dataID__: 'client:2'},\n        ],\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        service: 'GTALK',\n      },\n      'client:2': {\n        __dataID__: 'client:2',\n        service: 'TWITTER',\n      },\n    });\n  });\n\n  it('caches connection fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          friends(first:\"2\") {\n            edges {\n              node {\n                id\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          },\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'User',\n        id: '123',\n        friends: {\n          edges: [\n            {\n              node: {\n                __typename: 'User',\n                id: '1',\n              },\n              cursor: '1',\n            },\n            {\n              node: {\n                __typename: 'User',\n                id: '2',\n              },\n              cursor: '2',\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 19,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __filterCalls__: [],\n        __forceIndex__: 0,\n        __range__: getRangeForRecord('client:1'),\n      },\n      'client:client:1:1': {\n        __dataID__: 'client:client:1:1',\n        node: {__dataID__: '1'},\n        cursor: '1',\n      },\n      '1': {\n        __dataID__: '1',\n        id: '1',\n      },\n      'client:client:1:2': {\n        __dataID__: 'client:client:1:2',\n        node: {__dataID__: '2'},\n        cursor: '2',\n      },\n      '2': {\n        __dataID__: '2',\n        id: '2',\n      },\n    });\n  });\n\n  it('caches connection fields with no edges', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          friends(first:\"2\") {\n            edges {\n              node {\n                id\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          },\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'User',\n        id: '123',\n        friends: {\n          edges: [],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 9,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __filterCalls__: [],\n        __forceIndex__: 0,\n        __range__: getRangeForRecord('client:1'),\n      },\n    });\n  });\n\n  it('caches simple mutations', () => {\n    var query = getNode(Relay.QL`query{node(id:\"123\"){id,doesViewerLike}}`);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n        doesViewerLike: false,\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {mutationWriter} = cacheManager.mocks;\n\n    var mutationQuery = getNode(Relay.QL`\n      mutation {\n        feedbackLike(input:$input) {\n          clientMutationId,\n          feedback {\n            id,\n            doesViewerLike,\n          },\n        }\n      }\n    `);\n    var payload = {\n      [CLIENT_MUTATION_ID]: 'abc',\n      feedback: {\n        id: '123',\n        doesViewerLike: true,\n      },\n    };\n    storeData.handleUpdatePayload(\n      mutationQuery,\n      payload,\n      {configs: [], isOptimisticUpdate: false}\n    );\n\n    expect(mutationWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 2, // both scalar fields are updated\n      writeRootCall: 0,\n    });\n    expect(mutationWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        doesViewerLike: true,\n      },\n    });\n  });\n\n  it('caches mutation that inserts an edge', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          comments(first:\"1\") {\n            count,\n            edges {\n              node {\n                id,\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          }\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'Story',\n        id: '123',\n        comments: {\n          count: 2,\n          edges: [\n            {\n              node: {\n                id: '1',\n              },\n              cursor: '1',\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {mutationWriter} = cacheManager.mocks;\n\n    var configs = [{\n      type: RelayMutationType.RANGE_ADD,\n      connectionName: 'comments',\n      edgeName: 'feedbackCommentEdge',\n      rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n    }];\n\n    var mutationQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedback {\n            id,\n            comments {\n              count,\n            },\n          },\n          feedbackCommentEdge {\n            node {\n              id,\n            },\n            cursor,\n            source {\n              id,\n            },\n          },\n        }\n      }\n    `);\n    var payload = {\n      [CLIENT_MUTATION_ID]: 'abc',\n      feedback: {\n        comments: {\n          count: 3,\n        },\n        id: '123',\n      },\n      feedbackCommentEdge: {\n        __typename: 'User',\n        node: {\n          id: '2',\n        },\n        cursor: '2',\n        source: {\n          id: '123',\n        },\n      },\n    };\n    storeData.handleUpdatePayload(\n      mutationQuery,\n      payload,\n      {configs, isOptimisticUpdate: false}\n    );\n\n    expect(mutationWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 11,\n      writeRootCall: 0,\n    });\n    expect(mutationWriter.writeField).toBeCalledWithNodeFields({\n      'client:1': {\n        __range__: getRangeForRecord('client:1'),\n        count: 3,\n      },\n      'client:client:1:2': {\n        __dataID__: 'client:client:1:2',\n        node: {__dataID__: '2'},\n        cursor: '2',\n        source: {__dataID__: '123'},\n      },\n      '2': {\n        __dataID__: '2',\n        id: '2',\n      },\n    });\n  });\n\n  it('caches mutation that deletes an edge', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          comments(first:\"1\") {\n            count,\n            edges {\n              node {\n                id,\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          }\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'Story',\n        id: '123',\n        comments: {\n          count: 2,\n          edges: [\n            {\n              node: {\n                id: '1',\n              },\n              cursor: '1',\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {mutationWriter} = cacheManager.mocks;\n\n    var configs = [{\n      type: RelayMutationType.RANGE_DELETE,\n      pathToConnection: ['feedback', 'comments'],\n      deletedIDFieldName: 'deletedCommentId',\n    }];\n\n    var mutationQuery = getNode(Relay.QL`\n      mutation {\n        commentDelete(input:$input) {\n          clientMutationId,\n          deletedCommentId,\n          feedback {\n            id,\n            comments {\n              count,\n            },\n          },\n        }\n      }\n    `);\n    var payload = {\n      [CLIENT_MUTATION_ID]: 'abc',\n      deletedCommentId: '1',\n      feedback: {\n        id: '123',\n        comments: {\n          count: 1,\n        },\n      },\n    };\n    storeData.handleUpdatePayload(\n      mutationQuery,\n      payload,\n      {configs, isOptimisticUpdate: false}\n    );\n\n    expect(mutationWriter).toContainCalledMethods({\n      writeNode: 1,\n      writeField: 4,\n      writeRootCall: 0,\n    });\n    expect(mutationWriter.writeField).toBeCalledWithNodeFields({\n      'client:1': {\n        __range__: getRangeForRecord('client:1'),\n        count: 1,\n      },\n    });\n  });\n\n  it('clears cache manager', () => {\n    storeData.clearCacheManager();\n    expect(storeData.hasCacheManager()).toBe(false);\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLMutatorConstants","Relay","RelayConnectionInterface","RelayMockCacheManager","RelayMutationType","RelayStoreData","RelayTestUtils","transformRelayQueryPayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMockCacheManager = require('RelayMockCacheManager');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('RelayStoreData', function() {\n  var cacheManager;\n  var storeData;\n\n  var {getNode} = RelayTestUtils;\n  var CLIENT_MUTATION_ID, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;\n\n  function getPathToRecord(dataID) {\n    return storeData.getRecordStore().getPathToRecord(dataID);\n  }\n\n  function getRangeForRecord(dataID) {\n    var nodeData = storeData.getNodeData();\n    expect(Object.keys(nodeData)).toContain(dataID);\n    return nodeData[dataID].__range__;\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({\n      CLIENT_MUTATION_ID,\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n    } = RelayConnectionInterface);\n\n    cacheManager = RelayMockCacheManager.genCacheManager();\n    storeData = new RelayStoreData();\n    storeData.injectCacheManager(cacheManager);\n\n    jasmine.addMatchers({\n      toContainCalledMethods: () => ({\n        compare: (actual, calls) => {\n          let message;\n          const pass = Object.keys(calls).every(methodName => {\n            const expected = calls[methodName];\n            const value = actual[methodName].mock.calls.length;\n            const pass = expected === value;\n\n            const expTimes = expected + ' time' + (expected === 1 ? '' : 's');\n            const actTimes = value + ' time' + (value === 1 ? '' : 's');\n            const not = pass ? 'not ' : '';\n            message = 'Expected `' + methodName + '` ' + not + 'to be called ' +\n              expTimes + ', was called ' + actTimes + '.';\n            return pass;\n          });\n          return {pass, message};\n        },\n      }),\n      toBeCalledWithNodeFields: (util, customEqualityTesters) => ({\n        compare: (actual, nodeFields) => {\n          let message;\n          const pass = Object.keys(nodeFields).every(\n            expectedID => Object.keys(nodeFields[expectedID]).every(\n              expectedFieldName => {\n                message =\n                  'Expected function to be called with (' +\n                  expectedID + ', ' +\n                  expectedFieldName + ', ' +\n                  nodeFields[expectedID][expectedFieldName] + ').';\n                return actual.mock.calls.some(\n                  ([actualID, actualFieldName, actualFieldValue]) => (\n                    actualID === expectedID &&\n                    actualFieldName === expectedFieldName &&\n                    util.equals(\n                      actualFieldValue,\n                      nodeFields[expectedID][actualFieldName],\n                      customEqualityTesters\n                    )\n                  )\n                );\n              }\n            )\n          );\n          return {pass, message};\n        },\n      }),\n    });\n  });\n\n  it('caches node metadata', () => {\n    var query = getNode(Relay.QL`query{node(id:\"123\"){id}}`);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 3,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        __typename: 'User',\n        id: '123',\n      },\n    });\n  });\n\n  it('caches custom root calls', () => {\n    var query = getNode(Relay.QL`query{username(name:\"yuzhi\"){id}}`);\n    var response = {\n      username: {\n        __typename: 'User',\n        id: '123',\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 3,\n      writeRootCall: 1,\n    });\n    expect(queryWriter.writeRootCall).toBeCalledWith(\n      'username',\n      'yuzhi',\n      '123'\n    );\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        __typename: 'User',\n        id: '123',\n      },\n    });\n  });\n\n  it('caches nodes with client IDs', () => {\n    var query = getNode(Relay.QL`query{viewer{isFbEmployee}}`);\n    var response = {\n      viewer: {\n        __typename: 'User',\n        isFbEmployee: true,\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 2,\n      writeRootCall: 1,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      'client:1': {\n        __dataID__: 'client:1',\n        isFbEmployee: true,\n      },\n    });\n  });\n\n  it('caches linked records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          hometown {\n            id,\n            url,\n          },\n        }\n      }\n    `);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n        hometown: {\n          __typename: 'Page',\n          id: '456',\n          url: 'http://...',\n        },\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 7,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        hometown: {__dataID__: '456'},\n      },\n      '456': {\n        __dataID__: '456',\n        id: '456',\n        url: 'http://...',\n      },\n    });\n  });\n\n  it('caches plural fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          screennames {\n            service,\n          },\n        }\n      }\n    `);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n        screennames: [\n          {service: 'GTALK'},\n          {service: 'TWITTER'},\n        ],\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(getPathToRecord('client:1')).toEqual(getPathToRecord('client:2'));\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 8,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        __typename: 'User',\n        id: '123',\n        screennames: [\n          {__dataID__: 'client:1'},\n          {__dataID__: 'client:2'},\n        ],\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        service: 'GTALK',\n      },\n      'client:2': {\n        __dataID__: 'client:2',\n        service: 'TWITTER',\n      },\n    });\n  });\n\n  it('caches connection fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          friends(first:\"2\") {\n            edges {\n              node {\n                id\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          },\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'User',\n        id: '123',\n        friends: {\n          edges: [\n            {\n              node: {\n                __typename: 'User',\n                id: '1',\n              },\n              cursor: '1',\n            },\n            {\n              node: {\n                __typename: 'User',\n                id: '2',\n              },\n              cursor: '2',\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 19,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __filterCalls__: [],\n        __forceIndex__: 0,\n        __range__: getRangeForRecord('client:1'),\n      },\n      'client:client:1:1': {\n        __dataID__: 'client:client:1:1',\n        node: {__dataID__: '1'},\n        cursor: '1',\n      },\n      '1': {\n        __dataID__: '1',\n        id: '1',\n      },\n      'client:client:1:2': {\n        __dataID__: 'client:client:1:2',\n        node: {__dataID__: '2'},\n        cursor: '2',\n      },\n      '2': {\n        __dataID__: '2',\n        id: '2',\n      },\n    });\n  });\n\n  it('caches connection fields with no edges', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          friends(first:\"2\") {\n            edges {\n              node {\n                id\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          },\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'User',\n        id: '123',\n        friends: {\n          edges: [],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {queryWriter} = cacheManager.mocks;\n\n    expect(queryWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 9,\n      writeRootCall: 0,\n    });\n    expect(queryWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        friends: {__dataID__: 'client:1'},\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __filterCalls__: [],\n        __forceIndex__: 0,\n        __range__: getRangeForRecord('client:1'),\n      },\n    });\n  });\n\n  it('caches simple mutations', () => {\n    var query = getNode(Relay.QL`query{node(id:\"123\"){id,doesViewerLike}}`);\n    var response = {\n      node: {\n        __typename: 'User',\n        id: '123',\n        doesViewerLike: false,\n      },\n    };\n    storeData.handleQueryPayload(query, response);\n    var {mutationWriter} = cacheManager.mocks;\n\n    var mutationQuery = getNode(Relay.QL`\n      mutation {\n        feedbackLike(input:$input) {\n          clientMutationId,\n          feedback {\n            id,\n            doesViewerLike,\n          },\n        }\n      }\n    `);\n    var payload = {\n      [CLIENT_MUTATION_ID]: 'abc',\n      feedback: {\n        id: '123',\n        doesViewerLike: true,\n      },\n    };\n    storeData.handleUpdatePayload(\n      mutationQuery,\n      payload,\n      {configs: [], isOptimisticUpdate: false}\n    );\n\n    expect(mutationWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 2, // both scalar fields are updated\n      writeRootCall: 0,\n    });\n    expect(mutationWriter.writeField).toBeCalledWithNodeFields({\n      '123': {\n        doesViewerLike: true,\n      },\n    });\n  });\n\n  it('caches mutation that inserts an edge', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          comments(first:\"1\") {\n            count,\n            edges {\n              node {\n                id,\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          }\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'Story',\n        id: '123',\n        comments: {\n          count: 2,\n          edges: [\n            {\n              node: {\n                id: '1',\n              },\n              cursor: '1',\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {mutationWriter} = cacheManager.mocks;\n\n    var configs = [{\n      type: RelayMutationType.RANGE_ADD,\n      connectionName: 'comments',\n      edgeName: 'feedbackCommentEdge',\n      rangeBehaviors: {'': GraphQLMutatorConstants.PREPEND},\n    }];\n\n    var mutationQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedback {\n            id,\n            comments {\n              count,\n            },\n          },\n          feedbackCommentEdge {\n            node {\n              id,\n            },\n            cursor,\n            source {\n              id,\n            },\n          },\n        }\n      }\n    `);\n    var payload = {\n      [CLIENT_MUTATION_ID]: 'abc',\n      feedback: {\n        comments: {\n          count: 3,\n        },\n        id: '123',\n      },\n      feedbackCommentEdge: {\n        __typename: 'User',\n        node: {\n          id: '2',\n        },\n        cursor: '2',\n        source: {\n          id: '123',\n        },\n      },\n    };\n    storeData.handleUpdatePayload(\n      mutationQuery,\n      payload,\n      {configs, isOptimisticUpdate: false}\n    );\n\n    expect(mutationWriter).toContainCalledMethods({\n      writeNode: 0,\n      writeField: 11,\n      writeRootCall: 0,\n    });\n    expect(mutationWriter.writeField).toBeCalledWithNodeFields({\n      'client:1': {\n        __range__: getRangeForRecord('client:1'),\n        count: 3,\n      },\n      'client:client:1:2': {\n        __dataID__: 'client:client:1:2',\n        node: {__dataID__: '2'},\n        cursor: '2',\n        source: {__dataID__: '123'},\n      },\n      '2': {\n        __dataID__: '2',\n        id: '2',\n      },\n    });\n  });\n\n  it('caches mutation that deletes an edge', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id,\n          comments(first:\"1\") {\n            count,\n            edges {\n              node {\n                id,\n              },\n              cursor,\n            },\n            pageInfo {\n              hasPreviousPage,\n              hasNextPage,\n            },\n          }\n        }\n      }\n    `);\n    var response = transformRelayQueryPayload(query, {\n      node: {\n        __typename: 'Story',\n        id: '123',\n        comments: {\n          count: 2,\n          edges: [\n            {\n              node: {\n                id: '1',\n              },\n              cursor: '1',\n            },\n          ],\n          [PAGE_INFO]: {\n            [HAS_PREV_PAGE]: false,\n            [HAS_NEXT_PAGE]: true,\n          },\n        },\n      },\n    });\n    storeData.handleQueryPayload(query, response);\n    var {mutationWriter} = cacheManager.mocks;\n\n    var configs = [{\n      type: RelayMutationType.RANGE_DELETE,\n      pathToConnection: ['feedback', 'comments'],\n      deletedIDFieldName: 'deletedCommentId',\n    }];\n\n    var mutationQuery = getNode(Relay.QL`\n      mutation {\n        commentDelete(input:$input) {\n          clientMutationId,\n          deletedCommentId,\n          feedback {\n            id,\n            comments {\n              count,\n            },\n          },\n        }\n      }\n    `);\n    var payload = {\n      [CLIENT_MUTATION_ID]: 'abc',\n      deletedCommentId: '1',\n      feedback: {\n        id: '123',\n        comments: {\n          count: 1,\n        },\n      },\n    };\n    storeData.handleUpdatePayload(\n      mutationQuery,\n      payload,\n      {configs, isOptimisticUpdate: false}\n    );\n\n    expect(mutationWriter).toContainCalledMethods({\n      writeNode: 1,\n      writeField: 4,\n      writeRootCall: 0,\n    });\n    expect(mutationWriter.writeField).toBeCalledWithNodeFields({\n      'client:1': {\n        __range__: getRangeForRecord('client:1'),\n        count: 1,\n      },\n    });\n  });\n\n  it('clears cache manager', () => {\n    storeData.clearCacheManager();\n    expect(storeData.hasCacheManager()).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayStoreData_cacheManager-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayStoreData-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayGarbageCollector = require('RelayGarbageCollector');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayStoreData', () => {\n  var Relay;\n\n  var {getNode, getVerbatimNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    // @side-effect related to garbage collection\n    Relay = require('Relay');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('handleQueryPayload', () => {\n    it('writes responses to `records`', () => {\n      var storeData = new RelayStoreData();\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            doesViewerLike,\n            topLevelComments {\n              count,\n            },\n          }\n        }\n      `);\n      var response = {\n        node: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n          __typename: 'Story',\n        },\n      };\n      storeData.handleQueryPayload(query, response);\n\n      // results are written to `records`\n      var recordStore = storeData.getRecordStore();\n      expect(recordStore.getRecordState('123')).toBe('EXISTENT');\n      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        recordStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(recordStore.getField(commentsID, 'count')).toBe(1);\n\n      // `queuedRecords` is unchanged\n      expect(storeData.getQueuedData()).toEqual({});\n    });\n\n    it('uses cached IDs for root fields without IDs', () => {\n      var storeData = new RelayStoreData();\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            doesViewerLike,\n            topLevelComments {\n              count,\n            },\n          }\n        }\n      `);\n      var response = {\n        node: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n          __typename: 'Story',\n        },\n      };\n      storeData.handleQueryPayload(query, response);\n\n      // results are written to `records`\n      var recordStore = storeData.getRecordStore();\n      expect(recordStore.getRecordState('123')).toBe('EXISTENT');\n      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        recordStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(recordStore.getField(commentsID, 'count')).toBe(1);\n\n      // `queuedRecords` is unchanged\n      expect(storeData.getQueuedData()).toEqual({});\n    });\n  });\n\n  describe('handleUpdatePayload', () => {\n    it('writes server payloads to `records`', () => {\n      var storeData = new RelayStoreData();\n      // create the root node\n      storeData.getRecordWriter().putRecord('123');\n\n      var mutationQuery = getNode(Relay.QL`\n        mutation {\n          feedbackLike(input:$input) {\n            clientMutationId,\n            feedback {\n              id,\n              doesViewerLike,\n              topLevelComments {\n                count,\n              }\n            },\n          }\n        }\n      `);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'abc',\n        feedback: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n        },\n      };\n      storeData.handleUpdatePayload(mutationQuery, payload, {\n        configs: [],\n        isOptimisticUpdate: false,\n      });\n\n      // results are written to `records`\n      var recordStore = storeData.getRecordStore();\n      expect(recordStore.getRecordState('123')).toBe('EXISTENT');\n      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        recordStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(recordStore.getField(commentsID, 'count')).toBe(1);\n\n      // `queuedRecords` is unchanged\n      expect(storeData.getQueuedData()).toEqual({});\n    });\n\n    it('writes optimistic payloads to `queuedRecords`', () => {\n      var storeData = new RelayStoreData();\n      // create the root node\n      storeData.getRecordWriter().putRecord('123');\n\n      var mutationQuery = getNode(Relay.QL`\n        mutation {\n          feedbackLike(input:$input) {\n            clientMutationId,\n            feedback {\n              id,\n              doesViewerLike,\n              topLevelComments {\n                count,\n              }\n            },\n          }\n        }\n      `);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'abc',\n        feedback: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n        },\n      };\n      storeData.handleUpdatePayload(mutationQuery, payload, {\n        configs: [],\n        isOptimisticUpdate: true,\n        clientMutationID: 'mutationID',\n      });\n\n      // results are written to `queuedRecords`\n      var queuedStore = storeData.getQueuedStore();\n      expect(queuedStore.getRecordState('123')).toBe('EXISTENT');\n      expect(queuedStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        queuedStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(queuedStore.getField(commentsID, 'count')).toBe(1);\n\n      // `records` is unchanged\n      expect(storeData.getNodeData()).toEqual({\n        '123': {\n          __dataID__: '123',\n          __typename: undefined,\n        },\n      });\n    });\n\n    it(\n      'writes optimistic payloads to `queuedRecords` even if values are ' +\n      'identical to those in `records`',\n      () => {\n        // Example case: With a story unliked, quickly like and unlike it. The\n        // second unlike will have the same value as the store\n        // (`doesViewerLike === false`), but this must be recorded as an\n        // optimistic value so that the first server payload (with the story\n        // liked) is ignored.\n        var storeData = new RelayStoreData();\n\n        // write starting values for a query\n        var query = getNode(Relay.QL`\n          query {\n            node(id:\"123\") {\n              id,\n              doesViewerLike,\n              topLevelComments {\n                count,\n              },\n            }\n          }\n        `);\n        var response = {\n          node: {\n            id: '123',\n            doesViewerLike: false,\n            topLevelComments: {\n              count: 1,\n            },\n            __typename: 'Story',\n          },\n        };\n        storeData.handleQueryPayload(query, response);\n\n        // write an optimistic update with the same values as the store\n        var mutationQuery = getNode(Relay.QL`\n          mutation {\n            feedbackLike(input:$input) {\n              clientMutationId,\n              feedback {\n                id,\n                doesViewerLike,\n                topLevelComments {\n                  count,\n                }\n              },\n            }\n          }\n        `);\n        var payload = {\n          [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'abc',\n          feedback: {\n            id: '123',\n            doesViewerLike: false,\n            topLevelComments: {\n              count: 1,\n            },\n          },\n        };\n        storeData.handleUpdatePayload(mutationQuery, payload, {\n          configs: [],\n          isOptimisticUpdate: true,\n          clientMutationID: 'mutationID',\n        });\n\n        // simulate a server response with different data\n        response = {\n          node: {\n            id: '123',\n            doesViewerLike: true, // inverted\n            topLevelComments: null, // delete\n          },\n        };\n        storeData.handleQueryPayload(query, response);\n\n        // verify that the optimistic update takes precedence over the\n        // server update\n        var recordStore = storeData.getQueuedStore();\n        expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n        var commentsID =\n          recordStore.getLinkedRecordID('123', 'topLevelComments');\n        expect(commentsID).toBeTruthy();\n        expect(recordStore.getField(commentsID, 'count')).toBe(1);\n      }\n    );\n  });\n\n  describe('buildFragmentQueryForDataID', () => {\n    it('builds root queries for refetchable IDs', () => {\n      var data = new RelayStoreData();\n      var fragment = getNode(Relay.QL`\n        fragment on User {\n          id\n          name\n        }\n      `);\n      var query = data.buildFragmentQueryForDataID(\n        fragment,\n        '123'\n      );\n      expect(query).toEqualQueryRoot(getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n            __typename\n            ... on User {\n              id\n              name\n            }\n          }\n        }\n      `));\n      expect(query.getName()).toBe(fragment.getDebugName());\n      expect(query.isAbstract()).toBe(true);\n    });\n\n    it('builds root queries using the path for non-refetchable IDs', () => {\n      var storeData = new RelayStoreData();\n      var addressFragment = Relay.QL`fragment on User{id,address{city}}`;\n      var node = getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            id,\n            ${addressFragment}\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          __typename: 'User',\n          address: {\n            city: 'Menlo Park',\n          },\n        },\n      };\n      storeData.handleQueryPayload(node, payload);\n\n      var fragment = getNode(Relay.QL`\n        fragment on StreetAddress {\n          city,\n        }\n      `);\n      var query = storeData.buildFragmentQueryForDataID(fragment, 'client:1');\n      expect(query).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n        query RelayStoreData($id_0: ID!) {\n          node(id: $id_0) {\n            ... on User {\n              id,\n              __typename,\n              address {\n                ... on StreetAddress {\n                  city,\n                },\n              },\n            }\n          },\n        }\n      `, {id_0: '123'}));\n      expect(query.getName()).toBe(node.getName());\n      expect(query.isAbstract()).toBe(true);\n    });\n  });\n\n  describe('garbage collection', () => {\n    it('initializes the garbage collector if no data has been added', () => {\n      var data = new RelayStoreData();\n      expect(data.getGarbageCollector()).toBe(undefined);\n      expect(() => data.initializeGarbageCollector()).not.toThrow();\n      expect(\n        data.getGarbageCollector() instanceof RelayGarbageCollector\n      ).toBe(true);\n    });\n\n    it('warns if initialized after data has been added', () => {\n      jest.mock('warning');\n\n      var response = {node: {id: 0, __typename: 'User'}};\n      var data = new RelayStoreData();\n      var query = getNode(Relay.QL`query{node(id:\"a\") {id}}`);\n      data.handleQueryPayload(query, response);\n\n      const warningMsg =\n        'RelayStoreData: Garbage collection can only be initialized when ' +\n        'no data is present.';\n      expect([warningMsg]).toBeWarnedNTimes(0);\n      data.initializeGarbageCollector();\n      expect([warningMsg]).toBeWarnedNTimes(1);\n    });\n\n    it(\n      'registers created dataIDs in the garbage collector if it has been ' +\n      'initialized',\n      () => {\n        RelayGarbageCollector.prototype.register = jest.genMockFunction();\n        var response = {node: {id: 0}};\n        var data = new RelayStoreData();\n        data.initializeGarbageCollector();\n        var query = getNode(Relay.QL`query{node(id:\"a\") {id}}`);\n        var garbageCollector = data.getGarbageCollector();\n\n        expect(garbageCollector.register).not.toBeCalled();\n        data.handleQueryPayload(query, response);\n        expect(garbageCollector.register).toBeCalled();\n        expect(garbageCollector.register.mock.calls[0][0]).toBe('a');\n      }\n    );\n  });\n});\n","dependencies":["configureForRelayOSS","RelayConnectionInterface","RelayStoreData","RelayGarbageCollector","RelayTestUtils","Relay"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment');\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayGarbageCollector = require('RelayGarbageCollector');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayStoreData', () => {\n  var Relay;\n\n  var {getNode, getVerbatimNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    // @side-effect related to garbage collection\n    Relay = require('Relay');\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('handleQueryPayload', () => {\n    it('writes responses to `records`', () => {\n      var storeData = new RelayStoreData();\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            doesViewerLike,\n            topLevelComments {\n              count,\n            },\n          }\n        }\n      `);\n      var response = {\n        node: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n          __typename: 'Story',\n        },\n      };\n      storeData.handleQueryPayload(query, response);\n\n      // results are written to `records`\n      var recordStore = storeData.getRecordStore();\n      expect(recordStore.getRecordState('123')).toBe('EXISTENT');\n      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        recordStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(recordStore.getField(commentsID, 'count')).toBe(1);\n\n      // `queuedRecords` is unchanged\n      expect(storeData.getQueuedData()).toEqual({});\n    });\n\n    it('uses cached IDs for root fields without IDs', () => {\n      var storeData = new RelayStoreData();\n\n      var query = getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n            doesViewerLike,\n            topLevelComments {\n              count,\n            },\n          }\n        }\n      `);\n      var response = {\n        node: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n          __typename: 'Story',\n        },\n      };\n      storeData.handleQueryPayload(query, response);\n\n      // results are written to `records`\n      var recordStore = storeData.getRecordStore();\n      expect(recordStore.getRecordState('123')).toBe('EXISTENT');\n      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        recordStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(recordStore.getField(commentsID, 'count')).toBe(1);\n\n      // `queuedRecords` is unchanged\n      expect(storeData.getQueuedData()).toEqual({});\n    });\n  });\n\n  describe('handleUpdatePayload', () => {\n    it('writes server payloads to `records`', () => {\n      var storeData = new RelayStoreData();\n      // create the root node\n      storeData.getRecordWriter().putRecord('123');\n\n      var mutationQuery = getNode(Relay.QL`\n        mutation {\n          feedbackLike(input:$input) {\n            clientMutationId,\n            feedback {\n              id,\n              doesViewerLike,\n              topLevelComments {\n                count,\n              }\n            },\n          }\n        }\n      `);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'abc',\n        feedback: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n        },\n      };\n      storeData.handleUpdatePayload(mutationQuery, payload, {\n        configs: [],\n        isOptimisticUpdate: false,\n      });\n\n      // results are written to `records`\n      var recordStore = storeData.getRecordStore();\n      expect(recordStore.getRecordState('123')).toBe('EXISTENT');\n      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        recordStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(recordStore.getField(commentsID, 'count')).toBe(1);\n\n      // `queuedRecords` is unchanged\n      expect(storeData.getQueuedData()).toEqual({});\n    });\n\n    it('writes optimistic payloads to `queuedRecords`', () => {\n      var storeData = new RelayStoreData();\n      // create the root node\n      storeData.getRecordWriter().putRecord('123');\n\n      var mutationQuery = getNode(Relay.QL`\n        mutation {\n          feedbackLike(input:$input) {\n            clientMutationId,\n            feedback {\n              id,\n              doesViewerLike,\n              topLevelComments {\n                count,\n              }\n            },\n          }\n        }\n      `);\n      var payload = {\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'abc',\n        feedback: {\n          id: '123',\n          doesViewerLike: false,\n          topLevelComments: {\n            count: 1,\n          },\n        },\n      };\n      storeData.handleUpdatePayload(mutationQuery, payload, {\n        configs: [],\n        isOptimisticUpdate: true,\n        clientMutationID: 'mutationID',\n      });\n\n      // results are written to `queuedRecords`\n      var queuedStore = storeData.getQueuedStore();\n      expect(queuedStore.getRecordState('123')).toBe('EXISTENT');\n      expect(queuedStore.getField('123', 'doesViewerLike')).toBe(false);\n      var commentsID =\n        queuedStore.getLinkedRecordID('123', 'topLevelComments');\n      expect(queuedStore.getField(commentsID, 'count')).toBe(1);\n\n      // `records` is unchanged\n      expect(storeData.getNodeData()).toEqual({\n        '123': {\n          __dataID__: '123',\n          __typename: undefined,\n        },\n      });\n    });\n\n    it(\n      'writes optimistic payloads to `queuedRecords` even if values are ' +\n      'identical to those in `records`',\n      () => {\n        // Example case: With a story unliked, quickly like and unlike it. The\n        // second unlike will have the same value as the store\n        // (`doesViewerLike === false`), but this must be recorded as an\n        // optimistic value so that the first server payload (with the story\n        // liked) is ignored.\n        var storeData = new RelayStoreData();\n\n        // write starting values for a query\n        var query = getNode(Relay.QL`\n          query {\n            node(id:\"123\") {\n              id,\n              doesViewerLike,\n              topLevelComments {\n                count,\n              },\n            }\n          }\n        `);\n        var response = {\n          node: {\n            id: '123',\n            doesViewerLike: false,\n            topLevelComments: {\n              count: 1,\n            },\n            __typename: 'Story',\n          },\n        };\n        storeData.handleQueryPayload(query, response);\n\n        // write an optimistic update with the same values as the store\n        var mutationQuery = getNode(Relay.QL`\n          mutation {\n            feedbackLike(input:$input) {\n              clientMutationId,\n              feedback {\n                id,\n                doesViewerLike,\n                topLevelComments {\n                  count,\n                }\n              },\n            }\n          }\n        `);\n        var payload = {\n          [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'abc',\n          feedback: {\n            id: '123',\n            doesViewerLike: false,\n            topLevelComments: {\n              count: 1,\n            },\n          },\n        };\n        storeData.handleUpdatePayload(mutationQuery, payload, {\n          configs: [],\n          isOptimisticUpdate: true,\n          clientMutationID: 'mutationID',\n        });\n\n        // simulate a server response with different data\n        response = {\n          node: {\n            id: '123',\n            doesViewerLike: true, // inverted\n            topLevelComments: null, // delete\n          },\n        };\n        storeData.handleQueryPayload(query, response);\n\n        // verify that the optimistic update takes precedence over the\n        // server update\n        var recordStore = storeData.getQueuedStore();\n        expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);\n        var commentsID =\n          recordStore.getLinkedRecordID('123', 'topLevelComments');\n        expect(commentsID).toBeTruthy();\n        expect(recordStore.getField(commentsID, 'count')).toBe(1);\n      }\n    );\n  });\n\n  describe('buildFragmentQueryForDataID', () => {\n    it('builds root queries for refetchable IDs', () => {\n      var data = new RelayStoreData();\n      var fragment = getNode(Relay.QL`\n        fragment on User {\n          id\n          name\n        }\n      `);\n      var query = data.buildFragmentQueryForDataID(\n        fragment,\n        '123'\n      );\n      expect(query).toEqualQueryRoot(getNode(Relay.QL`\n        query {\n          node(id:\"123\") {\n            id\n            __typename\n            ... on User {\n              id\n              name\n            }\n          }\n        }\n      `));\n      expect(query.getName()).toBe(fragment.getDebugName());\n      expect(query.isAbstract()).toBe(true);\n    });\n\n    it('builds root queries using the path for non-refetchable IDs', () => {\n      var storeData = new RelayStoreData();\n      var addressFragment = Relay.QL`fragment on User{id,address{city}}`;\n      var node = getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            id,\n            ${addressFragment}\n          }\n        }\n      `);\n      var payload = {\n        node: {\n          id: '123',\n          __typename: 'User',\n          address: {\n            city: 'Menlo Park',\n          },\n        },\n      };\n      storeData.handleQueryPayload(node, payload);\n\n      var fragment = getNode(Relay.QL`\n        fragment on StreetAddress {\n          city,\n        }\n      `);\n      var query = storeData.buildFragmentQueryForDataID(fragment, 'client:1');\n      expect(query).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n        query RelayStoreData($id_0: ID!) {\n          node(id: $id_0) {\n            ... on User {\n              id,\n              __typename,\n              address {\n                ... on StreetAddress {\n                  city,\n                },\n              },\n            }\n          },\n        }\n      `, {id_0: '123'}));\n      expect(query.getName()).toBe(node.getName());\n      expect(query.isAbstract()).toBe(true);\n    });\n  });\n\n  describe('garbage collection', () => {\n    it('initializes the garbage collector if no data has been added', () => {\n      var data = new RelayStoreData();\n      expect(data.getGarbageCollector()).toBe(undefined);\n      expect(() => data.initializeGarbageCollector()).not.toThrow();\n      expect(\n        data.getGarbageCollector() instanceof RelayGarbageCollector\n      ).toBe(true);\n    });\n\n    it('warns if initialized after data has been added', () => {\n      jest.mock('warning');\n\n      var response = {node: {id: 0, __typename: 'User'}};\n      var data = new RelayStoreData();\n      var query = getNode(Relay.QL`query{node(id:\"a\") {id}}`);\n      data.handleQueryPayload(query, response);\n\n      const warningMsg =\n        'RelayStoreData: Garbage collection can only be initialized when ' +\n        'no data is present.';\n      expect([warningMsg]).toBeWarnedNTimes(0);\n      data.initializeGarbageCollector();\n      expect([warningMsg]).toBeWarnedNTimes(1);\n    });\n\n    it(\n      'registers created dataIDs in the garbage collector if it has been ' +\n      'initialized',\n      () => {\n        RelayGarbageCollector.prototype.register = jest.genMockFunction();\n        var response = {node: {id: 0}};\n        var data = new RelayStoreData();\n        data.initializeGarbageCollector();\n        var query = getNode(Relay.QL`query{node(id:\"a\") {id}}`);\n        var garbageCollector = data.getGarbageCollector();\n\n        expect(garbageCollector.register).not.toBeCalled();\n        data.handleQueryPayload(query, response);\n        expect(garbageCollector.register).toBeCalled();\n        expect(garbageCollector.register.mock.calls[0][0]).toBe('a');\n      }\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayStoreData-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecordWriter-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.autoMockOff();\n\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMockCacheManager = require('RelayMockCacheManager');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\nconst {APPEND, PREPEND, REMOVE} = require('GraphQLMutatorConstants');\n\ndescribe('RelayRecordWriter', () => {\n\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('getDataID()', () => {\n    it('returns undefined for unknown root call ids', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(store.getDataID('username', 'zuck')).toBe(undefined);\n    });\n    it('returns id for node/nodes root call ids', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(store.getDataID('node', '4')).toBe('4');\n      expect(store.getDataID('nodes', '4')).toBe('4');\n    });\n  });\n\n  describe('putDataID()', () => {\n    it('sets root call ids', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putDataID('username', 'zuck', 'node:4');\n      expect(store.getDataID('username', 'zuck')).toBe('node:4');\n      expect(cache.writeRootCall).toBeCalledWith('username', 'zuck', 'node:4');\n    });\n\n    it('does not set ids for node/nodes root calls', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const rootCallMap = {};\n      const store =\n        new RelayRecordWriter({}, rootCallMap, false, null, cache);\n      store.putDataID('node', '4', 'node:4');\n      store.putDataID('nodes', '4', 'node:4');\n      expect(rootCallMap).toEqual({});\n      expect(cache.writeRootCall).not.toBeCalled();\n    });\n  });\n\n  describe('deleteRecord()', () => {\n    it('sets records to null', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const records = {\n        '1': {\n          __dataID__: '1',\n        },\n      };\n      const store = new RelayRecordWriter(records, {}, false, null, cache);\n      store.deleteRecord('1');\n      expect(store.getRecordState('1')).toBe('NONEXISTENT');\n      expect(cache.writeNode).toBeCalledWith('1', null);\n      store.deleteRecord('2');\n      expect(store.getRecordState('2')).toBe('NONEXISTENT');\n      expect(cache.writeNode).toBeCalledWith('2', null);\n    });\n  });\n\n  describe('putRecord()', () => {\n    it('creates records', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const records = {};\n      const store = new RelayRecordWriter(records, {}, false, null, cache);\n\n      store.putRecord('1', 'Type');\n      expect(store.getRecordState('1')).toBe('EXISTENT');\n      expect(store.getType('1')).toBe('Type');\n      expect(cache.writeField).toBeCalledWith('1', '__dataID__', '1', 'Type');\n    });\n\n    it('creates records for optimistic write', () => {\n      const records = {};\n      const store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('b', 'Type');\n      expect(store.getRecordState('b')).toBe('EXISTENT');\n      expect(records.b.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.b.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putField()', () => {\n    it('throws if the record does not exist', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.putField('1', 'name', null);\n      }).toFailInvariant(\n        'RelayRecordWriter.putField(): Expected record `1` to exist before ' +\n        'writing field `name`.'\n      );\n    });\n\n    it('writes scalar fields', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putField('1', 'name', null);\n      expect(store.getField('1', 'name')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'name', null, 'Type');\n      store.putField('1', 'name', undefined);\n      expect(store.getField('1', 'name')).toBe(undefined);\n      expect(cache.writeField)\n        .toBeCalledWith('1', 'name', undefined, 'Type');\n      store.putField('1', 'name', 'Joe');\n      expect(store.getField('1', 'name')).toBe('Joe');\n      expect(cache.writeField).toBeCalledWith('1', 'name', 'Joe', 'Type');\n      const email = 'joesavona@fb.com';\n      store.putField('1', 'email_addresses', [email]);\n      expect(store.getField('1', 'email_addresses')).toEqual([email]);\n      expect(cache.writeField)\n        .toBeCalledWith('1', 'email_addresses', [email], 'Type');\n      const phone = {\n        is_verified: true,\n        phone_number: {\n          display_number: '1-800-555-1212', // directory assistance\n        },\n      };\n      store.putField('1', 'all_phones', [phone]);\n      expect(store.getField('1', 'all_phones')).toEqual([phone]);\n      expect(cache.writeField)\n        .toBeCalledWith('1', 'all_phones', [phone], 'Type');\n    });\n\n    it('writes fields optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('b', 'Type');\n      store.putField('b', 'name', 'd');\n      expect(store.getField('b', 'name')).toBe('d');\n      expect(records.b.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.b.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('deleteField()', () => {\n    it('throws if the record does not exist', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.deleteField('1', 'name', null);\n      }).toThrowError(\n        'RelayRecordWriter.deleteField(): Expected record `1` to exist ' +\n        'before deleting field `name`.'\n      );\n    });\n\n    it('deletes fields', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putRecord('2', 'Type');\n\n      store.putField('1', 'scalar', 'foo');\n      store.deleteField('1', 'scalar');\n      expect(store.getField('1', 'scalar')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'scalar', null);\n\n      store.putLinkedRecordID('1', 'singular', '2');\n      store.deleteField('1', 'singular');\n      expect(store.getField('1', 'singular')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'singular', null);\n\n      store.putLinkedRecordIDs('1', 'plural', ['2']);\n      store.deleteField('1', 'plural');\n      expect(store.getField('1', 'plural')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'plural', null);\n    });\n\n    it('deletes fields optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('b', 'Type');\n      store.deleteField('b', 'name');\n      expect(store.getField('b', 'name')).toBe(null);\n      expect(records.b.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.b.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putLinkedRecordID()', () => {\n    it('throws if either record does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      store.putRecord('1', 'Type');\n      expect(() => {\n        store.putLinkedRecordID('2', 'link', '1');\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordID(): Expected record `2` to exist ' +\n        'before linking to record `1`.'\n      );\n      expect(() => {\n        store.putLinkedRecordID('1', 'link', '2');\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordID(): Expected record `2` to exist ' +\n        'before linking from record `1`.'\n      );\n    });\n\n    it('writes links between records', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('viewerID', 'Type');\n      store.putRecord('actorID', 'Type');\n      store.putLinkedRecordID('viewerID', 'actor', 'actorID');\n      expect(store.getLinkedRecordID('viewerID', 'actor')).toBe('actorID');\n      expect(cache.writeField).toBeCalledWith('viewerID', 'actor', {\n        __dataID__: 'actorID',\n      });\n    });\n\n    it('writes linked record optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('a', 'Type');\n      store.putRecord('b', 'Type');\n\n      store.putLinkedRecordID('a', 'friend', 'b');\n      expect(store.getLinkedRecordID('a', 'friend')).toBe('b');\n      expect(records.a.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.a.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putLinkedRecordIDs()', () => {\n    it('throws if either record does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      store.putRecord('1', 'Type');\n      expect(() => {\n        store.putLinkedRecordIDs('2', 'link', ['1']);\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordIDs(): Expected record `2` to ' +\n        'exist before linking records.'\n      );\n      expect(() => {\n        store.putLinkedRecordIDs('1', 'link', ['2']);\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordIDs(): Expected record `2` to ' +\n        'exist before linking from `1`.'\n      );\n    });\n\n    it('writes one-to-n links between records', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('storyID', 'Type');\n      store.putRecord('actor1', 'Type');\n      store.putRecord('actor2', 'Type');\n      store.putLinkedRecordIDs('storyID', 'actors', ['actor1', 'actor2']);\n      expect(store.getLinkedRecordIDs('storyID', 'actors'))\n        .toEqual(['actor1', 'actor2']);\n      expect(cache.writeField).toBeCalledWith('storyID', 'actors', [\n        {__dataID__: 'actor1'},\n        {__dataID__: 'actor2'},\n      ]);\n    });\n\n    it('writes linked records optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('a', 'Type');\n      store.putRecord('b', 'Type');\n\n      store.putLinkedRecordIDs('a', 'friends', ['b']);\n      expect(store.getLinkedRecordIDs('a', 'friends')).toEqual(['b']);\n      expect(records.a.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.a.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putRange()', () => {\n    it('throws if the record does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.putRange('1', []);\n      }).toFailInvariant(\n        'RelayRecordWriter.putRange(): Expected record `1` to exist ' +\n        'before adding a range.'\n      );\n    });\n\n    it('creates ranges if not defined', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      expect(records['1'].__range__ instanceof GraphQLRange).toBe(true);\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__range__',\n        records['1'].__range__\n      );\n    });\n\n    it('overwrites ranges if present',  () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      var range1 = records['1'].__range__;\n      store.putRange('1', []);\n      var range2 = records['1'].__range__;\n      expect(range2 instanceof GraphQLRange).toBe(true);\n      expect(range1).not.toBe(range2);\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__range__',\n        range2\n      );\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__forceIndex__',\n        0\n      );\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__filterCalls__',\n        []\n      );\n    });\n\n    it('sets the force index for the new range', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      expect(store.getRangeForceIndex('1')).toBe(0); // not in store yet\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      expect(store.getRangeForceIndex('1')).toBe(0);\n      store.putRange('1', [], 10);\n      expect(store.getRangeForceIndex('1')).toBe(10);\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__forceIndex__',\n        10\n      );\n    });\n\n    it('returns a negative force index for deleted ranges', () => {\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false);\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      store.deleteRecord('1');\n      expect(store.getRecordState('1')).toBe('NONEXISTENT');\n      expect(store.getRangeForceIndex('1')).toBe(-1);\n    });\n\n    it('sets the filter calls for a range', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      var calls = [\n        {\n          name: 'orderby',\n          value: 'TOP_STORIES',\n        },\n        {\n          name: 'first',\n          value: '10',\n        },\n      ];\n      store.putRecord('1', 'Type');\n      store.putRange('1', calls);\n      expect(store.getRangeFilterCalls('1')).toEqual(calls.slice(0, 1));\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__filterCalls__',\n        calls.slice(0, 1)\n      );\n    });\n  });\n\n  describe('putRangeEdges()', () => {\n    it('throws if the record or range does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.putRangeEdges('1', [], {}, []);\n      }).toFailInvariant(\n        'RelayRecordWriter.putRangeEdges(): Expected record `1` to exist and ' +\n        'have a range.'\n      );\n      store.putRecord('1', 'Type');\n      expect(() => {\n        store.putRangeEdges('1', [], {}, []);\n      }).toFailInvariant(\n        'RelayRecordWriter.putRangeEdges(): Expected record `1` to exist and ' +\n        'have a range.'\n      );\n    });\n\n    it('adds edges to the range', () => {\n      var connectionID = '1';\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var nodeConnectionMap = {};\n      var store = new RelayRecordStore({records}, null, nodeConnectionMap);\n      var writer = new RelayRecordWriter(\n        records,\n        {},\n        false,\n        nodeConnectionMap,\n        cache\n      );\n      writer.putRecord(connectionID, 'Type');\n      writer.putRange(connectionID, []);\n      var pageInfo = {\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      };\n      var calls = [{name: 'first', value: 3}];\n      var edges = [];\n      var nodes = [];\n      for (var ii = 0; ii < 3; ii++) {\n        var edgeID = 'edge' + ii;\n        var nodeID = 'node' + ii;\n        writer.putRecord(edgeID, 'Type');\n        writer.putRecord(nodeID, 'Type');\n        writer.putLinkedRecordID(edgeID, 'node', nodeID);\n        writer.putField(edgeID, 'cursor', 'cursor' + ii);\n        edges.push(edgeID);\n        nodes.push(nodeID);\n      }\n      writer.putRangeEdges(\n        connectionID,\n        calls,\n        pageInfo,\n        edges\n      );\n\n      // node are automatically associated with the range\n      nodes.forEach(nodeID => {\n        expect(Object.keys(nodeConnectionMap[nodeID])).toEqual([connectionID]);\n      });\n\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.diffCalls).toEqual([]);\n      expect(rangeInfo.filterCalls).toEqual([]);\n      expect(rangeInfo.filteredEdges).toEqual([\n        {edgeID: 'edge0', nodeID: 'node0'},\n        {edgeID: 'edge1', nodeID: 'node1'},\n        {edgeID: 'edge2', nodeID: 'node2'},\n      ]);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n  });\n\n  describe('applyRangeUpdate()', () => {\n    var cache;\n    var connectionID;\n    var firstEdgeID;\n    var firstNodeID;\n    var lastEdgeID;\n    var nodeConnectionMap;\n    var optimisticWriter;\n    var queuedRecords;\n    var records;\n    var store;\n    var writer;\n\n    var _inc = 0;\n    function addEdgeToStore(store) {\n      var index = _inc++;\n      var edgeID = 'edge:' + index;\n      var nodeID = 'node:' + index;\n      var cursor = 'cursor:' + index;\n\n      store.putRecord(edgeID, 'Type');\n      store.putRecord(nodeID, 'Type');\n      store.putLinkedRecordID(edgeID, 'node', nodeID);\n      store.putField(edgeID, 'cursor', cursor);\n\n      return {cursor, edgeID, nodeID};\n    }\n\n    beforeEach(() => {\n      records = {};\n      queuedRecords = {};\n      cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      nodeConnectionMap = {};\n      store = new RelayRecordStore(\n        {records, queuedRecords},\n        null,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        {},\n        false,\n        nodeConnectionMap,\n        cache\n      );\n      optimisticWriter = new RelayRecordWriter(\n        queuedRecords,\n        {},\n        true,\n        nodeConnectionMap,\n        cache,\n        'mutationID'\n      );\n      connectionID = '123';\n\n      // create a range record\n      writer.putRecord(connectionID, 'Type');\n      writer.putRange(connectionID, []);\n      optimisticWriter.putRecord(connectionID, 'Type');\n\n      // ...with a first edge\n      var edge = addEdgeToStore(writer);\n      firstEdgeID = edge.edgeID;\n      firstNodeID = edge.nodeID;\n      writer.putRangeEdges(\n        connectionID,\n        [{name: 'first', value: 1}],\n        {\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n        },\n        [firstEdgeID]\n      );\n\n      // ...and a last edge\n      edge = addEdgeToStore(writer);\n      lastEdgeID = edge.edgeID;\n      writer.putRangeEdges(\n        connectionID,\n        [{name: 'last', value: 1}],\n        {\n          [HAS_NEXT_PAGE]: false,\n          [HAS_PREV_PAGE]: true,\n        },\n        [lastEdgeID]\n      );\n\n      cache.writeNode.mockClear();\n      cache.writeField.mockClear();\n      cache.writeRootCall.mockClear();\n    });\n\n    it('throws if the connection does not exist', () => {\n      var {edgeID} = addEdgeToStore(writer);\n      expect(() => {\n        writer.applyRangeUpdate('client:does.not.exist', edgeID, PREPEND);\n      }).toFailInvariant(\n        'RelayRecordWriter: Cannot apply `prepend` ' +\n        'update to non-existent record `client:does.not.exist`.'\n      );\n    });\n\n    it('prepends edges to base stores', () => {\n      var {edgeID, nodeID} = addEdgeToStore(writer);\n      writer.applyRangeUpdate(connectionID, edgeID, PREPEND);\n\n      // contains prepended edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n        firstEdgeID,\n      ]);\n      expect(store.getConnectionIDsForRecord(nodeID)).toEqual([connectionID]);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n\n    it('optimistically prepends edges to queued stores', () => {\n      var {edgeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(\n        connectionID,\n        edgeID,\n        PREPEND\n      );\n\n      // contains prepended edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n        firstEdgeID,\n      ]);\n      // cache not updated on optimistic range update\n      expect(cache.writeField).not.toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n\n      expect(queuedRecords[connectionID].__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(queuedRecords[connectionID].__mutationIDs__)\n        .toEqual(['mutationID']);\n    });\n\n    it('appends edges to base stores', () => {\n      var {edgeID, nodeID} = addEdgeToStore(writer);\n      writer.applyRangeUpdate(connectionID, edgeID, APPEND);\n\n      // contains appended edge\n      var calls = [{name: 'last', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        lastEdgeID,\n        edgeID,\n      ]);\n      expect(store.getConnectionIDsForRecord(nodeID)).toEqual([connectionID]);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n\n    it('optimistically appends edges to queued stores', () => {\n      var {edgeID, nodeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(\n        connectionID,\n        edgeID,\n        APPEND\n      );\n\n      // contains appended edge\n      var calls = [{name: 'last', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        lastEdgeID,\n        edgeID,\n      ]);\n      // cache not updated on optimistic range update\n      expect(cache.writeField).not.toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n\n      expect(store.getConnectionIDsForRecord(nodeID)).toEqual(null);\n      expect(queuedRecords[connectionID].__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(queuedRecords[connectionID].__mutationIDs__)\n        .toEqual(['mutationID']);\n    });\n\n    it('deletes edges from base stores', () => {\n      expect(store.getConnectionIDsForRecord(firstNodeID)).toEqual([\n        connectionID,\n      ]);\n      writer.applyRangeUpdate(connectionID, firstEdgeID, REMOVE);\n\n      // does not contain removed edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges).toEqual([]);\n      expect(store.getConnectionIDsForRecord(firstNodeID)).toEqual(null);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n\n    it('optimistically deletes existing edges from queued stores', () => {\n      optimisticWriter.applyRangeUpdate(\n        connectionID,\n        firstEdgeID,\n        REMOVE\n      );\n\n      // does not contain removed edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges).toEqual([]);\n      // cache not updated on optimistic range update\n      expect(cache.writeField).not.toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n\n      // base store is unchanged\n      expect(store.getConnectionIDsForRecord(firstNodeID)).toEqual([\n        connectionID,\n      ]);\n      expect(queuedRecords[connectionID].__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(queuedRecords[connectionID].__mutationIDs__)\n        .toEqual(['mutationID']);\n    });\n\n    it('deletes optimistically prepended edges from queued stores', () => {\n      var {edgeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, PREPEND);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n\n      // does not contain prepended & removed edge\n      var calls = [{name: 'first', value: 1}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        firstEdgeID,\n      ]);\n    });\n\n    it('deletes optimistically appended edges from queued stores', () => {\n      var {edgeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, APPEND);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n\n      // does not contain prepended & removed edge\n      var calls = [{name: 'last', value: 1}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        lastEdgeID,\n      ]);\n    });\n  });\n\n  describe('setHasDeferredFragmentData()', () => {\n    it('creates a cache in honor of the first entry', () => {\n      const records = {'a': {}};\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'fragID');\n      expect(records.a.hasOwnProperty('__resolvedFragmentMap__')).toBe(true);\n    });\n\n    it('creates a key in an already existing cache', () => {\n      const resolvedFragmentMap = {'fragID': true};\n      const records = {\n        'a': {'__resolvedFragmentMap__': resolvedFragmentMap},\n      };\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'otherFragID');\n      expect(resolvedFragmentMap.hasOwnProperty('otherFragID')).toBe(true);\n    });\n\n    it('increments the generation when a fragment\\'s resolvedness ' +\n       'changes', () => {\n      const records = {\n        // No resolved fragment map at all\n        'a': {},\n        // Map does not contain a key corresponding to our fragment\n        'b': {\n          '__resolvedFragmentMap__': {'otherFragID': true},\n          '__resolvedFragmentMapGeneration__': 0,\n        },\n      };\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'fragID');\n      expect(records.a.__resolvedFragmentMapGeneration__).toBe(0);\n      store.setHasDeferredFragmentData('b', 'fragID');\n      expect(records.b.__resolvedFragmentMapGeneration__).toBe(1);\n    });\n\n    it('increments the generation even when a fragment\\'s resolvedness ' +\n       'does not change', () => {\n      const records = {\n        // No resolved fragment map at all\n        'a': {},\n        // Map contains a key corresponding to our fragment\n        'b': {\n          '__resolvedFragmentMap__': {'fragID': true},\n          '__resolvedFragmentMapGeneration__': 0,\n        },\n      };\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'fragID');\n      expect(records.a.__resolvedFragmentMapGeneration__).toBe(0);\n      store.setHasDeferredFragmentData('b', 'fragID');\n      expect(records.b.__resolvedFragmentMapGeneration__).toBe(1);\n    });\n  });\n});\n","dependencies":["GraphQLRange","RelayConnectionInterface","RelayMockCacheManager","RelayRecordStatusMap","RelayRecordStore","RelayRecordWriter","RelayTestUtils","GraphQLMutatorConstants"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.autoMockOff();\n\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMockCacheManager = require('RelayMockCacheManager');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\nconst {APPEND, PREPEND, REMOVE} = require('GraphQLMutatorConstants');\n\ndescribe('RelayRecordWriter', () => {\n\n  var HAS_NEXT_PAGE, HAS_PREV_PAGE;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    ({HAS_NEXT_PAGE, HAS_PREV_PAGE} = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('getDataID()', () => {\n    it('returns undefined for unknown root call ids', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(store.getDataID('username', 'zuck')).toBe(undefined);\n    });\n    it('returns id for node/nodes root call ids', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(store.getDataID('node', '4')).toBe('4');\n      expect(store.getDataID('nodes', '4')).toBe('4');\n    });\n  });\n\n  describe('putDataID()', () => {\n    it('sets root call ids', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putDataID('username', 'zuck', 'node:4');\n      expect(store.getDataID('username', 'zuck')).toBe('node:4');\n      expect(cache.writeRootCall).toBeCalledWith('username', 'zuck', 'node:4');\n    });\n\n    it('does not set ids for node/nodes root calls', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const rootCallMap = {};\n      const store =\n        new RelayRecordWriter({}, rootCallMap, false, null, cache);\n      store.putDataID('node', '4', 'node:4');\n      store.putDataID('nodes', '4', 'node:4');\n      expect(rootCallMap).toEqual({});\n      expect(cache.writeRootCall).not.toBeCalled();\n    });\n  });\n\n  describe('deleteRecord()', () => {\n    it('sets records to null', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const records = {\n        '1': {\n          __dataID__: '1',\n        },\n      };\n      const store = new RelayRecordWriter(records, {}, false, null, cache);\n      store.deleteRecord('1');\n      expect(store.getRecordState('1')).toBe('NONEXISTENT');\n      expect(cache.writeNode).toBeCalledWith('1', null);\n      store.deleteRecord('2');\n      expect(store.getRecordState('2')).toBe('NONEXISTENT');\n      expect(cache.writeNode).toBeCalledWith('2', null);\n    });\n  });\n\n  describe('putRecord()', () => {\n    it('creates records', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const records = {};\n      const store = new RelayRecordWriter(records, {}, false, null, cache);\n\n      store.putRecord('1', 'Type');\n      expect(store.getRecordState('1')).toBe('EXISTENT');\n      expect(store.getType('1')).toBe('Type');\n      expect(cache.writeField).toBeCalledWith('1', '__dataID__', '1', 'Type');\n    });\n\n    it('creates records for optimistic write', () => {\n      const records = {};\n      const store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('b', 'Type');\n      expect(store.getRecordState('b')).toBe('EXISTENT');\n      expect(records.b.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.b.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putField()', () => {\n    it('throws if the record does not exist', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.putField('1', 'name', null);\n      }).toFailInvariant(\n        'RelayRecordWriter.putField(): Expected record `1` to exist before ' +\n        'writing field `name`.'\n      );\n    });\n\n    it('writes scalar fields', () => {\n      const cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      const store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putField('1', 'name', null);\n      expect(store.getField('1', 'name')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'name', null, 'Type');\n      store.putField('1', 'name', undefined);\n      expect(store.getField('1', 'name')).toBe(undefined);\n      expect(cache.writeField)\n        .toBeCalledWith('1', 'name', undefined, 'Type');\n      store.putField('1', 'name', 'Joe');\n      expect(store.getField('1', 'name')).toBe('Joe');\n      expect(cache.writeField).toBeCalledWith('1', 'name', 'Joe', 'Type');\n      const email = 'joesavona@fb.com';\n      store.putField('1', 'email_addresses', [email]);\n      expect(store.getField('1', 'email_addresses')).toEqual([email]);\n      expect(cache.writeField)\n        .toBeCalledWith('1', 'email_addresses', [email], 'Type');\n      const phone = {\n        is_verified: true,\n        phone_number: {\n          display_number: '1-800-555-1212', // directory assistance\n        },\n      };\n      store.putField('1', 'all_phones', [phone]);\n      expect(store.getField('1', 'all_phones')).toEqual([phone]);\n      expect(cache.writeField)\n        .toBeCalledWith('1', 'all_phones', [phone], 'Type');\n    });\n\n    it('writes fields optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('b', 'Type');\n      store.putField('b', 'name', 'd');\n      expect(store.getField('b', 'name')).toBe('d');\n      expect(records.b.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.b.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('deleteField()', () => {\n    it('throws if the record does not exist', () => {\n      const store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.deleteField('1', 'name', null);\n      }).toThrowError(\n        'RelayRecordWriter.deleteField(): Expected record `1` to exist ' +\n        'before deleting field `name`.'\n      );\n    });\n\n    it('deletes fields', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putRecord('2', 'Type');\n\n      store.putField('1', 'scalar', 'foo');\n      store.deleteField('1', 'scalar');\n      expect(store.getField('1', 'scalar')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'scalar', null);\n\n      store.putLinkedRecordID('1', 'singular', '2');\n      store.deleteField('1', 'singular');\n      expect(store.getField('1', 'singular')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'singular', null);\n\n      store.putLinkedRecordIDs('1', 'plural', ['2']);\n      store.deleteField('1', 'plural');\n      expect(store.getField('1', 'plural')).toBe(null);\n      expect(cache.writeField).toBeCalledWith('1', 'plural', null);\n    });\n\n    it('deletes fields optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('b', 'Type');\n      store.deleteField('b', 'name');\n      expect(store.getField('b', 'name')).toBe(null);\n      expect(records.b.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.b.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putLinkedRecordID()', () => {\n    it('throws if either record does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      store.putRecord('1', 'Type');\n      expect(() => {\n        store.putLinkedRecordID('2', 'link', '1');\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordID(): Expected record `2` to exist ' +\n        'before linking to record `1`.'\n      );\n      expect(() => {\n        store.putLinkedRecordID('1', 'link', '2');\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordID(): Expected record `2` to exist ' +\n        'before linking from record `1`.'\n      );\n    });\n\n    it('writes links between records', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('viewerID', 'Type');\n      store.putRecord('actorID', 'Type');\n      store.putLinkedRecordID('viewerID', 'actor', 'actorID');\n      expect(store.getLinkedRecordID('viewerID', 'actor')).toBe('actorID');\n      expect(cache.writeField).toBeCalledWith('viewerID', 'actor', {\n        __dataID__: 'actorID',\n      });\n    });\n\n    it('writes linked record optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('a', 'Type');\n      store.putRecord('b', 'Type');\n\n      store.putLinkedRecordID('a', 'friend', 'b');\n      expect(store.getLinkedRecordID('a', 'friend')).toBe('b');\n      expect(records.a.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.a.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putLinkedRecordIDs()', () => {\n    it('throws if either record does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      store.putRecord('1', 'Type');\n      expect(() => {\n        store.putLinkedRecordIDs('2', 'link', ['1']);\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordIDs(): Expected record `2` to ' +\n        'exist before linking records.'\n      );\n      expect(() => {\n        store.putLinkedRecordIDs('1', 'link', ['2']);\n      }).toFailInvariant(\n        'RelayRecordWriter.putLinkedRecordIDs(): Expected record `2` to ' +\n        'exist before linking from `1`.'\n      );\n    });\n\n    it('writes one-to-n links between records', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var store = new RelayRecordWriter({}, {}, false, null, cache);\n      store.putRecord('storyID', 'Type');\n      store.putRecord('actor1', 'Type');\n      store.putRecord('actor2', 'Type');\n      store.putLinkedRecordIDs('storyID', 'actors', ['actor1', 'actor2']);\n      expect(store.getLinkedRecordIDs('storyID', 'actors'))\n        .toEqual(['actor1', 'actor2']);\n      expect(cache.writeField).toBeCalledWith('storyID', 'actors', [\n        {__dataID__: 'actor1'},\n        {__dataID__: 'actor2'},\n      ]);\n    });\n\n    it('writes linked records optimistically', () => {\n      var records = {};\n      var store =\n        new RelayRecordWriter(records, {}, true, null, null, 'mutationID');\n\n      store.putRecord('a', 'Type');\n      store.putRecord('b', 'Type');\n\n      store.putLinkedRecordIDs('a', 'friends', ['b']);\n      expect(store.getLinkedRecordIDs('a', 'friends')).toEqual(['b']);\n      expect(records.a.__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(records.a.__mutationIDs__).toEqual(['mutationID']);\n    });\n  });\n\n  describe('putRange()', () => {\n    it('throws if the record does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.putRange('1', []);\n      }).toFailInvariant(\n        'RelayRecordWriter.putRange(): Expected record `1` to exist ' +\n        'before adding a range.'\n      );\n    });\n\n    it('creates ranges if not defined', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      expect(records['1'].__range__ instanceof GraphQLRange).toBe(true);\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__range__',\n        records['1'].__range__\n      );\n    });\n\n    it('overwrites ranges if present',  () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      var range1 = records['1'].__range__;\n      store.putRange('1', []);\n      var range2 = records['1'].__range__;\n      expect(range2 instanceof GraphQLRange).toBe(true);\n      expect(range1).not.toBe(range2);\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__range__',\n        range2\n      );\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__forceIndex__',\n        0\n      );\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__filterCalls__',\n        []\n      );\n    });\n\n    it('sets the force index for the new range', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      expect(store.getRangeForceIndex('1')).toBe(0); // not in store yet\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      expect(store.getRangeForceIndex('1')).toBe(0);\n      store.putRange('1', [], 10);\n      expect(store.getRangeForceIndex('1')).toBe(10);\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__forceIndex__',\n        10\n      );\n    });\n\n    it('returns a negative force index for deleted ranges', () => {\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false);\n      store.putRecord('1', 'Type');\n      store.putRange('1', []);\n      store.deleteRecord('1');\n      expect(store.getRecordState('1')).toBe('NONEXISTENT');\n      expect(store.getRangeForceIndex('1')).toBe(-1);\n    });\n\n    it('sets the filter calls for a range', () => {\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var store = new RelayRecordWriter(records, {}, false, null, cache);\n      var calls = [\n        {\n          name: 'orderby',\n          value: 'TOP_STORIES',\n        },\n        {\n          name: 'first',\n          value: '10',\n        },\n      ];\n      store.putRecord('1', 'Type');\n      store.putRange('1', calls);\n      expect(store.getRangeFilterCalls('1')).toEqual(calls.slice(0, 1));\n      expect(cache.writeField).toBeCalledWith(\n        '1',\n        '__filterCalls__',\n        calls.slice(0, 1)\n      );\n    });\n  });\n\n  describe('putRangeEdges()', () => {\n    it('throws if the record or range does not exist', () => {\n      var store = new RelayRecordWriter({}, {}, false);\n      expect(() => {\n        store.putRangeEdges('1', [], {}, []);\n      }).toFailInvariant(\n        'RelayRecordWriter.putRangeEdges(): Expected record `1` to exist and ' +\n        'have a range.'\n      );\n      store.putRecord('1', 'Type');\n      expect(() => {\n        store.putRangeEdges('1', [], {}, []);\n      }).toFailInvariant(\n        'RelayRecordWriter.putRangeEdges(): Expected record `1` to exist and ' +\n        'have a range.'\n      );\n    });\n\n    it('adds edges to the range', () => {\n      var connectionID = '1';\n      var cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      var records = {};\n      var nodeConnectionMap = {};\n      var store = new RelayRecordStore({records}, null, nodeConnectionMap);\n      var writer = new RelayRecordWriter(\n        records,\n        {},\n        false,\n        nodeConnectionMap,\n        cache\n      );\n      writer.putRecord(connectionID, 'Type');\n      writer.putRange(connectionID, []);\n      var pageInfo = {\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      };\n      var calls = [{name: 'first', value: 3}];\n      var edges = [];\n      var nodes = [];\n      for (var ii = 0; ii < 3; ii++) {\n        var edgeID = 'edge' + ii;\n        var nodeID = 'node' + ii;\n        writer.putRecord(edgeID, 'Type');\n        writer.putRecord(nodeID, 'Type');\n        writer.putLinkedRecordID(edgeID, 'node', nodeID);\n        writer.putField(edgeID, 'cursor', 'cursor' + ii);\n        edges.push(edgeID);\n        nodes.push(nodeID);\n      }\n      writer.putRangeEdges(\n        connectionID,\n        calls,\n        pageInfo,\n        edges\n      );\n\n      // node are automatically associated with the range\n      nodes.forEach(nodeID => {\n        expect(Object.keys(nodeConnectionMap[nodeID])).toEqual([connectionID]);\n      });\n\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.diffCalls).toEqual([]);\n      expect(rangeInfo.filterCalls).toEqual([]);\n      expect(rangeInfo.filteredEdges).toEqual([\n        {edgeID: 'edge0', nodeID: 'node0'},\n        {edgeID: 'edge1', nodeID: 'node1'},\n        {edgeID: 'edge2', nodeID: 'node2'},\n      ]);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n  });\n\n  describe('applyRangeUpdate()', () => {\n    var cache;\n    var connectionID;\n    var firstEdgeID;\n    var firstNodeID;\n    var lastEdgeID;\n    var nodeConnectionMap;\n    var optimisticWriter;\n    var queuedRecords;\n    var records;\n    var store;\n    var writer;\n\n    var _inc = 0;\n    function addEdgeToStore(store) {\n      var index = _inc++;\n      var edgeID = 'edge:' + index;\n      var nodeID = 'node:' + index;\n      var cursor = 'cursor:' + index;\n\n      store.putRecord(edgeID, 'Type');\n      store.putRecord(nodeID, 'Type');\n      store.putLinkedRecordID(edgeID, 'node', nodeID);\n      store.putField(edgeID, 'cursor', cursor);\n\n      return {cursor, edgeID, nodeID};\n    }\n\n    beforeEach(() => {\n      records = {};\n      queuedRecords = {};\n      cache = RelayMockCacheManager.genCacheManager().getQueryWriter();\n      nodeConnectionMap = {};\n      store = new RelayRecordStore(\n        {records, queuedRecords},\n        null,\n        nodeConnectionMap\n      );\n      writer = new RelayRecordWriter(\n        records,\n        {},\n        false,\n        nodeConnectionMap,\n        cache\n      );\n      optimisticWriter = new RelayRecordWriter(\n        queuedRecords,\n        {},\n        true,\n        nodeConnectionMap,\n        cache,\n        'mutationID'\n      );\n      connectionID = '123';\n\n      // create a range record\n      writer.putRecord(connectionID, 'Type');\n      writer.putRange(connectionID, []);\n      optimisticWriter.putRecord(connectionID, 'Type');\n\n      // ...with a first edge\n      var edge = addEdgeToStore(writer);\n      firstEdgeID = edge.edgeID;\n      firstNodeID = edge.nodeID;\n      writer.putRangeEdges(\n        connectionID,\n        [{name: 'first', value: 1}],\n        {\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n        },\n        [firstEdgeID]\n      );\n\n      // ...and a last edge\n      edge = addEdgeToStore(writer);\n      lastEdgeID = edge.edgeID;\n      writer.putRangeEdges(\n        connectionID,\n        [{name: 'last', value: 1}],\n        {\n          [HAS_NEXT_PAGE]: false,\n          [HAS_PREV_PAGE]: true,\n        },\n        [lastEdgeID]\n      );\n\n      cache.writeNode.mockClear();\n      cache.writeField.mockClear();\n      cache.writeRootCall.mockClear();\n    });\n\n    it('throws if the connection does not exist', () => {\n      var {edgeID} = addEdgeToStore(writer);\n      expect(() => {\n        writer.applyRangeUpdate('client:does.not.exist', edgeID, PREPEND);\n      }).toFailInvariant(\n        'RelayRecordWriter: Cannot apply `prepend` ' +\n        'update to non-existent record `client:does.not.exist`.'\n      );\n    });\n\n    it('prepends edges to base stores', () => {\n      var {edgeID, nodeID} = addEdgeToStore(writer);\n      writer.applyRangeUpdate(connectionID, edgeID, PREPEND);\n\n      // contains prepended edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n        firstEdgeID,\n      ]);\n      expect(store.getConnectionIDsForRecord(nodeID)).toEqual([connectionID]);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n\n    it('optimistically prepends edges to queued stores', () => {\n      var {edgeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(\n        connectionID,\n        edgeID,\n        PREPEND\n      );\n\n      // contains prepended edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        edgeID,\n        firstEdgeID,\n      ]);\n      // cache not updated on optimistic range update\n      expect(cache.writeField).not.toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n\n      expect(queuedRecords[connectionID].__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(queuedRecords[connectionID].__mutationIDs__)\n        .toEqual(['mutationID']);\n    });\n\n    it('appends edges to base stores', () => {\n      var {edgeID, nodeID} = addEdgeToStore(writer);\n      writer.applyRangeUpdate(connectionID, edgeID, APPEND);\n\n      // contains appended edge\n      var calls = [{name: 'last', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        lastEdgeID,\n        edgeID,\n      ]);\n      expect(store.getConnectionIDsForRecord(nodeID)).toEqual([connectionID]);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n\n    it('optimistically appends edges to queued stores', () => {\n      var {edgeID, nodeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(\n        connectionID,\n        edgeID,\n        APPEND\n      );\n\n      // contains appended edge\n      var calls = [{name: 'last', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        lastEdgeID,\n        edgeID,\n      ]);\n      // cache not updated on optimistic range update\n      expect(cache.writeField).not.toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n\n      expect(store.getConnectionIDsForRecord(nodeID)).toEqual(null);\n      expect(queuedRecords[connectionID].__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(queuedRecords[connectionID].__mutationIDs__)\n        .toEqual(['mutationID']);\n    });\n\n    it('deletes edges from base stores', () => {\n      expect(store.getConnectionIDsForRecord(firstNodeID)).toEqual([\n        connectionID,\n      ]);\n      writer.applyRangeUpdate(connectionID, firstEdgeID, REMOVE);\n\n      // does not contain removed edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges).toEqual([]);\n      expect(store.getConnectionIDsForRecord(firstNodeID)).toEqual(null);\n      expect(cache.writeField).toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n    });\n\n    it('optimistically deletes existing edges from queued stores', () => {\n      optimisticWriter.applyRangeUpdate(\n        connectionID,\n        firstEdgeID,\n        REMOVE\n      );\n\n      // does not contain removed edge\n      var calls = [{name: 'first', value: 2}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges).toEqual([]);\n      // cache not updated on optimistic range update\n      expect(cache.writeField).not.toBeCalledWith(\n        connectionID,\n        '__range__',\n        records[connectionID].__range__\n      );\n\n      // base store is unchanged\n      expect(store.getConnectionIDsForRecord(firstNodeID)).toEqual([\n        connectionID,\n      ]);\n      expect(queuedRecords[connectionID].__status__)\n        .toBe(RelayRecordStatusMap.setOptimisticStatus(0, true));\n      expect(queuedRecords[connectionID].__mutationIDs__)\n        .toEqual(['mutationID']);\n    });\n\n    it('deletes optimistically prepended edges from queued stores', () => {\n      var {edgeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, PREPEND);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n\n      // does not contain prepended & removed edge\n      var calls = [{name: 'first', value: 1}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        firstEdgeID,\n      ]);\n    });\n\n    it('deletes optimistically appended edges from queued stores', () => {\n      var {edgeID} = addEdgeToStore(optimisticWriter);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, APPEND);\n      optimisticWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n\n      // does not contain prepended & removed edge\n      var calls = [{name: 'last', value: 1}];\n      var rangeInfo = store.getRangeMetadata(connectionID, calls);\n      expect(rangeInfo.filteredEdges.map(edge => edge.edgeID)).toEqual([\n        lastEdgeID,\n      ]);\n    });\n  });\n\n  describe('setHasDeferredFragmentData()', () => {\n    it('creates a cache in honor of the first entry', () => {\n      const records = {'a': {}};\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'fragID');\n      expect(records.a.hasOwnProperty('__resolvedFragmentMap__')).toBe(true);\n    });\n\n    it('creates a key in an already existing cache', () => {\n      const resolvedFragmentMap = {'fragID': true};\n      const records = {\n        'a': {'__resolvedFragmentMap__': resolvedFragmentMap},\n      };\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'otherFragID');\n      expect(resolvedFragmentMap.hasOwnProperty('otherFragID')).toBe(true);\n    });\n\n    it('increments the generation when a fragment\\'s resolvedness ' +\n       'changes', () => {\n      const records = {\n        // No resolved fragment map at all\n        'a': {},\n        // Map does not contain a key corresponding to our fragment\n        'b': {\n          '__resolvedFragmentMap__': {'otherFragID': true},\n          '__resolvedFragmentMapGeneration__': 0,\n        },\n      };\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'fragID');\n      expect(records.a.__resolvedFragmentMapGeneration__).toBe(0);\n      store.setHasDeferredFragmentData('b', 'fragID');\n      expect(records.b.__resolvedFragmentMapGeneration__).toBe(1);\n    });\n\n    it('increments the generation even when a fragment\\'s resolvedness ' +\n       'does not change', () => {\n      const records = {\n        // No resolved fragment map at all\n        'a': {},\n        // Map contains a key corresponding to our fragment\n        'b': {\n          '__resolvedFragmentMap__': {'fragID': true},\n          '__resolvedFragmentMapGeneration__': 0,\n        },\n      };\n      const store = new RelayRecordWriter(records, {}, false);\n      store.setHasDeferredFragmentData('a', 'fragID');\n      expect(records.a.__resolvedFragmentMapGeneration__).toBe(0);\n      store.setHasDeferredFragmentData('b', 'fragID');\n      expect(records.b.__resolvedFragmentMapGeneration__).toBe(1);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecordWriter-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecordStore-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayRecordStore', () => {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('getRecordState()', () => {\n    it('returns \"UNKNOWN\" if an ID is unfetched', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      expect(store.getRecordState('4')).toBe('UNKNOWN');\n    });\n\n    it('returns \"NONEXISTENT\" if an ID is deleted', () => {\n      var records = {'4': null};\n      var store = new RelayRecordStore({records});\n      expect(store.getRecordState('4')).toBe('NONEXISTENT');\n    });\n\n    it('returns \"EXISTENT\" if the record exists', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers queued records over non-existent records', () => {\n      var queuedRecord = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers queued records over deleted records', () => {\n      var queuedRecord = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': null},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers queued records when they are deleted', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        queuedRecords: {'4': null},\n      });\n      expect(store.getRecordState('4')).toBe('NONEXISTENT');\n    });\n\n    it('prefers queued records over cached records', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        queuedRecords: {'4': record},\n        records: {},\n        cachedRecords: {'4': null},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers existing records over cached records', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        cachedRecords: {'4': null},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('falls back to cached records when necessary', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {},\n        cachedRecords: {'4': record},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n  });\n\n  describe('hasOptimisticUpdate', () => {\n    it('returns true if record is queued', () => {\n      var store = new RelayRecordStore({\n        records: {},\n        queuedRecords: {'4': {__dataID__: '4'}},\n      });\n      expect(store.hasOptimisticUpdate('4')).toBe(true);\n    });\n\n    it('returns false if record is not queued', () => {\n      var store = new RelayRecordStore({\n        records: {'4': {__dataID__: '4'}},\n        queuedRecords: {},\n      });\n      expect(store.hasOptimisticUpdate('4')).toBe(false);\n    });\n\n    it('throws if called on a non-queued record store', () => {\n      var store = new RelayRecordStore({\n        records: {'4': {__dataID__: '4'}},\n      });\n      expect(() => {\n        store.hasOptimisticUpdate('4');\n      }).toFailInvariant(\n        'RelayRecordStore.hasOptimisticUpdate(): Optimistic updates require ' +\n        'queued records.'\n      );\n    });\n  });\n\n  describe('getPathToRecord', () => {\n    it('returns undefined for refetchable records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var actorID = '123';\n      var path = new RelayQueryPath(query);\n      path = path.getPath(query.getFieldByStorageKey('actor'), actorID);\n      writer.putRecord(actorID, 'Type', path);\n      expect(store.getPathToRecord(actorID)).toBe(undefined);\n    });\n\n    it('returns the path for non-refetchable records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              address {\n                city\n              }\n            }\n          }\n        }\n      `);\n      var actorID = '123';\n      var addressID = 'client:1';\n      var path = new RelayQueryPath(query);\n      path = path.getPath(query.getFieldByStorageKey('actor'), actorID);\n      path = path.getPath(\n        query.getFieldByStorageKey('actor').getFieldByStorageKey('address'),\n        addressID\n      );\n      writer.putRecord(addressID, 'Type', path);\n      expect(store.getPathToRecord(addressID)).toMatchPath(path);\n    });\n  });\n\n  describe('getField()', () => {\n    it('returns undefined if the record is undefined', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(undefined);\n    });\n\n    it('returns null if the record is deleted', () => {\n      var records = {'4': null};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(null);\n    });\n\n    it('returns undefined if the field is undefined', () => {\n      var records = {'4': {}};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(undefined);\n    });\n\n    it('returns null if the field is deleted', () => {\n      var records = {'4': {'name': null}};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(null);\n    });\n\n    it('returns field values for scalar fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          name: 'Zuck',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe('Zuck');\n      expect(store.getField('4', 'id')).toBe('4');\n\n      var queuedStore = new RelayRecordStore({queuedRecords: records});\n      expect(queuedStore.getField('4', 'name')).toBe('Zuck');\n      expect(queuedStore.getField('4', 'id')).toBe('4');\n\n      var cachedStore = new RelayRecordStore({cachedRecords: records});\n      expect(cachedStore.getField('4', 'name')).toBe('Zuck');\n      expect(cachedStore.getField('4', 'id')).toBe('4');\n    });\n\n    it('prefers fields from queued records', () => {\n      var record = {\n        id: '4',\n        name: 'Zuck',\n        __dataID__: '4',\n      };\n      var queuedRecord = {\n        id: '4',\n        name: 'Mark',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getField('4', 'name')).toBe('Mark');\n    });\n\n    it('prefers fields from existing records over cached records', () => {\n      var record = {\n        id: '4',\n        name: 'Zuck',\n        __dataID__: '4',\n      };\n      var cachedRecord = {\n        id: '4',\n        name: 'Mark',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        cachedRecords: {'4': cachedRecord},\n      });\n      expect(store.getField('4', 'name')).toBe('Zuck');\n    });\n\n    it('falls through to existing records for fields not in the queued record', () => {\n      var record = {\n        id: '4',\n        name: 'Zuck',\n        __dataID__: '4',\n      };\n      var queuedRecord = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getField('4', 'name')).toBe('Zuck');\n    });\n\n    it('falls through to cached records for fields not in the existing record', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var cachedRecord = {\n        id: '4',\n        name: 'Mark',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        cachedRecords: {'4': cachedRecord},\n        records: {'4': record},\n      });\n      expect(store.getField('4', 'name')).toBe('Mark');\n    });\n  });\n\n  describe('getLinkedRecordID()', () => {\n    it('throws if the data is an unexpected format', () => {\n      var records = {\n        story: {\n          feedback: 'not an object',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(() => {\n        store.getLinkedRecordID('story', 'feedback');\n      }).toThrow();\n    });\n\n    it('returns undefined for unfetched objects', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordID('4', 'address')).toBe(undefined);\n    });\n\n    it('returns null for deleted linked fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          address: null,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordID('4', 'address')).toBe(null);\n    });\n\n    it('returns the data ID for linked fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          address: {\n            __dataID__: 'client:1',\n          },\n        },\n        'client:1': {\n          street: '1 Hacker Way',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordID('4', 'address')).toBe('client:1');\n    });\n  });\n\n  describe('getLinkedRecordIDs()', () => {\n    it('throws if the data is an unexpected format', () => {\n      var records = {\n        'story': {\n          actors: ['not an object'],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(() => {\n        store.getLinkedRecordIDs('story', 'actors');\n      }).toThrow();\n    });\n\n    it('returns undefined for unfetched fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordIDs('4', 'actors')).toBe(undefined);\n    });\n\n    it('returns null for deleted linked fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          actors: null,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordIDs('4', 'actors')).toBe(null);\n    });\n\n    it('returns an array of linked data IDs', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          actors: [\n            {__dataID__: 'item:1'},\n            {__dataID__: 'item:2'},\n          ],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordIDs('4', 'actors')).toEqual([\n        'item:1',\n        'item:2',\n      ]);\n    });\n  });\n\n  describe('getRangeMetadata()', () => {\n    var mockRange, records;\n\n    beforeEach(() => {\n      mockRange = new GraphQLRange();\n      records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          'friends': {\n            __dataID__: 'client:1',\n          },\n        },\n        'client:1': {\n          __range__: mockRange,\n        },\n        'edge:1': {\n          __dataID__: 'edge:1',\n          node: {\n            __dataID__: 'node:1',\n          },\n        },\n        'node:1': {\n          __dataID__: 'node:1',\n        },\n      };\n    });\n\n    it('returns null/undefined if the connection ID is null-ish', () => {\n      var store = new RelayRecordStore({records: {}});\n      expect(store.getRangeMetadata(null, [])).toBe(null);\n      expect(store.getRangeMetadata(undefined, [])).toBe(undefined);\n    });\n\n    it('returns undefined if the `edges` are unfetched', () => {\n      delete records['client:1'].__range__;\n      var store = new RelayRecordStore({records});\n      var calls = [\n        {name: 'first', value: '10'},\n        {name: 'orderby', value: 'TOP_STORIES'},\n      ];\n      expect(store.getRangeMetadata('client:1', calls)).toBe(undefined);\n    });\n\n    it('throws if the range is null', () => {\n      records['client:1'].__range__ = null;\n      var store = new RelayRecordStore({records});\n      store.getRangeMetadata('client:1', []);\n      expect([\n        'RelayRecordStore.getRangeMetadata(): Expected range to exist if ' +\n        '`edges` has been fetched.',\n      ]).toBeWarnedNTimes(1);\n    });\n\n    it('filters out edges without nodes', () => {\n      records['node:1'] = null;\n      var store = new RelayRecordStore({records});\n      mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n        requestedEdgeIDs: ['edge:1'],\n      });\n      var metadata = store.getRangeMetadata(\n        'client:1',\n        [{name: 'first', value: 1}]\n      );\n      expect(metadata.filteredEdges).toEqual([]);\n    });\n\n    it('returns empty diff calls if range is already fetched', () => {\n      var diffCalls = [];\n      mockRange.retrieveRangeInfoForQuery.mockReturnValue({diffCalls});\n      var store = new RelayRecordStore({records});\n      var rangeInfo = store.getRangeMetadata('client:1', []);\n      expect(rangeInfo.diffCalls).toEqual([]);\n      expect(rangeInfo.filterCalls).toEqual([]);\n      expect(rangeInfo.filteredEdges).toEqual([]);\n    });\n\n    it('returns diff/filter calls and requested edges from the range', () => {\n      mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n        requestedEdgeIDs: ['edge:1'],\n        diffCalls: [\n          {name: 'first', value: '1'},\n          {name: 'after', value: 'edge:1'},\n        ],\n      });\n      var store = new RelayRecordStore({records});\n      var rangeInfo = store.getRangeMetadata('client:1', [\n        {name: 'orderby', value: ['TOP_STORIES']},\n        {name: 'first', value: 2},\n      ]);\n      expect(mockRange.retrieveRangeInfoForQuery).toBeCalled();\n      expect(rangeInfo.diffCalls).toEqual([\n        {name: 'orderby', value: ['TOP_STORIES']},\n        {name: 'first', value: '1'},\n        {name: 'after', value: 'edge:1'},\n      ]);\n      expect(rangeInfo.filteredEdges).toEqual([{\n        edgeID: 'edge:1',\n        nodeID: 'node:1',\n      }]);\n      expect(rangeInfo.filterCalls).toEqual([\n        {name: 'orderby', value: ['TOP_STORIES']},\n      ]);\n    });\n  });\n\n  describe('getRangeFilterCalls', () => {\n    it('returns null/undefined for deleted/unfetched records', () => {\n      var records = {\n        deleted: null,\n        notARange: {},\n      };\n      var store = new RelayRecordStore({records});\n\n      expect(store.getRangeFilterCalls('unfetched')).toBe(undefined);\n      expect(store.getRangeFilterCalls('deleted')).toBe(null);\n      expect(store.getRangeFilterCalls('notARange')).toBe(undefined);\n    });\n\n    it('returns filter calls for range records', () => {\n      var calls = [\n        {\n          name: 'orderby',\n          value: 'TOP_STORIES',\n        },\n      ];\n      var records = {\n        'client:1': {\n          __range__: new GraphQLRange(),\n          __filterCalls__: calls,\n        },\n      };\n      var store = new RelayRecordStore({records});\n\n      expect(store.getRangeFilterCalls('client:1')).toEqual(calls);\n    });\n  });\n\n  describe('getConnectionIDsForRecord', () => {\n    it('returns null for non-existent records', () => {\n      var records = {\n        deleted: null,\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForRecord('unfetched')).toBe(null);\n      expect(store.getConnectionIDsForRecord('deleted')).toBe(null);\n    });\n\n    it('returns null if the record is not in a connection', () => {\n      var records = {\n        '1': {\n          __dataID__: '1',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForRecord('1')).toBe(null);\n    });\n\n    it('returns the connection ids containing the node', () => {\n      var records = {\n        '1': {\n          __dataID__: '1',\n        },\n        'range:1': {\n          __dataID__: 'range:1',\n        },\n        'range:2': {\n          __dataID__: 'range:2',\n        },\n      };\n      var nodeRangeMap = {\n        '1': {\n          'range:1': true,\n          'range:2': true,\n        },\n      };\n      var store = new RelayRecordStore({records}, null, nodeRangeMap);\n      var writer = new RelayRecordWriter(records, {}, false, nodeRangeMap);\n      expect(store.getConnectionIDsForRecord('1')).toEqual([\n        'range:1',\n        'range:2',\n      ]);\n\n      // node/connection link is cleared when the node is deleted\n      writer.deleteRecord('1');\n      expect(store.getConnectionIDsForRecord('1')).toEqual(null);\n    });\n  });\n\n  describe('getConnectionIDsForField()', () => {\n    it('returns null/undefined for non-existent records', () => {\n      var records = {\n        'deleted': null,\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForField('unfetched', 'news_feed')).toBe(\n        undefined\n      );\n      expect(store.getConnectionIDsForField('deleted', 'news_feed')).toBe(null);\n    });\n\n    it('returns undefined if the connection is unfetched', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      writer.putRecord('1', 'Type');\n      expect(store.getConnectionIDsForField('1', 'news_feed')).toBe(undefined);\n    });\n\n    it('returns all fetched connections', () => {\n      var records = {\n        '1': {\n          __dataID__: '1',\n          'photos': {\n            __dataID__: '2',\n          },\n          'photos{orderby:\"likes\"}': {\n            __dataID__: '3',\n          },\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForField('1', 'photos')).toEqual(['2', '3']);\n    });\n  });\n\n  describe('getRootCallID', () => {\n    it('returns undefined if unfetched and not cached', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      expect(store.getDataID('viewer')).toBe(undefined);\n    });\n\n    it('returns cached id if unfetched', () => {\n      var id = 'client:1';\n      var cachedRootCallMap = {viewer: {'': id}};\n      var rootCallMap = {};\n      var records = {};\n\n      var store = new RelayRecordStore(\n        {records},\n        {rootCallMap, cachedRootCallMap}\n      );\n      expect(store.getDataID('viewer')).toBe(id);\n    });\n\n    it('returns fetched id over cached id', () => {\n      var cachedID = 'client:cached';\n      var cachedRootCallMap = {viewer: {'': cachedID}};\n      var id = 'client:fetched';\n      var rootCallMap = {viewer: {'': id}};\n      var records = {};\n\n      var store = new RelayRecordStore(\n        {records},\n        {rootCallMap, cachedRootCallMap}\n      );\n      expect(store.getDataID('viewer')).toBe(id);\n    });\n  });\n\n  describe('removeRecord', () => {\n    it('completely removes the data from the store', () => {\n      var cachedRecords = {'a': {__dataID__: 'a'}};\n      var queuedRecords = {'a': {__dataID__: 'a'}};\n      var records = {'a': {__dataID__: 'a'}};\n      var nodeConnectionMap = {\n        a: {'client:1': true},\n      };\n      var store = new RelayRecordStore(\n        {cachedRecords, queuedRecords, records},\n        null,\n        nodeConnectionMap\n      );\n      expect(cachedRecords.hasOwnProperty('a')).toBe(true);\n      expect(queuedRecords.hasOwnProperty('a')).toBe(true);\n      expect(records.hasOwnProperty('a')).toBe(true);\n      expect(nodeConnectionMap.hasOwnProperty('a')).toBe(true);\n      store.removeRecord('a');\n      expect(cachedRecords.hasOwnProperty('a')).toBe(false);\n      expect(queuedRecords.hasOwnProperty('a')).toBe(false);\n      expect(records.hasOwnProperty('a')).toBe(false);\n      expect(nodeConnectionMap.hasOwnProperty('a')).toBe(false);\n    });\n  });\n\n  describe('hasDeferredFragmentData()', () => {\n    it('returns true when a fragment has been marked as resolved', () => {\n      const records = {\n        'a': {'__resolvedFragmentMap__': {'fragID': true}},\n      };\n      const store = new RelayRecordStore({records});\n      expect(store.hasDeferredFragmentData('a', 'fragID')).toBe(true);\n    });\n\n    it('returns false when a fragment has not been marked as resolved', () => {\n      const records = {\n        // No resolved fragment map at all\n        'a': {},\n        // Map does not contain a key corresponding to our fragment\n        'b': {'__resolvedFragmentMap__': {'otherFragID': true}},\n      };\n      const store = new RelayRecordStore({records});\n      expect(store.hasDeferredFragmentData('a', 'fragID')).toBe(false);\n      expect(store.hasDeferredFragmentData('b', 'fragID')).toBe(false);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLRange","Relay","RelayQueryPath","RelayRecordStore","RelayRecordWriter","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayRecordStore', () => {\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('getRecordState()', () => {\n    it('returns \"UNKNOWN\" if an ID is unfetched', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      expect(store.getRecordState('4')).toBe('UNKNOWN');\n    });\n\n    it('returns \"NONEXISTENT\" if an ID is deleted', () => {\n      var records = {'4': null};\n      var store = new RelayRecordStore({records});\n      expect(store.getRecordState('4')).toBe('NONEXISTENT');\n    });\n\n    it('returns \"EXISTENT\" if the record exists', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers queued records over non-existent records', () => {\n      var queuedRecord = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers queued records over deleted records', () => {\n      var queuedRecord = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': null},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers queued records when they are deleted', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        queuedRecords: {'4': null},\n      });\n      expect(store.getRecordState('4')).toBe('NONEXISTENT');\n    });\n\n    it('prefers queued records over cached records', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        queuedRecords: {'4': record},\n        records: {},\n        cachedRecords: {'4': null},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('prefers existing records over cached records', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        cachedRecords: {'4': null},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n\n    it('falls back to cached records when necessary', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {},\n        cachedRecords: {'4': record},\n      });\n      expect(store.getRecordState('4')).toBe('EXISTENT');\n    });\n  });\n\n  describe('hasOptimisticUpdate', () => {\n    it('returns true if record is queued', () => {\n      var store = new RelayRecordStore({\n        records: {},\n        queuedRecords: {'4': {__dataID__: '4'}},\n      });\n      expect(store.hasOptimisticUpdate('4')).toBe(true);\n    });\n\n    it('returns false if record is not queued', () => {\n      var store = new RelayRecordStore({\n        records: {'4': {__dataID__: '4'}},\n        queuedRecords: {},\n      });\n      expect(store.hasOptimisticUpdate('4')).toBe(false);\n    });\n\n    it('throws if called on a non-queued record store', () => {\n      var store = new RelayRecordStore({\n        records: {'4': {__dataID__: '4'}},\n      });\n      expect(() => {\n        store.hasOptimisticUpdate('4');\n      }).toFailInvariant(\n        'RelayRecordStore.hasOptimisticUpdate(): Optimistic updates require ' +\n        'queued records.'\n      );\n    });\n  });\n\n  describe('getPathToRecord', () => {\n    it('returns undefined for refetchable records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `);\n      var actorID = '123';\n      var path = new RelayQueryPath(query);\n      path = path.getPath(query.getFieldByStorageKey('actor'), actorID);\n      writer.putRecord(actorID, 'Type', path);\n      expect(store.getPathToRecord(actorID)).toBe(undefined);\n    });\n\n    it('returns the path for non-refetchable records', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      var query = getNode(Relay.QL`\n        query {\n          viewer {\n            actor {\n              address {\n                city\n              }\n            }\n          }\n        }\n      `);\n      var actorID = '123';\n      var addressID = 'client:1';\n      var path = new RelayQueryPath(query);\n      path = path.getPath(query.getFieldByStorageKey('actor'), actorID);\n      path = path.getPath(\n        query.getFieldByStorageKey('actor').getFieldByStorageKey('address'),\n        addressID\n      );\n      writer.putRecord(addressID, 'Type', path);\n      expect(store.getPathToRecord(addressID)).toMatchPath(path);\n    });\n  });\n\n  describe('getField()', () => {\n    it('returns undefined if the record is undefined', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(undefined);\n    });\n\n    it('returns null if the record is deleted', () => {\n      var records = {'4': null};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(null);\n    });\n\n    it('returns undefined if the field is undefined', () => {\n      var records = {'4': {}};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(undefined);\n    });\n\n    it('returns null if the field is deleted', () => {\n      var records = {'4': {'name': null}};\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe(null);\n    });\n\n    it('returns field values for scalar fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          name: 'Zuck',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getField('4', 'name')).toBe('Zuck');\n      expect(store.getField('4', 'id')).toBe('4');\n\n      var queuedStore = new RelayRecordStore({queuedRecords: records});\n      expect(queuedStore.getField('4', 'name')).toBe('Zuck');\n      expect(queuedStore.getField('4', 'id')).toBe('4');\n\n      var cachedStore = new RelayRecordStore({cachedRecords: records});\n      expect(cachedStore.getField('4', 'name')).toBe('Zuck');\n      expect(cachedStore.getField('4', 'id')).toBe('4');\n    });\n\n    it('prefers fields from queued records', () => {\n      var record = {\n        id: '4',\n        name: 'Zuck',\n        __dataID__: '4',\n      };\n      var queuedRecord = {\n        id: '4',\n        name: 'Mark',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getField('4', 'name')).toBe('Mark');\n    });\n\n    it('prefers fields from existing records over cached records', () => {\n      var record = {\n        id: '4',\n        name: 'Zuck',\n        __dataID__: '4',\n      };\n      var cachedRecord = {\n        id: '4',\n        name: 'Mark',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        cachedRecords: {'4': cachedRecord},\n      });\n      expect(store.getField('4', 'name')).toBe('Zuck');\n    });\n\n    it('falls through to existing records for fields not in the queued record', () => {\n      var record = {\n        id: '4',\n        name: 'Zuck',\n        __dataID__: '4',\n      };\n      var queuedRecord = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        records: {'4': record},\n        queuedRecords: {'4': queuedRecord},\n      });\n      expect(store.getField('4', 'name')).toBe('Zuck');\n    });\n\n    it('falls through to cached records for fields not in the existing record', () => {\n      var record = {\n        id: '4',\n        __dataID__: '4',\n      };\n      var cachedRecord = {\n        id: '4',\n        name: 'Mark',\n        __dataID__: '4',\n      };\n      var store = new RelayRecordStore({\n        cachedRecords: {'4': cachedRecord},\n        records: {'4': record},\n      });\n      expect(store.getField('4', 'name')).toBe('Mark');\n    });\n  });\n\n  describe('getLinkedRecordID()', () => {\n    it('throws if the data is an unexpected format', () => {\n      var records = {\n        story: {\n          feedback: 'not an object',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(() => {\n        store.getLinkedRecordID('story', 'feedback');\n      }).toThrow();\n    });\n\n    it('returns undefined for unfetched objects', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordID('4', 'address')).toBe(undefined);\n    });\n\n    it('returns null for deleted linked fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          address: null,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordID('4', 'address')).toBe(null);\n    });\n\n    it('returns the data ID for linked fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          address: {\n            __dataID__: 'client:1',\n          },\n        },\n        'client:1': {\n          street: '1 Hacker Way',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordID('4', 'address')).toBe('client:1');\n    });\n  });\n\n  describe('getLinkedRecordIDs()', () => {\n    it('throws if the data is an unexpected format', () => {\n      var records = {\n        'story': {\n          actors: ['not an object'],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(() => {\n        store.getLinkedRecordIDs('story', 'actors');\n      }).toThrow();\n    });\n\n    it('returns undefined for unfetched fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordIDs('4', 'actors')).toBe(undefined);\n    });\n\n    it('returns null for deleted linked fields', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          actors: null,\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordIDs('4', 'actors')).toBe(null);\n    });\n\n    it('returns an array of linked data IDs', () => {\n      var records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          actors: [\n            {__dataID__: 'item:1'},\n            {__dataID__: 'item:2'},\n          ],\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getLinkedRecordIDs('4', 'actors')).toEqual([\n        'item:1',\n        'item:2',\n      ]);\n    });\n  });\n\n  describe('getRangeMetadata()', () => {\n    var mockRange, records;\n\n    beforeEach(() => {\n      mockRange = new GraphQLRange();\n      records = {\n        '4': {\n          id: '4',\n          __dataID__: '4',\n          'friends': {\n            __dataID__: 'client:1',\n          },\n        },\n        'client:1': {\n          __range__: mockRange,\n        },\n        'edge:1': {\n          __dataID__: 'edge:1',\n          node: {\n            __dataID__: 'node:1',\n          },\n        },\n        'node:1': {\n          __dataID__: 'node:1',\n        },\n      };\n    });\n\n    it('returns null/undefined if the connection ID is null-ish', () => {\n      var store = new RelayRecordStore({records: {}});\n      expect(store.getRangeMetadata(null, [])).toBe(null);\n      expect(store.getRangeMetadata(undefined, [])).toBe(undefined);\n    });\n\n    it('returns undefined if the `edges` are unfetched', () => {\n      delete records['client:1'].__range__;\n      var store = new RelayRecordStore({records});\n      var calls = [\n        {name: 'first', value: '10'},\n        {name: 'orderby', value: 'TOP_STORIES'},\n      ];\n      expect(store.getRangeMetadata('client:1', calls)).toBe(undefined);\n    });\n\n    it('throws if the range is null', () => {\n      records['client:1'].__range__ = null;\n      var store = new RelayRecordStore({records});\n      store.getRangeMetadata('client:1', []);\n      expect([\n        'RelayRecordStore.getRangeMetadata(): Expected range to exist if ' +\n        '`edges` has been fetched.',\n      ]).toBeWarnedNTimes(1);\n    });\n\n    it('filters out edges without nodes', () => {\n      records['node:1'] = null;\n      var store = new RelayRecordStore({records});\n      mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n        requestedEdgeIDs: ['edge:1'],\n      });\n      var metadata = store.getRangeMetadata(\n        'client:1',\n        [{name: 'first', value: 1}]\n      );\n      expect(metadata.filteredEdges).toEqual([]);\n    });\n\n    it('returns empty diff calls if range is already fetched', () => {\n      var diffCalls = [];\n      mockRange.retrieveRangeInfoForQuery.mockReturnValue({diffCalls});\n      var store = new RelayRecordStore({records});\n      var rangeInfo = store.getRangeMetadata('client:1', []);\n      expect(rangeInfo.diffCalls).toEqual([]);\n      expect(rangeInfo.filterCalls).toEqual([]);\n      expect(rangeInfo.filteredEdges).toEqual([]);\n    });\n\n    it('returns diff/filter calls and requested edges from the range', () => {\n      mockRange.retrieveRangeInfoForQuery.mockReturnValue({\n        requestedEdgeIDs: ['edge:1'],\n        diffCalls: [\n          {name: 'first', value: '1'},\n          {name: 'after', value: 'edge:1'},\n        ],\n      });\n      var store = new RelayRecordStore({records});\n      var rangeInfo = store.getRangeMetadata('client:1', [\n        {name: 'orderby', value: ['TOP_STORIES']},\n        {name: 'first', value: 2},\n      ]);\n      expect(mockRange.retrieveRangeInfoForQuery).toBeCalled();\n      expect(rangeInfo.diffCalls).toEqual([\n        {name: 'orderby', value: ['TOP_STORIES']},\n        {name: 'first', value: '1'},\n        {name: 'after', value: 'edge:1'},\n      ]);\n      expect(rangeInfo.filteredEdges).toEqual([{\n        edgeID: 'edge:1',\n        nodeID: 'node:1',\n      }]);\n      expect(rangeInfo.filterCalls).toEqual([\n        {name: 'orderby', value: ['TOP_STORIES']},\n      ]);\n    });\n  });\n\n  describe('getRangeFilterCalls', () => {\n    it('returns null/undefined for deleted/unfetched records', () => {\n      var records = {\n        deleted: null,\n        notARange: {},\n      };\n      var store = new RelayRecordStore({records});\n\n      expect(store.getRangeFilterCalls('unfetched')).toBe(undefined);\n      expect(store.getRangeFilterCalls('deleted')).toBe(null);\n      expect(store.getRangeFilterCalls('notARange')).toBe(undefined);\n    });\n\n    it('returns filter calls for range records', () => {\n      var calls = [\n        {\n          name: 'orderby',\n          value: 'TOP_STORIES',\n        },\n      ];\n      var records = {\n        'client:1': {\n          __range__: new GraphQLRange(),\n          __filterCalls__: calls,\n        },\n      };\n      var store = new RelayRecordStore({records});\n\n      expect(store.getRangeFilterCalls('client:1')).toEqual(calls);\n    });\n  });\n\n  describe('getConnectionIDsForRecord', () => {\n    it('returns null for non-existent records', () => {\n      var records = {\n        deleted: null,\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForRecord('unfetched')).toBe(null);\n      expect(store.getConnectionIDsForRecord('deleted')).toBe(null);\n    });\n\n    it('returns null if the record is not in a connection', () => {\n      var records = {\n        '1': {\n          __dataID__: '1',\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForRecord('1')).toBe(null);\n    });\n\n    it('returns the connection ids containing the node', () => {\n      var records = {\n        '1': {\n          __dataID__: '1',\n        },\n        'range:1': {\n          __dataID__: 'range:1',\n        },\n        'range:2': {\n          __dataID__: 'range:2',\n        },\n      };\n      var nodeRangeMap = {\n        '1': {\n          'range:1': true,\n          'range:2': true,\n        },\n      };\n      var store = new RelayRecordStore({records}, null, nodeRangeMap);\n      var writer = new RelayRecordWriter(records, {}, false, nodeRangeMap);\n      expect(store.getConnectionIDsForRecord('1')).toEqual([\n        'range:1',\n        'range:2',\n      ]);\n\n      // node/connection link is cleared when the node is deleted\n      writer.deleteRecord('1');\n      expect(store.getConnectionIDsForRecord('1')).toEqual(null);\n    });\n  });\n\n  describe('getConnectionIDsForField()', () => {\n    it('returns null/undefined for non-existent records', () => {\n      var records = {\n        'deleted': null,\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForField('unfetched', 'news_feed')).toBe(\n        undefined\n      );\n      expect(store.getConnectionIDsForField('deleted', 'news_feed')).toBe(null);\n    });\n\n    it('returns undefined if the connection is unfetched', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      var writer = new RelayRecordWriter(records, {}, false);\n      writer.putRecord('1', 'Type');\n      expect(store.getConnectionIDsForField('1', 'news_feed')).toBe(undefined);\n    });\n\n    it('returns all fetched connections', () => {\n      var records = {\n        '1': {\n          __dataID__: '1',\n          'photos': {\n            __dataID__: '2',\n          },\n          'photos{orderby:\"likes\"}': {\n            __dataID__: '3',\n          },\n        },\n      };\n      var store = new RelayRecordStore({records});\n      expect(store.getConnectionIDsForField('1', 'photos')).toEqual(['2', '3']);\n    });\n  });\n\n  describe('getRootCallID', () => {\n    it('returns undefined if unfetched and not cached', () => {\n      var records = {};\n      var store = new RelayRecordStore({records});\n      expect(store.getDataID('viewer')).toBe(undefined);\n    });\n\n    it('returns cached id if unfetched', () => {\n      var id = 'client:1';\n      var cachedRootCallMap = {viewer: {'': id}};\n      var rootCallMap = {};\n      var records = {};\n\n      var store = new RelayRecordStore(\n        {records},\n        {rootCallMap, cachedRootCallMap}\n      );\n      expect(store.getDataID('viewer')).toBe(id);\n    });\n\n    it('returns fetched id over cached id', () => {\n      var cachedID = 'client:cached';\n      var cachedRootCallMap = {viewer: {'': cachedID}};\n      var id = 'client:fetched';\n      var rootCallMap = {viewer: {'': id}};\n      var records = {};\n\n      var store = new RelayRecordStore(\n        {records},\n        {rootCallMap, cachedRootCallMap}\n      );\n      expect(store.getDataID('viewer')).toBe(id);\n    });\n  });\n\n  describe('removeRecord', () => {\n    it('completely removes the data from the store', () => {\n      var cachedRecords = {'a': {__dataID__: 'a'}};\n      var queuedRecords = {'a': {__dataID__: 'a'}};\n      var records = {'a': {__dataID__: 'a'}};\n      var nodeConnectionMap = {\n        a: {'client:1': true},\n      };\n      var store = new RelayRecordStore(\n        {cachedRecords, queuedRecords, records},\n        null,\n        nodeConnectionMap\n      );\n      expect(cachedRecords.hasOwnProperty('a')).toBe(true);\n      expect(queuedRecords.hasOwnProperty('a')).toBe(true);\n      expect(records.hasOwnProperty('a')).toBe(true);\n      expect(nodeConnectionMap.hasOwnProperty('a')).toBe(true);\n      store.removeRecord('a');\n      expect(cachedRecords.hasOwnProperty('a')).toBe(false);\n      expect(queuedRecords.hasOwnProperty('a')).toBe(false);\n      expect(records.hasOwnProperty('a')).toBe(false);\n      expect(nodeConnectionMap.hasOwnProperty('a')).toBe(false);\n    });\n  });\n\n  describe('hasDeferredFragmentData()', () => {\n    it('returns true when a fragment has been marked as resolved', () => {\n      const records = {\n        'a': {'__resolvedFragmentMap__': {'fragID': true}},\n      };\n      const store = new RelayRecordStore({records});\n      expect(store.hasDeferredFragmentData('a', 'fragID')).toBe(true);\n    });\n\n    it('returns false when a fragment has not been marked as resolved', () => {\n      const records = {\n        // No resolved fragment map at all\n        'a': {},\n        // Map does not contain a key corresponding to our fragment\n        'b': {'__resolvedFragmentMap__': {'otherFragID': true}},\n      };\n      const store = new RelayRecordStore({records});\n      expect(store.hasDeferredFragmentData('a', 'fragID')).toBe(false);\n      expect(store.hasDeferredFragmentData('b', 'fragID')).toBe(false);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecordStore-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecordStatusMap-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\n\ndescribe('RelayRecordStatusMap', () => {\n  it('sets and checks optimistic status correctly', () => {\n    var result = 0;\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(false);\n  });\n\n  it('sets and checks error status correctly', () => {\n    var result = 0;\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(false);\n  });\n\n});\n","dependencies":["RelayRecordStatusMap"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\n\ndescribe('RelayRecordStatusMap', () => {\n  it('sets and checks optimistic status correctly', () => {\n    var result = 0;\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setOptimisticStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isOptimisticStatus(result)).toBe(false);\n  });\n\n  it('sets and checks error status correctly', () => {\n    var result = 0;\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(false);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      true\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(true);\n    result = RelayRecordStatusMap.setErrorStatus(\n      result,\n      false\n    );\n    expect(RelayRecordStatusMap.isErrorStatus(result)).toBe(false);\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecordStatusMap-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecord-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayRecord = require('RelayRecord');\n\ndescribe('RelayRecord', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  it('checks if a value is a record', () => {\n    expect(RelayRecord.isRecord({__dataID__: '123'})).toBe(true);\n\n    expect(RelayRecord.isRecord(null)).toBe(false);\n    expect(RelayRecord.isRecord(undefined)).toBe(false);\n    expect(RelayRecord.isRecord([])).toBe(false);\n    expect(RelayRecord.isRecord({})).toBe(false);\n\n    const deceptiveArray = [];\n    deceptiveArray.__dataID__ = '123';\n    expect(RelayRecord.isRecord(deceptiveArray)).toBe(false);\n  });\n\n  it('checks if a key is for metadata', () => {\n    expect(RelayRecord.isMetadataKey('__dataID__')).toBe(true);\n    expect(RelayRecord.isMetadataKey('__range__')).toBe(true);\n\n    expect(RelayRecord.isMetadataKey('id')).toBe(false);\n    expect(RelayRecord.isMetadataKey('')).toBe(false);\n  });\n});\n","dependencies":["RelayRecord"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayRecord = require('RelayRecord');\n\ndescribe('RelayRecord', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  it('checks if a value is a record', () => {\n    expect(RelayRecord.isRecord({__dataID__: '123'})).toBe(true);\n\n    expect(RelayRecord.isRecord(null)).toBe(false);\n    expect(RelayRecord.isRecord(undefined)).toBe(false);\n    expect(RelayRecord.isRecord([])).toBe(false);\n    expect(RelayRecord.isRecord({})).toBe(false);\n\n    const deceptiveArray = [];\n    deceptiveArray.__dataID__ = '123';\n    expect(RelayRecord.isRecord(deceptiveArray)).toBe(false);\n  });\n\n  it('checks if a key is for metadata', () => {\n    expect(RelayRecord.isMetadataKey('__dataID__')).toBe(true);\n    expect(RelayRecord.isMetadataKey('__range__')).toBe(true);\n\n    expect(RelayRecord.isMetadataKey('id')).toBe(false);\n    expect(RelayRecord.isMetadataKey('')).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayRecord-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayReadyState-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.mock('warning');\n\nconst RelayReadyState = require('RelayReadyState');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst warning = require('warning');\n\ndescribe('RelayReadyState', () => {\n  let onReadyStateChange;\n  let readyState;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    onReadyStateChange = jest.genMockFunction();\n    readyState = new RelayReadyState(onReadyStateChange);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('invokes the callback asynchronously when state changes', () => {\n    readyState.update({ready: true});\n\n    expect(onReadyStateChange).not.toBeCalled();\n\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('invokes the callback once per immediate', () => {\n    readyState.update({ready: true, stale: true});\n    readyState.update({ready: true, stale: false});\n    readyState.update({done: true, ready: true});\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('ignores asynchronous state changes after being aborted', () => {\n    readyState.update({aborted: true});\n    jest.runAllTimers();\n\n    readyState.update({ready: true});\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: true, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('ignores synchronous state changes after being aborted', () => {\n    readyState.update({aborted: true});\n    readyState.update({ready: true});\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: true, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('warns about state changes after being done', () => {\n    readyState.update({done: true, ready: true});\n    jest.runAllTimers();\n    readyState.update({ready: true});\n\n    expect([\n      'RelayReadyState: Invalid state change from `%s` to `%s`.',\n      JSON.stringify(\n        {aborted: false, done: true, error: null, ready: true, stale: false}\n      ),\n      JSON.stringify({ready: true}),\n    ]).toBeWarnedNTimes(1);\n\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n    jest.runAllTimers();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n\n  it('warns about state changes after encountering errors', () => {\n    const error = new Error('Expected error.');\n    readyState.update({error});\n    jest.runAllTimers();\n    readyState.update({ready: true});\n\n    expect([\n      'RelayReadyState: Invalid state change from `%s` to `%s`.',\n      JSON.stringify(\n        {aborted: false, done: false, error, ready: false, stale: false}\n      ),\n      JSON.stringify({ready: true}),\n    ]).toBeWarnedNTimes(1);\n\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n    jest.runAllTimers();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n\n  it('ignores state changed to aborted when done', () => {\n    readyState.update({done: true, ready: true});\n    jest.runAllTimers();\n\n    readyState.update({aborted: true});\n    jest.runAllTimers();\n\n    expect(warning).not.toBeCalled();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n\n  it('ignores state changed to aborted when an error occurred', () => {\n    readyState.update({error: new Error('Expected error.')});\n    jest.runAllTimers();\n\n    readyState.update({aborted: true});\n    jest.runAllTimers();\n\n    expect(warning).not.toBeCalled();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n});\n","dependencies":["RelayReadyState","RelayTestUtils","warning"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.mock('warning');\n\nconst RelayReadyState = require('RelayReadyState');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst warning = require('warning');\n\ndescribe('RelayReadyState', () => {\n  let onReadyStateChange;\n  let readyState;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    onReadyStateChange = jest.genMockFunction();\n    readyState = new RelayReadyState(onReadyStateChange);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('invokes the callback asynchronously when state changes', () => {\n    readyState.update({ready: true});\n\n    expect(onReadyStateChange).not.toBeCalled();\n\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: false, done: false, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('invokes the callback once per immediate', () => {\n    readyState.update({ready: true, stale: true});\n    readyState.update({ready: true, stale: false});\n    readyState.update({done: true, ready: true});\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: false, done: true, error: null, ready: true, stale: false}],\n    ]);\n  });\n\n  it('ignores asynchronous state changes after being aborted', () => {\n    readyState.update({aborted: true});\n    jest.runAllTimers();\n\n    readyState.update({ready: true});\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: true, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('ignores synchronous state changes after being aborted', () => {\n    readyState.update({aborted: true});\n    readyState.update({ready: true});\n    jest.runAllTimers();\n\n    expect(onReadyStateChange.mock.calls).toEqual([\n      [{aborted: true, done: false, error: null, ready: false, stale: false}],\n    ]);\n  });\n\n  it('warns about state changes after being done', () => {\n    readyState.update({done: true, ready: true});\n    jest.runAllTimers();\n    readyState.update({ready: true});\n\n    expect([\n      'RelayReadyState: Invalid state change from `%s` to `%s`.',\n      JSON.stringify(\n        {aborted: false, done: true, error: null, ready: true, stale: false}\n      ),\n      JSON.stringify({ready: true}),\n    ]).toBeWarnedNTimes(1);\n\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n    jest.runAllTimers();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n\n  it('warns about state changes after encountering errors', () => {\n    const error = new Error('Expected error.');\n    readyState.update({error});\n    jest.runAllTimers();\n    readyState.update({ready: true});\n\n    expect([\n      'RelayReadyState: Invalid state change from `%s` to `%s`.',\n      JSON.stringify(\n        {aborted: false, done: false, error, ready: false, stale: false}\n      ),\n      JSON.stringify({ready: true}),\n    ]).toBeWarnedNTimes(1);\n\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n    jest.runAllTimers();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n\n  it('ignores state changed to aborted when done', () => {\n    readyState.update({done: true, ready: true});\n    jest.runAllTimers();\n\n    readyState.update({aborted: true});\n    jest.runAllTimers();\n\n    expect(warning).not.toBeCalled();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n\n  it('ignores state changed to aborted when an error occurred', () => {\n    readyState.update({error: new Error('Expected error.')});\n    jest.runAllTimers();\n\n    readyState.update({aborted: true});\n    jest.runAllTimers();\n\n    expect(warning).not.toBeCalled();\n    expect(onReadyStateChange.mock.calls.length).toBe(1);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayReadyState-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayQueryTracker-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayQueryTracker');\n\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst invariant = require('invariant');\n\ndescribe('RelayQueryTracker', () => {\n  var {getNode} = RelayTestUtils;\n\n  function getField(node, ...fieldNames) {\n    for (var ii = 0; ii < fieldNames.length; ii++) {\n      node = node.getFieldByStorageKey(fieldNames[ii]);\n      invariant(\n        !!node,\n        'getField(): Expected node to have field named `%s`.',\n        fieldNames[ii]\n      );\n    }\n    return node;\n  }\n\n  function sortChildren(children) {\n    return children.sort((a, b) => {\n      var aKey = a.getSerializationKey();\n      var bKey = b.getSerializationKey();\n      return aKey < bKey ?\n        -1 :\n        (aKey > bKey ? 1 : 0);\n    });\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('tracks queries for ID-less root records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var path = new RelayQueryPath(query);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(query, 'client:1', path);\n    var trackedChildren = tracker.getTrackedChildrenForID('client:1');\n    expect(trackedChildren.length).toBe(1);\n    expect(trackedChildren[0])\n      .toEqualQueryNode(query.getFieldByStorageKey('actor'));\n  });\n\n  it('tracks queries for refetchable root records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          address {\n            city\n          }\n        }\n      }\n    `);\n    var nodeID = '123';\n    var path = new RelayQueryPath(query);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(query, nodeID, path);\n    var trackedChildren = sortChildren(tracker.getTrackedChildrenForID(nodeID));\n    var children = sortChildren(query.getChildren());\n    expect(trackedChildren.length).toBe(3);\n    children.forEach((child, ii) => {\n      expect(trackedChildren[ii]).toEqualQueryNode(child);\n    });\n  });\n\n  it('tracks queries for refetchable records (with IDs)', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var actorID = '123';\n    var path = new RelayQueryPath(query)\n      .getPath(getField(query, 'actor'), actorID);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(actor, actorID, path);\n    var children = sortChildren(actor.getChildren());\n    var trackedChildren =\n      sortChildren(tracker.getTrackedChildrenForID(actorID));\n    children.forEach((child, ii) => {\n      expect(trackedChildren[ii]).toEqualQueryNode(child);\n    });\n  });\n\n  it('does not track queries for non-refetchable records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    var address =\n      query.getFieldByStorageKey('actor').getFieldByStorageKey('address');\n    var actorID = '123';\n    var addressID = 'client:1';\n    var path = new RelayQueryPath(query)\n      .getPath(getField(query, 'actor'), actorID)\n      .getPath(getField(query, 'actor', 'address'), addressID);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(address, addressID, path);\n    var trackedChildren = tracker.getTrackedChildrenForID(addressID);\n    expect(trackedChildren.length).toBe(0);\n  });\n\n  it('untracks all nodes for the given dataID', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var actorID = '123';\n    var path = new RelayQueryPath(query)\n      .getPath(getField(query, 'actor'), actorID);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(actor, actorID, path);\n    expect(tracker.getTrackedChildrenForID(actorID)).not.toEqual([]);\n    tracker.untrackNodesForID(actorID);\n    expect(tracker.getTrackedChildrenForID(actorID)).toEqual([]);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQueryPath","RelayQueryTracker","RelayTestUtils","invariant"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayQueryTracker');\n\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst invariant = require('invariant');\n\ndescribe('RelayQueryTracker', () => {\n  var {getNode} = RelayTestUtils;\n\n  function getField(node, ...fieldNames) {\n    for (var ii = 0; ii < fieldNames.length; ii++) {\n      node = node.getFieldByStorageKey(fieldNames[ii]);\n      invariant(\n        !!node,\n        'getField(): Expected node to have field named `%s`.',\n        fieldNames[ii]\n      );\n    }\n    return node;\n  }\n\n  function sortChildren(children) {\n    return children.sort((a, b) => {\n      var aKey = a.getSerializationKey();\n      var bKey = b.getSerializationKey();\n      return aKey < bKey ?\n        -1 :\n        (aKey > bKey ? 1 : 0);\n    });\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('tracks queries for ID-less root records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var path = new RelayQueryPath(query);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(query, 'client:1', path);\n    var trackedChildren = tracker.getTrackedChildrenForID('client:1');\n    expect(trackedChildren.length).toBe(1);\n    expect(trackedChildren[0])\n      .toEqualQueryNode(query.getFieldByStorageKey('actor'));\n  });\n\n  it('tracks queries for refetchable root records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          address {\n            city\n          }\n        }\n      }\n    `);\n    var nodeID = '123';\n    var path = new RelayQueryPath(query);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(query, nodeID, path);\n    var trackedChildren = sortChildren(tracker.getTrackedChildrenForID(nodeID));\n    var children = sortChildren(query.getChildren());\n    expect(trackedChildren.length).toBe(3);\n    children.forEach((child, ii) => {\n      expect(trackedChildren[ii]).toEqualQueryNode(child);\n    });\n  });\n\n  it('tracks queries for refetchable records (with IDs)', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var actorID = '123';\n    var path = new RelayQueryPath(query)\n      .getPath(getField(query, 'actor'), actorID);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(actor, actorID, path);\n    var children = sortChildren(actor.getChildren());\n    var trackedChildren =\n      sortChildren(tracker.getTrackedChildrenForID(actorID));\n    children.forEach((child, ii) => {\n      expect(trackedChildren[ii]).toEqualQueryNode(child);\n    });\n  });\n\n  it('does not track queries for non-refetchable records', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    var address =\n      query.getFieldByStorageKey('actor').getFieldByStorageKey('address');\n    var actorID = '123';\n    var addressID = 'client:1';\n    var path = new RelayQueryPath(query)\n      .getPath(getField(query, 'actor'), actorID)\n      .getPath(getField(query, 'actor', 'address'), addressID);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(address, addressID, path);\n    var trackedChildren = tracker.getTrackedChildrenForID(addressID);\n    expect(trackedChildren.length).toBe(0);\n  });\n\n  it('untracks all nodes for the given dataID', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            address {\n              city\n            }\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var actorID = '123';\n    var path = new RelayQueryPath(query)\n      .getPath(getField(query, 'actor'), actorID);\n    var tracker = new RelayQueryTracker();\n\n    tracker.trackNodeForID(actor, actorID, path);\n    expect(tracker.getTrackedChildrenForID(actorID)).not.toEqual([]);\n    tracker.untrackNodesForID(actorID);\n    expect(tracker.getTrackedChildrenForID(actorID)).toEqual([]);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayQueryTracker-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayQueryResultObservable-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayStoreData')\n  .dontMock('GraphQLStoreChangeEmitter')\n  .dontMock('GraphQLStoreQueryResolver');\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst Relay = require('Relay');\nconst RelayQueryResultObservable = require('RelayQueryResultObservable');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst readRelayQueryData = require('readRelayQueryData');\n\ndescribe('RelayQueryResultObservable', () => {\n  var storeData;\n  var changeEmitter;\n\n  var query;\n  var records;\n  var results;\n  var store;\n  var writer;\n\n  // helper functions\n  var {getNode} = RelayTestUtils;\n\n  function genMockSubscriber() {\n    var onCompleted = jest.genMockFunction();\n    var onError = jest.genMockFunction();\n    var onNext = jest.genMockFunction();\n    var mockClear = () => {\n      [onCompleted, onError, onNext].forEach(fn => fn.mockClear());\n    };\n    return {\n      onCompleted,\n      onError,\n      onNext,\n      mockClear,\n    };\n  }\n\n  function observeRelayQueryData(dataID) {\n    return new RelayQueryResultObservable(storeData, query, dataID);\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    query = getNode(Relay.QL`fragment on Node{id,name}`);\n    records = {\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        name: 'Joe',\n        firstName: 'Joe',\n      },\n    };\n    results = {\n      __dataID__: '123',\n      id: '123',\n      name: 'Joe',\n    };\n    store = new RelayRecordStore({records});\n    writer = new RelayRecordWriter(records, {}, false);\n    storeData = new RelayStoreData();\n\n    storeData.getQueuedStore = jest.genMockFunction().mockImplementation(() => {\n      return store;\n    });\n\n    changeEmitter = storeData.getChangeEmitter();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('does not read data before the first subscriber is registered', () => {\n    observeRelayQueryData('123');\n    expect(readRelayQueryData).not.toBeCalled();\n  });\n\n  it('cannot double-unsubscribe a subscription', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    var subscription = observer.subscribe(subscriber);\n    subscription.dispose();\n    expect(() => subscription.dispose()).toFailInvariant(\n      'RelayQueryResultObservable: Subscriptions may only be disposed once.'\n    );\n  });\n\n  it('immediately calls onNext of the first subscriber', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n\n    expect(readRelayQueryData).toBeCalledWith(\n      storeData,\n      query,\n      '123'\n    );\n    expect(subscriber.onNext).toBeCalledWith(results);\n    expect(subscriber.onError).not.toBeCalled();\n  });\n\n  it('immediately calls onNext of subsequent subscribers', () => {\n    var observer = observeRelayQueryData('123');\n    var firstSubscriber = genMockSubscriber();\n    observer.subscribe(firstSubscriber);\n    readRelayQueryData.mockClear();\n    firstSubscriber.mockClear();\n\n    var secondSubscriber = genMockSubscriber();\n    observer.subscribe(secondSubscriber);\n    expect(readRelayQueryData).not.toBeCalled();\n    expect(firstSubscriber.onNext).not.toBeCalled();\n    expect(secondSubscriber.onNext).toBeCalledWith(results);\n    expect(secondSubscriber.onError).not.toBeCalled();\n  });\n\n  it('updates all subscribers when data changes', () => {\n    var observer = observeRelayQueryData('123');\n    var subscribers = [\n      genMockSubscriber(),\n      genMockSubscriber(),\n    ];\n    subscribers.forEach(subscriber => {\n      observer.subscribe(subscriber);\n      subscriber.mockClear();\n    });\n\n    writer.putField('123', 'name', 'Joseph');\n    results.name = 'Joseph';\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n\n    subscribers.forEach(subscriber => {\n      expect(subscriber.onCompleted).not.toBeCalled();\n      expect(subscriber.onError).not.toBeCalled();\n      expect(subscriber.onNext).toBeCalledWith(results);\n    });\n  });\n\n  it('does not call callbacks after a subscription is disposed', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    var subscription = observer.subscribe(subscriber);\n    subscriber.mockClear();\n    subscription.dispose();\n\n    writer.putField('123', 'name', 'Joseph');\n    results.name = 'Joseph';\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).not.toBeCalled();\n  });\n\n  it('calls onNext if the record is initially unfetched', () => {\n    var observer = observeRelayQueryData('oops');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith(undefined);\n    subscriber.mockClear();\n\n    // fetching the record calls onNext\n    writer.putRecord('oops');\n    changeEmitter.broadcastChangeForID('oops');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith({\n      __dataID__: 'oops',\n    });\n  });\n\n  it('calls onNext if the record is deleted', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n    subscriber.mockClear();\n\n    // deleting the record calls onNext\n    writer.deleteRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith(null);\n    subscriber.mockClear();\n\n    // restoring the record calls onNext\n    writer.putRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith({\n      __dataID__: '123',\n    });\n  });\n\n  it('calls onNext if the record is evicted from the store', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n    subscriber.mockClear();\n\n    // evicting the record calls onNext\n    store.removeRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith(undefined);\n    subscriber.mockClear();\n\n    // restoring the record calls onNext\n    writer.putRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith({\n      __dataID__: '123',\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","RelayFragmentPointer","Relay","RelayQueryResultObservable","RelayRecordStore","RelayRecordWriter","RelayStoreData","RelayTestUtils","readRelayQueryData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayStoreData')\n  .dontMock('GraphQLStoreChangeEmitter')\n  .dontMock('GraphQLStoreQueryResolver');\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst Relay = require('Relay');\nconst RelayQueryResultObservable = require('RelayQueryResultObservable');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst readRelayQueryData = require('readRelayQueryData');\n\ndescribe('RelayQueryResultObservable', () => {\n  var storeData;\n  var changeEmitter;\n\n  var query;\n  var records;\n  var results;\n  var store;\n  var writer;\n\n  // helper functions\n  var {getNode} = RelayTestUtils;\n\n  function genMockSubscriber() {\n    var onCompleted = jest.genMockFunction();\n    var onError = jest.genMockFunction();\n    var onNext = jest.genMockFunction();\n    var mockClear = () => {\n      [onCompleted, onError, onNext].forEach(fn => fn.mockClear());\n    };\n    return {\n      onCompleted,\n      onError,\n      onNext,\n      mockClear,\n    };\n  }\n\n  function observeRelayQueryData(dataID) {\n    return new RelayQueryResultObservable(storeData, query, dataID);\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    query = getNode(Relay.QL`fragment on Node{id,name}`);\n    records = {\n      '123': {\n        __dataID__: '123',\n        id: '123',\n        name: 'Joe',\n        firstName: 'Joe',\n      },\n    };\n    results = {\n      __dataID__: '123',\n      id: '123',\n      name: 'Joe',\n    };\n    store = new RelayRecordStore({records});\n    writer = new RelayRecordWriter(records, {}, false);\n    storeData = new RelayStoreData();\n\n    storeData.getQueuedStore = jest.genMockFunction().mockImplementation(() => {\n      return store;\n    });\n\n    changeEmitter = storeData.getChangeEmitter();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('does not read data before the first subscriber is registered', () => {\n    observeRelayQueryData('123');\n    expect(readRelayQueryData).not.toBeCalled();\n  });\n\n  it('cannot double-unsubscribe a subscription', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    var subscription = observer.subscribe(subscriber);\n    subscription.dispose();\n    expect(() => subscription.dispose()).toFailInvariant(\n      'RelayQueryResultObservable: Subscriptions may only be disposed once.'\n    );\n  });\n\n  it('immediately calls onNext of the first subscriber', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n\n    expect(readRelayQueryData).toBeCalledWith(\n      storeData,\n      query,\n      '123'\n    );\n    expect(subscriber.onNext).toBeCalledWith(results);\n    expect(subscriber.onError).not.toBeCalled();\n  });\n\n  it('immediately calls onNext of subsequent subscribers', () => {\n    var observer = observeRelayQueryData('123');\n    var firstSubscriber = genMockSubscriber();\n    observer.subscribe(firstSubscriber);\n    readRelayQueryData.mockClear();\n    firstSubscriber.mockClear();\n\n    var secondSubscriber = genMockSubscriber();\n    observer.subscribe(secondSubscriber);\n    expect(readRelayQueryData).not.toBeCalled();\n    expect(firstSubscriber.onNext).not.toBeCalled();\n    expect(secondSubscriber.onNext).toBeCalledWith(results);\n    expect(secondSubscriber.onError).not.toBeCalled();\n  });\n\n  it('updates all subscribers when data changes', () => {\n    var observer = observeRelayQueryData('123');\n    var subscribers = [\n      genMockSubscriber(),\n      genMockSubscriber(),\n    ];\n    subscribers.forEach(subscriber => {\n      observer.subscribe(subscriber);\n      subscriber.mockClear();\n    });\n\n    writer.putField('123', 'name', 'Joseph');\n    results.name = 'Joseph';\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n\n    subscribers.forEach(subscriber => {\n      expect(subscriber.onCompleted).not.toBeCalled();\n      expect(subscriber.onError).not.toBeCalled();\n      expect(subscriber.onNext).toBeCalledWith(results);\n    });\n  });\n\n  it('does not call callbacks after a subscription is disposed', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    var subscription = observer.subscribe(subscriber);\n    subscriber.mockClear();\n    subscription.dispose();\n\n    writer.putField('123', 'name', 'Joseph');\n    results.name = 'Joseph';\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).not.toBeCalled();\n  });\n\n  it('calls onNext if the record is initially unfetched', () => {\n    var observer = observeRelayQueryData('oops');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith(undefined);\n    subscriber.mockClear();\n\n    // fetching the record calls onNext\n    writer.putRecord('oops');\n    changeEmitter.broadcastChangeForID('oops');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith({\n      __dataID__: 'oops',\n    });\n  });\n\n  it('calls onNext if the record is deleted', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n    subscriber.mockClear();\n\n    // deleting the record calls onNext\n    writer.deleteRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith(null);\n    subscriber.mockClear();\n\n    // restoring the record calls onNext\n    writer.putRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith({\n      __dataID__: '123',\n    });\n  });\n\n  it('calls onNext if the record is evicted from the store', () => {\n    var observer = observeRelayQueryData('123');\n    var subscriber = genMockSubscriber();\n    observer.subscribe(subscriber);\n    subscriber.mockClear();\n\n    // evicting the record calls onNext\n    store.removeRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith(undefined);\n    subscriber.mockClear();\n\n    // restoring the record calls onNext\n    writer.putRecord('123');\n    changeEmitter.broadcastChangeForID('123');\n    jest.runAllTimers();\n    expect(subscriber.onCompleted).not.toBeCalled();\n    expect(subscriber.onError).not.toBeCalled();\n    expect(subscriber.onNext).toBeCalledWith({\n      __dataID__: '123',\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayQueryResultObservable-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayPendingQueryTracker-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayPendingQueryTracker')\n  .dontMock('RelayTaskQueue');\n\nconst Relay = require('Relay');\nconst RelayFetchMode = require('RelayFetchMode');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst fetchRelayQuery = require('fetchRelayQuery');\nconst subtractRelayQuery = require('subtractRelayQuery');\nconst writeRelayQueryPayload = require('writeRelayQueryPayload');\n\ndescribe('RelayPendingQueryTracker', () => {\n  var pendingQueryTracker;\n\n  var addPending;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    var storeData = new RelayStoreData();\n    pendingQueryTracker = storeData.getPendingQueryTracker();\n\n    subtractRelayQuery.mockImplementation(query => query);\n\n    addPending = ({query, fetchMode}) => {\n      fetchMode = fetchMode || RelayFetchMode.CLIENT;\n      return pendingQueryTracker.add({\n        query,\n        fetchMode,\n        forceIndex: null,\n      }).getResolvedPromise();\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n    jasmine.addMatchers({\n      toConsoleWarn() {\n        return {\n          compare(callback, expected) {\n            const consoleWarn = console.warn;\n            let pass = false;\n            console.warn = (...args) => {\n              if (args.length === expected.length &&\n                  args.every((arg, ii) => arg === expected[ii])) {\n                pass = true;\n              } else {\n                consoleWarn(...args);\n              }\n            };\n            callback();\n            console.warn = consoleWarn;\n            return {pass};\n          },\n        };\n      },\n    });\n  });\n\n  it('subtracts pending queries that share root call', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        node(id:\"4\"){actor{id,name}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name,birthdate{day}}}\n      }\n    `);\n    var mockQueryD = getNode(Relay.QL`\n      query {\n        node(id:\"4\"){actor{id,name,birthdate{day}}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery).not.toBeCalled();\n\n    addPending({query: mockQueryB});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery).not.toBeCalled();\n\n    addPending({query: mockQueryC});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery.mock.calls).toEqual([\n      [mockQueryC, mockQueryA],\n    ]);\n\n    fetchRelayQuery.mock.requests[1].resolve({node: {__typename: 'User'}});\n    jest.runAllTimers();\n\n    subtractRelayQuery.mockClear();\n    addPending({query: mockQueryD});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery).not.toBeCalled();\n  });\n\n  it('subtracts pending queries until completely subtracted', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    subtractRelayQuery.mockImplementation(() => null);\n\n    addPending({query: mockQueryB});\n    addPending({query: mockQueryC});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery.mock.calls).toEqual([\n      [mockQueryB, mockQueryA],\n      [mockQueryC, mockQueryA],\n    ]);\n  });\n\n  it('does not fetch completely subtracted queries', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryB);\n      expect(subQuery).toBe(mockQueryA);\n      return null;\n    });\n\n    addPending({query: mockQueryB});\n    jest.runAllTimers();\n\n    expect(fetchRelayQuery.mock.calls.length).toBe(1);\n    expect(fetchRelayQuery.mock.calls[0][0]).toEqualQueryRoot(mockQueryA);\n  });\n\n  it('calls `writeRelayQueryPayload` when receiving data', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(1);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQueryA);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n  });\n\n  it('resolves after dependencies are ready', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name,birthdate{day}}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,birthdate{day}}}\n      }\n    `);\n\n    var pendingA = addPending({query: mockQueryA});\n    var mockSuccessA = jest.genMockFunction();\n    pendingA.done(mockSuccessA);\n\n    // Simulates: B - A = C\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryB);\n      expect(subQuery).toBe(mockQueryA);\n      return mockQueryC;\n    });\n\n    var pendingB = addPending({query: mockQueryB});\n    var mockSuccessB = jest.genMockFunction();\n    pendingB.done(mockSuccessB);\n\n    fetchRelayQuery.mock.requests[1].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    expect(mockSuccessA).not.toBeCalled();\n    expect(mockSuccessB).not.toBeCalled();\n\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    expect(mockSuccessA).toBeCalled();\n    expect(mockSuccessB).toBeCalled();\n  });\n\n  it('fails direct dependents and not indirect ones', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name,birthdate{day}}}\n      }\n    `);\n    var mockQueryBPrime = getNode(Relay.QL`\n      query {\n        viewer{actor{id,birthdate{day}}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,firstName,birthdate{day}}}\n      }\n    `);\n    var mockQueryCPrime = getNode(Relay.QL`\n      query {\n        viewer{actor{id,firstName,birthdate{day}}}\n      }\n    `);\n\n    var pendingA = addPending({query: mockQueryA});\n    var mockFailureA = jest.genMockFunction();\n    pendingA.catch(mockFailureA);\n    jest.runAllTimers();\n\n    // Simulates: B - A = B'\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryB);\n      expect(subQuery).toBe(mockQueryA);\n      return mockQueryBPrime;\n    });\n\n    var pendingB = addPending({query: mockQueryB});\n    var mockFailureB = jest.genMockFunction();\n    pendingB.catch(mockFailureB);\n    jest.runAllTimers();\n\n    // Simulates: C - A = C, C - B' = C'\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryC);\n      expect([mockQueryA, mockQueryBPrime]).toContain(subQuery);\n      return subQuery === mockQueryA ? mockQueryC : mockQueryCPrime;\n    });\n\n    var pendingC = addPending({query: mockQueryC});\n    var mockSuccessC = jest.genMockFunction();\n    pendingC.done(mockSuccessC);\n    jest.runAllTimers();\n\n    var mockFetchError = new Error('Expected `fetchRelayQuery` error.');\n    fetchRelayQuery.mock.requests[1].resolve({viewer:{}});\n    fetchRelayQuery.mock.requests[0].reject(mockFetchError);\n    fetchRelayQuery.mock.requests[2].resolve({viewer:{}});\n\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockFetchError.message]);\n\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(2);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQueryBPrime);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n    expect(writeCalls[1][1]).toEqualQueryRoot(mockQueryCPrime);\n    expect(writeCalls[1][2]).toEqual({viewer:{}});\n\n    expect(mockFailureA).toBeCalled();\n    expect(mockFailureB).toBeCalled();\n    expect(mockSuccessC).toBeCalled();\n  });\n\n  it('fails if fetching throws an error', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var pendingA = addPending({query: mockQuery});\n    var mockFailureA = jest.genMockFunction();\n    pendingA.catch(mockFailureA);\n\n    var mockError = new Error('Expected error.');\n    fetchRelayQuery.mock.requests[0].reject(mockError);\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockError.message]);\n\n    expect(mockFailureA).toBeCalledWith(mockError);\n  });\n\n  it('fails if `writeRelayQueryPayload` throws', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var pendingA = addPending({query: mockQuery});\n    var mockFailureA = jest.genMockFunction();\n    pendingA.catch(mockFailureA);\n\n    var mockError = new Error('Expected error.');\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    writeRelayQueryPayload.mockImplementation(() => {\n      throw mockError;\n    });\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockError.message]);\n\n    expect(mockFailureA).toBeCalledWith(mockError);\n  });\n\n  it('can resolve preload queries *after* they are added', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({\n      query: mockQuery,\n      fetchMode: RelayFetchMode.PRELOAD,\n    });\n\n    pendingQueryTracker.resolvePreloadQuery(\n      mockQuery.getID(),\n      {response: {viewer:{}}}\n    );\n\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(1);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQuery);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n  });\n\n  it('can resolve preload queries *before* they are added', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    pendingQueryTracker.resolvePreloadQuery(\n      mockQuery.getID(),\n      {response: {viewer:{}}}\n    );\n\n    addPending({\n      query: mockQuery,\n      fetchMode: RelayFetchMode.PRELOAD,\n    });\n\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(1);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQuery);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n  });\n\n  it('can reject preloaded pending queries by id', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    var mockPending = addPending({\n      query: mockQuery,\n      fetchMode: RelayFetchMode.PRELOAD,\n    });\n    var mockCallback = jest.genMockFunction();\n    mockPending.catch(mockCallback);\n\n    var mockError = new Error('Expected error.');\n    pendingQueryTracker.rejectPreloadQuery(\n      mockQuery.getID(),\n      mockError\n    );\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockError.message]);\n\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n    expect(mockCallback).toBeCalledWith(mockError);\n  });\n\n  it('has pending queries when not queries are all resolved', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeTruthy();\n  });\n\n  it('has no pending queries when queries are all resolved', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n  });\n\n  it('has no pending queries after being reset', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    pendingQueryTracker.resetPending();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayFetchMode","RelayStoreData","RelayTestUtils","fetchRelayQuery","subtractRelayQuery","writeRelayQueryPayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayPendingQueryTracker')\n  .dontMock('RelayTaskQueue');\n\nconst Relay = require('Relay');\nconst RelayFetchMode = require('RelayFetchMode');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst fetchRelayQuery = require('fetchRelayQuery');\nconst subtractRelayQuery = require('subtractRelayQuery');\nconst writeRelayQueryPayload = require('writeRelayQueryPayload');\n\ndescribe('RelayPendingQueryTracker', () => {\n  var pendingQueryTracker;\n\n  var addPending;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    var storeData = new RelayStoreData();\n    pendingQueryTracker = storeData.getPendingQueryTracker();\n\n    subtractRelayQuery.mockImplementation(query => query);\n\n    addPending = ({query, fetchMode}) => {\n      fetchMode = fetchMode || RelayFetchMode.CLIENT;\n      return pendingQueryTracker.add({\n        query,\n        fetchMode,\n        forceIndex: null,\n      }).getResolvedPromise();\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n    jasmine.addMatchers({\n      toConsoleWarn() {\n        return {\n          compare(callback, expected) {\n            const consoleWarn = console.warn;\n            let pass = false;\n            console.warn = (...args) => {\n              if (args.length === expected.length &&\n                  args.every((arg, ii) => arg === expected[ii])) {\n                pass = true;\n              } else {\n                consoleWarn(...args);\n              }\n            };\n            callback();\n            console.warn = consoleWarn;\n            return {pass};\n          },\n        };\n      },\n    });\n  });\n\n  it('subtracts pending queries that share root call', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        node(id:\"4\"){actor{id,name}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name,birthdate{day}}}\n      }\n    `);\n    var mockQueryD = getNode(Relay.QL`\n      query {\n        node(id:\"4\"){actor{id,name,birthdate{day}}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery).not.toBeCalled();\n\n    addPending({query: mockQueryB});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery).not.toBeCalled();\n\n    addPending({query: mockQueryC});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery.mock.calls).toEqual([\n      [mockQueryC, mockQueryA],\n    ]);\n\n    fetchRelayQuery.mock.requests[1].resolve({node: {__typename: 'User'}});\n    jest.runAllTimers();\n\n    subtractRelayQuery.mockClear();\n    addPending({query: mockQueryD});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery).not.toBeCalled();\n  });\n\n  it('subtracts pending queries until completely subtracted', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    subtractRelayQuery.mockImplementation(() => null);\n\n    addPending({query: mockQueryB});\n    addPending({query: mockQueryC});\n    jest.runAllTimers();\n\n    expect(subtractRelayQuery.mock.calls).toEqual([\n      [mockQueryB, mockQueryA],\n      [mockQueryC, mockQueryA],\n    ]);\n  });\n\n  it('does not fetch completely subtracted queries', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryB);\n      expect(subQuery).toBe(mockQueryA);\n      return null;\n    });\n\n    addPending({query: mockQueryB});\n    jest.runAllTimers();\n\n    expect(fetchRelayQuery.mock.calls.length).toBe(1);\n    expect(fetchRelayQuery.mock.calls[0][0]).toEqualQueryRoot(mockQueryA);\n  });\n\n  it('calls `writeRelayQueryPayload` when receiving data', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(1);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQueryA);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n  });\n\n  it('resolves after dependencies are ready', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name,birthdate{day}}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,birthdate{day}}}\n      }\n    `);\n\n    var pendingA = addPending({query: mockQueryA});\n    var mockSuccessA = jest.genMockFunction();\n    pendingA.done(mockSuccessA);\n\n    // Simulates: B - A = C\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryB);\n      expect(subQuery).toBe(mockQueryA);\n      return mockQueryC;\n    });\n\n    var pendingB = addPending({query: mockQueryB});\n    var mockSuccessB = jest.genMockFunction();\n    pendingB.done(mockSuccessB);\n\n    fetchRelayQuery.mock.requests[1].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    expect(mockSuccessA).not.toBeCalled();\n    expect(mockSuccessB).not.toBeCalled();\n\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    expect(mockSuccessA).toBeCalled();\n    expect(mockSuccessB).toBeCalled();\n  });\n\n  it('fails direct dependents and not indirect ones', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var mockQueryB = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name,birthdate{day}}}\n      }\n    `);\n    var mockQueryBPrime = getNode(Relay.QL`\n      query {\n        viewer{actor{id,birthdate{day}}}\n      }\n    `);\n    var mockQueryC = getNode(Relay.QL`\n      query {\n        viewer{actor{id,firstName,birthdate{day}}}\n      }\n    `);\n    var mockQueryCPrime = getNode(Relay.QL`\n      query {\n        viewer{actor{id,firstName,birthdate{day}}}\n      }\n    `);\n\n    var pendingA = addPending({query: mockQueryA});\n    var mockFailureA = jest.genMockFunction();\n    pendingA.catch(mockFailureA);\n    jest.runAllTimers();\n\n    // Simulates: B - A = B'\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryB);\n      expect(subQuery).toBe(mockQueryA);\n      return mockQueryBPrime;\n    });\n\n    var pendingB = addPending({query: mockQueryB});\n    var mockFailureB = jest.genMockFunction();\n    pendingB.catch(mockFailureB);\n    jest.runAllTimers();\n\n    // Simulates: C - A = C, C - B' = C'\n    subtractRelayQuery.mockImplementation((query, subQuery) => {\n      expect(query).toBe(mockQueryC);\n      expect([mockQueryA, mockQueryBPrime]).toContain(subQuery);\n      return subQuery === mockQueryA ? mockQueryC : mockQueryCPrime;\n    });\n\n    var pendingC = addPending({query: mockQueryC});\n    var mockSuccessC = jest.genMockFunction();\n    pendingC.done(mockSuccessC);\n    jest.runAllTimers();\n\n    var mockFetchError = new Error('Expected `fetchRelayQuery` error.');\n    fetchRelayQuery.mock.requests[1].resolve({viewer:{}});\n    fetchRelayQuery.mock.requests[0].reject(mockFetchError);\n    fetchRelayQuery.mock.requests[2].resolve({viewer:{}});\n\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockFetchError.message]);\n\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(2);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQueryBPrime);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n    expect(writeCalls[1][1]).toEqualQueryRoot(mockQueryCPrime);\n    expect(writeCalls[1][2]).toEqual({viewer:{}});\n\n    expect(mockFailureA).toBeCalled();\n    expect(mockFailureB).toBeCalled();\n    expect(mockSuccessC).toBeCalled();\n  });\n\n  it('fails if fetching throws an error', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var pendingA = addPending({query: mockQuery});\n    var mockFailureA = jest.genMockFunction();\n    pendingA.catch(mockFailureA);\n\n    var mockError = new Error('Expected error.');\n    fetchRelayQuery.mock.requests[0].reject(mockError);\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockError.message]);\n\n    expect(mockFailureA).toBeCalledWith(mockError);\n  });\n\n  it('fails if `writeRelayQueryPayload` throws', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    var pendingA = addPending({query: mockQuery});\n    var mockFailureA = jest.genMockFunction();\n    pendingA.catch(mockFailureA);\n\n    var mockError = new Error('Expected error.');\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    writeRelayQueryPayload.mockImplementation(() => {\n      throw mockError;\n    });\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockError.message]);\n\n    expect(mockFailureA).toBeCalledWith(mockError);\n  });\n\n  it('can resolve preload queries *after* they are added', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    addPending({\n      query: mockQuery,\n      fetchMode: RelayFetchMode.PRELOAD,\n    });\n\n    pendingQueryTracker.resolvePreloadQuery(\n      mockQuery.getID(),\n      {response: {viewer:{}}}\n    );\n\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(1);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQuery);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n  });\n\n  it('can resolve preload queries *before* they are added', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    pendingQueryTracker.resolvePreloadQuery(\n      mockQuery.getID(),\n      {response: {viewer:{}}}\n    );\n\n    addPending({\n      query: mockQuery,\n      fetchMode: RelayFetchMode.PRELOAD,\n    });\n\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n    var writeCalls = writeRelayQueryPayload.mock.calls;\n    expect(writeCalls.length).toBe(1);\n    expect(writeCalls[0][1]).toEqualQueryRoot(mockQuery);\n    expect(writeCalls[0][2]).toEqual({viewer:{}});\n  });\n\n  it('can reject preloaded pending queries by id', () => {\n    var mockQuery = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n\n    var mockPending = addPending({\n      query: mockQuery,\n      fetchMode: RelayFetchMode.PRELOAD,\n    });\n    var mockCallback = jest.genMockFunction();\n    mockPending.catch(mockCallback);\n\n    var mockError = new Error('Expected error.');\n    pendingQueryTracker.rejectPreloadQuery(\n      mockQuery.getID(),\n      mockError\n    );\n    expect(() => {\n      jest.runAllTimers();\n    }).toConsoleWarn([mockError.message]);\n\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n    expect(mockCallback).toBeCalledWith(mockError);\n  });\n\n  it('has pending queries when not queries are all resolved', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeTruthy();\n  });\n\n  it('has no pending queries when queries are all resolved', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    fetchRelayQuery.mock.requests[0].resolve({viewer:{}});\n    jest.runAllTimers();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n  });\n\n  it('has no pending queries after being reset', () => {\n    var mockQueryA = getNode(Relay.QL`\n      query {\n        viewer{actor{id,name}}\n      }\n    `);\n    addPending({query: mockQueryA});\n    jest.runAllTimers();\n\n    pendingQueryTracker.resetPending();\n\n    expect(pendingQueryTracker.hasPendingQueries()).toBeFalsy();\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayPendingQueryTracker-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayGarbageCollector-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .dontMock('performanceNow');\n\nconst Relay = require('Relay');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst forEachObject = require('forEachObject');\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('RelayGarbageCollector', () => {\n  const {getNode} = RelayTestUtils;\n  const {HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO} = RelayNodeInterface;\n\n  function defaultScheduler(run) {\n    // collect everything without pausing\n    while (run()) {}\n  }\n\n  function createGC(records, scheduler) {\n    scheduler = scheduler || defaultScheduler;\n\n    const storeData = new RelayStoreData();\n    storeData.initializeGarbageCollector(scheduler);\n    const nodeData = storeData.getNodeData();\n    if (records) {\n      forEachObject(records, (data, dataID) => {\n        nodeData[dataID] = data;\n      });\n    }\n\n    return {\n      garbageCollector: storeData.getGarbageCollector(),\n      storeData,\n    };\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('collect()', () => {\n    it('collects all unreferenced nodes', () => {\n      const records = {\n        referenced: {__dataID__: 'referenced'},\n        unreferenced: {__dataID__: 'unreferenced'},\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('unreferenced');\n      garbageCollector.incrementReferenceCount('unreferenced');\n      garbageCollector.decrementReferenceCount('unreferenced');\n      garbageCollector.register('referenced');\n      garbageCollector.incrementReferenceCount('referenced');\n      garbageCollector.collect();\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        referenced: records.referenced,\n      });\n    });\n  });\n\n  describe('collectFromNode()', () => {\n    it('collects reachable unreferenced nodes', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          field: {__dataID__: 'b'},\n        },\n        b: {\n          __dataID__: 'b',\n          field: {__dataID__: 'c'},\n        },\n        c: {\n          __dataID__: 'c',\n        },\n        unreachable: {\n          __dataID__: 'unreachable',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.register('c');\n      garbageCollector.register('unreachable');\n\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        unreachable: {__dataID__: 'unreachable'},\n      });\n    });\n\n    it('skips referenced nodes', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          unreferenced: {__dataID__: 'unreferenced'},\n          referenced: {__dataID__: 'referenced'},\n        },\n        unreferenced: {\n          __dataID__: 'unreferenced',\n        },\n        referenced: {\n          __dataID__: 'referenced',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.register('referenced');\n      garbageCollector.register('unreferenced');\n      garbageCollector.incrementReferenceCount('referenced');\n\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        referenced: {__dataID__: 'referenced'},\n      });\n    });\n\n    it('handles deleted/removed nodes', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          removed: {__dataID__: 'removed'},\n          deleted: {__dataID__: 'deleted'},\n          b: {__dataID__: 'b'},\n        },\n        deleted: null,\n        b: {\n          __dataID__: 'b',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.register('deleted');\n\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('collects connection edges and nodes', () => {\n      const records = {\n        unreachable: {\n          __dataID__: 'unreachable',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      const payload = {\n        viewer: {\n          newsFeed: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id:'s1',\n                  message:{\n                    text:'s1',\n                  },\n                  __typename: 'Story',\n                },\n              },\n            ],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      const query = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  message {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      `);\n      storeData.handleQueryPayload(\n        query,\n        transformRelayQueryPayload(query, payload)\n      );\n      const viewerID = storeData.getRecordStore().getDataID('viewer', null);\n      garbageCollector.collectFromNode(viewerID);\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        unreachable: {__dataID__: 'unreachable'},\n      });\n    });\n  });\n\n  describe('acquireHold()', () => {\n    it('collects nodes if no holds are acquired', () => {\n      // base case\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('waits to collect until holds are released', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      const {release} = garbageCollector.acquireHold();\n      garbageCollector.register('a');\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      // not collected while hold is active\n      expect(storeData.getNodeData()).toEqual(records);\n      release();\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('throws if a hold is released more than once', () => {\n      const {garbageCollector} = createGC({});\n      const {release} = garbageCollector.acquireHold();\n      release();\n      expect(() => release()).toFailInvariant(\n        'RelayGarbageCollector: hold can only be released once.'\n      );\n    });\n\n    it('skips collection if a hold is active', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      let run = null;\n      const {garbageCollector, storeData} = createGC(\n        records,\n        _run => run = _run\n      );\n      garbageCollector.register('a');\n      garbageCollector.collect();\n      jest.runAllTimers();\n\n      const {release} = garbageCollector.acquireHold();\n      run();\n      // not collected while hold is active\n      expect(storeData.getNodeData()).toEqual(records);\n      release();\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual(records);\n      run();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n  });\n\n  describe('scheduling', () => {\n    it('does not call scheduler if there is nothing to collect', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const scheduler = jest.genMockFunction();\n      const {garbageCollector} = createGC(records, scheduler);\n      garbageCollector.register('a');\n      garbageCollector.incrementReferenceCount('a');\n      garbageCollector.collectFromNode('a');\n      expect(scheduler).not.toBeCalled();\n    });\n\n    it('does not call scheduler if no collections are enqueued', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const scheduler = jest.genMockFunction();\n      const {garbageCollector} = createGC(records, scheduler);\n      garbageCollector.register('a');\n\n      const {release} = garbageCollector.acquireHold();\n      release();\n      expect(scheduler).not.toBeCalled();\n    });\n\n    it('calls the injected scheduler and collects one record at a time', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          field: {__dataID__: 'b'},\n        },\n        b: {\n          __dataID__: 'b',\n          field: {__dataID__: 'c'},\n        },\n        c: {\n          __dataID__: 'c',\n          field: {__dataID__: 'd'},\n        },\n        d: {\n          __dataID__: 'd',\n        },\n      };\n      let run = null;\n      const {garbageCollector, storeData} = createGC(\n        records,\n        _run => run = _run\n      );\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.register('c');\n      garbageCollector.register('d');\n\n      garbageCollector.collectFromNode('a', 1);\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual(records);\n      expect(run()).toBe(true);\n      expect(storeData.getNodeData()).toEqual({\n        b: records.b,\n        c: records.c,\n        d: records.d,\n      });\n      expect(run()).toBe(true);\n      expect(storeData.getNodeData()).toEqual({\n        c: records.c,\n        d: records.d,\n      });\n      expect(run()).toBe(true);\n      expect(storeData.getNodeData()).toEqual({\n        d: records.d,\n      });\n      expect(run()).toBe(false);\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('does not overlap collections', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n        b: {__dataID__: 'b'},\n      };\n      let run = null;\n      const scheduler = jest.genMockFunction().mockImplementation(\n        _run => run = _run\n      );\n      const {garbageCollector} = createGC(records, scheduler);\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.collectFromNode('a');\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(scheduler.mock.calls.length).toBe(1);\n      run();\n      run(); // 'a' is enqueued twice\n      scheduler.mockClear();\n      garbageCollector.collectFromNode('b');\n      jest.runAllTimers();\n      jest.runAllTimers();\n      expect(scheduler.mock.calls.length).toBe(1);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayNodeInterface","RelayStoreData","RelayTestUtils","forEachObject","transformRelayQueryPayload"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('GraphQLRange')\n  .dontMock('GraphQLSegment')\n  .dontMock('performanceNow');\n\nconst Relay = require('Relay');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst forEachObject = require('forEachObject');\nconst transformRelayQueryPayload = require('transformRelayQueryPayload');\n\ndescribe('RelayGarbageCollector', () => {\n  const {getNode} = RelayTestUtils;\n  const {HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO} = RelayNodeInterface;\n\n  function defaultScheduler(run) {\n    // collect everything without pausing\n    while (run()) {}\n  }\n\n  function createGC(records, scheduler) {\n    scheduler = scheduler || defaultScheduler;\n\n    const storeData = new RelayStoreData();\n    storeData.initializeGarbageCollector(scheduler);\n    const nodeData = storeData.getNodeData();\n    if (records) {\n      forEachObject(records, (data, dataID) => {\n        nodeData[dataID] = data;\n      });\n    }\n\n    return {\n      garbageCollector: storeData.getGarbageCollector(),\n      storeData,\n    };\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('collect()', () => {\n    it('collects all unreferenced nodes', () => {\n      const records = {\n        referenced: {__dataID__: 'referenced'},\n        unreferenced: {__dataID__: 'unreferenced'},\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('unreferenced');\n      garbageCollector.incrementReferenceCount('unreferenced');\n      garbageCollector.decrementReferenceCount('unreferenced');\n      garbageCollector.register('referenced');\n      garbageCollector.incrementReferenceCount('referenced');\n      garbageCollector.collect();\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        referenced: records.referenced,\n      });\n    });\n  });\n\n  describe('collectFromNode()', () => {\n    it('collects reachable unreferenced nodes', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          field: {__dataID__: 'b'},\n        },\n        b: {\n          __dataID__: 'b',\n          field: {__dataID__: 'c'},\n        },\n        c: {\n          __dataID__: 'c',\n        },\n        unreachable: {\n          __dataID__: 'unreachable',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.register('c');\n      garbageCollector.register('unreachable');\n\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        unreachable: {__dataID__: 'unreachable'},\n      });\n    });\n\n    it('skips referenced nodes', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          unreferenced: {__dataID__: 'unreferenced'},\n          referenced: {__dataID__: 'referenced'},\n        },\n        unreferenced: {\n          __dataID__: 'unreferenced',\n        },\n        referenced: {\n          __dataID__: 'referenced',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.register('referenced');\n      garbageCollector.register('unreferenced');\n      garbageCollector.incrementReferenceCount('referenced');\n\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        referenced: {__dataID__: 'referenced'},\n      });\n    });\n\n    it('handles deleted/removed nodes', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          removed: {__dataID__: 'removed'},\n          deleted: {__dataID__: 'deleted'},\n          b: {__dataID__: 'b'},\n        },\n        deleted: null,\n        b: {\n          __dataID__: 'b',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.register('deleted');\n\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('collects connection edges and nodes', () => {\n      const records = {\n        unreachable: {\n          __dataID__: 'unreachable',\n        },\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      const payload = {\n        viewer: {\n          newsFeed: {\n            edges: [\n              {\n                cursor: 'c1',\n                node: {\n                  id:'s1',\n                  message:{\n                    text:'s1',\n                  },\n                  __typename: 'Story',\n                },\n              },\n            ],\n            [PAGE_INFO]: {\n              [HAS_NEXT_PAGE]: true,\n              [HAS_PREV_PAGE]: false,\n            },\n          },\n        },\n      };\n      const query = getNode(Relay.QL`\n        query {\n          viewer {\n            newsFeed(first:\"1\") {\n              edges {\n                node {\n                  message {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      `);\n      storeData.handleQueryPayload(\n        query,\n        transformRelayQueryPayload(query, payload)\n      );\n      const viewerID = storeData.getRecordStore().getDataID('viewer', null);\n      garbageCollector.collectFromNode(viewerID);\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({\n        unreachable: {__dataID__: 'unreachable'},\n      });\n    });\n  });\n\n  describe('acquireHold()', () => {\n    it('collects nodes if no holds are acquired', () => {\n      // base case\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      garbageCollector.register('a');\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('waits to collect until holds are released', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const {garbageCollector, storeData} = createGC(records);\n      const {release} = garbageCollector.acquireHold();\n      garbageCollector.register('a');\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      // not collected while hold is active\n      expect(storeData.getNodeData()).toEqual(records);\n      release();\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('throws if a hold is released more than once', () => {\n      const {garbageCollector} = createGC({});\n      const {release} = garbageCollector.acquireHold();\n      release();\n      expect(() => release()).toFailInvariant(\n        'RelayGarbageCollector: hold can only be released once.'\n      );\n    });\n\n    it('skips collection if a hold is active', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      let run = null;\n      const {garbageCollector, storeData} = createGC(\n        records,\n        _run => run = _run\n      );\n      garbageCollector.register('a');\n      garbageCollector.collect();\n      jest.runAllTimers();\n\n      const {release} = garbageCollector.acquireHold();\n      run();\n      // not collected while hold is active\n      expect(storeData.getNodeData()).toEqual(records);\n      release();\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual(records);\n      run();\n      expect(storeData.getNodeData()).toEqual({});\n    });\n  });\n\n  describe('scheduling', () => {\n    it('does not call scheduler if there is nothing to collect', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const scheduler = jest.genMockFunction();\n      const {garbageCollector} = createGC(records, scheduler);\n      garbageCollector.register('a');\n      garbageCollector.incrementReferenceCount('a');\n      garbageCollector.collectFromNode('a');\n      expect(scheduler).not.toBeCalled();\n    });\n\n    it('does not call scheduler if no collections are enqueued', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n      };\n      const scheduler = jest.genMockFunction();\n      const {garbageCollector} = createGC(records, scheduler);\n      garbageCollector.register('a');\n\n      const {release} = garbageCollector.acquireHold();\n      release();\n      expect(scheduler).not.toBeCalled();\n    });\n\n    it('calls the injected scheduler and collects one record at a time', () => {\n      const records = {\n        a: {\n          __dataID__: 'a',\n          field: {__dataID__: 'b'},\n        },\n        b: {\n          __dataID__: 'b',\n          field: {__dataID__: 'c'},\n        },\n        c: {\n          __dataID__: 'c',\n          field: {__dataID__: 'd'},\n        },\n        d: {\n          __dataID__: 'd',\n        },\n      };\n      let run = null;\n      const {garbageCollector, storeData} = createGC(\n        records,\n        _run => run = _run\n      );\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.register('c');\n      garbageCollector.register('d');\n\n      garbageCollector.collectFromNode('a', 1);\n      jest.runAllTimers();\n      expect(storeData.getNodeData()).toEqual(records);\n      expect(run()).toBe(true);\n      expect(storeData.getNodeData()).toEqual({\n        b: records.b,\n        c: records.c,\n        d: records.d,\n      });\n      expect(run()).toBe(true);\n      expect(storeData.getNodeData()).toEqual({\n        c: records.c,\n        d: records.d,\n      });\n      expect(run()).toBe(true);\n      expect(storeData.getNodeData()).toEqual({\n        d: records.d,\n      });\n      expect(run()).toBe(false);\n      expect(storeData.getNodeData()).toEqual({});\n    });\n\n    it('does not overlap collections', () => {\n      const records = {\n        a: {__dataID__: 'a'},\n        b: {__dataID__: 'b'},\n      };\n      let run = null;\n      const scheduler = jest.genMockFunction().mockImplementation(\n        _run => run = _run\n      );\n      const {garbageCollector} = createGC(records, scheduler);\n      garbageCollector.register('a');\n      garbageCollector.register('b');\n      garbageCollector.collectFromNode('a');\n      garbageCollector.collectFromNode('a');\n      jest.runAllTimers();\n      expect(scheduler.mock.calls.length).toBe(1);\n      run();\n      run(); // 'a' is enqueued twice\n      scheduler.mockClear();\n      garbageCollector.collectFromNode('b');\n      jest.runAllTimers();\n      jest.runAllTimers();\n      expect(scheduler.mock.calls.length).toBe(1);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayGarbageCollector-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayDiskCacheReader-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayChangeTracker = require('RelayChangeTracker');\nconst RelayDiskCacheReader = require('RelayDiskCacheReader');\nconst RelayGarbageCollector = require('RelayGarbageCollector');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst invariant = require('invariant');\n\ndescribe('RelayDiskCacheReader', () => {\n  var {getNode} = RelayTestUtils;\n\n  function readDiskCache({\n    cachedRecords,\n    cachedRootCallMap,\n    dataID,\n    diskCacheData,\n    fragment,\n    garbageCollector,\n    path,\n    queries,\n    records,\n    rootCallMap,\n  }) {\n    cachedRecords = cachedRecords || {};\n    cachedRootCallMap = cachedRootCallMap || {};\n    diskCacheData = diskCacheData || {};\n\n    var store = new RelayRecordStore(\n      {\n        records: records || {},\n        cachedRecords,\n      },\n      {\n        rootCallMap: rootCallMap || {},\n        cachedRootCallMap,\n      }\n    );\n\n    var cacheManager = {\n      readNode: jest.genMockFunction().mockImplementation((id, callback) => {\n        setTimeout(() => {\n          callback(undefined, diskCacheData[id]);\n        });\n      }),\n      readRootCall: jest.genMockFunction().mockImplementation(\n        (callName, callArg, callback) => {\n          var rootKey = callName + '*' + callArg;\n          setTimeout(() => {\n            callback(undefined, diskCacheData[rootKey]);\n          });\n        }\n      ),\n    };\n\n    var changeTracker = new RelayChangeTracker();\n\n    var callbacks = {\n      onSuccess: jest.genMockFunction(),\n      onFailure: jest.genMockFunction(),\n    };\n\n    let abort;\n    if (queries) {\n      ({abort} = RelayDiskCacheReader.readQueries(\n        queries,\n        store,\n        cachedRecords,\n        cachedRootCallMap,\n        garbageCollector,\n        cacheManager,\n        changeTracker,\n        callbacks\n      ));\n    } else if (dataID && fragment && path) {\n      ({abort} = RelayDiskCacheReader.readFragment(\n        dataID,\n        fragment,\n        path,\n        store,\n        cachedRecords,\n        cachedRootCallMap,\n        garbageCollector,\n        cacheManager,\n        changeTracker,\n        callbacks\n      ));\n    } else {\n      invariant(false, 'Input did not match for reading queries nor fragments');\n    }\n\n    return {abort, cacheManager, callbacks, changeTracker, store};\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jest.clearAllTimers();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n  });\n\n  describe('read', () => {\n    it('reads disk for custom root call', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var {cacheManager} = readDiskCache({queries});\n\n      var mockReadRoot = cacheManager.readRootCall.mock;\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);\n    });\n\n    it('does not read disk for node root call', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id}}\n        `),\n      };\n      var {cacheManager} = readDiskCache({queries});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n    });\n\n    it('calls `onFailure` when custom root call is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var {cacheManager, callbacks} = readDiskCache({queries});\n\n      var mockReadRoot = cacheManager.readRootCall.mock;\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);\n\n      jest.runAllTimers();\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n    });\n\n    it('calls `onSuccess` when custom root call is on disk ', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var diskCacheData = {\n        'username*yuzhi': '1055790163',\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      var mockReadRoot = cacheManager.readRootCall.mock;\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);\n\n      jest.runAllTimers();\n\n      expect(mockReadRoot.calls.length).toBe(1);\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          1055790163: true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when custom root call is in store ', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var rootCallMap = {username: {yuzhi: '1055790163'}};\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, records, rootCallMap});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when custom root call is in cached store ', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var cachedRecords = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var cachedRootCallMap = {username: {yuzhi: '1055790163'}};\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, cachedRecords, cachedRootCallMap});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when node is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id}}\n        `),\n      };\n      var {cacheManager, callbacks} = readDiskCache({queries});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runAllTimers();\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n    });\n\n    it('calls `onFailure` when a field is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id, name}}\n        `),\n      };\n\n      // Missing `name`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when a nested node is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id, hometown {name}}}\n        `),\n      };\n\n      // Missing `hometownid`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          hometown: {__dataID__: 'hometownid'},\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('hometownid');\n\n      jest.runAllTimers();\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'hometown'))\n        .toBe('hometownid');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('hometownid')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when one of the plural nodes is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id, screennames {service}}}\n        `),\n      };\n\n      // Missing `sn2`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}, {__dataID__: 'sn2'}],\n        },\n        'sn1': {\n          __dataID__: 'sn1',\n          service: 'GTALK',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('sn1');\n      expect(cacheManager.readNode.mock.calls[2][0]).toBe('sn2');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordIDs('1055790163', 'screennames'))\n        .toEqual(['sn1', 'sn2']);\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('sn1')).toBe('EXISTENT');\n      expect(store.getField('sn1', 'service')).toBe('GTALK');\n      expect(store.getRecordState('sn2')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'sn1': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when range field is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      // Missing `__range__`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'friends_id'},\n        },\n        'friends_id': {\n          __dataID__: 'friends_id',\n          count: 500,\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('friends_id');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('friends_id')).toBe('EXISTENT');\n      expect(store.getField('friends_id', 'count')).toBe(500);\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'friends_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when range on disk has diff calls', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'friends_id'},\n        },\n        'friends_id': {\n          __dataID__: 'friends_id',\n          __range__: new GraphQLRange(),\n        },\n      };\n\n      diskCacheData.friends_id.__range__.retrieveRangeInfoForQuery\n        .mockReturnValue({\n          requestedEdgeIDs: [],\n          diffCalls: [RelayTestUtils.createCall('first', 5)],\n          pageInfo: {},\n        });\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('friends_id');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('friends_id')).toBe('EXISTENT');\n      expect(store.hasRange('friends_id')).toBe(true);\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'friends_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when edge node is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      // Missing `edge_id`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'friends_id'},\n        },\n        'friends_id': {\n          __dataID__: 'friends_id',\n          __range__: new GraphQLRange(),\n        },\n      };\n\n      diskCacheData.friends_id.__range__.retrieveRangeInfoForQuery\n        .mockReturnValue({\n          requestedEdgeIDs: ['edge_id'],\n          diffCalls: [],\n          pageInfo: {},\n        });\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(cacheManager.readNode.mock.calls[2][0]).toBe('edge_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('friends_id');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('friends_id')).toBe('EXISTENT');\n      expect(store.hasRange('friends_id')).toBe(true);\n      expect(store.getRecordState('edge_id')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'friends_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when connection is on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'client:friends_id'},\n        },\n        'client:friends_id': {\n          __dataID__: 'client:friends_id',\n          __range__: new GraphQLRange(),\n        },\n        'client:edge_id': {\n          __dataID__: 'client:edge_id',\n          cursor: '1234',\n          node: {__dataID__: 'friend_id'},\n        },\n        'friend_id': {\n          __dataID__: 'friend_id',\n          id: 'friend_id',\n          name: 'name',\n        },\n      };\n\n      var rangeInfo = {\n        requestedEdgeIDs: ['client:edge_id'],\n        diffCalls: [],\n        pageInfo: {},\n      };\n      diskCacheData['client:friends_id'].__range__.retrieveRangeInfoForQuery\n        .mockReturnValue(rangeInfo);\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('client:friends_id');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(cacheManager.readNode.mock.calls[2][0]).toBe('client:edge_id');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(4);\n      expect(cacheManager.readNode.mock.calls[3][0]).toBe('friend_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(4);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('client:friends_id');\n      expect(store.getRecordState('client:friends_id')).toBe('EXISTENT');\n      var query = queries.q0;\n      var friendsField = query.getFieldByStorageKey('friends');\n      var friendsPath = new RelayQueryPath(query)\n          .getPath(query.getFieldByStorageKey('friends'), 'client:friends_id');\n      expect(store.getPathToRecord(`client:friends_id`))\n        .toMatchPath(friendsPath);\n      expect(store.getRangeMetadata(\n        'client:friends_id',\n        [{name:'first', value: '5'}]\n      )).toEqual({\n        ...rangeInfo,\n        filterCalls: [],\n        filteredEdges: [{\n          edgeID: 'client:edge_id',\n          nodeID: 'friend_id',\n        }],\n      });\n      expect(store.getRecordState('client:edge_id')).toBe('EXISTENT');\n      var edgePath = friendsPath\n        .getPath(friendsField.getFieldByStorageKey('edges'), 'client:edge_id');\n      expect(store.getPathToRecord(`client:edge_id`)).toMatchPath(edgePath);\n      expect(store.getField('client:edge_id', 'cursor')).toBe('1234');\n      expect(store.getLinkedRecordID('client:edge_id', 'node'))\n        .toBe('friend_id');\n      expect(store.getRecordState('friend_id')).toBe('EXISTENT');\n      expect(store.getField('friend_id', 'id')).toBe('friend_id');\n      expect(store.getField('friend_id', 'name')).toBe('name');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'client:friends_id': true,\n          'client:edge_id': true,\n          'friend_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('marks records as updated when more fields are loaded from cache', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              id\n              screennames {\n                service\n              }\n            }\n          }\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}],\n        },\n        'sn1': {\n          __dataID__: 'sn1',\n          service: 'GTALK',\n        },\n      };\n      var {callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData, records});\n\n      jest.runAllTimers();\n\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n\n      // Updates the top-level record which existed in node data and creates the\n      // linked record.\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getLinkedRecordIDs('1055790163', 'screennames'))\n        .toEqual(['sn1']);\n      expect(store.getRecordState('sn1')).toBe('EXISTENT');\n      expect(store.getField('sn1', 'service')).toBe('GTALK');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          'sn1': true,\n        },\n        updated: {\n          '1055790163': true,\n        },\n      });\n    });\n\n    it('marks records as created if they are null in the cache', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              id\n              screennames {\n                service\n              }\n            }\n          }\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}, {__dataID__: 'sn2'}],\n        },\n        'sn1': null,\n        'sn2': undefined,\n      };\n      var {callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData, records});\n\n      jest.runAllTimers();\n\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Updates the top-level record which existed in node data and creates the\n      // linked record.\n      expect(store.getRecordState('sn1')).toBe('NONEXISTENT');\n      expect(store.getRecordState('sn2')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          'sn1': true,\n          // sn2 not created since the value is unknown in the cache\n        },\n        updated: {\n          '1055790163': true,\n        },\n      });\n    });\n\n    it('does not mark deleted records as updated', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              id\n              screennames {\n                service\n              }\n            }\n          }\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n        // linked from the above in diskCache only\n        'sn1': null,\n      };\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}],\n        },\n        'sn1': {\n          __dataID__: 'sn1',\n          service: 'GTALK',\n        },\n      };\n      var {callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData, records});\n\n      jest.runAllTimers();\n\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getLinkedRecordIDs('1055790163', 'screennames'))\n        .toEqual(['sn1']);\n      expect(store.getRecordState('sn1')).toBe('NONEXISTENT');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          '1055790163': true,\n        },\n      });\n    });\n\n    it('registers new records with the garbage collector', () => {\n      const garbageCollector = new RelayGarbageCollector();\n      RelayGarbageCollector.prototype.register = jest.genMockFunction();\n      const queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id: \"123\") {\n              id\n            }\n          }\n        `),\n      };\n      const records = {\n      };\n      const diskCacheData = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n        },\n      };\n      readDiskCache({diskCacheData, garbageCollector, queries, records});\n\n      jest.runAllTimers();\n\n      expect(garbageCollector.register.mock.calls.length).toBe(1);\n      expect(garbageCollector.register.mock.calls[0][0]).toBe('123');\n    });\n  });\n\n  // Most field types are already tested in the normal read function above.\n  // This will test the various cases for the root node in `readFragment`.\n\n  describe('readFragment', () => {\n    it('calls `onFailure` when node is not in disk', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {};\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when a field is not on disk', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe(undefined);\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          1055790163: true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when node is in disk', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          1055790163: true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when node is in cached store', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var cachedRecords = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, cachedRecords});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when node is in store', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, records});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n  });\n\n  describe('abort', () => {\n    it('does not call `onSuccess` if aborted', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {abort, callbacks, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      abort();\n      // this would read 1055790163 from cache if not aborted\n      jest.runAllTimers();\n\n      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');\n      expect(callbacks.onFailure).not.toBeCalled();\n      expect(callbacks.onSuccess).not.toBeCalled();\n    });\n\n    it('does not `onFailure` if aborted', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {abort, callbacks, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      abort();\n      // The read would fail since `name` is missing from cached data.\n      jest.runAllTimers();\n\n      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');\n      expect(callbacks.onFailure).not.toBeCalled();\n      expect(callbacks.onSuccess).not.toBeCalled();\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLRange","Relay","RelayChangeTracker","RelayDiskCacheReader","RelayGarbageCollector","RelayQueryPath","RelayRecordStore","RelayTestUtils","invariant"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayChangeTracker = require('RelayChangeTracker');\nconst RelayDiskCacheReader = require('RelayDiskCacheReader');\nconst RelayGarbageCollector = require('RelayGarbageCollector');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst invariant = require('invariant');\n\ndescribe('RelayDiskCacheReader', () => {\n  var {getNode} = RelayTestUtils;\n\n  function readDiskCache({\n    cachedRecords,\n    cachedRootCallMap,\n    dataID,\n    diskCacheData,\n    fragment,\n    garbageCollector,\n    path,\n    queries,\n    records,\n    rootCallMap,\n  }) {\n    cachedRecords = cachedRecords || {};\n    cachedRootCallMap = cachedRootCallMap || {};\n    diskCacheData = diskCacheData || {};\n\n    var store = new RelayRecordStore(\n      {\n        records: records || {},\n        cachedRecords,\n      },\n      {\n        rootCallMap: rootCallMap || {},\n        cachedRootCallMap,\n      }\n    );\n\n    var cacheManager = {\n      readNode: jest.genMockFunction().mockImplementation((id, callback) => {\n        setTimeout(() => {\n          callback(undefined, diskCacheData[id]);\n        });\n      }),\n      readRootCall: jest.genMockFunction().mockImplementation(\n        (callName, callArg, callback) => {\n          var rootKey = callName + '*' + callArg;\n          setTimeout(() => {\n            callback(undefined, diskCacheData[rootKey]);\n          });\n        }\n      ),\n    };\n\n    var changeTracker = new RelayChangeTracker();\n\n    var callbacks = {\n      onSuccess: jest.genMockFunction(),\n      onFailure: jest.genMockFunction(),\n    };\n\n    let abort;\n    if (queries) {\n      ({abort} = RelayDiskCacheReader.readQueries(\n        queries,\n        store,\n        cachedRecords,\n        cachedRootCallMap,\n        garbageCollector,\n        cacheManager,\n        changeTracker,\n        callbacks\n      ));\n    } else if (dataID && fragment && path) {\n      ({abort} = RelayDiskCacheReader.readFragment(\n        dataID,\n        fragment,\n        path,\n        store,\n        cachedRecords,\n        cachedRootCallMap,\n        garbageCollector,\n        cacheManager,\n        changeTracker,\n        callbacks\n      ));\n    } else {\n      invariant(false, 'Input did not match for reading queries nor fragments');\n    }\n\n    return {abort, cacheManager, callbacks, changeTracker, store};\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jest.clearAllTimers();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n  });\n\n  describe('read', () => {\n    it('reads disk for custom root call', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var {cacheManager} = readDiskCache({queries});\n\n      var mockReadRoot = cacheManager.readRootCall.mock;\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);\n    });\n\n    it('does not read disk for node root call', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id}}\n        `),\n      };\n      var {cacheManager} = readDiskCache({queries});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n    });\n\n    it('calls `onFailure` when custom root call is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var {cacheManager, callbacks} = readDiskCache({queries});\n\n      var mockReadRoot = cacheManager.readRootCall.mock;\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);\n\n      jest.runAllTimers();\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n    });\n\n    it('calls `onSuccess` when custom root call is on disk ', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var diskCacheData = {\n        'username*yuzhi': '1055790163',\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      var mockReadRoot = cacheManager.readRootCall.mock;\n      expect(mockReadRoot.calls.length).toBe(1);\n      expect(mockReadRoot.calls[0].slice(0, 2)).toEqual(['username', 'yuzhi']);\n\n      jest.runAllTimers();\n\n      expect(mockReadRoot.calls.length).toBe(1);\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          1055790163: true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when custom root call is in store ', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var rootCallMap = {username: {yuzhi: '1055790163'}};\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, records, rootCallMap});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when custom root call is in cached store ', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {username(name:\"yuzhi\") {id}}\n        `),\n      };\n      var cachedRecords = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var cachedRootCallMap = {username: {yuzhi: '1055790163'}};\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, cachedRecords, cachedRootCallMap});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getDataID('username', 'yuzhi')).toBe('1055790163');\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when node is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id}}\n        `),\n      };\n      var {cacheManager, callbacks} = readDiskCache({queries});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runAllTimers();\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n    });\n\n    it('calls `onFailure` when a field is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id, name}}\n        `),\n      };\n\n      // Missing `name`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when a nested node is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id, hometown {name}}}\n        `),\n      };\n\n      // Missing `hometownid`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          hometown: {__dataID__: 'hometownid'},\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('hometownid');\n\n      jest.runAllTimers();\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'hometown'))\n        .toBe('hometownid');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('hometownid')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when one of the plural nodes is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {node(id:\"1055790163\") {id, screennames {service}}}\n        `),\n      };\n\n      // Missing `sn2`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}, {__dataID__: 'sn2'}],\n        },\n        'sn1': {\n          __dataID__: 'sn1',\n          service: 'GTALK',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('sn1');\n      expect(cacheManager.readNode.mock.calls[2][0]).toBe('sn2');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordIDs('1055790163', 'screennames'))\n        .toEqual(['sn1', 'sn2']);\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('sn1')).toBe('EXISTENT');\n      expect(store.getField('sn1', 'service')).toBe('GTALK');\n      expect(store.getRecordState('sn2')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'sn1': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when range field is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      // Missing `__range__`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'friends_id'},\n        },\n        'friends_id': {\n          __dataID__: 'friends_id',\n          count: 500,\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('friends_id');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('friends_id')).toBe('EXISTENT');\n      expect(store.getField('friends_id', 'count')).toBe(500);\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'friends_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when range on disk has diff calls', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'friends_id'},\n        },\n        'friends_id': {\n          __dataID__: 'friends_id',\n          __range__: new GraphQLRange(),\n        },\n      };\n\n      diskCacheData.friends_id.__range__.retrieveRangeInfoForQuery\n        .mockReturnValue({\n          requestedEdgeIDs: [],\n          diffCalls: [RelayTestUtils.createCall('first', 5)],\n          pageInfo: {},\n        });\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('friends_id');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('friends_id')).toBe('EXISTENT');\n      expect(store.hasRange('friends_id')).toBe(true);\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'friends_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when edge node is not on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      // Missing `edge_id`\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'friends_id'},\n        },\n        'friends_id': {\n          __dataID__: 'friends_id',\n          __range__: new GraphQLRange(),\n        },\n      };\n\n      diskCacheData.friends_id.__range__.retrieveRangeInfoForQuery\n        .mockReturnValue({\n          requestedEdgeIDs: ['edge_id'],\n          diffCalls: [],\n          pageInfo: {},\n        });\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('friends_id');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(cacheManager.readNode.mock.calls[2][0]).toBe('edge_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Confirm that partial data was read into the cache:\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('friends_id');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getRecordState('friends_id')).toBe('EXISTENT');\n      expect(store.hasRange('friends_id')).toBe(true);\n      expect(store.getRecordState('edge_id')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'friends_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when connection is on disk', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              friends(first:\"5\") {\n                edges {\n                  node {\n                    name,\n                  },\n                  cursor\n                }\n              }\n            }\n          }\n        `),\n      };\n\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          friends: {__dataID__: 'client:friends_id'},\n        },\n        'client:friends_id': {\n          __dataID__: 'client:friends_id',\n          __range__: new GraphQLRange(),\n        },\n        'client:edge_id': {\n          __dataID__: 'client:edge_id',\n          cursor: '1234',\n          node: {__dataID__: 'friend_id'},\n        },\n        'friend_id': {\n          __dataID__: 'friend_id',\n          id: 'friend_id',\n          name: 'name',\n        },\n      };\n\n      var rangeInfo = {\n        requestedEdgeIDs: ['client:edge_id'],\n        diffCalls: [],\n        pageInfo: {},\n      };\n      diskCacheData['client:friends_id'].__range__.retrieveRangeInfoForQuery\n        .mockReturnValue(rangeInfo);\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData});\n\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(1);\n      expect(cacheManager.readNode.mock.calls[0][0]).toBe('1055790163');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(2);\n      expect(cacheManager.readNode.mock.calls[1][0]).toBe('client:friends_id');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(3);\n      expect(cacheManager.readNode.mock.calls[2][0]).toBe('client:edge_id');\n\n      jest.runOnlyPendingTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(4);\n      expect(cacheManager.readNode.mock.calls[3][0]).toBe('friend_id');\n\n      jest.runAllTimers();\n      expect(cacheManager.readRootCall.mock.calls.length).toBe(0);\n      expect(cacheManager.readNode.mock.calls.length).toBe(4);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getLinkedRecordID('1055790163', 'friends'))\n        .toBe('client:friends_id');\n      expect(store.getRecordState('client:friends_id')).toBe('EXISTENT');\n      var query = queries.q0;\n      var friendsField = query.getFieldByStorageKey('friends');\n      var friendsPath = new RelayQueryPath(query)\n          .getPath(query.getFieldByStorageKey('friends'), 'client:friends_id');\n      expect(store.getPathToRecord(`client:friends_id`))\n        .toMatchPath(friendsPath);\n      expect(store.getRangeMetadata(\n        'client:friends_id',\n        [{name:'first', value: '5'}]\n      )).toEqual({\n        ...rangeInfo,\n        filterCalls: [],\n        filteredEdges: [{\n          edgeID: 'client:edge_id',\n          nodeID: 'friend_id',\n        }],\n      });\n      expect(store.getRecordState('client:edge_id')).toBe('EXISTENT');\n      var edgePath = friendsPath\n        .getPath(friendsField.getFieldByStorageKey('edges'), 'client:edge_id');\n      expect(store.getPathToRecord(`client:edge_id`)).toMatchPath(edgePath);\n      expect(store.getField('client:edge_id', 'cursor')).toBe('1234');\n      expect(store.getLinkedRecordID('client:edge_id', 'node'))\n        .toBe('friend_id');\n      expect(store.getRecordState('friend_id')).toBe('EXISTENT');\n      expect(store.getField('friend_id', 'id')).toBe('friend_id');\n      expect(store.getField('friend_id', 'name')).toBe('name');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          '1055790163': true,\n          'client:friends_id': true,\n          'client:edge_id': true,\n          'friend_id': true,\n        },\n        updated: {},\n      });\n    });\n\n    it('marks records as updated when more fields are loaded from cache', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              id\n              screennames {\n                service\n              }\n            }\n          }\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}],\n        },\n        'sn1': {\n          __dataID__: 'sn1',\n          service: 'GTALK',\n        },\n      };\n      var {callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData, records});\n\n      jest.runAllTimers();\n\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n\n      // Updates the top-level record which existed in node data and creates the\n      // linked record.\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(store.getLinkedRecordIDs('1055790163', 'screennames'))\n        .toEqual(['sn1']);\n      expect(store.getRecordState('sn1')).toBe('EXISTENT');\n      expect(store.getField('sn1', 'service')).toBe('GTALK');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          'sn1': true,\n        },\n        updated: {\n          '1055790163': true,\n        },\n      });\n    });\n\n    it('marks records as created if they are null in the cache', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              id\n              screennames {\n                service\n              }\n            }\n          }\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}, {__dataID__: 'sn2'}],\n        },\n        'sn1': null,\n        'sn2': undefined,\n      };\n      var {callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData, records});\n\n      jest.runAllTimers();\n\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n\n      // Updates the top-level record which existed in node data and creates the\n      // linked record.\n      expect(store.getRecordState('sn1')).toBe('NONEXISTENT');\n      expect(store.getRecordState('sn2')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          'sn1': true,\n          // sn2 not created since the value is unknown in the cache\n        },\n        updated: {\n          '1055790163': true,\n        },\n      });\n    });\n\n    it('does not mark deleted records as updated', () => {\n      var queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id:\"1055790163\") {\n              id\n              screennames {\n                service\n              }\n            }\n          }\n        `),\n      };\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n        // linked from the above in diskCache only\n        'sn1': null,\n      };\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n          screennames: [{__dataID__: 'sn1'}],\n        },\n        'sn1': {\n          __dataID__: 'sn1',\n          service: 'GTALK',\n        },\n      };\n      var {callbacks, changeTracker, store} =\n        readDiskCache({queries, diskCacheData, records});\n\n      jest.runAllTimers();\n\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getLinkedRecordIDs('1055790163', 'screennames'))\n        .toEqual(['sn1']);\n      expect(store.getRecordState('sn1')).toBe('NONEXISTENT');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {\n          '1055790163': true,\n        },\n      });\n    });\n\n    it('registers new records with the garbage collector', () => {\n      const garbageCollector = new RelayGarbageCollector();\n      RelayGarbageCollector.prototype.register = jest.genMockFunction();\n      const queries = {\n        q0: getNode(Relay.QL`\n          query {\n            node(id: \"123\") {\n              id\n            }\n          }\n        `),\n      };\n      const records = {\n      };\n      const diskCacheData = {\n        '123': {\n          __dataID__: '123',\n          __typename: 'User',\n          id: '123',\n        },\n      };\n      readDiskCache({diskCacheData, garbageCollector, queries, records});\n\n      jest.runAllTimers();\n\n      expect(garbageCollector.register.mock.calls.length).toBe(1);\n      expect(garbageCollector.register.mock.calls[0][0]).toBe('123');\n    });\n  });\n\n  // Most field types are already tested in the normal read function above.\n  // This will test the various cases for the root node in `readFragment`.\n\n  describe('readFragment', () => {\n    it('calls `onFailure` when node is not in disk', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {};\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onFailure` when a field is not on disk', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(1);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(0);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe(undefined);\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          1055790163: true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when node is in disk', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(1);\n      expect(mockReadNode.calls[0][0]).toEqual('1055790163');\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {\n          1055790163: true,\n        },\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when node is in cached store', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var cachedRecords = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, cachedRecords});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n\n    it('calls `onSuccess` when node is in store', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var records = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {cacheManager, callbacks, changeTracker, store} =\n        readDiskCache({dataID, fragment, path, records});\n\n      jest.runAllTimers();\n\n      var mockReadNode = cacheManager.readNode.mock;\n      expect(mockReadNode.calls.length).toBe(0);\n      expect(callbacks.onFailure.mock.calls.length).toBe(0);\n      expect(callbacks.onSuccess.mock.calls.length).toBe(1);\n      expect(store.getRecordState('1055790163')).toBe('EXISTENT');\n      expect(store.getField('1055790163', 'id')).toBe('1055790163');\n      expect(store.getField('1055790163', 'name')).toBe('Yuzhi Zheng');\n      expect(store.getType('1055790163')).toBe('User');\n      expect(changeTracker.getChangeSet()).toEqual({\n        created: {},\n        updated: {},\n      });\n    });\n  });\n\n  describe('abort', () => {\n    it('does not call `onSuccess` if aborted', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          name: 'Yuzhi Zheng',\n          __typename: 'User',\n        },\n      };\n\n      var {abort, callbacks, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      abort();\n      // this would read 1055790163 from cache if not aborted\n      jest.runAllTimers();\n\n      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');\n      expect(callbacks.onFailure).not.toBeCalled();\n      expect(callbacks.onSuccess).not.toBeCalled();\n    });\n\n    it('does not `onFailure` if aborted', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id,\n          name,\n        }\n      `);\n      var path = new RelayQueryPath(getNode(Relay.QL`\n        query {\n          node(id: \"1055790163\") {id}\n        }\n     `));\n      var dataID = '1055790163';\n      var diskCacheData = {\n        '1055790163': {\n          __dataID__: '1055790163',\n          id: '1055790163',\n          __typename: 'User',\n        },\n      };\n\n      var {abort, callbacks, store} =\n        readDiskCache({dataID, fragment, path, diskCacheData});\n\n      abort();\n      // The read would fail since `name` is missing from cached data.\n      jest.runAllTimers();\n\n      expect(store.getRecordState('1055790163')).toBe('UNKNOWN');\n      expect(callbacks.onFailure).not.toBeCalled();\n      expect(callbacks.onSuccess).not.toBeCalled();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayDiskCacheReader-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/RelayContext-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayContext');\n\nrequire('configureForRelayOSS');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayQueryResultObservable = require('RelayQueryResultObservable');\nconst RelayMutation = require('RelayMutation');\nconst RelayMutationTransaction = require('RelayMutationTransaction');\nconst RelayMutationQueue = require('RelayMutationQueue');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst readRelayQueryData = require('readRelayQueryData');\n\ndescribe('RelayContext', () => {\n  var relayContext;\n  var filter;\n  var dataIDs;\n  var queries;\n  var callback;\n  var recordWriter;\n  var queryRunner;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    relayContext = new RelayContext();\n\n    filter = () => true;\n    dataIDs = ['feedback_id', 'likers_id'];\n    queries = {};\n    callback = jest.genMockFunction();\n    queryRunner = relayContext.getStoreData().getQueryRunner();\n    recordWriter = relayContext.getStoreData().getRecordWriter();\n  });\n\n  describe('primeCache', () => {\n    it('invokes `GraphQLQueryRunner#run`', () => {\n      relayContext.primeCache(queries, callback);\n\n      expect(queryRunner.run).toBeCalled();\n      expect(queryRunner.run.mock.calls[0][0]).toBe(queries);\n      expect(queryRunner.run.mock.calls[0][1]).toBe(callback);\n    });\n  });\n\n  describe('forceFetch', () => {\n    it('invokes `GraphQLQueryRunner#forceFetch`', () => {\n      relayContext.forceFetch(queries, callback);\n\n      expect(queryRunner.forceFetch).toBeCalled();\n      expect(queryRunner.forceFetch.mock.calls[0][0]).toBe(queries);\n      expect(queryRunner.forceFetch.mock.calls[0][1]).toBe(callback);\n    });\n  });\n\n  describe('read', () => {\n    it('invokes `readRelayQueryData`', () => {\n      relayContext.read(queries, dataIDs[0]);\n      expect(readRelayQueryData).toBeCalled();\n      expect(readRelayQueryData.mock.calls[0][1]).toEqual(queries);\n      expect(readRelayQueryData.mock.calls[0][2]).toBe(dataIDs[0]);\n      expect(readRelayQueryData.mock.calls[0][3]).toBeUndefined();\n    });\n\n    it('invokes `readRelayQueryData` with a filter', () => {\n      relayContext.read(queries, dataIDs[0], filter);\n      expect(readRelayQueryData).toBeCalled();\n      expect(readRelayQueryData.mock.calls[0][3]).toBe(filter);\n    });\n  });\n\n  describe('readAll', () => {\n    it('invokes `readRelayQueryData`', () => {\n      relayContext.readAll(queries, dataIDs);\n      expect(readRelayQueryData.mock.calls.length).toBe(dataIDs.length);\n      expect(readRelayQueryData.mock.calls.map(call => call[2])).toEqual(\n        dataIDs\n      );\n    });\n\n    it('invokes `readRelayQueryData` with a filter', () => {\n      relayContext.readAll(queries, dataIDs, filter);\n      expect(readRelayQueryData.mock.calls.length).toBe(dataIDs.length);\n      readRelayQueryData.mock.calls.forEach((call) => {\n        expect(call[3]).toBe(filter);\n      });\n    });\n  });\n\n  describe('readQuery', () => {\n    it('accepts a query with no arguments', () => {\n      recordWriter.putDataID('viewer', null, 'client:1');\n      relayContext.readQuery(getNode(Relay.QL`query{viewer{actor{id}}}`));\n      expect(readRelayQueryData.mock.calls.length).toBe(1);\n      expect(readRelayQueryData.mock.calls[0][2]).toBe('client:1');\n    });\n\n    it('accepts a query with arguments', () => {\n      relayContext.readQuery(getNode(Relay.QL`\n        query {\n          nodes(ids:[\"123\",\"456\"]) {\n            id\n          }\n        }\n      `));\n      expect(readRelayQueryData.mock.calls.length).toBe(2);\n      expect(readRelayQueryData.mock.calls[0][2]).toBe('123');\n      expect(readRelayQueryData.mock.calls[1][2]).toBe('456');\n    });\n\n    it('accepts a query with unrecognized arguments', () => {\n      var result = relayContext.readQuery(getNode(Relay.QL`\n        query {\n          username(name:\"foo\") {\n            id\n          }\n        }\n      `));\n      expect(readRelayQueryData.mock.calls.length).toBe(0);\n      expect(result).toEqual([undefined]);\n    });\n  });\n\n  describe('observe', () => {\n    it('instantiates RelayQueryResultObservable', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id\n        }\n      `);\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(\n        (pointerFragment, dataID) => {\n          expect(pointerFragment).toBe(fragment);\n          expect(dataID).toBe('123');\n          return {\n            __dataID__: '123',\n            id: '123',\n          };\n        }\n      );\n\n      var observer = relayContext.observe(fragment, '123');\n      var onNext = jest.genMockFunction();\n      expect(observer instanceof RelayQueryResultObservable).toBe(true);\n      observer.subscribe({onNext});\n      expect(onNext).toBeCalledWith({\n        __dataID__: '123',\n        id: '123',\n      });\n    });\n  });\n\n  describe('update functions', () => {\n    var mockMutation, createTransactionMock, mockTransaction, mockCallbacks;\n\n    beforeEach(() => {\n      mockTransaction = new RelayMutationTransaction();\n      mockTransaction.commit = jest.genMockFunction();\n      createTransactionMock = jest.genMockFunction();\n      createTransactionMock.mockReturnValue(mockTransaction);\n      RelayMutationQueue.prototype.createTransaction = createTransactionMock;\n      mockMutation = new RelayMutation();\n      mockCallbacks = jest.genMockFunction();\n    });\n\n    describe('applyUpdate', () => {\n      it('creates a new RelayMutationTransaction without committing it', () => {\n        const transaction =\n          relayContext.applyUpdate(mockMutation, mockCallbacks);\n        expect(transaction).toEqual(mockTransaction);\n        expect(createTransactionMock).toBeCalledWith(\n          mockMutation,\n          mockCallbacks\n        );\n        expect(mockTransaction.commit).not.toBeCalled();\n      });\n    });\n\n    describe('commitUpdate', () => {\n      it('creates a new RelayMutationTransaction and commits it', () => {\n        relayContext.commitUpdate(mockMutation, mockCallbacks);\n        expect(createTransactionMock).toBeCalledWith(\n          mockMutation,\n          mockCallbacks\n        );\n        expect(mockTransaction.commit).toBeCalled();\n      });\n    });\n\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","Relay","RelayContext","RelayQueryResultObservable","RelayMutation","RelayMutationTransaction","RelayMutationQueue","RelayTestUtils","readRelayQueryData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\njest.dontMock('RelayContext');\n\nrequire('configureForRelayOSS');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayQueryResultObservable = require('RelayQueryResultObservable');\nconst RelayMutation = require('RelayMutation');\nconst RelayMutationTransaction = require('RelayMutationTransaction');\nconst RelayMutationQueue = require('RelayMutationQueue');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst readRelayQueryData = require('readRelayQueryData');\n\ndescribe('RelayContext', () => {\n  var relayContext;\n  var filter;\n  var dataIDs;\n  var queries;\n  var callback;\n  var recordWriter;\n  var queryRunner;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    relayContext = new RelayContext();\n\n    filter = () => true;\n    dataIDs = ['feedback_id', 'likers_id'];\n    queries = {};\n    callback = jest.genMockFunction();\n    queryRunner = relayContext.getStoreData().getQueryRunner();\n    recordWriter = relayContext.getStoreData().getRecordWriter();\n  });\n\n  describe('primeCache', () => {\n    it('invokes `GraphQLQueryRunner#run`', () => {\n      relayContext.primeCache(queries, callback);\n\n      expect(queryRunner.run).toBeCalled();\n      expect(queryRunner.run.mock.calls[0][0]).toBe(queries);\n      expect(queryRunner.run.mock.calls[0][1]).toBe(callback);\n    });\n  });\n\n  describe('forceFetch', () => {\n    it('invokes `GraphQLQueryRunner#forceFetch`', () => {\n      relayContext.forceFetch(queries, callback);\n\n      expect(queryRunner.forceFetch).toBeCalled();\n      expect(queryRunner.forceFetch.mock.calls[0][0]).toBe(queries);\n      expect(queryRunner.forceFetch.mock.calls[0][1]).toBe(callback);\n    });\n  });\n\n  describe('read', () => {\n    it('invokes `readRelayQueryData`', () => {\n      relayContext.read(queries, dataIDs[0]);\n      expect(readRelayQueryData).toBeCalled();\n      expect(readRelayQueryData.mock.calls[0][1]).toEqual(queries);\n      expect(readRelayQueryData.mock.calls[0][2]).toBe(dataIDs[0]);\n      expect(readRelayQueryData.mock.calls[0][3]).toBeUndefined();\n    });\n\n    it('invokes `readRelayQueryData` with a filter', () => {\n      relayContext.read(queries, dataIDs[0], filter);\n      expect(readRelayQueryData).toBeCalled();\n      expect(readRelayQueryData.mock.calls[0][3]).toBe(filter);\n    });\n  });\n\n  describe('readAll', () => {\n    it('invokes `readRelayQueryData`', () => {\n      relayContext.readAll(queries, dataIDs);\n      expect(readRelayQueryData.mock.calls.length).toBe(dataIDs.length);\n      expect(readRelayQueryData.mock.calls.map(call => call[2])).toEqual(\n        dataIDs\n      );\n    });\n\n    it('invokes `readRelayQueryData` with a filter', () => {\n      relayContext.readAll(queries, dataIDs, filter);\n      expect(readRelayQueryData.mock.calls.length).toBe(dataIDs.length);\n      readRelayQueryData.mock.calls.forEach((call) => {\n        expect(call[3]).toBe(filter);\n      });\n    });\n  });\n\n  describe('readQuery', () => {\n    it('accepts a query with no arguments', () => {\n      recordWriter.putDataID('viewer', null, 'client:1');\n      relayContext.readQuery(getNode(Relay.QL`query{viewer{actor{id}}}`));\n      expect(readRelayQueryData.mock.calls.length).toBe(1);\n      expect(readRelayQueryData.mock.calls[0][2]).toBe('client:1');\n    });\n\n    it('accepts a query with arguments', () => {\n      relayContext.readQuery(getNode(Relay.QL`\n        query {\n          nodes(ids:[\"123\",\"456\"]) {\n            id\n          }\n        }\n      `));\n      expect(readRelayQueryData.mock.calls.length).toBe(2);\n      expect(readRelayQueryData.mock.calls[0][2]).toBe('123');\n      expect(readRelayQueryData.mock.calls[1][2]).toBe('456');\n    });\n\n    it('accepts a query with unrecognized arguments', () => {\n      var result = relayContext.readQuery(getNode(Relay.QL`\n        query {\n          username(name:\"foo\") {\n            id\n          }\n        }\n      `));\n      expect(readRelayQueryData.mock.calls.length).toBe(0);\n      expect(result).toEqual([undefined]);\n    });\n  });\n\n  describe('observe', () => {\n    it('instantiates RelayQueryResultObservable', () => {\n      var fragment = getNode(Relay.QL`\n        fragment on Node {\n          id\n        }\n      `);\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(\n        (pointerFragment, dataID) => {\n          expect(pointerFragment).toBe(fragment);\n          expect(dataID).toBe('123');\n          return {\n            __dataID__: '123',\n            id: '123',\n          };\n        }\n      );\n\n      var observer = relayContext.observe(fragment, '123');\n      var onNext = jest.genMockFunction();\n      expect(observer instanceof RelayQueryResultObservable).toBe(true);\n      observer.subscribe({onNext});\n      expect(onNext).toBeCalledWith({\n        __dataID__: '123',\n        id: '123',\n      });\n    });\n  });\n\n  describe('update functions', () => {\n    var mockMutation, createTransactionMock, mockTransaction, mockCallbacks;\n\n    beforeEach(() => {\n      mockTransaction = new RelayMutationTransaction();\n      mockTransaction.commit = jest.genMockFunction();\n      createTransactionMock = jest.genMockFunction();\n      createTransactionMock.mockReturnValue(mockTransaction);\n      RelayMutationQueue.prototype.createTransaction = createTransactionMock;\n      mockMutation = new RelayMutation();\n      mockCallbacks = jest.genMockFunction();\n    });\n\n    describe('applyUpdate', () => {\n      it('creates a new RelayMutationTransaction without committing it', () => {\n        const transaction =\n          relayContext.applyUpdate(mockMutation, mockCallbacks);\n        expect(transaction).toEqual(mockTransaction);\n        expect(createTransactionMock).toBeCalledWith(\n          mockMutation,\n          mockCallbacks\n        );\n        expect(mockTransaction.commit).not.toBeCalled();\n      });\n    });\n\n    describe('commitUpdate', () => {\n      it('creates a new RelayMutationTransaction and commits it', () => {\n        relayContext.commitUpdate(mockMutation, mockCallbacks);\n        expect(createTransactionMock).toBeCalledWith(\n          mockMutation,\n          mockCallbacks\n        );\n        expect(mockTransaction.commit).toBeCalled();\n      });\n    });\n\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/RelayContext-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/readRelayQueryData-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst callsToGraphQL = require('callsToGraphQL');\nconst readRelayQueryData = require('readRelayQueryData');\n\ndescribe('readRelayQueryData', () => {\n  let RelayRecordStore;\n\n  const {getNode, getVerbatimNode} = RelayTestUtils;\n  let END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO, START_CURSOR;\n\n  function getStoreData(records) {\n    const recordStore = new RelayRecordStore(records);\n    const storeData = new RelayStoreData();\n\n    storeData.getQueuedStore = jest.genMockFunction().mockImplementation(() => {\n      return recordStore;\n    });\n\n    return storeData;\n  }\n\n  function readData(storeData, queryNode, dataID, options) {\n    return readRelayQueryData(\n      storeData,\n      queryNode,\n      dataID,\n      options\n    ).data;\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n\n    ({\n      END_CURSOR,\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n      START_CURSOR,\n    } = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns undefined for data that is not in the store', () => {\n    const records = {};\n    const query = getNode(Relay.QL`fragment on Actor{id}`);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toBe(undefined);\n  });\n\n  it('returns null for data that is null in the store', () => {\n    const records = {1055790163: null};\n    const query = getNode(Relay.QL`fragment on Actor{id}`);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toBe(null);\n  });\n\n  it('retrieves data that is in the store', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const query = getNode(Relay.QL`query{viewer{actor{firstName}}}`);\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data).toEqual({\n      __dataID__: 'client:1',\n      actor: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    });\n  });\n\n  it('returns the ids for all read data', () => {\n    const records = {\n      address: null,\n      date: {day: 21},\n      hometown: {name: 'Vancouver'},\n      node: {\n        name: 'Chris',\n        birthdate: {__dataID__: 'date'},\n        address: {__dataID__: 'address'},\n        hometown: {__dataID__: 'hometown'},\n      },\n    };\n    const hometownFragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on Page {name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`\n      fragment on User {\n        address {city}\n        birthdate {day}\n        hometown {${hometownFragmentReference}}\n      }\n    `);\n    const {dataIDs} = readRelayQueryData(\n      getStoreData({records}),\n      query,\n      'node'\n    );\n    expect(dataIDs).toEqual({\n      address: true,\n      date: true,\n      hometown: true,\n      node: true,\n    });\n  });\n\n  it('retrieves data that references null nodes in the store', () => {\n    const records = {\n      1055790163: {\n        address: {__dataID__: 'client:1'},\n        firstName: 'Yuzhi',\n      },\n      'client:1': null,\n    };\n    const query = getNode(Relay.QL`\n      fragment on Actor {\n        address {\n          city,\n        },\n        firstName,\n      }\n    `);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toEqual({\n      __dataID__: '1055790163',\n      address: null,\n      firstName: 'Yuzhi',\n    });\n  });\n\n  it('includes `null` scalar values along with existing sibling fields', () => {\n    let records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        doesViewerLike: null,\n        id: 'feedbackID',\n      },\n    };\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        id,\n        doesViewerLike,\n      }\n    `);\n    let data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data.id).toBe('feedbackID');\n    expect(data.doesViewerLike).toBeNull();\n\n    records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        id: 'feedbackID',\n      },\n    };\n    data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data.id).toBe('feedbackID');\n    expect(data.doesViewerLike).toBeUndefined();\n    expect('doesViewerLike' in data).toBe(false);\n  });\n\n  it('retrieves empty plural fields', () => {\n    const records = {\n      user_id: {\n        id: 'user_id',\n        websites: [],\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{id,websites}`);\n    const data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.websites).toEqual([]);\n  });\n\n  it('retrieves plural fields', () => {\n    const websites = ['website1', 'website2'];\n\n    const records = {\n      user_id: {\n        id: 'user_id',\n        websites,\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{id,websites}`);\n    const data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.websites).toEqual(\n      ['website1', 'website2']\n    );\n  });\n\n  it('retrieves status information for nodes with queued changes', () => {\n    const STATUS = RelayRecordStatusMap.setOptimisticStatus(\n      RelayRecordStatusMap.setErrorStatus(0, true),\n      0\n    );\n    const records = {\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const queuedRecords = {\n      660361306: {\n        __dataID__: '660361306',\n        __status__: STATUS,\n        firstName: 'Snoop Lion',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{firstName}`);\n    const storeData = getStoreData({records, queuedRecords});\n    const data = readData(storeData, query, '660361306');\n    expect(data).toEqual({\n      __dataID__: '660361306',\n      __status__: STATUS,\n      firstName: 'Snoop Lion',\n    });\n  });\n\n  it('retrieves resolved fragment map generation information', () => {\n    const records = {\n      'a': {\n        __dataID__: 'a',\n        __resolvedFragmentMapGeneration__: 42,\n        firstName: 'Steve',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{firstName}`);\n    const data = readData(getStoreData({records}), query, 'a');\n    expect(data).toEqual({\n      __dataID__: 'a',\n      __resolvedFragmentMapGeneration__: 42,\n      firstName: 'Steve',\n    });\n  });\n\n  it('retrieves resolved fragment map info for fragment references', () => {\n    const records = {\n      user: {\n        __dataID__: 'a',\n        address: {\n          __dataID__: 'address',\n        },\n      },\n      address: {\n        __dataID__: 'address',\n        __resolvedFragmentMapGeneration__: 42,\n        city: 'Menlo Park',\n      },\n    };\n    const fragment = Relay.QL`fragment on StreetAddress { city }`;\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => fragment,\n      {}\n    );\n    const query = getVerbatimNode(Relay.QL`\n      fragment on User {\n        address {\n          ${fragmentReference}\n        }\n      }\n    `);\n    const data = readData(getStoreData({records}), query, 'user');\n    expect(data).toEqual({\n      __dataID__: 'user',\n      address: {\n        __dataID__: 'address',\n        __fragments__: {\n          [fragment.id]: 'address',\n        },\n        __resolvedFragmentMapGeneration__: 42,\n      },\n    });\n  });\n\n  it('populates data ID for nodes containing only non-local fragments', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const fragment = Relay.QL`fragment on Viewer{actor{firstName}}`;\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => fragment,\n      {}\n    );\n    const query = getNode(Relay.QL`query{viewer{${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data.__dataID__).toBe('client:1');\n    expect(data.__fragments__).toEqual({\n      [getNode(fragment).getConcreteFragmentID()]: 'client:1',\n    });\n  });\n\n  it('reads data for non-container fragment references', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const fragmentReference = new RelayFragmentReference(\n      () => Relay.QL`fragment on Viewer{actor{firstName}}`,\n      {}\n    );\n    const query = getNode(Relay.QL`query{viewer{${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data).toEqual({\n      __dataID__: 'client:1',\n      actor: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    });\n  });\n\n  it('merges data from multiple fragments that reference the same node', () => {\n    const records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        address: {__dataID__: 'client:1'},\n        last_name: 'Zheng',\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        city: 'San Francisco',\n        country: 'US',\n      },\n    };\n\n    const fragment1 = Relay.QL`fragment on Actor{address{city}}`;\n    const fragment2 = Relay.QL`fragment on Actor{address{country}}`;\n    const query = getNode(Relay.QL`  fragment on Actor {\n            ${fragment1},\n            ${fragment2},\n          }`);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toEqual({\n      __dataID__: '1055790163',\n      address: {\n        __dataID__: 'client:1',\n        city: 'San Francisco',\n        country: 'US',\n      },\n    });\n  });\n\n  it('retrieves non-edge fields from filtered connections', () => {\n    const records = {\n      'client:123': {\n        id: 'client:123',\n        count: 42,\n        __dataID__: 'client:123',\n        __range__: new GraphQLRange(),\n      },\n    };\n    const query = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        count\n      }\n    `);\n    const storeData = getStoreData({records});\n    const rangeID = storeData.getRangeData().getClientIDForRangeWithID(\n      callsToGraphQL([\n        {name: 'is_viewer_friend', value: null},\n        {name: 'first', value: 10},\n      ]),\n      {},\n      'client:123'\n    );\n    expect(rangeID).toBe('client:123_is_viewer_friend(),first(10)');\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: false,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n    const data = readData(storeData, query, rangeID);\n    expect(data).toEqual({\n      __dataID__: rangeID,\n      count: 42,\n    });\n  });\n\n  it('retrieves non-edge fields from a connection', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        count: 31337,\n      },\n    };\n    const query = getNode(Relay.QL`fragment on Feedback{likers{count}}`);\n    const data = readData(getStoreData({records}), query, 'feedback_id');\n    expect(data).toEqual({\n      __dataID__: 'feedback_id',\n      likers: {\n        __dataID__: 'likers_id',\n        count: 31337,\n      },\n    });\n  });\n\n  it('retrieves non-\"range\" fields within a connection', () => {\n    // This is a silly query (we don't need the `first(1)` call here) but was\n    // seen in the wild and should be handled gracefully.\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        topLevelComments(first:\"1\") {\n          count,\n        },\n      }\n    `);\n\n    const records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        topLevelComments: {\n          __dataID__: 'commentsID',\n        },\n      },\n      commentsID: {\n        __dataID__: 'commentsID',\n        __range__: new GraphQLRange(),\n        count: 57,\n      },\n    };\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    const data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data).toEqual({\n      __dataID__: 'feedbackID',\n      topLevelComments: {\n        __dataID__: 'commentsID_first(1)',\n        count: 57,\n      },\n    });\n  });\n\n  it('retrieves a mixture of \"range\" and non-\"range\" connection fields', () => {\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        topLevelComments(first:\"1\") {\n          count,\n          pageInfo {\n            hasNextPage,\n          },\n        },\n      }`\n    );\n\n    const records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        topLevelComments: {\n          __dataID__: 'commentsID',\n        },\n      },\n      commentsID: {\n        __dataID__: 'commentsID',\n        __range__: new GraphQLRange(),\n        count: 57,\n      },\n    };\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    const data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data).toEqual({\n      __dataID__: 'feedbackID',\n      topLevelComments: {\n        __dataID__: 'commentsID_first(1)',\n        count: 57,\n        [PAGE_INFO]: {\n          [HAS_NEXT_PAGE]: true,\n        },\n      },\n    });\n  });\n\n  it('requires filter calls on connections with range fields', () => {\n    const records = {\n      story_id: {\n        __dataID__: 'story_id',\n        feedback: {\n          __dataID__: 'feedback_id',\n        },\n      },\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        __range__: new GraphQLRange(),\n        count: 31337,\n      },\n    };\n    const error =\n      'readRelayQueryData(): The field `likers` is a connection. ' +\n      'Fields `edges` and `pageInfo` cannot be fetched without a ' +\n      '`first`, `last` or `find` argument.';\n\n    // Use fragment because all inline violations are caugh at transform time.\n    const edgesFragment = Relay.QL`\n      fragment on LikersOfContentConnection {\n        edges {\n          node {\n            name,\n          },\n        },\n      }\n    `;\n    let query = getNode(Relay.QL`\n      fragment on Story {\n        feedback {\n          likers {\n            ${edgesFragment}\n          },\n        },\n      }\n    `);\n    expect(\n      () => readData(getStoreData({records}), query, 'story_id')\n    ).toThrowError(error);\n\n    // Note that `pageInfo` also triggers the error...\n    const pageInfoFragment = Relay.QL`\n      fragment on LikersOfContentConnection {\n        pageInfo {\n          hasNextPage,\n        },\n      }\n    `;\n    query = getNode(Relay.QL`\n      fragment on Story {\n        feedback {\n          likers {\n            ${pageInfoFragment}\n          },\n        },\n      },\n    `);\n    expect(\n      () => readData(getStoreData({records}), query, 'story_id')\n    ).toThrowError(error);\n\n    // ...but not `count`:\n    query = getNode(Relay.QL`fragment on Story{feedback{likers{count}}}`);\n    expect(\n      () => readData(getStoreData({records}), query, 'story_id')\n    ).not.toThrowError();\n  });\n\n  it('requires filter calls on connections with filtered range fields ', () => {\n    const records = {\n      story_id: {\n        __dataID__: 'story_id',\n        feedback: {\n          __dataID__: 'feedback_id',\n        },\n      },\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        __range__: new GraphQLRange(),\n        count: 31337,\n      },\n    };\n    const error =\n      'readRelayQueryData(): The field `likers` is a connection. ' +\n      'Fields `edges` and `pageInfo` cannot be fetched without a ' +\n      '`first`, `last` or `find` argument.';\n\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on LikersOfContentConnection{edges{node{name}}}`,\n      {}\n    );\n    let query = getNode(Relay.QL`\n      fragment on Story{feedback{likers{${fragmentReference}}}}\n    `);\n    expect(() => readData(getStoreData({records}), query, 'story_id'))\n      .toThrowError(error);\n\n    let fragment = Relay.QL`fragment on LikersOfContentConnection{pageInfo}`;\n    query = getNode(Relay.QL`fragment on Story{feedback{likers{${fragment}}}}`);\n    expect(() => readData(getStoreData({records}), query, 'story_id'))\n      .toThrowError(error);\n\n    fragment = Relay.QL`fragment on LikersOfContentConnection{count}`;\n    query = getNode(Relay.QL`fragment on Story{feedback{likers{${fragment}}}}`);\n    expect(() => readData(getStoreData({records}), query, 'story_id'))\n      .not.toThrowError();\n  });\n\n  it('reads `edge`/`pageInfo` without range info like linked records', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        edges: [\n          {\n            __dataID__: 'likers_edge_id',\n          },\n        ],\n        [PAGE_INFO]: {\n          __dataID__: 'likers_page_info_id',\n        },\n      },\n      likers_edge_id: {\n        __dataID__: 'likers_edge_id',\n        node: {\n          __dataID__: 'liker_id',\n        },\n      },\n      likers_page_info_id: {\n        __dataID__: 'likers_page_info_id',\n        [HAS_NEXT_PAGE]: true,\n      },\n      liker_id: {\n        __dataID__: 'liker_id',\n        name: 'Tim',\n      },\n    };\n\n    let query = getNode(Relay.QL`\n      fragment on Feedback{likers(first:\"1\"){edges{node{name}}}}\n    `);\n    let data = readData(getStoreData({records}), query, 'feedback_id');\n    expect(data).toEqual({\n      __dataID__: 'feedback_id',\n      likers: {\n        __dataID__: 'likers_id_first(1)',\n        edges: [\n          {\n            __dataID__: 'likers_edge_id',\n            node: {\n              __dataID__: 'liker_id',\n              name: 'Tim',\n            },\n          },\n        ],\n      },\n    });\n\n    query = getNode(Relay.QL`\n      fragment on Feedback{likers(first:\"1\"){pageInfo{hasNextPage}}}\n    `);\n    data = readData(getStoreData({records}), query, 'feedback_id');\n    expect(data).toEqual({\n      __dataID__: 'feedback_id',\n      likers: {\n        __dataID__: 'likers_id_first(1)',\n        [PAGE_INFO]: {\n          __dataID__: 'likers_page_info_id',\n          [HAS_NEXT_PAGE]: true,\n        },\n      },\n    });\n  });\n\n  it('recurses through fragments when retrieving pageInfo', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        comments: {\n          __dataID__: 'comments_id',\n        },\n      },\n      comments_id: {\n        __dataID__: 'comments_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on PageInfo{hasNextPage}`,\n      {}\n    );\n    const query = getNode(Relay.QL`  fragment on Feedback{\n            comments(first:\"1\") {\n              pageInfo {\n                startCursor,\n                ${fragmentReference},\n              },\n            }\n          }`);\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    let data = readData(\n      getStoreData({records}),\n      query,\n      'feedback_id',\n      {traverseFragmentReferences: true}\n    );\n\n    expect(data.comments).toEqual({\n      __dataID__: 'comments_id_first(1)',\n      [PAGE_INFO]: {\n        [START_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n      },\n    });\n\n    data = readData(getStoreData({records}), query, 'feedback_id');\n\n    const fragmentSourceID =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(data.comments.pageInfo.__fragments__).toEqual({\n      [fragmentSourceID]: 'comments_id_first(1)',\n    });\n  });\n\n  it('retrieves data and fragment pointers from range', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        comments: {\n          __dataID__: 'comments_id',\n        },\n      },\n      comments_id: {\n        __dataID__: 'comments_id',\n        __range__: new GraphQLRange(),\n      },\n      comment_node_id: {\n        __dataID__: 'comment_node_id',\n        id: 'comment_node_id',\n      },\n      comment_edge_id: {\n        __dataID__: 'comment_edge_id',\n        node: {__dataID__: 'comment_node_id'},\n        cursor: 'cursor',\n      },\n    };\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on CommentsConnection{edges{node{id}}}`,\n      {}\n    );\n    const query = getNode(Relay.QL`  fragment on Feedback{\n            comments(first:\"1\") {\n              edges {\n                node {\n                  id\n                },\n              },\n              pageInfo {\n                startCursor\n              },\n              ${fragmentReference}\n            }\n          }`);\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    let data = readData(\n      getStoreData({records}),\n      query,\n      'feedback_id',\n      {traverseFragmentReferences: true}\n    );\n\n    expect(data.comments).toEqual({\n      __dataID__: 'comments_id_first(1)',\n      edges: [{\n        __dataID__: 'comment_edge_id',\n        node: {\n          __dataID__: 'comment_node_id',\n          id: 'comment_node_id',\n        },\n      }],\n      [PAGE_INFO]: {\n        [START_CURSOR]: 'cursor',\n      },\n    });\n\n    data = readData(getStoreData({records}), query, 'feedback_id');\n\n    const fragmentSourceID =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(data.comments.__fragments__).toEqual({\n      [fragmentSourceID]: 'comments_id_first(1)',\n    });\n  });\n\n  it('returns RelayFragmentPointers for child queries', () => {\n    const records = {\n      user_id: {\n        __dataID__: 'user_id',\n        id: 'user_id',\n        screennames: [\n          {__dataID__: 'client1'},\n          {__dataID__: 'client2'},\n        ],\n        hometown: {__dataID__: 'hometown_id'},\n      },\n      hometown_id: {\n        __dataID__: 'hometown_id',\n        id: 'hometown_id',\n        name: 'hometown name',\n      },\n      client1: {\n        __dataID__: 'client1',\n        service: 'GTALK',\n        name: '123',\n      },\n      client2: {\n        __dataID__: 'client1',\n        service: 'TWITTER',\n        name: '123',\n      },\n    };\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on Screenname {service, name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`\n      fragment on User {\n        id,\n        hometown {\n          name,\n        },\n        screennames {\n          ${fragmentReference},\n        },\n      }\n    `);\n\n    // Mark top fragment as local, and child fragment as non-local.\n    const data = readData(getStoreData({records}), query, 'user_id');\n\n    expect(data.id).toBe('user_id');\n    expect(data.hometown.name).toEqual('hometown name');\n    expect(data.screennames.length).toBe(2);\n    const screennames = data.screennames;\n    const fragmentSourceID0 =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(screennames[0].__fragments__).toEqual({\n      [fragmentSourceID0]: 'client1',\n    });\n    const fragmentSourceID1 =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(screennames[1].__fragments__).toEqual({\n      [fragmentSourceID1]: 'client2',\n    });\n  });\n\n  it('reads dataID if a linked dataID is `null` or `undefined`', () => {\n    const query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            name\n          },\n        }\n      }\n    `);\n    let records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: null,\n      },\n    };\n    let data = readData(getStoreData({records}), query, 'client:1');\n    expect(data.actor).toBeNull();\n\n    records = {\n      'client:1': {\n        __dataID__: 'client:1',\n      },\n    };\n    data = readData(getStoreData({records}), query, 'client:1');\n    expect(data.actor).toBeUndefined();\n  });\n\n  it('does not clobber previously-read sibling fields when a linked dataID is `null` or `undefined`', () => {\n    const query = getNode(Relay.QL`\n      fragment on User {\n        id,\n        address {\n          city,\n        },\n      }\n    `);\n    let records = {\n      user_id: {\n        __dataID__: 'user_id',\n        id: 'user_id',\n        address: null,\n      },\n    };\n    let data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.address).toBeNull();\n    expect(data.id).toBe('user_id');\n\n    records = {\n      user_id: {\n        __dataID__: 'user_id',\n        id: 'user_id',\n      },\n    };\n    data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.address).toBeUndefined();\n    expect(data.id).toBe('user_id');\n  });\n\n  it('does not set undefined value if linked dataID missing', () => {\n    const query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            name,\n          },\n        }\n      }\n    `);\n\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n      },\n    };\n\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data).toEqual({__dataID__: 'client:1'});\n\n    // Extra assertion because `toEqual` matcher skips over properties with\n    // undefined values...\n    expect('actor' in data).toBe(false);\n  });\n\n  it('allocates linked fields even if all child fields are null', () => {\n    const query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          birthdate {\n            year,\n          },\n        }\n      }\n    `);\n    const records = {\n      '123': {\n        __dataID__: '123',\n        birthdate: {\n          __dataID__: 'client:1',\n        },\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        year: null,\n      },\n    };\n    const data = readData(getStoreData({records}), query, '123');\n\n    expect(data.birthdate).not.toBeNull();\n    expect(data.birthdate.year).toBeNull();\n  });\n\n  it('reads fields for connections without calls', () => {\n    const query = getNode(Relay.QL`\n      fragment on User {\n        friends {\n          count,\n        },\n      }\n    `);\n    let records = {\n      'user_id': {\n        __dataID__: 'user_id',\n        friends: {\n          __dataID__: 'client:1',\n        },\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        count: 42,\n      },\n    };\n    let data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.friends.count).toBe(42);\n\n    // Now imagine another query (say, a deferred query) has populated the store\n    // with range info for this connection.\n    records = {\n      'user_id': {\n        __dataID__: 'user_id',\n        friends: {\n          __dataID__: 'client:1',\n        },\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: new GraphQLRange(),\n        count: 42,\n      },\n    };\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edgeID'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n    data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.friends.count).toBe(42);\n  });\n\n  it('handles \"empty\" ref query dependencies', () => {\n    // People normally won't write queries like this by hand, but they can be\n    // produced as the result of splitting deferred queries.\n    //\n    // The `feedback` field here only has a generated `id`, so is \"empty\".\n    let query = getNode(Relay.QL`\n      fragment on Story {\n        id,\n        feedback\n      }\n    `);\n\n    // Mark the `id` field in `feedback{id}` as a ref query dependency.\n    query = query.clone(\n      query.getChildren().map((outerChild, ii) => {\n        if (ii === 1) {\n          return outerChild.clone(\n            outerChild.getChildren().map((innerChild, jj) => {\n              if (jj === 0) {\n                return innerChild.cloneAsRefQueryDependency();\n              } else {\n                return innerChild;\n              }\n            })\n          );\n        } else {\n          return outerChild;\n        }\n      })\n    );\n\n    const records = {\n      storyID: {\n        __dataID__: 'storyID',\n        id: 'storyID',\n        feedback: {\n          __dataID__: 'feedbackID',\n        },\n      },\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        id: 'feedbackID',\n      },\n    };\n    const data = readData(getStoreData({records}), query, 'storyID');\n    expect(data).toEqual({\n      __dataID__: 'storyID',\n      id: 'storyID',\n      feedback: {\n        __dataID__: 'feedbackID',\n      },\n    });\n  });\n\n  it('parses range client IDs', () => {\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`\n        fragment on FriendsConnection {\n          edges {\n            node {\n              address {\n                city,\n                country\n              }\n            },\n          },\n        }\n      `,\n      {}\n    );\n    const query = getNode(Relay.QL`\n      fragment on User {\n        friends(first:\"25\") {\n          ${fragmentReference},\n        },\n      }\n    `);\n\n    const records = {\n      userID: {\n        __dataID__: 'userID',\n        friends: {\n          __dataID__: 'friendsID',\n        },\n      },\n      friendsID: {\n        __dataID__: 'friendsID',\n        __range__: new GraphQLRange(),\n      },\n      edgeID: {\n        __dataID__: 'edgeID',\n        node: {\n          __dataID__: 'friendID',\n        },\n        cursor: 'cursor',\n      },\n      friendID: {\n        __dataID__: 'friendID',\n        address: {\n          __dataID__: 'addressID',\n        },\n      },\n      addressID: {\n        __dataID__: 'addressID',\n        city: 'Menlo Park',\n        country: 'USA',\n      },\n    };\n    const storeData = getStoreData({records});\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edgeID'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: false,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    // First we read the outer fragment, which populates the\n    // GraphQLStoreRangeUtils rangeData cache.\n    // (TODO: task to fix that hidden global state: #7250441)\n    let data = readData(storeData, query, 'userID');\n    const fragmentSourceID =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(data).toEqual({\n      __dataID__: 'userID',\n      friends: {\n        __dataID__: 'friendsID_first(25)',\n        __fragments__: {\n          [fragmentSourceID]: 'friendsID_first(25)',\n        },\n      },\n    });\n\n    // Now we read the inner (non-local) fragment, using the range client ID.\n    data = readData(\n      storeData,\n      getNode(fragmentReference.getFragment()),\n      'friendsID_first(25)'\n    );\n    expect(data).toEqual({\n      __dataID__: 'friendsID_first(25)',\n      edges: [\n        {\n          __dataID__: 'edgeID',\n          node: {\n            __dataID__: 'friendID',\n            address: {\n              __dataID__: 'addressID',\n              city: 'Menlo Park',\n              country: 'USA',\n            },\n          },\n        },\n      ],\n    });\n  });\n\n  it('can be configured to read generated fields (scalar case)', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        __typename: 'User',\n        firstName: 'Greg',\n        id: '660361306',\n      },\n    };\n    const query = getNode(Relay.QL`query{viewer{actor{firstName}}}`);\n    const data = readData(\n      getStoreData({records}),\n      query,\n      'client:1',\n      {traverseGeneratedFields: true}\n    );\n    expect(data).toEqual({\n      __dataID__: 'client:1',\n      actor: {\n        __dataID__: '660361306',\n        __typename: 'User',\n        firstName: 'Greg',\n        id: '660361306',\n      },\n    });\n  });\n\n  it('can be configured to read generated fields (page info case)', () => {\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        topLevelComments(first:\"1\") {\n          pageInfo {\n            hasNextPage,\n          },\n        },\n      }`\n    );\n\n    const records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        topLevelComments: {\n          __dataID__: 'commentsID',\n        },\n      },\n      commentsID: {\n        __dataID__: 'commentsID',\n        __range__: new GraphQLRange(),\n        count: 57,\n      },\n    };\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    const data = readData(\n      getStoreData({records}),\n      query,\n      'feedbackID',\n      {traverseGeneratedFields: true}\n    );\n    expect(data).toEqual({\n      __dataID__: 'feedbackID',\n      topLevelComments: {\n        __dataID__: 'commentsID_first(1)',\n        [PAGE_INFO]: {\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n        },\n      },\n    });\n  });\n\n  it('does not attempt to traverse missing data IDs', () => {\n    const records = {};\n\n    // If we did traverse, this fragment reference would lead us to create an\n    // object with a __dataID__ instead of the desired `undefined`.\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on User{name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`query{node(id:\"4\"){${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, '4');\n    expect(data).toBe(undefined);\n  });\n\n  it('does not attempt to traverse non-existent data IDs', () => {\n    const records = {4: null};\n\n    // If we did traverse, this fragment reference would lead us to create an\n    // object with a __dataID__ instead of the desired `null`.\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on User{name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`query{node(id:\"4\"){${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, '4');\n    expect(data).toBe(null);\n  });\n\n  it('reads data for matching fragments', () => {\n    const records = {\n      123: {\n        __dataID__: '123',\n        id: '123',\n        __typename: 'User',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User { id }`);\n    const data = readData(getStoreData({records}), query, '123');\n    expect(data).toEqual({\n      __dataID__: '123',\n      id: '123',\n    });\n  });\n\n  it('returns undefined for non-matching fragments', () => {\n    const records = {\n      123: {\n        __dataID__: '123',\n        id: '123',\n        __typename: 'User',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on Page { id }`);\n    const data = readData(getStoreData({records}), query, '123');\n    expect(data).toEqual(undefined);\n  });\n\n  it('skips non-matching child fragments', () => {\n    const records = {\n      123: {\n        __dataID__: '123',\n        id: '123',\n        __typename: 'User',\n        name: 'Greg',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on Actor {\n      ... on User {\n        name\n      }\n      ... on Page {\n        id\n      }\n    }`);\n    const data = readData(getStoreData({records}), query, '123');\n    expect(data).toEqual({\n      __dataID__: '123',\n      name: 'Greg',\n    });\n  });\n\n  // TODO: Fix these tests, #10252182.\n\n  // describe('readRelayQueryData-partialStatus', () => {\n  //   it('marks nodes with missing scalar field as partial', () => {\n  //     const records = {\n  //       feedbackID: {\n  //         __dataID__: 'feedbackID',\n  //         id: 'feedbackID',\n  //       },\n  //     };\n  //     // Missing `doesViewerLike` in store\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         id,\n  //         doesViewerLike,\n  //       }\n  //     `);\n\n  //     const data = readData(getStoreData({records}), query, 'feedbackID');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nested nodes with missing field as partial', () => {\n  //     const records = {\n  //       feedbackID: {\n  //         __dataID__: 'feedbackID',\n  //         id: 'feedbackID',\n  //         comments: {__dataID__: 'client:1'},\n  //       },\n  //       'client:1': {\n  //         __dataID__:'client:1',\n  //       },\n  //     };\n  //     // Missing `comments {count}` in store\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         id,\n  //         comments {count}\n  //       }\n  //     `);\n\n  //     const data = readData(getStoreData({records}), query, 'feedbackID');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.comments.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing linked nodes as partial', () => {\n  //     const records = {\n  //       'client:1': {\n  //         __dataID__: 'client:1',\n  //         actor: {\n  //           __dataID__: '660361306',\n  //         },\n  //       },\n  //     };\n  //     // Missing the actor node.\n  //     const query = getNode(Relay.QL`query{viewer{actor{firstName}}}`);\n  //     const data = readData(getStoreData({records}), query, 'client:1');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing plural linked nodes as partial', () => {\n  //     const records = {\n  //       '660361306': {\n  //         __dataID__: '660361306',\n  //         allPhones: [{__dataID__: 'client:1'}, {__dataID__: 'client:1'}],\n  //       },\n  //       'client:1': {\n  //         __dataID__: 'client:1',\n  //       },\n  //       'client:2': {\n  //         __dataID__: 'client:2',\n  //         isVerified: true,\n  //       },\n  //     };\n  //     // Missing the `isVerified` in the first element.\n  //     const query = getNode(Relay.QL`\n  //       fragment on User {\n  //         allPhones {\n  //           isVerified,\n  //         },\n  //       }\n  //     `);\n  //     const data = readData(getStoreData({records}), query, '660361306');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     const firstPhone = data.allPhones[0];\n  //     expect(RelayRecordStatusMap.isPartialStatus(firstPhone.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing edges as partial', () => {\n  //     const records = {\n  //       feedback_id: {\n  //         __dataID__: 'feedback_id',\n  //         comments: {\n  //           __dataID__: 'comments_id',\n  //         },\n  //       },\n  //       comments_id: {\n  //         __dataID__: 'comments_id',\n  //         __range__: new GraphQLRange(),\n  //       },\n  //       comment_node_id: {\n  //         __dataID__: 'comment_node_id',\n  //         id: 'comment_node_id',\n  //       },\n  //       comment_edge_id: {\n  //         __dataID__: 'comment_edge_id',\n  //         node: {__dataID__: 'comment_node_id'},\n  //         cursor: 'cursor',\n  //       },\n  //     };\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         comments(first:\"5\") {\n  //           edges {\n  //             node {\n  //               id\n  //             },\n  //           },\n  //           pageInfo {\n  //             startCursor\n  //           },\n  //         },\n  //       },\n  //     `);\n\n  //     // Missing edges due to non-empty diffCalls.\n  //     GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n  //       requestedEdgeIDs: ['comment_edge_id'],\n  //       diffCalls: [RelayTestUtils.createCall('first', 4)],\n  //       pageInfo: {\n  //         [START_CURSOR]: 'cursor',\n  //         [END_CURSOR]: 'cursor',\n  //         [HAS_NEXT_PAGE]: true,\n  //         [HAS_PREV_PAGE]: false,\n  //       },\n  //     });\n\n  //     const data = readData(\n  //       getStoreData({records}),\n  //       query,\n  //       'feedback_id',\n  //       {traverseFragmentReferences: true}\n  //     );\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     const comments = data[comments];\n  //     expect(RelayRecordStatusMap.isPartialStatus(comments.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing edge data as partial', () => {\n  //     const records = {\n  //       feedback_id: {\n  //         __dataID__: 'feedback_id',\n  //         comments: {\n  //           __dataID__: 'comments_id',\n  //         },\n  //       },\n  //       comments_id: {\n  //         __dataID__: 'comments_id',\n  //         __range__: new GraphQLRange(),\n  //       },\n  //       comment_node_id: {\n  //         __dataID__: 'comment_node_id',\n  //         id: 'comment_node_id',\n  //       },\n  //       comment_edge_id: {\n  //         __dataID__: 'comment_edge_id',\n  //         node: {__dataID__: 'comment_node_id'},\n  //         cursor: 'cursor',\n  //       },\n  //     };\n  //     // Missing `body{text}` on the comment\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         comments(first:\"1\") {\n  //           edges {\n  //             node {\n  //               id,\n  //               body {text}\n  //             },\n  //           },\n  //           pageInfo {\n  //             startCursor\n  //           }\n  //         }\n  //       }\n  //     `);\n\n  //     GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n  //       requestedEdgeIDs: ['comment_edge_id'],\n  //       diffCalls: [],\n  //       pageInfo: {\n  //         [START_CURSOR]: 'cursor',\n  //         [END_CURSOR]: 'cursor',\n  //         [HAS_NEXT_PAGE]: true,\n  //         [HAS_PREV_PAGE]: false,\n  //       },\n  //     });\n\n  //     const data = readData(\n  //       getStoreData({records}),\n  //       query,\n  //       'feedback_id',\n  //       {traverseFragmentReferences: true}\n  //     );\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     const comments = data[comments];\n  //     expect(RelayRecordStatusMap.isPartialStatus(comments.__status__))\n  //       .toBe(true);\n  //     const comment = comments.edges[0].node;\n  //     expect(RelayRecordStatusMap.isPartialStatus(comment.__status__))\n  //       .toBe(true);\n  //   });\n  // });\n});\n","dependencies":["configureForRelayOSS","GraphQLRange","Relay","RelayConnectionInterface","RelayFragmentReference","RelayStoreData","RelayRecordStatusMap","RelayTestUtils","callsToGraphQL","readRelayQueryData","RelayRecordStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLRange = require('GraphQLRange');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst callsToGraphQL = require('callsToGraphQL');\nconst readRelayQueryData = require('readRelayQueryData');\n\ndescribe('readRelayQueryData', () => {\n  let RelayRecordStore;\n\n  const {getNode, getVerbatimNode} = RelayTestUtils;\n  let END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO, START_CURSOR;\n\n  function getStoreData(records) {\n    const recordStore = new RelayRecordStore(records);\n    const storeData = new RelayStoreData();\n\n    storeData.getQueuedStore = jest.genMockFunction().mockImplementation(() => {\n      return recordStore;\n    });\n\n    return storeData;\n  }\n\n  function readData(storeData, queryNode, dataID, options) {\n    return readRelayQueryData(\n      storeData,\n      queryNode,\n      dataID,\n      options\n    ).data;\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayRecordStore = require('RelayRecordStore');\n\n    ({\n      END_CURSOR,\n      HAS_NEXT_PAGE,\n      HAS_PREV_PAGE,\n      PAGE_INFO,\n      START_CURSOR,\n    } = RelayConnectionInterface);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns undefined for data that is not in the store', () => {\n    const records = {};\n    const query = getNode(Relay.QL`fragment on Actor{id}`);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toBe(undefined);\n  });\n\n  it('returns null for data that is null in the store', () => {\n    const records = {1055790163: null};\n    const query = getNode(Relay.QL`fragment on Actor{id}`);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toBe(null);\n  });\n\n  it('retrieves data that is in the store', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const query = getNode(Relay.QL`query{viewer{actor{firstName}}}`);\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data).toEqual({\n      __dataID__: 'client:1',\n      actor: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    });\n  });\n\n  it('returns the ids for all read data', () => {\n    const records = {\n      address: null,\n      date: {day: 21},\n      hometown: {name: 'Vancouver'},\n      node: {\n        name: 'Chris',\n        birthdate: {__dataID__: 'date'},\n        address: {__dataID__: 'address'},\n        hometown: {__dataID__: 'hometown'},\n      },\n    };\n    const hometownFragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on Page {name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`\n      fragment on User {\n        address {city}\n        birthdate {day}\n        hometown {${hometownFragmentReference}}\n      }\n    `);\n    const {dataIDs} = readRelayQueryData(\n      getStoreData({records}),\n      query,\n      'node'\n    );\n    expect(dataIDs).toEqual({\n      address: true,\n      date: true,\n      hometown: true,\n      node: true,\n    });\n  });\n\n  it('retrieves data that references null nodes in the store', () => {\n    const records = {\n      1055790163: {\n        address: {__dataID__: 'client:1'},\n        firstName: 'Yuzhi',\n      },\n      'client:1': null,\n    };\n    const query = getNode(Relay.QL`\n      fragment on Actor {\n        address {\n          city,\n        },\n        firstName,\n      }\n    `);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toEqual({\n      __dataID__: '1055790163',\n      address: null,\n      firstName: 'Yuzhi',\n    });\n  });\n\n  it('includes `null` scalar values along with existing sibling fields', () => {\n    let records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        doesViewerLike: null,\n        id: 'feedbackID',\n      },\n    };\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        id,\n        doesViewerLike,\n      }\n    `);\n    let data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data.id).toBe('feedbackID');\n    expect(data.doesViewerLike).toBeNull();\n\n    records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        id: 'feedbackID',\n      },\n    };\n    data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data.id).toBe('feedbackID');\n    expect(data.doesViewerLike).toBeUndefined();\n    expect('doesViewerLike' in data).toBe(false);\n  });\n\n  it('retrieves empty plural fields', () => {\n    const records = {\n      user_id: {\n        id: 'user_id',\n        websites: [],\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{id,websites}`);\n    const data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.websites).toEqual([]);\n  });\n\n  it('retrieves plural fields', () => {\n    const websites = ['website1', 'website2'];\n\n    const records = {\n      user_id: {\n        id: 'user_id',\n        websites,\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{id,websites}`);\n    const data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.websites).toEqual(\n      ['website1', 'website2']\n    );\n  });\n\n  it('retrieves status information for nodes with queued changes', () => {\n    const STATUS = RelayRecordStatusMap.setOptimisticStatus(\n      RelayRecordStatusMap.setErrorStatus(0, true),\n      0\n    );\n    const records = {\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const queuedRecords = {\n      660361306: {\n        __dataID__: '660361306',\n        __status__: STATUS,\n        firstName: 'Snoop Lion',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{firstName}`);\n    const storeData = getStoreData({records, queuedRecords});\n    const data = readData(storeData, query, '660361306');\n    expect(data).toEqual({\n      __dataID__: '660361306',\n      __status__: STATUS,\n      firstName: 'Snoop Lion',\n    });\n  });\n\n  it('retrieves resolved fragment map generation information', () => {\n    const records = {\n      'a': {\n        __dataID__: 'a',\n        __resolvedFragmentMapGeneration__: 42,\n        firstName: 'Steve',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User{firstName}`);\n    const data = readData(getStoreData({records}), query, 'a');\n    expect(data).toEqual({\n      __dataID__: 'a',\n      __resolvedFragmentMapGeneration__: 42,\n      firstName: 'Steve',\n    });\n  });\n\n  it('retrieves resolved fragment map info for fragment references', () => {\n    const records = {\n      user: {\n        __dataID__: 'a',\n        address: {\n          __dataID__: 'address',\n        },\n      },\n      address: {\n        __dataID__: 'address',\n        __resolvedFragmentMapGeneration__: 42,\n        city: 'Menlo Park',\n      },\n    };\n    const fragment = Relay.QL`fragment on StreetAddress { city }`;\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => fragment,\n      {}\n    );\n    const query = getVerbatimNode(Relay.QL`\n      fragment on User {\n        address {\n          ${fragmentReference}\n        }\n      }\n    `);\n    const data = readData(getStoreData({records}), query, 'user');\n    expect(data).toEqual({\n      __dataID__: 'user',\n      address: {\n        __dataID__: 'address',\n        __fragments__: {\n          [fragment.id]: 'address',\n        },\n        __resolvedFragmentMapGeneration__: 42,\n      },\n    });\n  });\n\n  it('populates data ID for nodes containing only non-local fragments', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const fragment = Relay.QL`fragment on Viewer{actor{firstName}}`;\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => fragment,\n      {}\n    );\n    const query = getNode(Relay.QL`query{viewer{${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data.__dataID__).toBe('client:1');\n    expect(data.__fragments__).toEqual({\n      [getNode(fragment).getConcreteFragmentID()]: 'client:1',\n    });\n  });\n\n  it('reads data for non-container fragment references', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    };\n    const fragmentReference = new RelayFragmentReference(\n      () => Relay.QL`fragment on Viewer{actor{firstName}}`,\n      {}\n    );\n    const query = getNode(Relay.QL`query{viewer{${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data).toEqual({\n      __dataID__: 'client:1',\n      actor: {\n        __dataID__: '660361306',\n        firstName: 'Greg',\n      },\n    });\n  });\n\n  it('merges data from multiple fragments that reference the same node', () => {\n    const records = {\n      1055790163: {\n        __dataID__: '1055790163',\n        address: {__dataID__: 'client:1'},\n        last_name: 'Zheng',\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        city: 'San Francisco',\n        country: 'US',\n      },\n    };\n\n    const fragment1 = Relay.QL`fragment on Actor{address{city}}`;\n    const fragment2 = Relay.QL`fragment on Actor{address{country}}`;\n    const query = getNode(Relay.QL`  fragment on Actor {\n            ${fragment1},\n            ${fragment2},\n          }`);\n    const data = readData(getStoreData({records}), query, '1055790163');\n    expect(data).toEqual({\n      __dataID__: '1055790163',\n      address: {\n        __dataID__: 'client:1',\n        city: 'San Francisco',\n        country: 'US',\n      },\n    });\n  });\n\n  it('retrieves non-edge fields from filtered connections', () => {\n    const records = {\n      'client:123': {\n        id: 'client:123',\n        count: 42,\n        __dataID__: 'client:123',\n        __range__: new GraphQLRange(),\n      },\n    };\n    const query = getNode(Relay.QL`\n      fragment on FriendsConnection {\n        count\n      }\n    `);\n    const storeData = getStoreData({records});\n    const rangeID = storeData.getRangeData().getClientIDForRangeWithID(\n      callsToGraphQL([\n        {name: 'is_viewer_friend', value: null},\n        {name: 'first', value: 10},\n      ]),\n      {},\n      'client:123'\n    );\n    expect(rangeID).toBe('client:123_is_viewer_friend(),first(10)');\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: false,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n    const data = readData(storeData, query, rangeID);\n    expect(data).toEqual({\n      __dataID__: rangeID,\n      count: 42,\n    });\n  });\n\n  it('retrieves non-edge fields from a connection', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        count: 31337,\n      },\n    };\n    const query = getNode(Relay.QL`fragment on Feedback{likers{count}}`);\n    const data = readData(getStoreData({records}), query, 'feedback_id');\n    expect(data).toEqual({\n      __dataID__: 'feedback_id',\n      likers: {\n        __dataID__: 'likers_id',\n        count: 31337,\n      },\n    });\n  });\n\n  it('retrieves non-\"range\" fields within a connection', () => {\n    // This is a silly query (we don't need the `first(1)` call here) but was\n    // seen in the wild and should be handled gracefully.\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        topLevelComments(first:\"1\") {\n          count,\n        },\n      }\n    `);\n\n    const records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        topLevelComments: {\n          __dataID__: 'commentsID',\n        },\n      },\n      commentsID: {\n        __dataID__: 'commentsID',\n        __range__: new GraphQLRange(),\n        count: 57,\n      },\n    };\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    const data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data).toEqual({\n      __dataID__: 'feedbackID',\n      topLevelComments: {\n        __dataID__: 'commentsID_first(1)',\n        count: 57,\n      },\n    });\n  });\n\n  it('retrieves a mixture of \"range\" and non-\"range\" connection fields', () => {\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        topLevelComments(first:\"1\") {\n          count,\n          pageInfo {\n            hasNextPage,\n          },\n        },\n      }`\n    );\n\n    const records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        topLevelComments: {\n          __dataID__: 'commentsID',\n        },\n      },\n      commentsID: {\n        __dataID__: 'commentsID',\n        __range__: new GraphQLRange(),\n        count: 57,\n      },\n    };\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    const data = readData(getStoreData({records}), query, 'feedbackID');\n    expect(data).toEqual({\n      __dataID__: 'feedbackID',\n      topLevelComments: {\n        __dataID__: 'commentsID_first(1)',\n        count: 57,\n        [PAGE_INFO]: {\n          [HAS_NEXT_PAGE]: true,\n        },\n      },\n    });\n  });\n\n  it('requires filter calls on connections with range fields', () => {\n    const records = {\n      story_id: {\n        __dataID__: 'story_id',\n        feedback: {\n          __dataID__: 'feedback_id',\n        },\n      },\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        __range__: new GraphQLRange(),\n        count: 31337,\n      },\n    };\n    const error =\n      'readRelayQueryData(): The field `likers` is a connection. ' +\n      'Fields `edges` and `pageInfo` cannot be fetched without a ' +\n      '`first`, `last` or `find` argument.';\n\n    // Use fragment because all inline violations are caugh at transform time.\n    const edgesFragment = Relay.QL`\n      fragment on LikersOfContentConnection {\n        edges {\n          node {\n            name,\n          },\n        },\n      }\n    `;\n    let query = getNode(Relay.QL`\n      fragment on Story {\n        feedback {\n          likers {\n            ${edgesFragment}\n          },\n        },\n      }\n    `);\n    expect(\n      () => readData(getStoreData({records}), query, 'story_id')\n    ).toThrowError(error);\n\n    // Note that `pageInfo` also triggers the error...\n    const pageInfoFragment = Relay.QL`\n      fragment on LikersOfContentConnection {\n        pageInfo {\n          hasNextPage,\n        },\n      }\n    `;\n    query = getNode(Relay.QL`\n      fragment on Story {\n        feedback {\n          likers {\n            ${pageInfoFragment}\n          },\n        },\n      },\n    `);\n    expect(\n      () => readData(getStoreData({records}), query, 'story_id')\n    ).toThrowError(error);\n\n    // ...but not `count`:\n    query = getNode(Relay.QL`fragment on Story{feedback{likers{count}}}`);\n    expect(\n      () => readData(getStoreData({records}), query, 'story_id')\n    ).not.toThrowError();\n  });\n\n  it('requires filter calls on connections with filtered range fields ', () => {\n    const records = {\n      story_id: {\n        __dataID__: 'story_id',\n        feedback: {\n          __dataID__: 'feedback_id',\n        },\n      },\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        __range__: new GraphQLRange(),\n        count: 31337,\n      },\n    };\n    const error =\n      'readRelayQueryData(): The field `likers` is a connection. ' +\n      'Fields `edges` and `pageInfo` cannot be fetched without a ' +\n      '`first`, `last` or `find` argument.';\n\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on LikersOfContentConnection{edges{node{name}}}`,\n      {}\n    );\n    let query = getNode(Relay.QL`\n      fragment on Story{feedback{likers{${fragmentReference}}}}\n    `);\n    expect(() => readData(getStoreData({records}), query, 'story_id'))\n      .toThrowError(error);\n\n    let fragment = Relay.QL`fragment on LikersOfContentConnection{pageInfo}`;\n    query = getNode(Relay.QL`fragment on Story{feedback{likers{${fragment}}}}`);\n    expect(() => readData(getStoreData({records}), query, 'story_id'))\n      .toThrowError(error);\n\n    fragment = Relay.QL`fragment on LikersOfContentConnection{count}`;\n    query = getNode(Relay.QL`fragment on Story{feedback{likers{${fragment}}}}`);\n    expect(() => readData(getStoreData({records}), query, 'story_id'))\n      .not.toThrowError();\n  });\n\n  it('reads `edge`/`pageInfo` without range info like linked records', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        likers: {\n          __dataID__: 'likers_id',\n        },\n      },\n      likers_id: {\n        __dataID__: 'likers_id',\n        edges: [\n          {\n            __dataID__: 'likers_edge_id',\n          },\n        ],\n        [PAGE_INFO]: {\n          __dataID__: 'likers_page_info_id',\n        },\n      },\n      likers_edge_id: {\n        __dataID__: 'likers_edge_id',\n        node: {\n          __dataID__: 'liker_id',\n        },\n      },\n      likers_page_info_id: {\n        __dataID__: 'likers_page_info_id',\n        [HAS_NEXT_PAGE]: true,\n      },\n      liker_id: {\n        __dataID__: 'liker_id',\n        name: 'Tim',\n      },\n    };\n\n    let query = getNode(Relay.QL`\n      fragment on Feedback{likers(first:\"1\"){edges{node{name}}}}\n    `);\n    let data = readData(getStoreData({records}), query, 'feedback_id');\n    expect(data).toEqual({\n      __dataID__: 'feedback_id',\n      likers: {\n        __dataID__: 'likers_id_first(1)',\n        edges: [\n          {\n            __dataID__: 'likers_edge_id',\n            node: {\n              __dataID__: 'liker_id',\n              name: 'Tim',\n            },\n          },\n        ],\n      },\n    });\n\n    query = getNode(Relay.QL`\n      fragment on Feedback{likers(first:\"1\"){pageInfo{hasNextPage}}}\n    `);\n    data = readData(getStoreData({records}), query, 'feedback_id');\n    expect(data).toEqual({\n      __dataID__: 'feedback_id',\n      likers: {\n        __dataID__: 'likers_id_first(1)',\n        [PAGE_INFO]: {\n          __dataID__: 'likers_page_info_id',\n          [HAS_NEXT_PAGE]: true,\n        },\n      },\n    });\n  });\n\n  it('recurses through fragments when retrieving pageInfo', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        comments: {\n          __dataID__: 'comments_id',\n        },\n      },\n      comments_id: {\n        __dataID__: 'comments_id',\n        __range__: new GraphQLRange(),\n      },\n    };\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on PageInfo{hasNextPage}`,\n      {}\n    );\n    const query = getNode(Relay.QL`  fragment on Feedback{\n            comments(first:\"1\") {\n              pageInfo {\n                startCursor,\n                ${fragmentReference},\n              },\n            }\n          }`);\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: [],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    let data = readData(\n      getStoreData({records}),\n      query,\n      'feedback_id',\n      {traverseFragmentReferences: true}\n    );\n\n    expect(data.comments).toEqual({\n      __dataID__: 'comments_id_first(1)',\n      [PAGE_INFO]: {\n        [START_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n      },\n    });\n\n    data = readData(getStoreData({records}), query, 'feedback_id');\n\n    const fragmentSourceID =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(data.comments.pageInfo.__fragments__).toEqual({\n      [fragmentSourceID]: 'comments_id_first(1)',\n    });\n  });\n\n  it('retrieves data and fragment pointers from range', () => {\n    const records = {\n      feedback_id: {\n        __dataID__: 'feedback_id',\n        comments: {\n          __dataID__: 'comments_id',\n        },\n      },\n      comments_id: {\n        __dataID__: 'comments_id',\n        __range__: new GraphQLRange(),\n      },\n      comment_node_id: {\n        __dataID__: 'comment_node_id',\n        id: 'comment_node_id',\n      },\n      comment_edge_id: {\n        __dataID__: 'comment_edge_id',\n        node: {__dataID__: 'comment_node_id'},\n        cursor: 'cursor',\n      },\n    };\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on CommentsConnection{edges{node{id}}}`,\n      {}\n    );\n    const query = getNode(Relay.QL`  fragment on Feedback{\n            comments(first:\"1\") {\n              edges {\n                node {\n                  id\n                },\n              },\n              pageInfo {\n                startCursor\n              },\n              ${fragmentReference}\n            }\n          }`);\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    let data = readData(\n      getStoreData({records}),\n      query,\n      'feedback_id',\n      {traverseFragmentReferences: true}\n    );\n\n    expect(data.comments).toEqual({\n      __dataID__: 'comments_id_first(1)',\n      edges: [{\n        __dataID__: 'comment_edge_id',\n        node: {\n          __dataID__: 'comment_node_id',\n          id: 'comment_node_id',\n        },\n      }],\n      [PAGE_INFO]: {\n        [START_CURSOR]: 'cursor',\n      },\n    });\n\n    data = readData(getStoreData({records}), query, 'feedback_id');\n\n    const fragmentSourceID =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(data.comments.__fragments__).toEqual({\n      [fragmentSourceID]: 'comments_id_first(1)',\n    });\n  });\n\n  it('returns RelayFragmentPointers for child queries', () => {\n    const records = {\n      user_id: {\n        __dataID__: 'user_id',\n        id: 'user_id',\n        screennames: [\n          {__dataID__: 'client1'},\n          {__dataID__: 'client2'},\n        ],\n        hometown: {__dataID__: 'hometown_id'},\n      },\n      hometown_id: {\n        __dataID__: 'hometown_id',\n        id: 'hometown_id',\n        name: 'hometown name',\n      },\n      client1: {\n        __dataID__: 'client1',\n        service: 'GTALK',\n        name: '123',\n      },\n      client2: {\n        __dataID__: 'client1',\n        service: 'TWITTER',\n        name: '123',\n      },\n    };\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on Screenname {service, name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`\n      fragment on User {\n        id,\n        hometown {\n          name,\n        },\n        screennames {\n          ${fragmentReference},\n        },\n      }\n    `);\n\n    // Mark top fragment as local, and child fragment as non-local.\n    const data = readData(getStoreData({records}), query, 'user_id');\n\n    expect(data.id).toBe('user_id');\n    expect(data.hometown.name).toEqual('hometown name');\n    expect(data.screennames.length).toBe(2);\n    const screennames = data.screennames;\n    const fragmentSourceID0 =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(screennames[0].__fragments__).toEqual({\n      [fragmentSourceID0]: 'client1',\n    });\n    const fragmentSourceID1 =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(screennames[1].__fragments__).toEqual({\n      [fragmentSourceID1]: 'client2',\n    });\n  });\n\n  it('reads dataID if a linked dataID is `null` or `undefined`', () => {\n    const query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            name\n          },\n        }\n      }\n    `);\n    let records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: null,\n      },\n    };\n    let data = readData(getStoreData({records}), query, 'client:1');\n    expect(data.actor).toBeNull();\n\n    records = {\n      'client:1': {\n        __dataID__: 'client:1',\n      },\n    };\n    data = readData(getStoreData({records}), query, 'client:1');\n    expect(data.actor).toBeUndefined();\n  });\n\n  it('does not clobber previously-read sibling fields when a linked dataID is `null` or `undefined`', () => {\n    const query = getNode(Relay.QL`\n      fragment on User {\n        id,\n        address {\n          city,\n        },\n      }\n    `);\n    let records = {\n      user_id: {\n        __dataID__: 'user_id',\n        id: 'user_id',\n        address: null,\n      },\n    };\n    let data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.address).toBeNull();\n    expect(data.id).toBe('user_id');\n\n    records = {\n      user_id: {\n        __dataID__: 'user_id',\n        id: 'user_id',\n      },\n    };\n    data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.address).toBeUndefined();\n    expect(data.id).toBe('user_id');\n  });\n\n  it('does not set undefined value if linked dataID missing', () => {\n    const query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            name,\n          },\n        }\n      }\n    `);\n\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n      },\n    };\n\n    const data = readData(getStoreData({records}), query, 'client:1');\n    expect(data).toEqual({__dataID__: 'client:1'});\n\n    // Extra assertion because `toEqual` matcher skips over properties with\n    // undefined values...\n    expect('actor' in data).toBe(false);\n  });\n\n  it('allocates linked fields even if all child fields are null', () => {\n    const query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          birthdate {\n            year,\n          },\n        }\n      }\n    `);\n    const records = {\n      '123': {\n        __dataID__: '123',\n        birthdate: {\n          __dataID__: 'client:1',\n        },\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        year: null,\n      },\n    };\n    const data = readData(getStoreData({records}), query, '123');\n\n    expect(data.birthdate).not.toBeNull();\n    expect(data.birthdate.year).toBeNull();\n  });\n\n  it('reads fields for connections without calls', () => {\n    const query = getNode(Relay.QL`\n      fragment on User {\n        friends {\n          count,\n        },\n      }\n    `);\n    let records = {\n      'user_id': {\n        __dataID__: 'user_id',\n        friends: {\n          __dataID__: 'client:1',\n        },\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        count: 42,\n      },\n    };\n    let data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.friends.count).toBe(42);\n\n    // Now imagine another query (say, a deferred query) has populated the store\n    // with range info for this connection.\n    records = {\n      'user_id': {\n        __dataID__: 'user_id',\n        friends: {\n          __dataID__: 'client:1',\n        },\n      },\n      'client:1': {\n        __dataID__: 'client:1',\n        __range__: new GraphQLRange(),\n        count: 42,\n      },\n    };\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edgeID'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n    data = readData(getStoreData({records}), query, 'user_id');\n    expect(data.friends.count).toBe(42);\n  });\n\n  it('handles \"empty\" ref query dependencies', () => {\n    // People normally won't write queries like this by hand, but they can be\n    // produced as the result of splitting deferred queries.\n    //\n    // The `feedback` field here only has a generated `id`, so is \"empty\".\n    let query = getNode(Relay.QL`\n      fragment on Story {\n        id,\n        feedback\n      }\n    `);\n\n    // Mark the `id` field in `feedback{id}` as a ref query dependency.\n    query = query.clone(\n      query.getChildren().map((outerChild, ii) => {\n        if (ii === 1) {\n          return outerChild.clone(\n            outerChild.getChildren().map((innerChild, jj) => {\n              if (jj === 0) {\n                return innerChild.cloneAsRefQueryDependency();\n              } else {\n                return innerChild;\n              }\n            })\n          );\n        } else {\n          return outerChild;\n        }\n      })\n    );\n\n    const records = {\n      storyID: {\n        __dataID__: 'storyID',\n        id: 'storyID',\n        feedback: {\n          __dataID__: 'feedbackID',\n        },\n      },\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        id: 'feedbackID',\n      },\n    };\n    const data = readData(getStoreData({records}), query, 'storyID');\n    expect(data).toEqual({\n      __dataID__: 'storyID',\n      id: 'storyID',\n      feedback: {\n        __dataID__: 'feedbackID',\n      },\n    });\n  });\n\n  it('parses range client IDs', () => {\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`\n        fragment on FriendsConnection {\n          edges {\n            node {\n              address {\n                city,\n                country\n              }\n            },\n          },\n        }\n      `,\n      {}\n    );\n    const query = getNode(Relay.QL`\n      fragment on User {\n        friends(first:\"25\") {\n          ${fragmentReference},\n        },\n      }\n    `);\n\n    const records = {\n      userID: {\n        __dataID__: 'userID',\n        friends: {\n          __dataID__: 'friendsID',\n        },\n      },\n      friendsID: {\n        __dataID__: 'friendsID',\n        __range__: new GraphQLRange(),\n      },\n      edgeID: {\n        __dataID__: 'edgeID',\n        node: {\n          __dataID__: 'friendID',\n        },\n        cursor: 'cursor',\n      },\n      friendID: {\n        __dataID__: 'friendID',\n        address: {\n          __dataID__: 'addressID',\n        },\n      },\n      addressID: {\n        __dataID__: 'addressID',\n        city: 'Menlo Park',\n        country: 'USA',\n      },\n    };\n    const storeData = getStoreData({records});\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['edgeID'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: false,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    // First we read the outer fragment, which populates the\n    // GraphQLStoreRangeUtils rangeData cache.\n    // (TODO: task to fix that hidden global state: #7250441)\n    let data = readData(storeData, query, 'userID');\n    const fragmentSourceID =\n      getNode(fragmentReference.getFragment()).getConcreteFragmentID();\n    expect(data).toEqual({\n      __dataID__: 'userID',\n      friends: {\n        __dataID__: 'friendsID_first(25)',\n        __fragments__: {\n          [fragmentSourceID]: 'friendsID_first(25)',\n        },\n      },\n    });\n\n    // Now we read the inner (non-local) fragment, using the range client ID.\n    data = readData(\n      storeData,\n      getNode(fragmentReference.getFragment()),\n      'friendsID_first(25)'\n    );\n    expect(data).toEqual({\n      __dataID__: 'friendsID_first(25)',\n      edges: [\n        {\n          __dataID__: 'edgeID',\n          node: {\n            __dataID__: 'friendID',\n            address: {\n              __dataID__: 'addressID',\n              city: 'Menlo Park',\n              country: 'USA',\n            },\n          },\n        },\n      ],\n    });\n  });\n\n  it('can be configured to read generated fields (scalar case)', () => {\n    const records = {\n      'client:1': {\n        __dataID__: 'client:1',\n        actor: {\n          __dataID__: '660361306',\n        },\n      },\n      660361306: {\n        __dataID__: '660361306',\n        __typename: 'User',\n        firstName: 'Greg',\n        id: '660361306',\n      },\n    };\n    const query = getNode(Relay.QL`query{viewer{actor{firstName}}}`);\n    const data = readData(\n      getStoreData({records}),\n      query,\n      'client:1',\n      {traverseGeneratedFields: true}\n    );\n    expect(data).toEqual({\n      __dataID__: 'client:1',\n      actor: {\n        __dataID__: '660361306',\n        __typename: 'User',\n        firstName: 'Greg',\n        id: '660361306',\n      },\n    });\n  });\n\n  it('can be configured to read generated fields (page info case)', () => {\n    const query = getNode(Relay.QL`\n      fragment on Feedback {\n        topLevelComments(first:\"1\") {\n          pageInfo {\n            hasNextPage,\n          },\n        },\n      }`\n    );\n\n    const records = {\n      feedbackID: {\n        __dataID__: 'feedbackID',\n        topLevelComments: {\n          __dataID__: 'commentsID',\n        },\n      },\n      commentsID: {\n        __dataID__: 'commentsID',\n        __range__: new GraphQLRange(),\n        count: 57,\n      },\n    };\n\n    GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n      requestedEdgeIDs: ['comment_edge_id'],\n      diffCalls: [],\n      pageInfo: {\n        [START_CURSOR]: 'cursor',\n        [END_CURSOR]: 'cursor',\n        [HAS_NEXT_PAGE]: true,\n        [HAS_PREV_PAGE]: false,\n      },\n    });\n\n    const data = readData(\n      getStoreData({records}),\n      query,\n      'feedbackID',\n      {traverseGeneratedFields: true}\n    );\n    expect(data).toEqual({\n      __dataID__: 'feedbackID',\n      topLevelComments: {\n        __dataID__: 'commentsID_first(1)',\n        [PAGE_INFO]: {\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: false,\n        },\n      },\n    });\n  });\n\n  it('does not attempt to traverse missing data IDs', () => {\n    const records = {};\n\n    // If we did traverse, this fragment reference would lead us to create an\n    // object with a __dataID__ instead of the desired `undefined`.\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on User{name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`query{node(id:\"4\"){${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, '4');\n    expect(data).toBe(undefined);\n  });\n\n  it('does not attempt to traverse non-existent data IDs', () => {\n    const records = {4: null};\n\n    // If we did traverse, this fragment reference would lead us to create an\n    // object with a __dataID__ instead of the desired `null`.\n    const fragmentReference = RelayFragmentReference.createForContainer(\n      () => Relay.QL`fragment on User{name}`,\n      {}\n    );\n    const query = getNode(Relay.QL`query{node(id:\"4\"){${fragmentReference}}}`);\n    const data = readData(getStoreData({records}), query, '4');\n    expect(data).toBe(null);\n  });\n\n  it('reads data for matching fragments', () => {\n    const records = {\n      123: {\n        __dataID__: '123',\n        id: '123',\n        __typename: 'User',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on User { id }`);\n    const data = readData(getStoreData({records}), query, '123');\n    expect(data).toEqual({\n      __dataID__: '123',\n      id: '123',\n    });\n  });\n\n  it('returns undefined for non-matching fragments', () => {\n    const records = {\n      123: {\n        __dataID__: '123',\n        id: '123',\n        __typename: 'User',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on Page { id }`);\n    const data = readData(getStoreData({records}), query, '123');\n    expect(data).toEqual(undefined);\n  });\n\n  it('skips non-matching child fragments', () => {\n    const records = {\n      123: {\n        __dataID__: '123',\n        id: '123',\n        __typename: 'User',\n        name: 'Greg',\n      },\n    };\n    const query = getNode(Relay.QL`fragment on Actor {\n      ... on User {\n        name\n      }\n      ... on Page {\n        id\n      }\n    }`);\n    const data = readData(getStoreData({records}), query, '123');\n    expect(data).toEqual({\n      __dataID__: '123',\n      name: 'Greg',\n    });\n  });\n\n  // TODO: Fix these tests, #10252182.\n\n  // describe('readRelayQueryData-partialStatus', () => {\n  //   it('marks nodes with missing scalar field as partial', () => {\n  //     const records = {\n  //       feedbackID: {\n  //         __dataID__: 'feedbackID',\n  //         id: 'feedbackID',\n  //       },\n  //     };\n  //     // Missing `doesViewerLike` in store\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         id,\n  //         doesViewerLike,\n  //       }\n  //     `);\n\n  //     const data = readData(getStoreData({records}), query, 'feedbackID');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nested nodes with missing field as partial', () => {\n  //     const records = {\n  //       feedbackID: {\n  //         __dataID__: 'feedbackID',\n  //         id: 'feedbackID',\n  //         comments: {__dataID__: 'client:1'},\n  //       },\n  //       'client:1': {\n  //         __dataID__:'client:1',\n  //       },\n  //     };\n  //     // Missing `comments {count}` in store\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         id,\n  //         comments {count}\n  //       }\n  //     `);\n\n  //     const data = readData(getStoreData({records}), query, 'feedbackID');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.comments.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing linked nodes as partial', () => {\n  //     const records = {\n  //       'client:1': {\n  //         __dataID__: 'client:1',\n  //         actor: {\n  //           __dataID__: '660361306',\n  //         },\n  //       },\n  //     };\n  //     // Missing the actor node.\n  //     const query = getNode(Relay.QL`query{viewer{actor{firstName}}}`);\n  //     const data = readData(getStoreData({records}), query, 'client:1');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing plural linked nodes as partial', () => {\n  //     const records = {\n  //       '660361306': {\n  //         __dataID__: '660361306',\n  //         allPhones: [{__dataID__: 'client:1'}, {__dataID__: 'client:1'}],\n  //       },\n  //       'client:1': {\n  //         __dataID__: 'client:1',\n  //       },\n  //       'client:2': {\n  //         __dataID__: 'client:2',\n  //         isVerified: true,\n  //       },\n  //     };\n  //     // Missing the `isVerified` in the first element.\n  //     const query = getNode(Relay.QL`\n  //       fragment on User {\n  //         allPhones {\n  //           isVerified,\n  //         },\n  //       }\n  //     `);\n  //     const data = readData(getStoreData({records}), query, '660361306');\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     const firstPhone = data.allPhones[0];\n  //     expect(RelayRecordStatusMap.isPartialStatus(firstPhone.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing edges as partial', () => {\n  //     const records = {\n  //       feedback_id: {\n  //         __dataID__: 'feedback_id',\n  //         comments: {\n  //           __dataID__: 'comments_id',\n  //         },\n  //       },\n  //       comments_id: {\n  //         __dataID__: 'comments_id',\n  //         __range__: new GraphQLRange(),\n  //       },\n  //       comment_node_id: {\n  //         __dataID__: 'comment_node_id',\n  //         id: 'comment_node_id',\n  //       },\n  //       comment_edge_id: {\n  //         __dataID__: 'comment_edge_id',\n  //         node: {__dataID__: 'comment_node_id'},\n  //         cursor: 'cursor',\n  //       },\n  //     };\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         comments(first:\"5\") {\n  //           edges {\n  //             node {\n  //               id\n  //             },\n  //           },\n  //           pageInfo {\n  //             startCursor\n  //           },\n  //         },\n  //       },\n  //     `);\n\n  //     // Missing edges due to non-empty diffCalls.\n  //     GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n  //       requestedEdgeIDs: ['comment_edge_id'],\n  //       diffCalls: [RelayTestUtils.createCall('first', 4)],\n  //       pageInfo: {\n  //         [START_CURSOR]: 'cursor',\n  //         [END_CURSOR]: 'cursor',\n  //         [HAS_NEXT_PAGE]: true,\n  //         [HAS_PREV_PAGE]: false,\n  //       },\n  //     });\n\n  //     const data = readData(\n  //       getStoreData({records}),\n  //       query,\n  //       'feedback_id',\n  //       {traverseFragmentReferences: true}\n  //     );\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     const comments = data[comments];\n  //     expect(RelayRecordStatusMap.isPartialStatus(comments.__status__))\n  //       .toBe(true);\n  //   });\n\n  //   it('marks nodes with missing edge data as partial', () => {\n  //     const records = {\n  //       feedback_id: {\n  //         __dataID__: 'feedback_id',\n  //         comments: {\n  //           __dataID__: 'comments_id',\n  //         },\n  //       },\n  //       comments_id: {\n  //         __dataID__: 'comments_id',\n  //         __range__: new GraphQLRange(),\n  //       },\n  //       comment_node_id: {\n  //         __dataID__: 'comment_node_id',\n  //         id: 'comment_node_id',\n  //       },\n  //       comment_edge_id: {\n  //         __dataID__: 'comment_edge_id',\n  //         node: {__dataID__: 'comment_node_id'},\n  //         cursor: 'cursor',\n  //       },\n  //     };\n  //     // Missing `body{text}` on the comment\n  //     const query = getNode(Relay.QL`\n  //       fragment on Feedback {\n  //         comments(first:\"1\") {\n  //           edges {\n  //             node {\n  //               id,\n  //               body {text}\n  //             },\n  //           },\n  //           pageInfo {\n  //             startCursor\n  //           }\n  //         }\n  //       }\n  //     `);\n\n  //     GraphQLRange.prototype.retrieveRangeInfoForQuery.mockReturnValue({\n  //       requestedEdgeIDs: ['comment_edge_id'],\n  //       diffCalls: [],\n  //       pageInfo: {\n  //         [START_CURSOR]: 'cursor',\n  //         [END_CURSOR]: 'cursor',\n  //         [HAS_NEXT_PAGE]: true,\n  //         [HAS_PREV_PAGE]: false,\n  //       },\n  //     });\n\n  //     const data = readData(\n  //       getStoreData({records}),\n  //       query,\n  //       'feedback_id',\n  //       {traverseFragmentReferences: true}\n  //     );\n  //     expect(RelayRecordStatusMap.isPartialStatus(data.__status__))\n  //       .toBe(true);\n  //     const comments = data[comments];\n  //     expect(RelayRecordStatusMap.isPartialStatus(comments.__status__))\n  //       .toBe(true);\n  //     const comment = comments.edges[0].node;\n  //     expect(RelayRecordStatusMap.isPartialStatus(comment.__status__))\n  //       .toBe(true);\n  //   });\n  // });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/readRelayQueryData-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/isRelayContext-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst RelayContext = require('RelayContext');\n\nconst isRelayContext = require('isRelayContext');\n\ndescribe('isRelayContext()', () => {\n  it('returns true for `RelayContext` instances', () => {\n    expect(isRelayContext(new RelayContext())).toBe(true);\n  });\n\n  it('returns true for objects that conform to the interface', () => {\n    const context = {\n      forceFetch: () => null,\n      getFragmentResolver: () => null,\n      getStoreData: () => null,\n      primeCache: () => null,\n    };\n    expect(isRelayContext(context)).toBe(true);\n  });\n\n  it('returns false for objects that do not conform to the interface', () => {\n    const fakeContext = {\n      forceFetch: true,\n      getFragmentResolver: true,\n      getStoreData: true,\n      primeCache: true,\n    };\n    expect(isRelayContext(fakeContext)).toBe(false);\n  });\n\n  it('returns false for non-objects', () => {\n    expect(isRelayContext(null)).toBe(false);\n    expect(isRelayContext(false)).toBe(false);\n    expect(isRelayContext('relay')).toBe(false);\n    expect(isRelayContext(1)).toBe(false);\n  });\n});\n","dependencies":["configureForRelayOSS","RelayContext","isRelayContext"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst RelayContext = require('RelayContext');\n\nconst isRelayContext = require('isRelayContext');\n\ndescribe('isRelayContext()', () => {\n  it('returns true for `RelayContext` instances', () => {\n    expect(isRelayContext(new RelayContext())).toBe(true);\n  });\n\n  it('returns true for objects that conform to the interface', () => {\n    const context = {\n      forceFetch: () => null,\n      getFragmentResolver: () => null,\n      getStoreData: () => null,\n      primeCache: () => null,\n    };\n    expect(isRelayContext(context)).toBe(true);\n  });\n\n  it('returns false for objects that do not conform to the interface', () => {\n    const fakeContext = {\n      forceFetch: true,\n      getFragmentResolver: true,\n      getStoreData: true,\n      primeCache: true,\n    };\n    expect(isRelayContext(fakeContext)).toBe(false);\n  });\n\n  it('returns false for non-objects', () => {\n    expect(isRelayContext(null)).toBe(false);\n    expect(isRelayContext(false)).toBe(false);\n    expect(isRelayContext('relay')).toBe(false);\n    expect(isRelayContext(1)).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/isRelayContext-test.js"}},"/Users/cpojer/Projects/relay/src/store/__tests__/filterExclusiveKeys-test.js":{"metadata":{"mtime":1455679339000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst filterExclusiveKeys = require('filterExclusiveKeys');\n\ndescribe('filterExclusiveKeys', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  it('computes exclusive keys between two objects with overlap', () => {\n    var a = {v: true, w: true, x: true};\n    var b = {x: true, y: true, z: true};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      ['v', 'w'],\n      ['y', 'z'],\n    ]);\n  });\n\n  it('computes exclusive keys with no first argument', () => {\n    var a = null;\n    var b = {x: true, y: true, z: true};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      [],\n      ['x', 'y', 'z'],\n    ]);\n  });\n\n  it('computes exclusive keys with an empty first argument', () => {\n    var a = {};\n    var b = {x: true, y: true, z: true};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      [],\n      ['x', 'y', 'z'],\n    ]);\n  });\n\n  it('computes exclusive keys with no second argument', () => {\n    var a = {x: true, y: true, z: true};\n    var b = null;\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      ['x', 'y', 'z'],\n      [],\n    ]);\n  });\n\n  it('computes exclusive keys with an empty second argument', () => {\n    var a = {x: true, y: true, z: true};\n    var b = {};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      ['x', 'y', 'z'],\n      [],\n    ]);\n  });\n});\n","dependencies":["filterExclusiveKeys"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst filterExclusiveKeys = require('filterExclusiveKeys');\n\ndescribe('filterExclusiveKeys', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  it('computes exclusive keys between two objects with overlap', () => {\n    var a = {v: true, w: true, x: true};\n    var b = {x: true, y: true, z: true};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      ['v', 'w'],\n      ['y', 'z'],\n    ]);\n  });\n\n  it('computes exclusive keys with no first argument', () => {\n    var a = null;\n    var b = {x: true, y: true, z: true};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      [],\n      ['x', 'y', 'z'],\n    ]);\n  });\n\n  it('computes exclusive keys with an empty first argument', () => {\n    var a = {};\n    var b = {x: true, y: true, z: true};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      [],\n      ['x', 'y', 'z'],\n    ]);\n  });\n\n  it('computes exclusive keys with no second argument', () => {\n    var a = {x: true, y: true, z: true};\n    var b = null;\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      ['x', 'y', 'z'],\n      [],\n    ]);\n  });\n\n  it('computes exclusive keys with an empty second argument', () => {\n    var a = {x: true, y: true, z: true};\n    var b = {};\n    expect(filterExclusiveKeys(a, b)).toEqual([\n      ['x', 'y', 'z'],\n      [],\n    ]);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/store/__tests__/filterExclusiveKeys-test.js"}},"/Users/cpojer/Projects/relay/src/route/__mocks__/RelayRoute.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\n'use strict';\n\nvar RelayRoute = require.requireActual('RelayRoute');\n\nRelayRoute.genMock = jest.genMockFunction().mockImplementation(() => {\n  class MockRoute extends RelayRoute {}\n  MockRoute.routeName = 'MockRoute';\n  MockRoute.path = '/jest';\n  return MockRoute;\n});\n\nRelayRoute.genMockInstance = jest.genMockFunction().mockImplementation(\n  () => new (RelayRoute.genMock())()\n);\n\nmodule.exports = RelayRoute;\n","dependencies":["RelayRoute"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\n'use strict';\n\nvar RelayRoute = require.requireActual('RelayRoute');\n\nRelayRoute.genMock = jest.genMockFunction().mockImplementation(() => {\n  class MockRoute extends RelayRoute {}\n  MockRoute.routeName = 'MockRoute';\n  MockRoute.path = '/jest';\n  return MockRoute;\n});\n\nRelayRoute.genMockInstance = jest.genMockFunction().mockImplementation(\n  () => new (RelayRoute.genMock())()\n);\n\nmodule.exports = RelayRoute;\n"},"name":"/Users/cpojer/Projects/relay/src/route/__mocks__/RelayRoute.js"}},"/Users/cpojer/Projects/relay/src/route/__mocks__/RelayMetaRoute.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMetaRoute');\n","dependencies":["RelayMetaRoute"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMetaRoute');\n"},"name":"/Users/cpojer/Projects/relay/src/route/__mocks__/RelayMetaRoute.js"}},"/Users/cpojer/Projects/relay/src/route/__tests__/RelayRoute-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayRoute = require('RelayRoute');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayRoute', () => {\n  var makeRoute;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    makeRoute = function() {\n      class MockRoute extends RelayRoute {}\n      MockRoute.routeName = 'MockRoute';\n      MockRoute.path = '/{required}';\n      MockRoute.paramDefinitions = {\n        required: {\n          type: 'String',\n          required: true,\n        },\n        optional: {\n          type: 'String',\n          required: false,\n        },\n      };\n      MockRoute.queries = {\n        required: Component => Relay.QL`\n          query {\n            node(id:$required) {\n              ${Component.getFragment('required')}\n            }\n          }\n        `,\n        optional: Component => Relay.QL`\n          query {\n            node(id:$optional) {\n              ${Component.getFragment('optional')}\n            }\n          }\n        `,\n      };\n      return MockRoute;\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('can be created using inheritance', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(route.name).toEqual('MockRoute');\n    expect(route.params.required).toEqual('foo');\n    expect(route.queries.required).toBeTruthy();\n  });\n\n  it('has an immutable spec in __DEV__', () => {\n    var dev = __DEV__;\n    window.__DEV__ = true;\n\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(() => route.name = 'yo').toThrow();\n    expect(() => route.params = 'I am').toThrow();\n    expect(() => route.queries = 'immutable').toThrow();\n    expect(() => route.params.foo = 'bar').toThrow();\n    expect(() => route.queries.myCustomQuery = () => {}).toThrow();\n\n    window.__DEV__ = dev;\n  });\n\n  it('allows params to be processed if `prepareParams` is defined', () => {\n    var MockRoute = makeRoute();\n    MockRoute.prepareParams =\n      jest.genMockFunction().mockReturnValue({required: 'bar'});\n    var route = new MockRoute({required: 'foo'});\n    expect(MockRoute.prepareParams).toBeCalledWith({required: 'foo'});\n    expect(route.params.required).toEqual('bar');\n  });\n\n  it('throws if a requires param is not supplied', () => {\n    var MockRoute = makeRoute();\n    expect(() => {\n      /* eslint-disable no-new */\n      new MockRoute({});\n      /* eslint-enable no-new */\n    }).toFailInvariant(\n      'RelayRoute: Missing required parameter `required` in `MockRoute`. ' +\n      'Check the supplied params or URI.'\n    );\n  });\n\n  it('defaults optional param definitions to undefined', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(Object.keys(route.params)).toContain('optional');\n  });\n\n  it('exposes queries in the queries property', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(route.queries.required).toBeTruthy();\n    expect(route.queries.optional).toBeTruthy();\n  });\n\n  it('allows to inject a URI creator', () => {\n    RelayRoute.injectURICreator(\n      (_, params) => '/foo/' + params.required\n    );\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'bar'});\n\n    expect(route.uri).not.toBe(null);\n    expect(route.uri).toEqual('/foo/bar');\n  });\n\n  it('uses the injection only if the URI is not already passed in', () => {\n    var mockCallback = jest.genMockFunction();\n    RelayRoute.injectURICreator(mockCallback);\n    var MockRoute = makeRoute();\n    var uri = '/foo/bar';\n    var route = new MockRoute({required: 'bar'}, uri);\n\n    expect(mockCallback).not.toBeCalled();\n    expect(route.uri).toEqual(uri);\n  });\n\n  it('throws for route subclasses missing `routeName`', () => {\n    class InvalidRoute extends RelayRoute {}\n\n    expect(() => {\n      /* eslint-disable no-new */\n      new InvalidRoute();\n      /* eslint-enable no-new */\n    }).toFailInvariant(\n      'InvalidRoute: Subclasses of RelayRoute must define a `routeName`.'\n    );\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayRoute","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayRoute = require('RelayRoute');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayRoute', () => {\n  var makeRoute;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    makeRoute = function() {\n      class MockRoute extends RelayRoute {}\n      MockRoute.routeName = 'MockRoute';\n      MockRoute.path = '/{required}';\n      MockRoute.paramDefinitions = {\n        required: {\n          type: 'String',\n          required: true,\n        },\n        optional: {\n          type: 'String',\n          required: false,\n        },\n      };\n      MockRoute.queries = {\n        required: Component => Relay.QL`\n          query {\n            node(id:$required) {\n              ${Component.getFragment('required')}\n            }\n          }\n        `,\n        optional: Component => Relay.QL`\n          query {\n            node(id:$optional) {\n              ${Component.getFragment('optional')}\n            }\n          }\n        `,\n      };\n      return MockRoute;\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('can be created using inheritance', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(route.name).toEqual('MockRoute');\n    expect(route.params.required).toEqual('foo');\n    expect(route.queries.required).toBeTruthy();\n  });\n\n  it('has an immutable spec in __DEV__', () => {\n    var dev = __DEV__;\n    window.__DEV__ = true;\n\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(() => route.name = 'yo').toThrow();\n    expect(() => route.params = 'I am').toThrow();\n    expect(() => route.queries = 'immutable').toThrow();\n    expect(() => route.params.foo = 'bar').toThrow();\n    expect(() => route.queries.myCustomQuery = () => {}).toThrow();\n\n    window.__DEV__ = dev;\n  });\n\n  it('allows params to be processed if `prepareParams` is defined', () => {\n    var MockRoute = makeRoute();\n    MockRoute.prepareParams =\n      jest.genMockFunction().mockReturnValue({required: 'bar'});\n    var route = new MockRoute({required: 'foo'});\n    expect(MockRoute.prepareParams).toBeCalledWith({required: 'foo'});\n    expect(route.params.required).toEqual('bar');\n  });\n\n  it('throws if a requires param is not supplied', () => {\n    var MockRoute = makeRoute();\n    expect(() => {\n      /* eslint-disable no-new */\n      new MockRoute({});\n      /* eslint-enable no-new */\n    }).toFailInvariant(\n      'RelayRoute: Missing required parameter `required` in `MockRoute`. ' +\n      'Check the supplied params or URI.'\n    );\n  });\n\n  it('defaults optional param definitions to undefined', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(Object.keys(route.params)).toContain('optional');\n  });\n\n  it('exposes queries in the queries property', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'foo'});\n    expect(route.queries.required).toBeTruthy();\n    expect(route.queries.optional).toBeTruthy();\n  });\n\n  it('allows to inject a URI creator', () => {\n    RelayRoute.injectURICreator(\n      (_, params) => '/foo/' + params.required\n    );\n    var MockRoute = makeRoute();\n    var route = new MockRoute({required: 'bar'});\n\n    expect(route.uri).not.toBe(null);\n    expect(route.uri).toEqual('/foo/bar');\n  });\n\n  it('uses the injection only if the URI is not already passed in', () => {\n    var mockCallback = jest.genMockFunction();\n    RelayRoute.injectURICreator(mockCallback);\n    var MockRoute = makeRoute();\n    var uri = '/foo/bar';\n    var route = new MockRoute({required: 'bar'}, uri);\n\n    expect(mockCallback).not.toBeCalled();\n    expect(route.uri).toEqual(uri);\n  });\n\n  it('throws for route subclasses missing `routeName`', () => {\n    class InvalidRoute extends RelayRoute {}\n\n    expect(() => {\n      /* eslint-disable no-new */\n      new InvalidRoute();\n      /* eslint-enable no-new */\n    }).toFailInvariant(\n      'InvalidRoute: Subclasses of RelayRoute must define a `routeName`.'\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/route/__tests__/RelayRoute-test.js"}},"/Users/cpojer/Projects/relay/src/route/__tests__/RelayMetaRoute-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayMetaRoute = require('RelayMetaRoute');\n\ndescribe('RelayMetaRoute', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  it('is immutable', () => {\n    var route = new RelayMetaRoute('TestRoute');\n    expect(() => route.name = 'foo').toThrow();\n  });\n\n  it('returns caches objects when using `get`', () => {\n    expect(\n      RelayMetaRoute.get('TestRoute')\n    ).toBe(RelayMetaRoute.get('TestRoute'));\n\n    expect(\n      RelayMetaRoute.get('TestRoute')\n    ).not.toBe(RelayMetaRoute.get('TestRoute2'));\n\n    expect(\n      RelayMetaRoute.get('TestRoute2')\n    ).toBe(RelayMetaRoute.get('TestRoute2'));\n  });\n});\n","dependencies":["RelayMetaRoute"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayMetaRoute = require('RelayMetaRoute');\n\ndescribe('RelayMetaRoute', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n  });\n\n  it('is immutable', () => {\n    var route = new RelayMetaRoute('TestRoute');\n    expect(() => route.name = 'foo').toThrow();\n  });\n\n  it('returns caches objects when using `get`', () => {\n    expect(\n      RelayMetaRoute.get('TestRoute')\n    ).toBe(RelayMetaRoute.get('TestRoute'));\n\n    expect(\n      RelayMetaRoute.get('TestRoute')\n    ).not.toBe(RelayMetaRoute.get('TestRoute2'));\n\n    expect(\n      RelayMetaRoute.get('TestRoute2')\n    ).toBe(RelayMetaRoute.get('TestRoute2'));\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/route/__tests__/RelayMetaRoute-test.js"}},"/Users/cpojer/Projects/relay/src/query-config/__mocks__/RelayQueryConfig.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\n'use strict';\n\nvar RelayQueryConfig = require.requireActual('RelayQueryConfig');\n\nRelayQueryConfig.genMock = jest.genMockFunction().mockImplementation(() => {\n  class MockQueryConfig extends RelayQueryConfig {}\n  MockQueryConfig.routeName = 'MockQueryConfig';\n  return MockQueryConfig;\n});\n\nRelayQueryConfig.genMockInstance = jest.genMockFunction().mockImplementation(\n  () => new (RelayQueryConfig.genMock())()\n);\n\nmodule.exports = RelayQueryConfig;\n","dependencies":["RelayQueryConfig"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n */\n\n'use strict';\n\nvar RelayQueryConfig = require.requireActual('RelayQueryConfig');\n\nRelayQueryConfig.genMock = jest.genMockFunction().mockImplementation(() => {\n  class MockQueryConfig extends RelayQueryConfig {}\n  MockQueryConfig.routeName = 'MockQueryConfig';\n  return MockQueryConfig;\n});\n\nRelayQueryConfig.genMockInstance = jest.genMockFunction().mockImplementation(\n  () => new (RelayQueryConfig.genMock())()\n);\n\nmodule.exports = RelayQueryConfig;\n"},"name":"/Users/cpojer/Projects/relay/src/query-config/__mocks__/RelayQueryConfig.js"}},"/Users/cpojer/Projects/relay/src/query-config/__tests__/RelayQueryConfig-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":" /**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryConfig', () => {\n  var makeConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    makeConfig = function() {\n      class MockConfig extends RelayQueryConfig <{\n        required: string,\n        optional?: string\n      }> {}\n      MockConfig.routeName = 'MockConfig';\n      MockConfig.queries = {\n        required: Component => Relay.QL`\n          query {\n            node(id:$required) {\n              ${Component.getQuery('required')}\n            }\n          }\n        `,\n        optional: Component => Relay.QL`\n          query {\n            node(id:$optional) {\n              ${Component.getQuery('optional')}\n            }\n          }\n        `,\n      };\n      return MockConfig;\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('can be created using inheritance', () => {\n    var MockConfig = makeConfig();\n    var config = new MockConfig({required: 'foo'});\n    expect(config.name).toEqual('MockConfig');\n    expect(config.params.required).toEqual('foo');\n    expect(config.queries.required).toBeTruthy();\n  });\n\n  it('has an immutable spec in __DEV__', () => {\n    var dev = __DEV__;\n    window.__DEV__ = true;\n\n    var MockConfig = makeConfig();\n    var config = new MockConfig({required: 'foo'});\n    expect(() => config.name = 'yo').toThrow();\n    expect(() => config.params = 'I am').toThrow();\n    expect(() => config.queries = 'immutable').toThrow();\n    expect(() => config.params.foo = 'bar').toThrow();\n    expect(() => config.queries.myCustomQuery = () => {}).toThrow();\n\n    window.__DEV__ = dev;\n  });\n\n  it('allows params to be processed if `prepareParams` is defined', () => {\n    var MockConfig = makeConfig();\n    MockConfig.prototype.prepareVariables =\n      jest.genMockFunction().mockReturnValue({required: 'bar'});\n    var config = new MockConfig({required: 'foo'});\n    expect(MockConfig.prototype.prepareVariables)\n      .toBeCalledWith({required: 'foo'});\n    expect(config.params.required).toEqual('bar');\n  });\n\n  it('exposes queries in the queries property', () => {\n    var MockConfig = makeConfig();\n    var config = new MockConfig({required: 'foo'});\n    expect(config.queries.required).toBeTruthy();\n    expect(config.queries.optional).toBeTruthy();\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQueryConfig","RelayTestUtils"],"source":" /**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryConfig', () => {\n  var makeConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    makeConfig = function() {\n      class MockConfig extends RelayQueryConfig <{\n        required: string,\n        optional?: string\n      }> {}\n      MockConfig.routeName = 'MockConfig';\n      MockConfig.queries = {\n        required: Component => Relay.QL`\n          query {\n            node(id:$required) {\n              ${Component.getQuery('required')}\n            }\n          }\n        `,\n        optional: Component => Relay.QL`\n          query {\n            node(id:$optional) {\n              ${Component.getQuery('optional')}\n            }\n          }\n        `,\n      };\n      return MockConfig;\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('can be created using inheritance', () => {\n    var MockConfig = makeConfig();\n    var config = new MockConfig({required: 'foo'});\n    expect(config.name).toEqual('MockConfig');\n    expect(config.params.required).toEqual('foo');\n    expect(config.queries.required).toBeTruthy();\n  });\n\n  it('has an immutable spec in __DEV__', () => {\n    var dev = __DEV__;\n    window.__DEV__ = true;\n\n    var MockConfig = makeConfig();\n    var config = new MockConfig({required: 'foo'});\n    expect(() => config.name = 'yo').toThrow();\n    expect(() => config.params = 'I am').toThrow();\n    expect(() => config.queries = 'immutable').toThrow();\n    expect(() => config.params.foo = 'bar').toThrow();\n    expect(() => config.queries.myCustomQuery = () => {}).toThrow();\n\n    window.__DEV__ = dev;\n  });\n\n  it('allows params to be processed if `prepareParams` is defined', () => {\n    var MockConfig = makeConfig();\n    MockConfig.prototype.prepareVariables =\n      jest.genMockFunction().mockReturnValue({required: 'bar'});\n    var config = new MockConfig({required: 'foo'});\n    expect(MockConfig.prototype.prepareVariables)\n      .toBeCalledWith({required: 'foo'});\n    expect(config.params.required).toEqual('bar');\n  });\n\n  it('exposes queries in the queries property', () => {\n    var MockConfig = makeConfig();\n    var config = new MockConfig({required: 'foo'});\n    expect(config.queries.required).toBeTruthy();\n    expect(config.queries.optional).toBeTruthy();\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query-config/__tests__/RelayQueryConfig-test.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/toGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('toGraphQL');\n","dependencies":["toGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('toGraphQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/toGraphQL.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/stableStringify.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('stableStringify');\n","dependencies":["stableStringify"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('stableStringify');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/stableStringify.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/serializeRelayQueryCall.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"  /**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('serializeRelayQueryCall');\n","dependencies":["serializeRelayQueryCall"],"source":"  /**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('serializeRelayQueryCall');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/serializeRelayQueryCall.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayRouteFragment.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRouteFragment');\n","dependencies":["RelayRouteFragment"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRouteFragment');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayRouteFragment.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayRefQueryDescriptor.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRefQueryDescriptor');\n","dependencies":["RelayRefQueryDescriptor"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayRefQueryDescriptor');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayRefQueryDescriptor.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQueryVisitor.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryVisitor');\n","dependencies":["RelayQueryVisitor"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryVisitor');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQueryVisitor.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQueryTransform.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryTransform');\n","dependencies":["RelayQueryTransform"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryTransform');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQueryTransform.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQueryPath.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayQueryPath = require.requireActual('RelayQueryPath');\n\nRelayQueryPath.fromJSON = jest.genMockFunction().mockImplementation(\n  RelayQueryPath.fromJSON\n);\n\nmodule.exports = RelayQueryPath;\n","dependencies":["RelayQueryPath"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayQueryPath = require.requireActual('RelayQueryPath');\n\nRelayQueryPath.fromJSON = jest.genMockFunction().mockImplementation(\n  RelayQueryPath.fromJSON\n);\n\nmodule.exports = RelayQueryPath;\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQueryPath.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQuery');\n","dependencies":["RelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQuery.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQL');\n","dependencies":["RelayQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayQL.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayFragmentReference.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayFragmentReference');\n","dependencies":["RelayFragmentReference"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayFragmentReference');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayFragmentReference.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayFragmentPointer.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayFragmentPointer = require.requireActual('RelayFragmentPointer');\n\nRelayFragmentPointer.createForRoot =\n  jest.genMockFunction().mockImplementation(\n    RelayFragmentPointer.createForRoot\n  );\n\nmodule.exports = RelayFragmentPointer;\n","dependencies":["RelayFragmentPointer"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar RelayFragmentPointer = require.requireActual('RelayFragmentPointer');\n\nRelayFragmentPointer.createForRoot =\n  jest.genMockFunction().mockImplementation(\n    RelayFragmentPointer.createForRoot\n  );\n\nmodule.exports = RelayFragmentPointer;\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/RelayFragmentPointer.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/QueryBuilder.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('QueryBuilder');\n","dependencies":["QueryBuilder"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('QueryBuilder');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/QueryBuilder.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/generateRQLFieldAlias.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('generateRQLFieldAlias')\n);\n","dependencies":["generateRQLFieldAlias"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = jest.genMockFunction().mockImplementation(\n  require.requireActual('generateRQLFieldAlias')\n);\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/generateRQLFieldAlias.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/generateConcreteFragmentID.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('generateConcreteFragmentID');\n","dependencies":["generateConcreteFragmentID"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('generateConcreteFragmentID');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/generateConcreteFragmentID.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/fromGraphQLQuery.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('fromGraphQLQuery');\n","dependencies":["fromGraphQLQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('fromGraphQLQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/fromGraphQLQuery.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/fromGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('fromGraphQL');\n","dependencies":["fromGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('fromGraphQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/fromGraphQL.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/forEachRootCallArg.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('forEachRootCallArg');\n","dependencies":["forEachRootCallArg"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('forEachRootCallArg');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/forEachRootCallArg.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/directivesToGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('directivesToGraphQL');\n","dependencies":["directivesToGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('directivesToGraphQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/directivesToGraphQL.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/createRelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('createRelayQuery');\n","dependencies":["createRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('createRelayQuery');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/createRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/callsToGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('callsToGraphQL');\n","dependencies":["callsToGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('callsToGraphQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/callsToGraphQL.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/callsFromGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('callsFromGraphQL');\n","dependencies":["callsFromGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('callsFromGraphQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/callsFromGraphQL.js"}},"/Users/cpojer/Projects/relay/src/query/__mocks__/buildRQL.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('buildRQL');\n","dependencies":["buildRQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('buildRQL');\n"},"name":"/Users/cpojer/Projects/relay/src/query/__mocks__/buildRQL.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/toGraphQL-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst filterObject = require('filterObject');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\nconst toGraphQL = require('toGraphQL');\n\ndescribe('toGraphQL', function() {\n  var {defer, getNode} = RelayTestUtils;\n\n  const CONCRETE_KEYS = {\n    alias: true,\n    arguments: true,\n    calls: true,\n    children: true,\n    directives: true,\n    fieldName: true,\n    isDeferred: true,\n    jsonPath: true,\n    kind: true,\n    metadata: true,\n    name: true,\n    responseType: true,\n    sourceQueryID: true,\n    type: true,\n    value: true,\n  };\n\n  function filterGraphQLNode(node) {\n    node = filterObject(node, (value, key) => {\n      if (!CONCRETE_KEYS[key]) {\n        return false;\n      }\n      return !!value && (!Array.isArray(value) || value.length);\n    });\n    if (node.calls) {\n      node.calls = node.calls.length ?\n        node.calls.map(filterGraphQLNode) :\n        null;\n    }\n    if (node.children) {\n      node.children = node.children.length ?\n        node.children.map(filterGraphQLNode) :\n        null;\n    }\n    if (node.directives) {\n      node.directives = node.directives.length ?\n        node.directives.map(filterGraphQLNode) :\n        null;\n    }\n    if (node.metadata) {\n      node.metadata = filterObject(\n        node.metadata,\n        value => !!value\n      );\n    }\n    return node;\n  }\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers({\n      toConvert() {\n        return {\n          compare(actual, query) {\n            // This filters out extraneous properties from `GraphQL.*` nodes\n            // such as `fields` or `fragments`, and reduces metadata down to\n            // compare only truthy values. Once the printer outputs plain values\n            // the filter step can be removed or simplified (might want to still\n            // filter metadata).\n            var expected = filterGraphQLNode(query);\n            expect(filterGraphQLNode(actual(getNode(query)))).toEqual(expected);\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('converts query', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            name\n          }\n        }\n      }\n    `);\n  });\n\n  it('converts query with root args', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        nodes(ids:[\"1\",\"2\",\"3\"]) {\n          id,\n          name\n        }\n      }\n    `);\n  });\n\n  it('converts fragment', () => {\n    expect(toGraphQL.Fragment).toConvert(Relay.QL`\n      fragment on Viewer {\n        actor {\n          id,\n          name\n        }\n      }\n    `);\n  });\n\n  it('converts field with calls', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            url(site:\"www\")\n          }\n        }\n      }\n    `);\n  });\n\n  it('converts connection and generated fields', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        viewer {\n          actor {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n  });\n\n  it('preserves batch call information', () => {\n    var fragment = Relay.QL`\n      fragment on User {\n        name\n      }\n    `;\n    var query = Relay.QL`\n      query {\n        viewer {\n          actor {\n            ${defer(fragment)},\n          }\n        }\n      }\n    `;\n    var splitQueries = splitDeferredRelayQueries(getNode(query));\n    var deferredQuery = toGraphQL.Query(splitQueries.deferred[0].required);\n    var batchCall = deferredQuery.calls[0].value;\n\n    expect(deferredQuery.isDeferred).toBe(true);\n    expect(batchCall.sourceQueryID).toBe('q1');\n    expect(batchCall.jsonPath).toBe('$.*.actor.id');\n  });\n\n  it('does not double-encode argument values', () => {\n    var value = {query: 'Menlo Park'};\n    var relayQuery = getNode(Relay.QL`\n      query {\n        checkinSearchQuery(query:$q) {\n          query,\n        }\n      }\n    `, {\n      q: value,\n    });\n    const identifyingArg = relayQuery.getIdentifyingArg();\n    expect(identifyingArg).toBeDefined();\n    expect(identifyingArg.value).toEqual(value);\n    var convertedQuery = toGraphQL.Query(relayQuery);\n    expect(convertedQuery.calls[0].value.callValue).toBe(value);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayTestUtils","filterObject","splitDeferredRelayQueries","toGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst filterObject = require('filterObject');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\nconst toGraphQL = require('toGraphQL');\n\ndescribe('toGraphQL', function() {\n  var {defer, getNode} = RelayTestUtils;\n\n  const CONCRETE_KEYS = {\n    alias: true,\n    arguments: true,\n    calls: true,\n    children: true,\n    directives: true,\n    fieldName: true,\n    isDeferred: true,\n    jsonPath: true,\n    kind: true,\n    metadata: true,\n    name: true,\n    responseType: true,\n    sourceQueryID: true,\n    type: true,\n    value: true,\n  };\n\n  function filterGraphQLNode(node) {\n    node = filterObject(node, (value, key) => {\n      if (!CONCRETE_KEYS[key]) {\n        return false;\n      }\n      return !!value && (!Array.isArray(value) || value.length);\n    });\n    if (node.calls) {\n      node.calls = node.calls.length ?\n        node.calls.map(filterGraphQLNode) :\n        null;\n    }\n    if (node.children) {\n      node.children = node.children.length ?\n        node.children.map(filterGraphQLNode) :\n        null;\n    }\n    if (node.directives) {\n      node.directives = node.directives.length ?\n        node.directives.map(filterGraphQLNode) :\n        null;\n    }\n    if (node.metadata) {\n      node.metadata = filterObject(\n        node.metadata,\n        value => !!value\n      );\n    }\n    return node;\n  }\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers({\n      toConvert() {\n        return {\n          compare(actual, query) {\n            // This filters out extraneous properties from `GraphQL.*` nodes\n            // such as `fields` or `fragments`, and reduces metadata down to\n            // compare only truthy values. Once the printer outputs plain values\n            // the filter step can be removed or simplified (might want to still\n            // filter metadata).\n            var expected = filterGraphQLNode(query);\n            expect(filterGraphQLNode(actual(getNode(query)))).toEqual(expected);\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('converts query', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            name\n          }\n        }\n      }\n    `);\n  });\n\n  it('converts query with root args', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        nodes(ids:[\"1\",\"2\",\"3\"]) {\n          id,\n          name\n        }\n      }\n    `);\n  });\n\n  it('converts fragment', () => {\n    expect(toGraphQL.Fragment).toConvert(Relay.QL`\n      fragment on Viewer {\n        actor {\n          id,\n          name\n        }\n      }\n    `);\n  });\n\n  it('converts field with calls', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id,\n            url(site:\"www\")\n          }\n        }\n      }\n    `);\n  });\n\n  it('converts connection and generated fields', () => {\n    expect(toGraphQL.Query).toConvert(Relay.QL`\n      query {\n        viewer {\n          actor {\n            friends(first:\"5\") {\n              edges {\n                node {\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    `);\n  });\n\n  it('preserves batch call information', () => {\n    var fragment = Relay.QL`\n      fragment on User {\n        name\n      }\n    `;\n    var query = Relay.QL`\n      query {\n        viewer {\n          actor {\n            ${defer(fragment)},\n          }\n        }\n      }\n    `;\n    var splitQueries = splitDeferredRelayQueries(getNode(query));\n    var deferredQuery = toGraphQL.Query(splitQueries.deferred[0].required);\n    var batchCall = deferredQuery.calls[0].value;\n\n    expect(deferredQuery.isDeferred).toBe(true);\n    expect(batchCall.sourceQueryID).toBe('q1');\n    expect(batchCall.jsonPath).toBe('$.*.actor.id');\n  });\n\n  it('does not double-encode argument values', () => {\n    var value = {query: 'Menlo Park'};\n    var relayQuery = getNode(Relay.QL`\n      query {\n        checkinSearchQuery(query:$q) {\n          query,\n        }\n      }\n    `, {\n      q: value,\n    });\n    const identifyingArg = relayQuery.getIdentifyingArg();\n    expect(identifyingArg).toBeDefined();\n    expect(identifyingArg.value).toEqual(value);\n    var convertedQuery = toGraphQL.Query(relayQuery);\n    expect(convertedQuery.calls[0].value.callValue).toBe(value);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/toGraphQL-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/stableStringify-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst stableStringify = require('stableStringify');\n\ndescribe('stableStringify', () => {\n  it('stringifies non-objects', () => {\n    expect(stableStringify('foo')).toBe('\"foo\"');\n    expect(stableStringify(1)).toBe('1');\n    expect(stableStringify(-1)).toBe('-1');\n    expect(stableStringify(true)).toBe('true');\n    expect(stableStringify(false)).toBe('false');\n    expect(stableStringify(null)).toBe('null');\n    expect(stableStringify()).toBe(undefined);\n  });\n\n  it('stringifies empty objects', () => {\n    expect(stableStringify({})).toBe('{}');\n  });\n\n  it('stringifies empty arrays', () => {\n    expect(stableStringify([])).toBe('[]');\n  });\n\n  it('stringifies shallow objects', () => {\n    var object = {};\n    object.a = 1;\n    object.b = 2;\n    expect(stableStringify(object)).toBe('{a:1,b:2}');\n  });\n\n  it('stringifies stably, despite opposite key insertion order', () => {\n    var object = {};\n    object.b = 2;\n    object.a = 1;\n    expect(stableStringify(object)).toBe('{a:1,b:2}');\n  });\n\n  it('stringifies shallow arrays', () => {\n    var array = ['foo', 'bar', 'baz'];\n    expect(stableStringify(array)).toBe('[0:\"foo\",1:\"bar\",2:\"baz\"]');\n  });\n\n  it('skips \"holes\" in sparse arrays', () => {\n    var array = [];\n    array[5] = 'foo';\n    expect(stableStringify(array)).toBe('[5:\"foo\"]');\n  });\n\n  it('stringifies nested structures', () => {\n    var object = {\n      top2: {\n        middle: {\n          inner: [1, 'foo', ['bar', 2]],\n          other: false,\n        },\n      },\n      top1: [\n        {first: true},\n        {first: false},\n        'random',\n      ],\n      misc: true,\n      extra: null,\n    };\n\n    var expected =\n      '{' +\n      'extra:null,' +\n      'misc:true,' +\n      'top1:[0:{first:true},1:{first:false},2:\"random\"],' +\n      'top2:{middle:{inner:[0:1,1:\"foo\",2:[0:\"bar\",1:2]],other:false}}' +\n      '}';\n\n    expect(stableStringify(object)).toBe(expected);\n  });\n});\n","dependencies":["stableStringify"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst stableStringify = require('stableStringify');\n\ndescribe('stableStringify', () => {\n  it('stringifies non-objects', () => {\n    expect(stableStringify('foo')).toBe('\"foo\"');\n    expect(stableStringify(1)).toBe('1');\n    expect(stableStringify(-1)).toBe('-1');\n    expect(stableStringify(true)).toBe('true');\n    expect(stableStringify(false)).toBe('false');\n    expect(stableStringify(null)).toBe('null');\n    expect(stableStringify()).toBe(undefined);\n  });\n\n  it('stringifies empty objects', () => {\n    expect(stableStringify({})).toBe('{}');\n  });\n\n  it('stringifies empty arrays', () => {\n    expect(stableStringify([])).toBe('[]');\n  });\n\n  it('stringifies shallow objects', () => {\n    var object = {};\n    object.a = 1;\n    object.b = 2;\n    expect(stableStringify(object)).toBe('{a:1,b:2}');\n  });\n\n  it('stringifies stably, despite opposite key insertion order', () => {\n    var object = {};\n    object.b = 2;\n    object.a = 1;\n    expect(stableStringify(object)).toBe('{a:1,b:2}');\n  });\n\n  it('stringifies shallow arrays', () => {\n    var array = ['foo', 'bar', 'baz'];\n    expect(stableStringify(array)).toBe('[0:\"foo\",1:\"bar\",2:\"baz\"]');\n  });\n\n  it('skips \"holes\" in sparse arrays', () => {\n    var array = [];\n    array[5] = 'foo';\n    expect(stableStringify(array)).toBe('[5:\"foo\"]');\n  });\n\n  it('stringifies nested structures', () => {\n    var object = {\n      top2: {\n        middle: {\n          inner: [1, 'foo', ['bar', 2]],\n          other: false,\n        },\n      },\n      top1: [\n        {first: true},\n        {first: false},\n        'random',\n      ],\n      misc: true,\n      extra: null,\n    };\n\n    var expected =\n      '{' +\n      'extra:null,' +\n      'misc:true,' +\n      'top1:[0:{first:true},1:{first:false},2:\"random\"],' +\n      'top2:{middle:{inner:[0:1,1:\"foo\",2:[0:\"bar\",1:2]],other:false}}' +\n      '}';\n\n    expect(stableStringify(object)).toBe(expected);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/stableStringify-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/serializeRelayQueryCall-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\n\ndescribe('serializeRelayQueryCall', () => {\n  it('serializes a call with a null argument', () => {\n    var call = {\n      name: 'me',\n      value: null,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.me()');\n  });\n\n  it('serializes a call with an undefined argument', () => {\n    var call = {\n      name: 'me',\n      value: undefined,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.me()');\n  });\n\n  it('serializes a call with a string argument', () => {\n    var call = {\n      name: 'first',\n      value: '5',\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.first(5)');\n  });\n\n  it('serializes a call with a numeric argument', () => {\n    var call = {\n      name: 'first',\n      value: 5,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.first(5)');\n  });\n\n  it('serializes a call with `true` argument', () => {\n    var call = {\n      name: 'if',\n      value: true,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.if(true)');\n  });\n\n  it('serializes a call with `false` argument', () => {\n    var call = {\n      name: 'unless',\n      value: false,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.unless(false)');\n  });\n\n  it('serializes a call with many arguments', () => {\n    var call = {\n      name: 'usernames',\n      value: ['glh', 'joesavona'],\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.usernames(glh,joesavona)');\n  });\n\n  it('sanitizes argument values', () => {\n    var call = {\n      name: 'checkin_search_query',\n      value: JSON.stringify({query: 'Menlo Park'}),\n    };\n    expect(serializeRelayQueryCall(call)).toEqual(\n      '.checkin_search_query({\"query\":\"Menlo Park\"})'\n    );\n  });\n\n  it('serializes empty string values', () => {\n    var call = {\n      name: 'query',\n      value: '',\n    };\n    expect(serializeRelayQueryCall(call)).toEqual(\n      '.query()'\n    );\n  });\n\n  it('serializes string values with leading/trailing whitespace', () => {\n    var call = {\n      name: 'query',\n      value: ' ',\n    };\n    expect(serializeRelayQueryCall(call)).toEqual(\n      '.query( )'\n    );\n  });\n});\n","dependencies":["serializeRelayQueryCall"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\n\ndescribe('serializeRelayQueryCall', () => {\n  it('serializes a call with a null argument', () => {\n    var call = {\n      name: 'me',\n      value: null,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.me()');\n  });\n\n  it('serializes a call with an undefined argument', () => {\n    var call = {\n      name: 'me',\n      value: undefined,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.me()');\n  });\n\n  it('serializes a call with a string argument', () => {\n    var call = {\n      name: 'first',\n      value: '5',\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.first(5)');\n  });\n\n  it('serializes a call with a numeric argument', () => {\n    var call = {\n      name: 'first',\n      value: 5,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.first(5)');\n  });\n\n  it('serializes a call with `true` argument', () => {\n    var call = {\n      name: 'if',\n      value: true,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.if(true)');\n  });\n\n  it('serializes a call with `false` argument', () => {\n    var call = {\n      name: 'unless',\n      value: false,\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.unless(false)');\n  });\n\n  it('serializes a call with many arguments', () => {\n    var call = {\n      name: 'usernames',\n      value: ['glh', 'joesavona'],\n    };\n    expect(serializeRelayQueryCall(call)).toEqual('.usernames(glh,joesavona)');\n  });\n\n  it('sanitizes argument values', () => {\n    var call = {\n      name: 'checkin_search_query',\n      value: JSON.stringify({query: 'Menlo Park'}),\n    };\n    expect(serializeRelayQueryCall(call)).toEqual(\n      '.checkin_search_query({\"query\":\"Menlo Park\"})'\n    );\n  });\n\n  it('serializes empty string values', () => {\n    var call = {\n      name: 'query',\n      value: '',\n    };\n    expect(serializeRelayQueryCall(call)).toEqual(\n      '.query()'\n    );\n  });\n\n  it('serializes string values with leading/trailing whitespace', () => {\n    var call = {\n      name: 'query',\n      value: ' ',\n    };\n    expect(serializeRelayQueryCall(call)).toEqual(\n      '.query( )'\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/serializeRelayQueryCall-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryVisitor-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryVisitor', () => {\n  var {getNode} = RelayTestUtils;\n  var query;\n\n  beforeEach(() => {\n    var variables = {\n      first: 10,\n      after: 'offset',\n    };\n\n    var fragment = Relay.QL`\n      fragment on User {\n        friends(first:$first,after:$after) {\n          edges {\n            node {\n              id,\n              name,\n              address {\n                city\n              }\n            }\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          ${fragment},\n          friends(first:$first,after:$after) {\n            edges {\n              node {\n                id,\n                firstName,\n                address {\n                  city,\n                }\n              }\n            }\n          }\n        }\n      }\n    `, null, variables);\n  });\n\n  it('traverses fields in-order', () => {\n    class InOrder extends RelayQueryVisitor<Array> {\n      visitField(field: RelayQuery.Field, state: Array): ?RelayQuery.Node {\n        state.push(field.getSchemaName());\n        this.traverse(field, state);\n      }\n    }\n    var transform = new InOrder();\n    var fields = [];\n    transform.visit(query, fields);\n\n    var expectedFields = [];\n    function traverse(node: RelayQuery.Node): void {\n      if (node instanceof RelayQuery.Field) {\n        expectedFields.push(node.getSchemaName());\n      }\n      node.getChildren().forEach(c => traverse(c));\n    }\n    traverse(query);\n\n    expect(fields.length).toBe(expectedFields.length);\n    expect(fields.every((f, ii) => f === expectedFields[ii])).toBeTruthy();\n  });\n\n  it('returns original input', () => {\n    class Visitor extends RelayQueryVisitor<any> {}\n\n    var transform = new Visitor();\n    var output = transform.visit(query, null);\n    expect(output === query).toBeTruthy();\n  });\n\n  it('returns the query intact when the visit methods return `null`', () => {\n    class NullReturningVisitor extends RelayQueryVisitor<any> {\n      visitField(field: RelayQuery.Field, state: any): ?RelayQuery.Node {\n        this.traverse(field, state);\n        return null;\n      }\n    }\n\n    var transform = new NullReturningVisitor();\n    var output = transform.visit(query, null);\n    expect(output).toBe(query);\n  });\n\n  it('does not automatically traverse subtrees when visitor is defined', () => {\n    class NoTraversal extends RelayQueryVisitor<Array> {\n      visitField(\n        field: RelayQuery.Field,\n        state: Array\n      ): ?RelayQuery.Node {\n        // should never get here\n        state.push(field.getSchemaName());\n        return field;\n      }\n\n      visitFragment(\n        fragment: RelayQuery.Fragment,\n        state: Array\n      ): ?RelayQuery.Node {\n        // should never get here\n        state.push(fragment.getName());\n        return fragment;\n      }\n\n      visitRoot(\n        root: RelayQuery.Root,\n        state: Array\n      ): ?RelayQuery.Node {\n        state.push(query.getName());\n        // should stop transform from looking at fields/fragments\n        return root;\n      }\n    }\n\n    var transform = new NoTraversal();\n    var fields = [];\n    transform.visit(query, fields);\n    expect(fields).toEqual(['RelayQueryVisitor']);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayQueryVisitor","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryVisitor', () => {\n  var {getNode} = RelayTestUtils;\n  var query;\n\n  beforeEach(() => {\n    var variables = {\n      first: 10,\n      after: 'offset',\n    };\n\n    var fragment = Relay.QL`\n      fragment on User {\n        friends(first:$first,after:$after) {\n          edges {\n            node {\n              id,\n              name,\n              address {\n                city\n              }\n            }\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          ${fragment},\n          friends(first:$first,after:$after) {\n            edges {\n              node {\n                id,\n                firstName,\n                address {\n                  city,\n                }\n              }\n            }\n          }\n        }\n      }\n    `, null, variables);\n  });\n\n  it('traverses fields in-order', () => {\n    class InOrder extends RelayQueryVisitor<Array> {\n      visitField(field: RelayQuery.Field, state: Array): ?RelayQuery.Node {\n        state.push(field.getSchemaName());\n        this.traverse(field, state);\n      }\n    }\n    var transform = new InOrder();\n    var fields = [];\n    transform.visit(query, fields);\n\n    var expectedFields = [];\n    function traverse(node: RelayQuery.Node): void {\n      if (node instanceof RelayQuery.Field) {\n        expectedFields.push(node.getSchemaName());\n      }\n      node.getChildren().forEach(c => traverse(c));\n    }\n    traverse(query);\n\n    expect(fields.length).toBe(expectedFields.length);\n    expect(fields.every((f, ii) => f === expectedFields[ii])).toBeTruthy();\n  });\n\n  it('returns original input', () => {\n    class Visitor extends RelayQueryVisitor<any> {}\n\n    var transform = new Visitor();\n    var output = transform.visit(query, null);\n    expect(output === query).toBeTruthy();\n  });\n\n  it('returns the query intact when the visit methods return `null`', () => {\n    class NullReturningVisitor extends RelayQueryVisitor<any> {\n      visitField(field: RelayQuery.Field, state: any): ?RelayQuery.Node {\n        this.traverse(field, state);\n        return null;\n      }\n    }\n\n    var transform = new NullReturningVisitor();\n    var output = transform.visit(query, null);\n    expect(output).toBe(query);\n  });\n\n  it('does not automatically traverse subtrees when visitor is defined', () => {\n    class NoTraversal extends RelayQueryVisitor<Array> {\n      visitField(\n        field: RelayQuery.Field,\n        state: Array\n      ): ?RelayQuery.Node {\n        // should never get here\n        state.push(field.getSchemaName());\n        return field;\n      }\n\n      visitFragment(\n        fragment: RelayQuery.Fragment,\n        state: Array\n      ): ?RelayQuery.Node {\n        // should never get here\n        state.push(fragment.getName());\n        return fragment;\n      }\n\n      visitRoot(\n        root: RelayQuery.Root,\n        state: Array\n      ): ?RelayQuery.Node {\n        state.push(query.getName());\n        // should stop transform from looking at fields/fragments\n        return root;\n      }\n    }\n\n    var transform = new NoTraversal();\n    var fields = [];\n    transform.visit(query, fields);\n    expect(fields).toEqual(['RelayQueryVisitor']);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryVisitor-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryTransform-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryTransform', () => {\n  var {getNode} = RelayTestUtils;\n  var query;\n\n  beforeEach(() => {\n    var variables = {\n      first: 10,\n      after: 'offset',\n    };\n\n    var fragment = Relay.QL`\n      fragment on User {\n        friends(first:$first,after:$after) {\n          edges {\n            node {\n              id,\n              name,\n              address {\n                city\n              }\n            }\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          ${fragment},\n          friends(first:$first,after:$after) {\n            edges {\n              node {\n                id,\n                lastName,\n                address {\n                  city,\n                }\n              }\n            }\n          }\n        }\n      }\n    `, null, variables);\n  });\n\n  it('returns original input', () => {\n    class NoOp extends RelayQueryTransform<any> {}\n\n    var transform = new NoOp();\n    var output = transform.visit(query, null);\n    expect(output).toBe(query);\n  });\n\n  it('returns null if field visitors all return null for scalars', () => {\n    class Nullify extends RelayQueryTransform<any> {\n      visitField(field: RelayQuery.Field, state: any): ?RelayQuery.Node {\n        if (!field.canHaveSubselections()) {\n          return null;\n        }\n        return this.traverse(field, state);\n      }\n    }\n\n    var transform = new Nullify();\n    var output = transform.visit(query, null);\n    expect(output).toBe(null);\n  });\n\n  it('returns cloned versions of fields', () => {\n    class RemoveIDs extends RelayQueryTransform<Array> {\n      visitField(field: RelayQuery.Field, state: Array): ?RelayQuery.Node {\n        // print `id` but filter from output\n        state.push(field.getSchemaName());\n        if (field.getSchemaName() === 'id') {\n          return null;\n        }\n        return this.traverse(field, state);\n      }\n    }\n\n    var transform = new RemoveIDs();\n    var fields = [];\n    var output = transform.visit(query, fields);\n\n    var expectedFields = [];\n    function traverse(node: RelayQuery.Node): void {\n      if (node instanceof RelayQuery.Field) {\n        expectedFields.push(node.getSchemaName());\n      }\n      node.getChildren().forEach(c => traverse(c));\n    }\n    traverse(output);\n\n    // output should be missing the id fields\n    expect(expectedFields.length).not.toBe(fields.length);\n    fields = fields.filter(name => name !== 'id');\n    expect(fields.length).toBe(expectedFields.length);\n    expect(fields.every((f, ii) => f === expectedFields[ii])).toBe(true);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayQueryTransform","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryTransform', () => {\n  var {getNode} = RelayTestUtils;\n  var query;\n\n  beforeEach(() => {\n    var variables = {\n      first: 10,\n      after: 'offset',\n    };\n\n    var fragment = Relay.QL`\n      fragment on User {\n        friends(first:$first,after:$after) {\n          edges {\n            node {\n              id,\n              name,\n              address {\n                city\n              }\n            }\n          }\n        }\n      }\n    `;\n    query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          id,\n          ${fragment},\n          friends(first:$first,after:$after) {\n            edges {\n              node {\n                id,\n                lastName,\n                address {\n                  city,\n                }\n              }\n            }\n          }\n        }\n      }\n    `, null, variables);\n  });\n\n  it('returns original input', () => {\n    class NoOp extends RelayQueryTransform<any> {}\n\n    var transform = new NoOp();\n    var output = transform.visit(query, null);\n    expect(output).toBe(query);\n  });\n\n  it('returns null if field visitors all return null for scalars', () => {\n    class Nullify extends RelayQueryTransform<any> {\n      visitField(field: RelayQuery.Field, state: any): ?RelayQuery.Node {\n        if (!field.canHaveSubselections()) {\n          return null;\n        }\n        return this.traverse(field, state);\n      }\n    }\n\n    var transform = new Nullify();\n    var output = transform.visit(query, null);\n    expect(output).toBe(null);\n  });\n\n  it('returns cloned versions of fields', () => {\n    class RemoveIDs extends RelayQueryTransform<Array> {\n      visitField(field: RelayQuery.Field, state: Array): ?RelayQuery.Node {\n        // print `id` but filter from output\n        state.push(field.getSchemaName());\n        if (field.getSchemaName() === 'id') {\n          return null;\n        }\n        return this.traverse(field, state);\n      }\n    }\n\n    var transform = new RemoveIDs();\n    var fields = [];\n    var output = transform.visit(query, fields);\n\n    var expectedFields = [];\n    function traverse(node: RelayQuery.Node): void {\n      if (node instanceof RelayQuery.Field) {\n        expectedFields.push(node.getSchemaName());\n      }\n      node.getChildren().forEach(c => traverse(c));\n    }\n    traverse(output);\n\n    // output should be missing the id fields\n    expect(expectedFields.length).not.toBe(fields.length);\n    fields = fields.filter(name => name !== 'id');\n    expect(fields.length).toBe(expectedFields.length);\n    expect(fields.every((f, ii) => f === expectedFields[ii])).toBe(true);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryTransform-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryRoot-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryRoot', () => {\n  var {getNode} = RelayTestUtils;\n\n  var me;\n  var usernames;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    me = getNode(Relay.QL`\n      query {\n        me {\n          name1: firstName,\n          name1: lastName,\n        }\n      }\n    `);\n\n    usernames = getNode(Relay.QL`\n      query {\n        usernames(names:\"mroch\") {\n          firstName,\n        }\n      }\n    `);\n    usernames.getConcreteQueryNode().metadata = {\n      isPlural: true,\n      identifyingArgName: 'names',\n    };\n  });\n\n  it('has a unique ID', () => {\n    var lastID = getNode(Relay.QL`query{me{firstName}}`).getID();\n    var nextID = getNode(Relay.QL`query{me{lastName}}`).getID();\n    expect(lastID).toMatch(/^q\\d+/);\n    expect(nextID).toMatch(/^q\\d+/);\n    expect(nextID).not.toEqual(lastID);\n  });\n\n  it('returns children', () => {\n    var children = me.getChildren();\n    expect(children.length).toBe(3);\n    expect(children[0].getSchemaName()).toBe('firstName');\n    expect(children[1].getSchemaName()).toBe('lastName');\n    expect(children[2].getSchemaName()).toBe('id');\n    expect(children[2].isGenerated()).toBe(true);\n\n    children = usernames.getChildren();\n    expect(children.length).toBe(3);\n    expect(children[0].getSchemaName()).toBe('firstName');\n    expect(children[1].getSchemaName()).toBe('id');\n    expect(children[1].isGenerated()).toBe(true);\n    expect(children[2].getSchemaName()).toBe('__typename');\n    expect(children[2].isGenerated()).toBe(true);\n  });\n\n  it('does not return skipped children', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          id,\n          firstName @skip(if: $true),\n          lastName @include(if: $false),\n          name @skip(if: $true) @include(if: false),\n          emailAddresses @skip(if: $true) @include(if: true),\n          username @skip(if: $false) @include(if: false),\n        }\n      }\n    `, {true: true, false: false});\n    var children = query.getChildren();\n    expect(children.length).toBe(1);\n    expect(children[0].getSchemaName()).toBe('id');\n  });\n\n  it('returns included children', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          id,\n          firstName @skip(if: $false),\n          lastName @include(if: $true),\n          name @skip(if: false) @include(if: $true),\n        }\n      }\n    `, {false: false, true: true});\n    var children = query.getChildren();\n    expect(children.length).toBe(4);\n    expect(children[0].getSchemaName()).toBe('id');\n    expect(children[1].getSchemaName()).toBe('firstName');\n    expect(children[2].getSchemaName()).toBe('lastName');\n    expect(children[3].getSchemaName()).toBe('name');\n  });\n\n  it('returns same object when cloning with same fields', () => {\n    var children = me.getChildren();\n    expect(me.clone(children)).toBe(me);\n    expect(me.clone(children.map(c => c))).toBe(me);\n    expect(me.clone(\n      [null, children[0], null, children[1], null, children[2], null]\n    )).toBe(me);\n\n    children = usernames.getChildren();\n    expect(usernames.clone(children)).toBe(usernames);\n    expect(usernames.clone(children.map(c => c))).toBe(usernames);\n  });\n\n  it('returns null when cloning without fields', () => {\n    expect(me.clone([])).toBe(null);\n    expect(me.clone([null])).toBe(null);\n    expect(usernames.clone([])).toBe(null);\n    expect(usernames.clone([null])).toBe(null);\n  });\n\n  it('returns new object when cloning with different fields', () => {\n    var children = me.getChildren();\n    expect(me.clone([children[0], null])).not.toBe(me);\n    expect(me.clone([children[0], null, null])).not.toBe(me);\n    expect(me.clone([children[0], null, null, null])).not.toBe(me);\n  });\n\n  it('clones with updated children', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          firstName,\n          lastName\n        }\n      }\n    `);\n    var clone = query.clone([query.getChildren()[0]]);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe('firstName');\n    expect(clone.getFieldByStorageKey('lastName')).toBe(undefined);\n  });\n\n  it('returns root calls with values', () => {\n    expect(me.getIdentifyingArg()).toEqual(undefined);\n\n    expect(usernames.getIdentifyingArg()).toEqual(\n      {name: 'names', value: 'mroch'}\n    );\n\n    expect(getNode(Relay.QL`\n      query {\n        usernames(names:[\"a\",\"b\",\"c\"]) {\n          firstName\n        }\n      }\n    `).getIdentifyingArg()).toEqual(\n      {name: 'names', value: ['a', 'b', 'c']}\n    );\n  });\n\n  it('returns ref params', () => {\n    // non-ref query:\n    expect(me.getBatchCall()).toBe(null);\n\n    // ref query:\n    var root = getNode({\n      ...Relay.QL`\n        query {\n          node(id: \"123\") {\n            id\n          }\n        }\n      `,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    var batchCall = root.getBatchCall();\n    expect(batchCall).toEqual({\n      refParamName: 'ref_q0',\n      sourceQueryID: 'q0',\n      sourceQueryPath: '$.*.actor.id',\n    });\n  });\n\n  it('is not equal to non-root nodes', () => {\n    var fragment = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          id\n        }\n      }\n    `);\n    var id = fragment.getChildren()[0].getChildren()[0];\n    expect(me.equals(fragment)).toBe(false);\n    expect(me.equals(id)).toBe(false);\n  });\n\n  it('is not equal to queries with different root calls', () => {\n    var diffRoot = getNode(Relay.QL`\n      query {\n        usernames(names:\"joesavona\") {\n          firstName\n        }\n      }\n    `);\n    expect(usernames.equals(diffRoot)).toBe(false);\n  });\n\n  it('equals the same query', () => {\n    expect(usernames.equals(usernames)).toBe(true);\n    expect(me.equals(me)).toBe(true);\n  });\n\n  it('equals equivalent queries', () => {\n    var me2 = getNode(Relay.QL`\n      query {\n        me {\n          name1: firstName,\n          name1: lastName,\n        }\n      }\n    `);\n\n    var usernames2 = getNode(Relay.QL`\n      query {\n        usernames(names:\"mroch\") {\n          firstName,\n        }\n      }\n    `);\n    usernames2.getConcreteQueryNode().metadata = {\n      isPlural: true,\n      identifyingArgName: 'names',\n    };\n\n    expect(me.equals(me2)).toBe(true);\n    expect(usernames.equals(usernames2)).toBe(true);\n    expect(me2.equals(me)).toBe(true);\n    expect(usernames2.equals(usernames)).toBe(true);\n  });\n\n  it('does not equal different queries with the same root', () => {\n    var me2 = getNode(Relay.QL`\n      query {\n        me {\n          name1: firstName,\n          lastName,\n        }\n      }\n    `);\n\n    var usernames2 = getNode(Relay.QL`\n      query {\n        usernames(names:\"mroch\") {\n          firstName,\n          lastName\n        }\n      }\n    `);\n    expect(me.equals(me2)).toBe(false);\n    expect(usernames.equals(usernames2)).toBe(false);\n    expect(me2.equals(me)).toBe(false);\n    expect(usernames2.equals(usernames)).toBe(false);\n  });\n\n  it('equals identical ref queries with matching ref params', () => {\n    var node = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    var other = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    expect(node.equals(other)).toBe(true);\n  });\n\n  it('does not equal queries with different ref params', () => {\n    var node = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    var other = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable(\n          'q0',\n          '$.*.actor.current_city.id'\n        )\n      )],\n    });\n    expect(node.equals(other)).toBe(false);\n  });\n\n  it('is not a ref query dependency', () => {\n    expect(me.isRefQueryDependency()).toBe(false);\n  });\n\n  it('is not generated', () => {\n    expect(me.isGenerated()).toBe(false);\n  });\n\n  it('returns the identifying argument type', () => {\n    var nodeQuery = getNode(Relay.QL`query{node(id:\"123\"){id}}`);\n    nodeQuery.getConcreteQueryNode().metadata = {\n      identifyingArgName: 'id',\n      identifyingArgType: 'scalar',\n    };\n    const nodeIdentifyingArg = nodeQuery.getIdentifyingArg();\n    expect(nodeIdentifyingArg).toBeDefined();\n    expect(nodeIdentifyingArg.type).toBe('scalar');\n\n    var me = getNode(Relay.QL`query{me{id}}`);\n    const meIdentifyingArg = me.getIdentifyingArg();\n    expect(meIdentifyingArg).toBeUndefined();\n  });\n\n  it('creates nodes', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var node = Relay.QL`\n      fragment on Viewer {\n        actor {\n          id\n        }\n      }\n    `;\n    var actorID = query.createNode(node);\n    expect(actorID instanceof RelayQuery.Fragment).toBe(true);\n    expect(actorID.getType()).toBe('Viewer');\n    expect(actorID.getRoute()).toBe(query.getRoute());\n    expect(actorID.getVariables()).toBe(query.getVariables());\n  });\n\n  it('returns directives', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me @include(if: $cond) {\n          id\n        }\n      }\n    `, {cond: true});\n    expect(query.getDirectives()).toEqual([\n      {\n        args: [\n          {name: 'if', value: true},\n        ],\n        name: 'include',\n      },\n    ]);\n  });\n\n  it('returns isAbstract', () => {\n    expect(getNode(Relay.QL`query { me }`).isAbstract()).toBe(false);\n    expect(getNode(Relay.QL`query { viewer }`).isAbstract()).toBe(false);\n    expect(getNode(Relay.QL`query { node(id: \"4\") }`).isAbstract()).toBe(true);\n  });\n\n  it('returns the root type', () => {\n    expect(getNode(Relay.QL`query { me }`).getType()).toBe('User');\n    expect(getNode(Relay.QL`query { viewer }`).getType()).toBe('Viewer');\n    expect(getNode(Relay.QL`query { node(id: \"123\") }`).getType()).toBe('Node');\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true', () => {\n      // query with children\n      expect(me.canHaveSubselections()).toBe(true);\n\n      // empty query\n      var query = getNode({\n        ...Relay.QL`query { viewer }`,\n        children: [],\n      });\n      expect(query.canHaveSubselections()).toBe(true);\n    });\n  });\n\n  describe('getStorageKey()', () => {\n    it('delegates to RelayQueryField::getStorageKey', () => {\n      const query = getNode(Relay.QL`query { settings(environment: MOBILE) }`);\n      // Inherit all of the other RelayQueryField::getStorageKey() behavior,\n      // like stripping out spurious if/unless and connection args.\n      const mockField = {getStorageKey: jest.genMockFunction()};\n      RelayQuery.Field.build = jest.genMockFn().mockReturnValue(mockField);\n      query.getStorageKey();\n      expect(RelayQuery.Field.build).toBeCalled();\n      expect(mockField.getStorageKey).toBeCalled();\n    });\n\n    it('strips identifying arguments', () => {\n      const identifyingQuery = getNode(\n        Relay.QL`query { username(name:\"yuzhi\") }`\n      );\n      identifyingQuery.getConcreteQueryNode().metadata = {\n        identifyingArgName: 'name',\n      };\n      expect(identifyingQuery.getStorageKey()).toBe('username');\n    });\n\n    it('identifies itself as plural or not', () => {\n      expect(me.isPlural()).toBe(false);\n      expect(usernames.isPlural()).toBe(true);\n    });\n\n    /*\n    Come a time when root fields support more than just identifying arguments,\n    write a test to ensure that non-identifying args don't get stripped out.\n\n    it('does not strip out non-identifying arguments', () => {\n      const query = getNode(Relay.QL`query { settings(environment: MOBILE) }`);\n      expect(query.getStorageKey()).toBe('settings.environment(MOBILE)');\n    });\n    */\n  });\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","Relay","RelayQuery","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryRoot', () => {\n  var {getNode} = RelayTestUtils;\n\n  var me;\n  var usernames;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    me = getNode(Relay.QL`\n      query {\n        me {\n          name1: firstName,\n          name1: lastName,\n        }\n      }\n    `);\n\n    usernames = getNode(Relay.QL`\n      query {\n        usernames(names:\"mroch\") {\n          firstName,\n        }\n      }\n    `);\n    usernames.getConcreteQueryNode().metadata = {\n      isPlural: true,\n      identifyingArgName: 'names',\n    };\n  });\n\n  it('has a unique ID', () => {\n    var lastID = getNode(Relay.QL`query{me{firstName}}`).getID();\n    var nextID = getNode(Relay.QL`query{me{lastName}}`).getID();\n    expect(lastID).toMatch(/^q\\d+/);\n    expect(nextID).toMatch(/^q\\d+/);\n    expect(nextID).not.toEqual(lastID);\n  });\n\n  it('returns children', () => {\n    var children = me.getChildren();\n    expect(children.length).toBe(3);\n    expect(children[0].getSchemaName()).toBe('firstName');\n    expect(children[1].getSchemaName()).toBe('lastName');\n    expect(children[2].getSchemaName()).toBe('id');\n    expect(children[2].isGenerated()).toBe(true);\n\n    children = usernames.getChildren();\n    expect(children.length).toBe(3);\n    expect(children[0].getSchemaName()).toBe('firstName');\n    expect(children[1].getSchemaName()).toBe('id');\n    expect(children[1].isGenerated()).toBe(true);\n    expect(children[2].getSchemaName()).toBe('__typename');\n    expect(children[2].isGenerated()).toBe(true);\n  });\n\n  it('does not return skipped children', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          id,\n          firstName @skip(if: $true),\n          lastName @include(if: $false),\n          name @skip(if: $true) @include(if: false),\n          emailAddresses @skip(if: $true) @include(if: true),\n          username @skip(if: $false) @include(if: false),\n        }\n      }\n    `, {true: true, false: false});\n    var children = query.getChildren();\n    expect(children.length).toBe(1);\n    expect(children[0].getSchemaName()).toBe('id');\n  });\n\n  it('returns included children', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          id,\n          firstName @skip(if: $false),\n          lastName @include(if: $true),\n          name @skip(if: false) @include(if: $true),\n        }\n      }\n    `, {false: false, true: true});\n    var children = query.getChildren();\n    expect(children.length).toBe(4);\n    expect(children[0].getSchemaName()).toBe('id');\n    expect(children[1].getSchemaName()).toBe('firstName');\n    expect(children[2].getSchemaName()).toBe('lastName');\n    expect(children[3].getSchemaName()).toBe('name');\n  });\n\n  it('returns same object when cloning with same fields', () => {\n    var children = me.getChildren();\n    expect(me.clone(children)).toBe(me);\n    expect(me.clone(children.map(c => c))).toBe(me);\n    expect(me.clone(\n      [null, children[0], null, children[1], null, children[2], null]\n    )).toBe(me);\n\n    children = usernames.getChildren();\n    expect(usernames.clone(children)).toBe(usernames);\n    expect(usernames.clone(children.map(c => c))).toBe(usernames);\n  });\n\n  it('returns null when cloning without fields', () => {\n    expect(me.clone([])).toBe(null);\n    expect(me.clone([null])).toBe(null);\n    expect(usernames.clone([])).toBe(null);\n    expect(usernames.clone([null])).toBe(null);\n  });\n\n  it('returns new object when cloning with different fields', () => {\n    var children = me.getChildren();\n    expect(me.clone([children[0], null])).not.toBe(me);\n    expect(me.clone([children[0], null, null])).not.toBe(me);\n    expect(me.clone([children[0], null, null, null])).not.toBe(me);\n  });\n\n  it('clones with updated children', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          firstName,\n          lastName\n        }\n      }\n    `);\n    var clone = query.clone([query.getChildren()[0]]);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe('firstName');\n    expect(clone.getFieldByStorageKey('lastName')).toBe(undefined);\n  });\n\n  it('returns root calls with values', () => {\n    expect(me.getIdentifyingArg()).toEqual(undefined);\n\n    expect(usernames.getIdentifyingArg()).toEqual(\n      {name: 'names', value: 'mroch'}\n    );\n\n    expect(getNode(Relay.QL`\n      query {\n        usernames(names:[\"a\",\"b\",\"c\"]) {\n          firstName\n        }\n      }\n    `).getIdentifyingArg()).toEqual(\n      {name: 'names', value: ['a', 'b', 'c']}\n    );\n  });\n\n  it('returns ref params', () => {\n    // non-ref query:\n    expect(me.getBatchCall()).toBe(null);\n\n    // ref query:\n    var root = getNode({\n      ...Relay.QL`\n        query {\n          node(id: \"123\") {\n            id\n          }\n        }\n      `,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    var batchCall = root.getBatchCall();\n    expect(batchCall).toEqual({\n      refParamName: 'ref_q0',\n      sourceQueryID: 'q0',\n      sourceQueryPath: '$.*.actor.id',\n    });\n  });\n\n  it('is not equal to non-root nodes', () => {\n    var fragment = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          id\n        }\n      }\n    `);\n    var id = fragment.getChildren()[0].getChildren()[0];\n    expect(me.equals(fragment)).toBe(false);\n    expect(me.equals(id)).toBe(false);\n  });\n\n  it('is not equal to queries with different root calls', () => {\n    var diffRoot = getNode(Relay.QL`\n      query {\n        usernames(names:\"joesavona\") {\n          firstName\n        }\n      }\n    `);\n    expect(usernames.equals(diffRoot)).toBe(false);\n  });\n\n  it('equals the same query', () => {\n    expect(usernames.equals(usernames)).toBe(true);\n    expect(me.equals(me)).toBe(true);\n  });\n\n  it('equals equivalent queries', () => {\n    var me2 = getNode(Relay.QL`\n      query {\n        me {\n          name1: firstName,\n          name1: lastName,\n        }\n      }\n    `);\n\n    var usernames2 = getNode(Relay.QL`\n      query {\n        usernames(names:\"mroch\") {\n          firstName,\n        }\n      }\n    `);\n    usernames2.getConcreteQueryNode().metadata = {\n      isPlural: true,\n      identifyingArgName: 'names',\n    };\n\n    expect(me.equals(me2)).toBe(true);\n    expect(usernames.equals(usernames2)).toBe(true);\n    expect(me2.equals(me)).toBe(true);\n    expect(usernames2.equals(usernames)).toBe(true);\n  });\n\n  it('does not equal different queries with the same root', () => {\n    var me2 = getNode(Relay.QL`\n      query {\n        me {\n          name1: firstName,\n          lastName,\n        }\n      }\n    `);\n\n    var usernames2 = getNode(Relay.QL`\n      query {\n        usernames(names:\"mroch\") {\n          firstName,\n          lastName\n        }\n      }\n    `);\n    expect(me.equals(me2)).toBe(false);\n    expect(usernames.equals(usernames2)).toBe(false);\n    expect(me2.equals(me)).toBe(false);\n    expect(usernames2.equals(usernames)).toBe(false);\n  });\n\n  it('equals identical ref queries with matching ref params', () => {\n    var node = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    var other = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    expect(node.equals(other)).toBe(true);\n  });\n\n  it('does not equal queries with different ref params', () => {\n    var node = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable('q0', '$.*.actor.id')\n      )],\n    });\n    var other = getNode({\n      ...Relay.QL`query { node(id: \"123\") }`,\n      calls: [QueryBuilder.createCall(\n        'id',\n        QueryBuilder.createBatchCallVariable(\n          'q0',\n          '$.*.actor.current_city.id'\n        )\n      )],\n    });\n    expect(node.equals(other)).toBe(false);\n  });\n\n  it('is not a ref query dependency', () => {\n    expect(me.isRefQueryDependency()).toBe(false);\n  });\n\n  it('is not generated', () => {\n    expect(me.isGenerated()).toBe(false);\n  });\n\n  it('returns the identifying argument type', () => {\n    var nodeQuery = getNode(Relay.QL`query{node(id:\"123\"){id}}`);\n    nodeQuery.getConcreteQueryNode().metadata = {\n      identifyingArgName: 'id',\n      identifyingArgType: 'scalar',\n    };\n    const nodeIdentifyingArg = nodeQuery.getIdentifyingArg();\n    expect(nodeIdentifyingArg).toBeDefined();\n    expect(nodeIdentifyingArg.type).toBe('scalar');\n\n    var me = getNode(Relay.QL`query{me{id}}`);\n    const meIdentifyingArg = me.getIdentifyingArg();\n    expect(meIdentifyingArg).toBeUndefined();\n  });\n\n  it('creates nodes', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var node = Relay.QL`\n      fragment on Viewer {\n        actor {\n          id\n        }\n      }\n    `;\n    var actorID = query.createNode(node);\n    expect(actorID instanceof RelayQuery.Fragment).toBe(true);\n    expect(actorID.getType()).toBe('Viewer');\n    expect(actorID.getRoute()).toBe(query.getRoute());\n    expect(actorID.getVariables()).toBe(query.getVariables());\n  });\n\n  it('returns directives', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me @include(if: $cond) {\n          id\n        }\n      }\n    `, {cond: true});\n    expect(query.getDirectives()).toEqual([\n      {\n        args: [\n          {name: 'if', value: true},\n        ],\n        name: 'include',\n      },\n    ]);\n  });\n\n  it('returns isAbstract', () => {\n    expect(getNode(Relay.QL`query { me }`).isAbstract()).toBe(false);\n    expect(getNode(Relay.QL`query { viewer }`).isAbstract()).toBe(false);\n    expect(getNode(Relay.QL`query { node(id: \"4\") }`).isAbstract()).toBe(true);\n  });\n\n  it('returns the root type', () => {\n    expect(getNode(Relay.QL`query { me }`).getType()).toBe('User');\n    expect(getNode(Relay.QL`query { viewer }`).getType()).toBe('Viewer');\n    expect(getNode(Relay.QL`query { node(id: \"123\") }`).getType()).toBe('Node');\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true', () => {\n      // query with children\n      expect(me.canHaveSubselections()).toBe(true);\n\n      // empty query\n      var query = getNode({\n        ...Relay.QL`query { viewer }`,\n        children: [],\n      });\n      expect(query.canHaveSubselections()).toBe(true);\n    });\n  });\n\n  describe('getStorageKey()', () => {\n    it('delegates to RelayQueryField::getStorageKey', () => {\n      const query = getNode(Relay.QL`query { settings(environment: MOBILE) }`);\n      // Inherit all of the other RelayQueryField::getStorageKey() behavior,\n      // like stripping out spurious if/unless and connection args.\n      const mockField = {getStorageKey: jest.genMockFunction()};\n      RelayQuery.Field.build = jest.genMockFn().mockReturnValue(mockField);\n      query.getStorageKey();\n      expect(RelayQuery.Field.build).toBeCalled();\n      expect(mockField.getStorageKey).toBeCalled();\n    });\n\n    it('strips identifying arguments', () => {\n      const identifyingQuery = getNode(\n        Relay.QL`query { username(name:\"yuzhi\") }`\n      );\n      identifyingQuery.getConcreteQueryNode().metadata = {\n        identifyingArgName: 'name',\n      };\n      expect(identifyingQuery.getStorageKey()).toBe('username');\n    });\n\n    it('identifies itself as plural or not', () => {\n      expect(me.isPlural()).toBe(false);\n      expect(usernames.isPlural()).toBe(true);\n    });\n\n    /*\n    Come a time when root fields support more than just identifying arguments,\n    write a test to ensure that non-identifying args don't get stripped out.\n\n    it('does not strip out non-identifying arguments', () => {\n      const query = getNode(Relay.QL`query { settings(environment: MOBILE) }`);\n      expect(query.getStorageKey()).toBe('settings.environment(MOBILE)');\n    });\n    */\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryRoot-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryPath-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryPath', () => {\n  var {getNode, getVerbatimNode} = RelayTestUtils;\n  let store;\n  let writer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    const records = {};\n    store = new RelayRecordStore({records});\n    writer = new RelayRecordWriter(records);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates root paths', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id\n        }\n      }\n    `);\n    var fragment = Relay.QL`\n      fragment on Node {\n        id\n        __typename\n        name\n      }\n    `;\n\n    var path = new RelayQueryPath(query);\n    expect(path.getName()).toBe(query.getName());\n\n    writer.putRecord('123', 'User');\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            id\n            __typename\n            ${fragment}\n          }\n        }\n      }\n    `));\n  });\n\n  it('creates root paths for argument-less root calls with IDs', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          id\n        }\n      }\n    `);\n    var fragment = Relay.QL`\n      fragment on Actor {\n        name\n      }\n    `;\n    var path = new RelayQueryPath(query);\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        me {\n          id\n          ${fragment}\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n  });\n\n  it('creates root paths for argument-less root calls without IDs', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          name\n        }\n      }\n    `;\n    var path = new RelayQueryPath(query);\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment}\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n  });\n\n  it('creates paths to non-refetchable fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id\n        }\n      }\n    `);\n    var address = getNode(Relay.QL`\n      fragment on Actor {\n        address {\n          city\n        }\n      }\n    `).getFieldByStorageKey('address');\n    var city = getNode(Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `).getFieldByStorageKey('city');\n\n    // address is not refetchable, has client ID\n    writer.putRecord('123', 'User');\n    var root = new RelayQueryPath(query);\n    var path = root.getPath(address, 'client:1');\n    var pathQuery = path.getQuery(store, city);\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            id\n            __typename\n            address {\n              city\n            }\n          }\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n    expect(pathQuery.getName()).toBe(query.getName());\n    expect(pathQuery.isAbstract()).toBe(true);\n  });\n\n  it('creates roots for refetchable fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var fragment = Relay.QL`\n      fragment on Node {\n        name\n      }\n    `;\n\n    // actor has an ID and is refetchable\n    writer.putRecord('123', 'User');\n    var root = new RelayQueryPath(query);\n    var path = root.getPath(actor, '123');\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            id\n            __typename\n            ... on Node {\n              id\n              __typename\n              name\n            }\n          }\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n  });\n\n  it('warns if the root record\\'s type is unknown', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var fragment = Relay.QL`\n      fragment on Node {\n        name\n      }\n    `;\n\n    // actor has an ID and is refetchable, but the type of actor is unknown.\n    var root = new RelayQueryPath(query);\n    var path = root.getPath(actor, '123');\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          # not wrapped in a concrete fragment because the type is unknown.\n          id\n          __typename\n          ... on Node {\n            id\n            __typename\n            name\n          }\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n    expect([\n      'RelayQueryPath: No typename found for %s record `%s`. Generating a ' +\n      'possibly invalid query.',\n      'unknown',\n      '123',\n    ]).toBeWarnedNTimes(1);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQueryPath","RelayRecordStore","RelayRecordWriter","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst Relay = require('Relay');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryPath', () => {\n  var {getNode, getVerbatimNode} = RelayTestUtils;\n  let store;\n  let writer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    const records = {};\n    store = new RelayRecordStore({records});\n    writer = new RelayRecordWriter(records);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates root paths', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id\n        }\n      }\n    `);\n    var fragment = Relay.QL`\n      fragment on Node {\n        id\n        __typename\n        name\n      }\n    `;\n\n    var path = new RelayQueryPath(query);\n    expect(path.getName()).toBe(query.getName());\n\n    writer.putRecord('123', 'User');\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            id\n            __typename\n            ${fragment}\n          }\n        }\n      }\n    `));\n  });\n\n  it('creates root paths for argument-less root calls with IDs', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          id\n        }\n      }\n    `);\n    var fragment = Relay.QL`\n      fragment on Actor {\n        name\n      }\n    `;\n    var path = new RelayQueryPath(query);\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        me {\n          id\n          ${fragment}\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n  });\n\n  it('creates root paths for argument-less root calls without IDs', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var fragment = Relay.QL`\n      fragment on Viewer {\n        actor {\n          name\n        }\n      }\n    `;\n    var path = new RelayQueryPath(query);\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getNode(Relay.QL`\n      query {\n        viewer {\n          ${fragment}\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n  });\n\n  it('creates paths to non-refetchable fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          id\n        }\n      }\n    `);\n    var address = getNode(Relay.QL`\n      fragment on Actor {\n        address {\n          city\n        }\n      }\n    `).getFieldByStorageKey('address');\n    var city = getNode(Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `).getFieldByStorageKey('city');\n\n    // address is not refetchable, has client ID\n    writer.putRecord('123', 'User');\n    var root = new RelayQueryPath(query);\n    var path = root.getPath(address, 'client:1');\n    var pathQuery = path.getQuery(store, city);\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            id\n            __typename\n            address {\n              city\n            }\n          }\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n    expect(pathQuery.getName()).toBe(query.getName());\n    expect(pathQuery.isAbstract()).toBe(true);\n  });\n\n  it('creates roots for refetchable fields', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var fragment = Relay.QL`\n      fragment on Node {\n        name\n      }\n    `;\n\n    // actor has an ID and is refetchable\n    writer.putRecord('123', 'User');\n    var root = new RelayQueryPath(query);\n    var path = root.getPath(actor, '123');\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          ... on User {\n            id\n            __typename\n            ... on Node {\n              id\n              __typename\n              name\n            }\n          }\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n  });\n\n  it('warns if the root record\\'s type is unknown', () => {\n    var query = getNode(Relay.QL`\n      query {\n        viewer {\n          actor {\n            id\n          }\n        }\n      }\n    `);\n    var actor = query.getFieldByStorageKey('actor');\n    var fragment = Relay.QL`\n      fragment on Node {\n        name\n      }\n    `;\n\n    // actor has an ID and is refetchable, but the type of actor is unknown.\n    var root = new RelayQueryPath(query);\n    var path = root.getPath(actor, '123');\n    var pathQuery = path.getQuery(store, getNode(fragment));\n    expect(pathQuery).toEqualQueryRoot(getVerbatimNode(Relay.QL`\n      query {\n        node(id:\"123\") {\n          # not wrapped in a concrete fragment because the type is unknown.\n          id\n          __typename\n          ... on Node {\n            id\n            __typename\n            name\n          }\n        }\n      }\n    `));\n    expect(path.getName()).toBe(query.getName());\n    expect([\n      'RelayQueryPath: No typename found for %s record `%s`. Generating a ' +\n      'possibly invalid query.',\n      'unknown',\n      '123',\n    ]).toBeWarnedNTimes(1);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryPath-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryMutation-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryMutation', () => {\n  var {getNode} = RelayTestUtils;\n\n  let input;\n  let mutationQuery;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    input = JSON.stringify({\n      [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'mutation:id',\n      actor: 'actor:id',\n      feedback_id: 'feedback:id',\n      message: {\n        text: 'comment!',\n      },\n    });\n    mutationQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedbackCommentEdge {\n            node {id},\n            source {id}\n          }\n        }\n      }\n    `, {input});\n  });\n\n  it('creates mutations', () => {\n    expect(mutationQuery.getName()).toBe('RelayQueryMutation');\n    expect(mutationQuery.getResponseType()).toBe(\n      'CommentCreateResponsePayload'\n    );\n    expect(mutationQuery.getCall()).toEqual({\n      name: 'commentCreate',\n      value: input,\n    });\n    var children = mutationQuery.getChildren();\n    expect(children.length).toBe(2);\n    expect(children[0].getSchemaName()).toBe(\n      RelayConnectionInterface.CLIENT_MUTATION_ID\n    );\n    expect(children[1].getSchemaName()).toBe('feedbackCommentEdge');\n    var edgeChildren = children[1].getChildren();\n    expect(edgeChildren.length).toBe(3);\n    expect(edgeChildren[0].getSchemaName()).toBe('node');\n    expect(edgeChildren[1].getSchemaName()).toBe('source');\n    expect(edgeChildren[2].getSchemaName()).toBe('cursor'); // generated\n  });\n\n  it('clones mutations', () => {\n    var clone = mutationQuery.clone(mutationQuery.getChildren());\n    expect(clone).toBe(mutationQuery);\n\n    clone = mutationQuery.clone(\n      mutationQuery.getChildren().slice(0, 1)\n    );\n    expect(clone).not.toBe(mutationQuery);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe(\n      RelayConnectionInterface.CLIENT_MUTATION_ID\n    );\n\n    clone = mutationQuery.clone([null]);\n    expect(clone).toBe(null);\n  });\n\n  it('tests for equality', () => {\n    var equivalentQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedbackCommentEdge {\n            node {id},\n            source {id}\n          }\n        }\n      }\n    `, {input});\n    var differentQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedbackCommentEdge {\n            cursor,\n            node {id},\n            source {id}\n          }\n        }\n      }\n    `, {input});\n\n    expect(mutationQuery).not.toBe(equivalentQuery);\n    expect(mutationQuery.equals(equivalentQuery)).toBe(true);\n    expect(mutationQuery.equals(differentQuery)).toBe(false);\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true', () => {\n      expect(mutationQuery.canHaveSubselections()).toBe(true);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryMutation', () => {\n  var {getNode} = RelayTestUtils;\n\n  let input;\n  let mutationQuery;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    input = JSON.stringify({\n      [RelayConnectionInterface.CLIENT_MUTATION_ID]: 'mutation:id',\n      actor: 'actor:id',\n      feedback_id: 'feedback:id',\n      message: {\n        text: 'comment!',\n      },\n    });\n    mutationQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedbackCommentEdge {\n            node {id},\n            source {id}\n          }\n        }\n      }\n    `, {input});\n  });\n\n  it('creates mutations', () => {\n    expect(mutationQuery.getName()).toBe('RelayQueryMutation');\n    expect(mutationQuery.getResponseType()).toBe(\n      'CommentCreateResponsePayload'\n    );\n    expect(mutationQuery.getCall()).toEqual({\n      name: 'commentCreate',\n      value: input,\n    });\n    var children = mutationQuery.getChildren();\n    expect(children.length).toBe(2);\n    expect(children[0].getSchemaName()).toBe(\n      RelayConnectionInterface.CLIENT_MUTATION_ID\n    );\n    expect(children[1].getSchemaName()).toBe('feedbackCommentEdge');\n    var edgeChildren = children[1].getChildren();\n    expect(edgeChildren.length).toBe(3);\n    expect(edgeChildren[0].getSchemaName()).toBe('node');\n    expect(edgeChildren[1].getSchemaName()).toBe('source');\n    expect(edgeChildren[2].getSchemaName()).toBe('cursor'); // generated\n  });\n\n  it('clones mutations', () => {\n    var clone = mutationQuery.clone(mutationQuery.getChildren());\n    expect(clone).toBe(mutationQuery);\n\n    clone = mutationQuery.clone(\n      mutationQuery.getChildren().slice(0, 1)\n    );\n    expect(clone).not.toBe(mutationQuery);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe(\n      RelayConnectionInterface.CLIENT_MUTATION_ID\n    );\n\n    clone = mutationQuery.clone([null]);\n    expect(clone).toBe(null);\n  });\n\n  it('tests for equality', () => {\n    var equivalentQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedbackCommentEdge {\n            node {id},\n            source {id}\n          }\n        }\n      }\n    `, {input});\n    var differentQuery = getNode(Relay.QL`\n      mutation {\n        commentCreate(input:$input) {\n          clientMutationId,\n          feedbackCommentEdge {\n            cursor,\n            node {id},\n            source {id}\n          }\n        }\n      }\n    `, {input});\n\n    expect(mutationQuery).not.toBe(equivalentQuery);\n    expect(mutationQuery.equals(equivalentQuery)).toBe(true);\n    expect(mutationQuery.equals(differentQuery)).toBe(false);\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true', () => {\n      expect(mutationQuery.canHaveSubselections()).toBe(true);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryMutation-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryFragment-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryFragment', () => {\n  var {getNode} = RelayTestUtils;\n\n  var fragment;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    var subfrag = Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `;\n    var frag = Relay.QL`\n      fragment on StreetAddress {\n        country,\n        ${subfrag},\n      }\n    `;\n    fragment = getNode(frag);\n  });\n\n  it('does not equal non-fragments', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          firstName\n        }\n      }\n    `);\n    var field = query.getChildren()[0];\n    expect(fragment.equals(query)).toBe(false);\n    expect(fragment.equals(field)).toBe(false);\n  });\n\n  it('does not equal different fragment', () => {\n    var fragment2 = getNode(Relay.QL`\n      fragment on StreetAddress {\n        country\n      }\n    `);\n    expect(fragment.equals(fragment2)).toBe(false);\n    expect(fragment2.equals(fragment)).toBe(false);\n  });\n\n  it('does not equal equivalent fragments with a different structure', () => {\n    expect(fragment.equals(fragment)).toBe(true);\n    // invert the fields between outer/inner fragments\n    var subfrag = Relay.QL`\n      fragment on StreetAddress {\n        country\n      }\n    `;\n    var fragment2 = getNode(Relay.QL`\n      fragment on StreetAddress {\n        city,\n        ${subfrag}\n      }\n    `);\n    expect(fragment.equals(fragment2)).toBe(false);\n    expect(fragment2.equals(fragment)).toBe(false);\n  });\n\n  it('equals fragments with the same structure', () => {\n    expect(fragment.equals(fragment)).toBe(true);\n    var subfrag = Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `;\n    var fragment2 = getNode(Relay.QL`\n      fragment on StreetAddress {\n        country,\n        ${subfrag}\n      }\n    `);\n    expect(fragment.equals(fragment2)).toBe(true);\n    expect(fragment2.equals(fragment)).toBe(true);\n  });\n\n  it('equals fragments with different names', () => {\n    // NOTE: Two fragments in the same scope will have different names.\n    var fragment1 = getNode(Relay.QL`fragment on Node { id }`);\n    var fragment2 = getNode(Relay.QL`fragment on Node { id }`);\n    expect(fragment1.equals(fragment2)).toBe(true);\n    expect(fragment2.equals(fragment1)).toBe(true);\n  });\n\n  it('returns metadata', () => {\n    var node = Relay.QL`\n      fragment on StreetAddress {\n        country,\n      }\n    `;\n    var fragment = getNode(node);\n    expect(fragment.getDebugName()).toBe('RelayQueryFragmentRelayQL');\n    expect(fragment.getType()).toBe('StreetAddress');\n  });\n\n  it('returns children', () => {\n    var children = fragment.getChildren();\n    expect(children.length).toBe(2);\n    expect(children[0].getSchemaName()).toBe('country');\n    expect(children[1].getDebugName()).toBe('RelayQueryFragmentRelayQL');\n  });\n\n  it('returns same object when cloning with same children', () => {\n    var children = fragment.getChildren();\n    expect(fragment.clone(children)).toBe(fragment);\n    expect(fragment.clone(children.map(c => c))).toBe(fragment);\n  });\n\n  it('returns null when cloning without children', () => {\n    expect(fragment.clone([])).toBe(null);\n    expect(fragment.clone([null])).toBe(null);\n  });\n\n  it('clones with updated children', () => {\n    var query = getNode(Relay.QL`\n      fragment on StreetAddress {\n        country,\n        city,\n      }\n    `);\n    var clone = query.clone([query.getChildren()[0]]);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe('country');\n    expect(clone.getFieldByStorageKey('city')).toBe(undefined);\n  });\n\n  it('is not a ref query dependency', () => {\n    expect(fragment.isRefQueryDependency()).toBe(false);\n  });\n\n  it('is not generated', () => {\n    expect(fragment.isGenerated()).toBe(false);\n  });\n\n  it('creates nodes', () => {\n    var fragmentRQL = Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `;\n    var fragment = getNode(fragmentRQL);\n    var node = fragment.createNode(fragmentRQL);\n    expect(node instanceof RelayQuery.Fragment).toBe(true);\n    expect(node.getType()).toBe('StreetAddress');\n    expect(node.getRoute()).toBe(fragment.getRoute());\n    expect(node.getVariables()).toBe(fragment.getVariables());\n  });\n\n  it('returns directives', () => {\n    var fragment = getNode(Relay.QL`\n      fragment on Story\n        @include(if: $cond)\n      {\n        feedback\n      }\n    `, {cond: true});\n    expect(fragment.getDirectives()).toEqual([\n      {\n        args: [\n          {name: 'if', value: true},\n        ],\n        name: 'include',\n      },\n    ]);\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true', () => {\n      // fragment with children\n      expect(fragment.canHaveSubselections()).toBe(true);\n\n      // fragment without children\n      expect(\n        getNode(Relay.QL`fragment on Viewer { ${null} }`).canHaveSubselections()\n      ).toBe(true);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryFragment', () => {\n  var {getNode} = RelayTestUtils;\n\n  var fragment;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    var subfrag = Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `;\n    var frag = Relay.QL`\n      fragment on StreetAddress {\n        country,\n        ${subfrag},\n      }\n    `;\n    fragment = getNode(frag);\n  });\n\n  it('does not equal non-fragments', () => {\n    var query = getNode(Relay.QL`\n      query {\n        me {\n          firstName\n        }\n      }\n    `);\n    var field = query.getChildren()[0];\n    expect(fragment.equals(query)).toBe(false);\n    expect(fragment.equals(field)).toBe(false);\n  });\n\n  it('does not equal different fragment', () => {\n    var fragment2 = getNode(Relay.QL`\n      fragment on StreetAddress {\n        country\n      }\n    `);\n    expect(fragment.equals(fragment2)).toBe(false);\n    expect(fragment2.equals(fragment)).toBe(false);\n  });\n\n  it('does not equal equivalent fragments with a different structure', () => {\n    expect(fragment.equals(fragment)).toBe(true);\n    // invert the fields between outer/inner fragments\n    var subfrag = Relay.QL`\n      fragment on StreetAddress {\n        country\n      }\n    `;\n    var fragment2 = getNode(Relay.QL`\n      fragment on StreetAddress {\n        city,\n        ${subfrag}\n      }\n    `);\n    expect(fragment.equals(fragment2)).toBe(false);\n    expect(fragment2.equals(fragment)).toBe(false);\n  });\n\n  it('equals fragments with the same structure', () => {\n    expect(fragment.equals(fragment)).toBe(true);\n    var subfrag = Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `;\n    var fragment2 = getNode(Relay.QL`\n      fragment on StreetAddress {\n        country,\n        ${subfrag}\n      }\n    `);\n    expect(fragment.equals(fragment2)).toBe(true);\n    expect(fragment2.equals(fragment)).toBe(true);\n  });\n\n  it('equals fragments with different names', () => {\n    // NOTE: Two fragments in the same scope will have different names.\n    var fragment1 = getNode(Relay.QL`fragment on Node { id }`);\n    var fragment2 = getNode(Relay.QL`fragment on Node { id }`);\n    expect(fragment1.equals(fragment2)).toBe(true);\n    expect(fragment2.equals(fragment1)).toBe(true);\n  });\n\n  it('returns metadata', () => {\n    var node = Relay.QL`\n      fragment on StreetAddress {\n        country,\n      }\n    `;\n    var fragment = getNode(node);\n    expect(fragment.getDebugName()).toBe('RelayQueryFragmentRelayQL');\n    expect(fragment.getType()).toBe('StreetAddress');\n  });\n\n  it('returns children', () => {\n    var children = fragment.getChildren();\n    expect(children.length).toBe(2);\n    expect(children[0].getSchemaName()).toBe('country');\n    expect(children[1].getDebugName()).toBe('RelayQueryFragmentRelayQL');\n  });\n\n  it('returns same object when cloning with same children', () => {\n    var children = fragment.getChildren();\n    expect(fragment.clone(children)).toBe(fragment);\n    expect(fragment.clone(children.map(c => c))).toBe(fragment);\n  });\n\n  it('returns null when cloning without children', () => {\n    expect(fragment.clone([])).toBe(null);\n    expect(fragment.clone([null])).toBe(null);\n  });\n\n  it('clones with updated children', () => {\n    var query = getNode(Relay.QL`\n      fragment on StreetAddress {\n        country,\n        city,\n      }\n    `);\n    var clone = query.clone([query.getChildren()[0]]);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe('country');\n    expect(clone.getFieldByStorageKey('city')).toBe(undefined);\n  });\n\n  it('is not a ref query dependency', () => {\n    expect(fragment.isRefQueryDependency()).toBe(false);\n  });\n\n  it('is not generated', () => {\n    expect(fragment.isGenerated()).toBe(false);\n  });\n\n  it('creates nodes', () => {\n    var fragmentRQL = Relay.QL`\n      fragment on StreetAddress {\n        city\n      }\n    `;\n    var fragment = getNode(fragmentRQL);\n    var node = fragment.createNode(fragmentRQL);\n    expect(node instanceof RelayQuery.Fragment).toBe(true);\n    expect(node.getType()).toBe('StreetAddress');\n    expect(node.getRoute()).toBe(fragment.getRoute());\n    expect(node.getVariables()).toBe(fragment.getVariables());\n  });\n\n  it('returns directives', () => {\n    var fragment = getNode(Relay.QL`\n      fragment on Story\n        @include(if: $cond)\n      {\n        feedback\n      }\n    `, {cond: true});\n    expect(fragment.getDirectives()).toEqual([\n      {\n        args: [\n          {name: 'if', value: true},\n        ],\n        name: 'include',\n      },\n    ]);\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true', () => {\n      // fragment with children\n      expect(fragment.canHaveSubselections()).toBe(true);\n\n      // fragment without children\n      expect(\n        getNode(Relay.QL`fragment on Viewer { ${null} }`).canHaveSubselections()\n      ).toBe(true);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryFragment-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryField-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\n\ndescribe('RelayQueryField', () => {\n  var {getNode} = RelayTestUtils;\n\n  let aliasedIdField;\n  let cursorField;\n  let edgesField;\n  let friendsScalarField;\n  let friendsConnectionField;\n  let friendsVariableField;\n  let generatedIdField;\n  let generatedIdFieldRQL;\n  let nodeField;\n  let nodeIdField;\n  let pageInfoField;\n  let userAddressField;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    var scalarRQL = Relay.QL`\n      fragment on Node {\n        id\n      }\n    `;\n    nodeIdField = getNode(scalarRQL).getChildren()[0];\n    expect(nodeIdField.getSchemaName()).toBe('id');\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"1\") {\n            edges {\n              node {\n                special_id: id,\n              },\n            },\n          },\n        }\n      }\n    `);\n    friendsConnectionField = query.getChildren()[0];\n    edgesField = friendsConnectionField.getChildren()[0];\n    nodeField = edgesField.getChildren()[0];\n    aliasedIdField =  nodeField.getChildren()[0];\n    expect(aliasedIdField.getSchemaName()).toBe('id');\n\n    var groupRQL = Relay.QL`\n      fragment on User {\n        address {\n          city\n        }\n      }\n    `;\n    userAddressField = getNode(groupRQL).getChildren()[0];\n    expect(userAddressField.getSchemaName()).toBe('address');\n\n    var friendsScalarFieldRQL = Relay.QL`\n      fragment on User {\n        friend_scalar: friends\n          (first:\"10\",after:\"offset\",orderby:\"name\") {\n          edges {\n            node {\n              id\n            }\n          }\n        }\n      }\n    `;\n    friendsScalarField = getNode(friendsScalarFieldRQL).getChildren()[0];\n    expect(friendsScalarField.getSchemaName()).toBe('friends');\n    pageInfoField = getNode(friendsScalarFieldRQL)\n      .getChildren()[0]\n      .getChildren()[1];\n    expect(pageInfoField.getSchemaName())\n      .toBe(RelayConnectionInterface.PAGE_INFO);\n    // feed.edges.cursor\n    cursorField = getNode(friendsScalarFieldRQL)\n      .getChildren()[0].getChildren()[0].getChildren()[1];\n    expect(cursorField.getSchemaName()).toBe('cursor');\n\n    var friendsVariableFieldRQL = Relay.QL`\n      fragment on User {\n        friends_variable: friends(first:$first,after:$after) {\n          edges {\n            node {\n              id\n            }\n          }\n        }\n      }\n    `;\n    var variables = {\n      after: 'offset',\n      first: 10,\n    };\n    friendsVariableField =\n      getNode(friendsVariableFieldRQL, variables).getChildren()[0];\n    expect(friendsVariableField.getSchemaName()).toBe('friends');\n\n    generatedIdFieldRQL = Relay.QL`\n      fragment on User {\n        name\n      }\n    `;\n    generatedIdField = getNode(generatedIdFieldRQL).getChildren()[1];\n    expect(generatedIdField.getSchemaName()).toBe('id');\n  });\n\n  it('returns the type', () => {\n    var actor = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          name\n        }\n      }\n    `).getChildren()[0];\n    expect(actor.getType()).toBe('Actor');\n  });\n\n  it('gets children by storage key', () => {\n    var edges = friendsScalarField.getFieldByStorageKey('edges');\n    expect(edges).toBe(friendsScalarField.getChildren()[0]);\n  });\n\n  it('gets children by field', () => {\n    var edges = friendsScalarField.getFieldByStorageKey('edges');\n    expect(edges).toBe(friendsScalarField.getChildren()[0]);\n    var varFeedEdges = friendsVariableField.getField(edges);\n    expect(varFeedEdges).toBe(friendsVariableField.getChildren()[0]);\n  });\n\n  it('equals the same fields', () => {\n    expect(nodeIdField.equals(nodeIdField)).toBe(true);\n    expect(userAddressField.equals(userAddressField)).toBe(true);\n    expect(friendsScalarField.equals(friendsScalarField)).toBe(true);\n    expect(friendsVariableField.equals(friendsVariableField)).toBe(true);\n    expect(generatedIdField.equals(generatedIdField)).toBe(true);\n    expect(pageInfoField.equals(pageInfoField)).toBe(true);\n    expect(cursorField.equals(cursorField)).toBe(true);\n  });\n\n  it('equals equivalent fields', () => {\n    var pictureScalarRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:\"32\")\n      }\n    `;\n    var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n    var pictureVariableRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size)\n      }\n    `;\n    var variables = {size: '32'};\n    var pictureVariable =\n      getNode(pictureVariableRQL,  variables).getChildren()[0];\n    expect(pictureScalar.equals(pictureVariable)).toBe(true);\n\n    var diffId = getNode(generatedIdFieldRQL).getChildren()[1];\n    expect(generatedIdField.equals(diffId)).toBe(true);\n  });\n\n  it('does not equal fields with different values', () => {\n    var pictureScalarRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:\"32\")\n      }\n    `;\n    var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n    var pictureVariableRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size)\n      }\n    `;\n    var pictureVariable =\n      getNode(pictureVariableRQL, {size: '33'}).getChildren()[0];\n    expect(pictureScalar.equals(pictureVariable)).toBe(false);\n  });\n\n  it('scalar fields have no children', () => {\n    expect(nodeIdField.canHaveSubselections()).toBe(false);\n    expect(nodeIdField.getChildren().length).toBe(0);\n  });\n\n  it('returns the same object when cloning a scalar field', () => {\n    expect(nodeIdField.clone([])).toBe(nodeIdField);\n  });\n\n  it('clones with updated children', () => {\n    var query = getNode(Relay.QL`\n      fragment on Story {\n        feedback {\n          id,\n          canViewerComment,\n        }\n      }\n    `).getChildren()[0];\n    var clone = query.clone([query.getChildren()[0]]);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe('id');\n    expect(clone.getFieldByStorageKey('canViewerComment')).toBe(undefined);\n  });\n\n  it('throws if cloning a subselection-ineligible field with children', () => {\n    const expectedError = (\n      'RelayQueryNode: Cannot add children to field `id` because it does not ' +\n      'support sub-selections (sub-fields).'\n    );\n    expect(() => {\n      nodeIdField.clone([null]);\n    }).toFailInvariant(expectedError);\n    expect(() => {\n      nodeIdField.cloneFieldWithCalls([null], []);\n    }).toFailInvariant(expectedError);\n  });\n\n  it('returns children', () => {\n    var children = userAddressField.getChildren();\n    expect(children.length).toBe(1);\n    expect(children[0].getSchemaName()).toBe('city');\n  });\n\n  it('return the same object when cloning with the same children', () => {\n    var children = userAddressField.getChildren();\n    var child = children[0];\n    expect(userAddressField.clone(children)).toBe(userAddressField);\n    expect(userAddressField.clone([child])).toBe(userAddressField);\n    expect(userAddressField.clone([child, null])).toBe(userAddressField);\n    expect(userAddressField.clone([null, child, null])).toBe(userAddressField);\n  });\n\n  it('returns a new object when cloning with different children', () => {\n    expect(userAddressField.clone([nodeIdField])).not.toBe(userAddressField);\n  });\n\n  it('returns null when cloning without children', () => {\n    expect(userAddressField.clone([])).toBe(null);\n    expect(userAddressField.clone([null])).toBe(null);\n    expect(userAddressField.cloneFieldWithCalls([], [])).toBe(null);\n    expect(userAddressField.cloneFieldWithCalls([null], [])).toBe(null);\n  });\n\n  it('returns the schema/application names', () => {\n    expect(friendsScalarField.getSchemaName()).toBe('friends');\n    expect(friendsScalarField.getApplicationName()).toBe('friend_scalar');\n\n    expect(friendsVariableField.getSchemaName()).toBe('friends');\n    expect(friendsVariableField.getApplicationName()).toBe('friends_variable');\n  });\n\n  it('returns call types', () => {\n    var field = getNode(\n      Relay.QL`fragment on User{profilePicture(size:\"32\")}`\n    ).getChildren()[0];\n    field.getConcreteQueryNode().calls[0].metadata = {type: 'scalar'};\n\n    expect(field.getCallType('size')).toBe('scalar');\n    expect(field.getCallType('nonExistentCall')).toBe(undefined);\n  });\n\n  it('throws if a variable is missing', () => {\n    var pictureFragment = Relay.QL`\n      fragment on User {\n        profilePicture(size:[$width,$height])\n      }\n    `;\n    var variables = {};\n    var pictureField = getNode(pictureFragment, variables).getChildren()[0];\n    expect(() => pictureField.getCallsWithValues()).toFailInvariant(\n      'callsFromGraphQL(): Expected a declared value for variable, `$width`.'\n    );\n  });\n\n  it('permits null or undefined variable values', () => {\n    var pictureFragment = Relay.QL`\n      fragment on User {\n        profilePicture(size:[$width,$height])\n      }\n    `;\n    var variables = {\n      width: null,\n      height: undefined,\n    };\n    var pictureField = getNode(pictureFragment, variables).getChildren()[0];\n    expect(pictureField.getCallsWithValues()).toEqual([\n      {\n        name: 'size',\n        value: [\n          null,\n          undefined,\n        ],\n      },\n    ]);\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true for fields that support sub-selections', () => {\n      expect(edgesField.canHaveSubselections()).toBe(true);\n      expect(friendsConnectionField.canHaveSubselections()).toBe(true);\n      expect(friendsScalarField.canHaveSubselections()).toBe(true);\n      expect(friendsVariableField.canHaveSubselections()).toBe(true);\n      expect(nodeField.canHaveSubselections()).toBe(true);\n      expect(pageInfoField.canHaveSubselections()).toBe(true);\n      expect(userAddressField.canHaveSubselections()).toBe(true);\n    });\n\n    it('returns false for fields that do not support sub-selections', () => {\n      expect(aliasedIdField.canHaveSubselections()).toBe(false);\n      expect(cursorField.canHaveSubselections()).toBe(false);\n      expect(generatedIdField.canHaveSubselections()).toBe(false);\n      expect(nodeIdField.canHaveSubselections()).toBe(false);\n    });\n  });\n\n  describe('getRangeBehaviorKey()', () => {\n    it('strips range calls on connections', () => {\n      var connectionField = getNode(\n        Relay.QL`fragment on User { friends(first:\"10\",isViewerFriend:true) }`\n      ).getChildren()[0];\n      expect(connectionField.getRangeBehaviorKey())\n        .toBe('isViewerFriend(true)');\n    });\n\n    it('throws for non-connection fields', () => {\n      var nonConnectionField = getNode(\n        Relay.QL`query { node(id:\"4\") }`\n      ).getChildren()[0];\n      expect(nonConnectionField.getRangeBehaviorKey).toThrow();\n    });\n\n    it('strips passing `if` calls', () => {\n      var ifTrue = getNode(\n        Relay.QL`fragment on User { friends(if:true) }`\n      ).getChildren()[0];\n      expect(ifTrue.getRangeBehaviorKey()).toBe('');\n\n      var ifFalse = getNode(\n        Relay.QL`fragment on User { friends(if:false) }`\n      ).getChildren()[0];\n      expect(ifFalse.getRangeBehaviorKey()).toBe('if(false)');\n    });\n\n    it('strips failing `unless` calls', () => {\n      var unlessTrue = getNode(\n        Relay.QL`fragment on User { friends(unless:true) }`\n      ).getChildren()[0];\n      expect(unlessTrue.getRangeBehaviorKey()).toBe('unless(true)');\n\n      var unlessFalse = getNode(Relay.QL`\n        fragment on User {\n          friends(unless:false)\n        }\n      `).getChildren()[0];\n      expect(unlessFalse.getRangeBehaviorKey()).toBe('');\n    });\n\n    it('substitutes variable values', () => {\n      var key = 'isViewerFriend(false)';\n      var friendsScalarRQL = Relay.QL`\n        fragment on User { friends(isViewerFriend:false) }\n      `;\n      var friendsScalar = getNode(friendsScalarRQL).getChildren()[0];\n      expect(friendsScalar.getRangeBehaviorKey()).toBe(key);\n\n      var friendsVariableRQL = Relay.QL`\n        fragment on User { friends(isViewerFriend:$isViewerFriend) }\n      `;\n      var variables = {isViewerFriend: false};\n      var friendsVariable =\n        getNode(friendsVariableRQL, variables).getChildren()[0];\n      expect(friendsVariable.getRangeBehaviorKey()).toBe(key);\n    });\n\n    it('produces stable keys regardless of argument order', () => {\n      var friendFieldA = getNode(Relay.QL`fragment on User {\n        friends(orderby: \"name\", isViewerFriend: true)\n      }`).getChildren()[0];\n      var friendFieldB = getNode(Relay.QL`fragment on User {\n        friends(isViewerFriend: true, orderby: \"name\")\n      }`).getChildren()[0];\n      const expectedKey = 'isViewerFriend(true).orderby(name)';\n      expect(friendFieldA.getRangeBehaviorKey()).toBe(expectedKey);\n      expect(friendFieldB.getRangeBehaviorKey()).toBe(expectedKey);\n    });\n  });\n\n  describe('getSerializationKey()', () => {\n    it('serializes all calls', () => {\n      expect(friendsScalarField.getSerializationKey()).toBe(\n        generateRQLFieldAlias('friends.after(offset).first(10).orderby(name)')\n      );\n    });\n\n    it('substitutes variable values', () => {\n      var key = generateRQLFieldAlias('profilePicture.size(32,64)');\n      var pictureScalarRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[\"32\",\"64\"])\n        }\n      `;\n      var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n      expect(pictureScalar.getSerializationKey()).toBe(key);\n\n      var pictureVariableRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[$width,$height])\n        }\n      `;\n      var variables = {\n        height: 64,\n        width: 32,\n      };\n      var pictureVariable =\n        getNode(pictureVariableRQL, variables).getChildren()[0];\n      expect(pictureVariable.getSerializationKey()).toBe(key);\n    });\n  });\n\n  describe('getShallowHash()', () => {\n    it('serializes all calls', () => {\n      expect(friendsScalarField.getShallowHash()).toBe(\n        'friends{after:\"offset\",first:\"10\",orderby:\"name\"}'\n      );\n    });\n\n    it('serializes argument literal values', () => {\n      var node = getNode(Relay.QL`\n        fragment on User {\n          profilePicture(size: [\"32\", \"64\"])\n        }\n      `);\n      expect(node.getChildren()[0].getShallowHash()).toBe(\n        'profilePicture{size:[0:\"32\",1:\"64\"]}'\n      );\n    });\n\n    it('serializes argument variable values', () => {\n      var node = getNode(Relay.QL`\n        fragment on User {\n          profilePicture(size: [$width, $height])\n        }\n      `, {\n        width: 32,\n        height: 64,\n      });\n      expect(node.getChildren()[0].getShallowHash()).toBe(\n        'profilePicture{size:[0:32,1:64]}'\n      );\n    });\n  });\n\n  describe('getStorageKey()', () => {\n    it('strips range calls on connections', () => {\n      var connectionField = getNode(Relay.QL`\n        fragment on User {\n          friends(first:\"10\",isViewerFriend:true) {\n            edges { node { id } }\n          }\n        }\n      `).getChildren()[0];\n      expect(connectionField.getStorageKey())\n        .toBe('friends{isViewerFriend:true}');\n    });\n\n    it('preserves range-like calls on non-connections', () => {\n      // NOTE: `segments.edges.node` is scalar.\n      var nonConnectionField = getNode(Relay.QL`\n        fragment on Node {\n          segments(first:\"3\") {\n            edges { node }\n          }\n        }\n      `).getChildren()[0];\n      expect(nonConnectionField.getStorageKey()).toBe('segments{first:\"3\"}');\n    });\n\n    it('strips passing `if` calls', () => {\n      var ifTrue = getNode(Relay.QL`\n        fragment on Node {\n          firstName(if:true)\n        }\n      `).getChildren()[0];\n      expect(ifTrue.getStorageKey()).toBe('firstName');\n\n      var ifFalse = getNode(Relay.QL`\n        fragment on Node {\n          firstName(if:false)\n        }\n      `).getChildren()[0];\n      expect(ifFalse.getStorageKey()).toBe('firstName{if:false}');\n    });\n\n    it('strips failing `unless` calls', () => {\n      var unlessTrue = getNode(Relay.QL`\n        fragment on Node{\n          firstName(unless:true)\n        }\n      `).getChildren()[0];\n      expect(unlessTrue.getStorageKey()).toBe('firstName{unless:true}');\n\n      var unlessFalse = getNode(Relay.QL`\n        fragment on Node{\n          firstName(unless:false)\n        }\n      `).getChildren()[0];\n      expect(unlessFalse.getStorageKey()).toBe('firstName');\n    });\n\n    it('substitutes variable values', () => {\n      var key = 'profilePicture{size:[0:\"32\",1:\"64\"]}';\n      var pictureScalarRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[\"32\",\"64\"])\n        }\n      `;\n      var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n      expect(pictureScalar.getStorageKey()).toBe(key);\n\n      var pictureVariableRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[$width,$height])\n        }\n      `;\n      var variables = {\n        height: '64',\n        width: '32',\n      };\n      var pictureVariable =\n        getNode(pictureVariableRQL, variables).getChildren()[0];\n      expect(pictureVariable.getStorageKey()).toBe(key);\n    });\n\n    it('produces stable keys regardless of argument order', () => {\n      var pictureFieldA = getNode(Relay.QL`fragment on User {\n        profilePicture(size: \"32\", preset: SMALL)\n      }`).getChildren()[0];\n      var pictureFieldB = getNode(Relay.QL`fragment on User {\n        profilePicture(preset: SMALL, size: \"32\")\n      }`).getChildren()[0];\n      const expectedKey = 'profilePicture{preset:\"SMALL\",size:\"32\"}';\n      expect(pictureFieldA.getStorageKey()).toBe(expectedKey);\n      expect(pictureFieldB.getStorageKey()).toBe(expectedKey);\n    });\n  });\n\n  it('returns arguments with values', () => {\n    // scalar values are converted to strings\n    expect(friendsScalarField.getCallsWithValues()).toEqual([\n      {name: 'first', value: '10'},\n      {name: 'after', value: 'offset'},\n      {name: 'orderby', value: 'name'},\n    ]);\n    // variables return their values\n    expect(friendsVariableField.getCallsWithValues()).toEqual([\n      {name: 'first', value: 10},\n      {name: 'after', value: 'offset'},\n    ]);\n\n    var pictureScalarRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:[\"32\",\"64\"])\n      }\n    `;\n    var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n    expect(pictureScalar.getCallsWithValues()).toEqual([\n      {name: 'size', value: ['32', '64']},\n    ]);\n\n    var pictureVariableRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:[$width,$height])\n      }\n    `;\n    var variables = {\n      height: '64',\n      width: 32,\n    };\n    var pictureVariable =\n      getNode(pictureVariableRQL, variables).getChildren()[0];\n    expect(pictureVariable.getCallsWithValues()).toEqual([\n      {name: 'size', value: [32, '64']},\n    ]);\n  });\n\n  it('returns arguments with array values', () => {\n    var variables = {vanities: ['a', 'b', 'c']};\n    var usernamesQuery = getNode(Relay.QL`\n      query {\n        usernames(names:$vanities) {\n          id\n        }\n      }\n    `, variables);\n    expect(usernamesQuery.getIdentifyingArg()).toEqual(\n      {name: 'names', value: ['a', 'b', 'c']}\n    );\n  });\n\n  it('clones with different call values', () => {\n    var clonedFeed = friendsVariableField.cloneFieldWithCalls(\n      friendsVariableField.getChildren(),\n      [{name: 'first', value: 25}]\n    );\n    expect(clonedFeed.getSchemaName()).toBe('friends');\n    expect(clonedFeed.getCallsWithValues()).toEqual([\n      {name: 'first', value: 25},\n    ]);\n    expect(clonedFeed.getSerializationKey()).toEqual(\n      generateRQLFieldAlias('friends.first(25)')\n    );\n    expect(clonedFeed.getStorageKey()).toEqual('friends');\n\n    clonedFeed = friendsVariableField.cloneFieldWithCalls(\n      friendsVariableField.getChildren(),\n      [\n        {name: 'first', value: 10},\n        {name: 'after', value: 'offset'},\n      ]\n    );\n    expect(clonedFeed).toBe(friendsVariableField);\n  });\n\n  it('returns isAbstract', () => {\n    expect(getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          name\n        }\n      }\n    `).getFieldByStorageKey('actor').isAbstract()).toBe(true);\n    expect(getNode(Relay.QL`\n      fragment on User {\n        address {\n          city\n        }\n      }\n    `).getFieldByStorageKey('address').isAbstract()).toBe(false);\n  });\n\n  it('returns isGenerated', () => {\n    expect(aliasedIdField.isGenerated()).toBe(false);\n    expect(cursorField.isGenerated()).toBe(true);\n    expect(userAddressField.isGenerated()).toBe(false);\n    expect(generatedIdField.isGenerated()).toBe(true);\n    expect(nodeIdField.isGenerated()).toBe(false);\n    expect(pageInfoField.isGenerated()).toBe(true);\n  });\n\n  it('returns isRefQueryDependency', () => {\n    // Not ref query dependencies:\n    expect(aliasedIdField.isRefQueryDependency()).toBe(false);\n    expect(cursorField.isRefQueryDependency()).toBe(false);\n    expect(userAddressField.isRefQueryDependency()).toBe(false);\n    expect(generatedIdField.isRefQueryDependency()).toBe(false);\n    expect(nodeIdField.isRefQueryDependency()).toBe(false);\n    expect(pageInfoField.isRefQueryDependency()).toBe(false);\n\n    // Pretend some of them are ref query dependencies:\n    expect(aliasedIdField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(cursorField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(generatedIdField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(nodeIdField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(pageInfoField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n  });\n\n  it('returns isRequisite', () => {\n    expect(aliasedIdField.isRequisite()).toBe(true);\n    expect(cursorField.isRequisite()).toBe(true);\n    expect(userAddressField.isRequisite()).toBe(false);\n    expect(generatedIdField.isRequisite()).toBe(true);\n    expect(nodeIdField.isRequisite()).toBe(true);\n    expect(pageInfoField.isRequisite()).toBe(true);\n  });\n\n  it('returns isFindable', () => {\n    expect(nodeIdField.isFindable()).toBe(false);\n    expect(friendsScalarField.isFindable()).toBe(true);\n    expect(userAddressField.isFindable()).toBe(false);\n  });\n\n  it('returns the inferred primary key', () => {\n    var field = getNode(Relay.QL`fragment on Story{feedback}`).getChildren()[0];\n    expect(field.getInferredPrimaryKey()).toBe('id');\n\n    expect(friendsScalarField.getInferredPrimaryKey()).toBe(undefined);\n  });\n\n  it('returns the inferred root call name', () => {\n    var field = getNode(Relay.QL`fragment on Story{feedback}`).getChildren()[0];\n    expect(field.getInferredRootCallName()).toBe('node');\n\n    expect(friendsScalarField.getInferredRootCallName()).toBe(undefined);\n  });\n\n  it('creates nodes', () => {\n    var fragmentRQL = Relay.QL`\n      fragment on FeedUnit {\n        actorCount\n      }\n    `;\n    var node = nodeIdField.createNode(fragmentRQL);\n    expect(node instanceof RelayQuery.Fragment).toBe(true);\n    expect(node.getType()).toBe('FeedUnit');\n    expect(node.getRoute()).toBe(nodeIdField.getRoute());\n    expect(node.getVariables()).toBe(nodeIdField.getVariables());\n    expect(node.getFieldByStorageKey('actorCount').getType()).toBe('Int');\n  });\n\n  it('returns directives', () => {\n    var field = getNode(Relay.QL`\n      fragment on Story {\n        feedback @include(if: $cond)\n      }\n    `, {cond: true}).getChildren()[0];\n    expect(field.getDirectives()).toEqual([\n      {\n        args: [\n          {name: 'if', value: true},\n        ],\n        name: 'include',\n      },\n    ]);\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayQuery","RelayTestUtils","generateRQLFieldAlias"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\n\ndescribe('RelayQueryField', () => {\n  var {getNode} = RelayTestUtils;\n\n  let aliasedIdField;\n  let cursorField;\n  let edgesField;\n  let friendsScalarField;\n  let friendsConnectionField;\n  let friendsVariableField;\n  let generatedIdField;\n  let generatedIdFieldRQL;\n  let nodeField;\n  let nodeIdField;\n  let pageInfoField;\n  let userAddressField;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    var scalarRQL = Relay.QL`\n      fragment on Node {\n        id\n      }\n    `;\n    nodeIdField = getNode(scalarRQL).getChildren()[0];\n    expect(nodeIdField.getSchemaName()).toBe('id');\n\n    var query = getNode(Relay.QL`\n      query {\n        node(id:\"4\") {\n          friends(first:\"1\") {\n            edges {\n              node {\n                special_id: id,\n              },\n            },\n          },\n        }\n      }\n    `);\n    friendsConnectionField = query.getChildren()[0];\n    edgesField = friendsConnectionField.getChildren()[0];\n    nodeField = edgesField.getChildren()[0];\n    aliasedIdField =  nodeField.getChildren()[0];\n    expect(aliasedIdField.getSchemaName()).toBe('id');\n\n    var groupRQL = Relay.QL`\n      fragment on User {\n        address {\n          city\n        }\n      }\n    `;\n    userAddressField = getNode(groupRQL).getChildren()[0];\n    expect(userAddressField.getSchemaName()).toBe('address');\n\n    var friendsScalarFieldRQL = Relay.QL`\n      fragment on User {\n        friend_scalar: friends\n          (first:\"10\",after:\"offset\",orderby:\"name\") {\n          edges {\n            node {\n              id\n            }\n          }\n        }\n      }\n    `;\n    friendsScalarField = getNode(friendsScalarFieldRQL).getChildren()[0];\n    expect(friendsScalarField.getSchemaName()).toBe('friends');\n    pageInfoField = getNode(friendsScalarFieldRQL)\n      .getChildren()[0]\n      .getChildren()[1];\n    expect(pageInfoField.getSchemaName())\n      .toBe(RelayConnectionInterface.PAGE_INFO);\n    // feed.edges.cursor\n    cursorField = getNode(friendsScalarFieldRQL)\n      .getChildren()[0].getChildren()[0].getChildren()[1];\n    expect(cursorField.getSchemaName()).toBe('cursor');\n\n    var friendsVariableFieldRQL = Relay.QL`\n      fragment on User {\n        friends_variable: friends(first:$first,after:$after) {\n          edges {\n            node {\n              id\n            }\n          }\n        }\n      }\n    `;\n    var variables = {\n      after: 'offset',\n      first: 10,\n    };\n    friendsVariableField =\n      getNode(friendsVariableFieldRQL, variables).getChildren()[0];\n    expect(friendsVariableField.getSchemaName()).toBe('friends');\n\n    generatedIdFieldRQL = Relay.QL`\n      fragment on User {\n        name\n      }\n    `;\n    generatedIdField = getNode(generatedIdFieldRQL).getChildren()[1];\n    expect(generatedIdField.getSchemaName()).toBe('id');\n  });\n\n  it('returns the type', () => {\n    var actor = getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          name\n        }\n      }\n    `).getChildren()[0];\n    expect(actor.getType()).toBe('Actor');\n  });\n\n  it('gets children by storage key', () => {\n    var edges = friendsScalarField.getFieldByStorageKey('edges');\n    expect(edges).toBe(friendsScalarField.getChildren()[0]);\n  });\n\n  it('gets children by field', () => {\n    var edges = friendsScalarField.getFieldByStorageKey('edges');\n    expect(edges).toBe(friendsScalarField.getChildren()[0]);\n    var varFeedEdges = friendsVariableField.getField(edges);\n    expect(varFeedEdges).toBe(friendsVariableField.getChildren()[0]);\n  });\n\n  it('equals the same fields', () => {\n    expect(nodeIdField.equals(nodeIdField)).toBe(true);\n    expect(userAddressField.equals(userAddressField)).toBe(true);\n    expect(friendsScalarField.equals(friendsScalarField)).toBe(true);\n    expect(friendsVariableField.equals(friendsVariableField)).toBe(true);\n    expect(generatedIdField.equals(generatedIdField)).toBe(true);\n    expect(pageInfoField.equals(pageInfoField)).toBe(true);\n    expect(cursorField.equals(cursorField)).toBe(true);\n  });\n\n  it('equals equivalent fields', () => {\n    var pictureScalarRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:\"32\")\n      }\n    `;\n    var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n    var pictureVariableRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size)\n      }\n    `;\n    var variables = {size: '32'};\n    var pictureVariable =\n      getNode(pictureVariableRQL,  variables).getChildren()[0];\n    expect(pictureScalar.equals(pictureVariable)).toBe(true);\n\n    var diffId = getNode(generatedIdFieldRQL).getChildren()[1];\n    expect(generatedIdField.equals(diffId)).toBe(true);\n  });\n\n  it('does not equal fields with different values', () => {\n    var pictureScalarRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:\"32\")\n      }\n    `;\n    var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n    var pictureVariableRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size)\n      }\n    `;\n    var pictureVariable =\n      getNode(pictureVariableRQL, {size: '33'}).getChildren()[0];\n    expect(pictureScalar.equals(pictureVariable)).toBe(false);\n  });\n\n  it('scalar fields have no children', () => {\n    expect(nodeIdField.canHaveSubselections()).toBe(false);\n    expect(nodeIdField.getChildren().length).toBe(0);\n  });\n\n  it('returns the same object when cloning a scalar field', () => {\n    expect(nodeIdField.clone([])).toBe(nodeIdField);\n  });\n\n  it('clones with updated children', () => {\n    var query = getNode(Relay.QL`\n      fragment on Story {\n        feedback {\n          id,\n          canViewerComment,\n        }\n      }\n    `).getChildren()[0];\n    var clone = query.clone([query.getChildren()[0]]);\n    expect(clone.getChildren().length).toBe(1);\n    expect(clone.getChildren()[0].getSchemaName()).toBe('id');\n    expect(clone.getFieldByStorageKey('canViewerComment')).toBe(undefined);\n  });\n\n  it('throws if cloning a subselection-ineligible field with children', () => {\n    const expectedError = (\n      'RelayQueryNode: Cannot add children to field `id` because it does not ' +\n      'support sub-selections (sub-fields).'\n    );\n    expect(() => {\n      nodeIdField.clone([null]);\n    }).toFailInvariant(expectedError);\n    expect(() => {\n      nodeIdField.cloneFieldWithCalls([null], []);\n    }).toFailInvariant(expectedError);\n  });\n\n  it('returns children', () => {\n    var children = userAddressField.getChildren();\n    expect(children.length).toBe(1);\n    expect(children[0].getSchemaName()).toBe('city');\n  });\n\n  it('return the same object when cloning with the same children', () => {\n    var children = userAddressField.getChildren();\n    var child = children[0];\n    expect(userAddressField.clone(children)).toBe(userAddressField);\n    expect(userAddressField.clone([child])).toBe(userAddressField);\n    expect(userAddressField.clone([child, null])).toBe(userAddressField);\n    expect(userAddressField.clone([null, child, null])).toBe(userAddressField);\n  });\n\n  it('returns a new object when cloning with different children', () => {\n    expect(userAddressField.clone([nodeIdField])).not.toBe(userAddressField);\n  });\n\n  it('returns null when cloning without children', () => {\n    expect(userAddressField.clone([])).toBe(null);\n    expect(userAddressField.clone([null])).toBe(null);\n    expect(userAddressField.cloneFieldWithCalls([], [])).toBe(null);\n    expect(userAddressField.cloneFieldWithCalls([null], [])).toBe(null);\n  });\n\n  it('returns the schema/application names', () => {\n    expect(friendsScalarField.getSchemaName()).toBe('friends');\n    expect(friendsScalarField.getApplicationName()).toBe('friend_scalar');\n\n    expect(friendsVariableField.getSchemaName()).toBe('friends');\n    expect(friendsVariableField.getApplicationName()).toBe('friends_variable');\n  });\n\n  it('returns call types', () => {\n    var field = getNode(\n      Relay.QL`fragment on User{profilePicture(size:\"32\")}`\n    ).getChildren()[0];\n    field.getConcreteQueryNode().calls[0].metadata = {type: 'scalar'};\n\n    expect(field.getCallType('size')).toBe('scalar');\n    expect(field.getCallType('nonExistentCall')).toBe(undefined);\n  });\n\n  it('throws if a variable is missing', () => {\n    var pictureFragment = Relay.QL`\n      fragment on User {\n        profilePicture(size:[$width,$height])\n      }\n    `;\n    var variables = {};\n    var pictureField = getNode(pictureFragment, variables).getChildren()[0];\n    expect(() => pictureField.getCallsWithValues()).toFailInvariant(\n      'callsFromGraphQL(): Expected a declared value for variable, `$width`.'\n    );\n  });\n\n  it('permits null or undefined variable values', () => {\n    var pictureFragment = Relay.QL`\n      fragment on User {\n        profilePicture(size:[$width,$height])\n      }\n    `;\n    var variables = {\n      width: null,\n      height: undefined,\n    };\n    var pictureField = getNode(pictureFragment, variables).getChildren()[0];\n    expect(pictureField.getCallsWithValues()).toEqual([\n      {\n        name: 'size',\n        value: [\n          null,\n          undefined,\n        ],\n      },\n    ]);\n  });\n\n  describe('canHaveSubselections()', () => {\n    it('returns true for fields that support sub-selections', () => {\n      expect(edgesField.canHaveSubselections()).toBe(true);\n      expect(friendsConnectionField.canHaveSubselections()).toBe(true);\n      expect(friendsScalarField.canHaveSubselections()).toBe(true);\n      expect(friendsVariableField.canHaveSubselections()).toBe(true);\n      expect(nodeField.canHaveSubselections()).toBe(true);\n      expect(pageInfoField.canHaveSubselections()).toBe(true);\n      expect(userAddressField.canHaveSubselections()).toBe(true);\n    });\n\n    it('returns false for fields that do not support sub-selections', () => {\n      expect(aliasedIdField.canHaveSubselections()).toBe(false);\n      expect(cursorField.canHaveSubselections()).toBe(false);\n      expect(generatedIdField.canHaveSubselections()).toBe(false);\n      expect(nodeIdField.canHaveSubselections()).toBe(false);\n    });\n  });\n\n  describe('getRangeBehaviorKey()', () => {\n    it('strips range calls on connections', () => {\n      var connectionField = getNode(\n        Relay.QL`fragment on User { friends(first:\"10\",isViewerFriend:true) }`\n      ).getChildren()[0];\n      expect(connectionField.getRangeBehaviorKey())\n        .toBe('isViewerFriend(true)');\n    });\n\n    it('throws for non-connection fields', () => {\n      var nonConnectionField = getNode(\n        Relay.QL`query { node(id:\"4\") }`\n      ).getChildren()[0];\n      expect(nonConnectionField.getRangeBehaviorKey).toThrow();\n    });\n\n    it('strips passing `if` calls', () => {\n      var ifTrue = getNode(\n        Relay.QL`fragment on User { friends(if:true) }`\n      ).getChildren()[0];\n      expect(ifTrue.getRangeBehaviorKey()).toBe('');\n\n      var ifFalse = getNode(\n        Relay.QL`fragment on User { friends(if:false) }`\n      ).getChildren()[0];\n      expect(ifFalse.getRangeBehaviorKey()).toBe('if(false)');\n    });\n\n    it('strips failing `unless` calls', () => {\n      var unlessTrue = getNode(\n        Relay.QL`fragment on User { friends(unless:true) }`\n      ).getChildren()[0];\n      expect(unlessTrue.getRangeBehaviorKey()).toBe('unless(true)');\n\n      var unlessFalse = getNode(Relay.QL`\n        fragment on User {\n          friends(unless:false)\n        }\n      `).getChildren()[0];\n      expect(unlessFalse.getRangeBehaviorKey()).toBe('');\n    });\n\n    it('substitutes variable values', () => {\n      var key = 'isViewerFriend(false)';\n      var friendsScalarRQL = Relay.QL`\n        fragment on User { friends(isViewerFriend:false) }\n      `;\n      var friendsScalar = getNode(friendsScalarRQL).getChildren()[0];\n      expect(friendsScalar.getRangeBehaviorKey()).toBe(key);\n\n      var friendsVariableRQL = Relay.QL`\n        fragment on User { friends(isViewerFriend:$isViewerFriend) }\n      `;\n      var variables = {isViewerFriend: false};\n      var friendsVariable =\n        getNode(friendsVariableRQL, variables).getChildren()[0];\n      expect(friendsVariable.getRangeBehaviorKey()).toBe(key);\n    });\n\n    it('produces stable keys regardless of argument order', () => {\n      var friendFieldA = getNode(Relay.QL`fragment on User {\n        friends(orderby: \"name\", isViewerFriend: true)\n      }`).getChildren()[0];\n      var friendFieldB = getNode(Relay.QL`fragment on User {\n        friends(isViewerFriend: true, orderby: \"name\")\n      }`).getChildren()[0];\n      const expectedKey = 'isViewerFriend(true).orderby(name)';\n      expect(friendFieldA.getRangeBehaviorKey()).toBe(expectedKey);\n      expect(friendFieldB.getRangeBehaviorKey()).toBe(expectedKey);\n    });\n  });\n\n  describe('getSerializationKey()', () => {\n    it('serializes all calls', () => {\n      expect(friendsScalarField.getSerializationKey()).toBe(\n        generateRQLFieldAlias('friends.after(offset).first(10).orderby(name)')\n      );\n    });\n\n    it('substitutes variable values', () => {\n      var key = generateRQLFieldAlias('profilePicture.size(32,64)');\n      var pictureScalarRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[\"32\",\"64\"])\n        }\n      `;\n      var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n      expect(pictureScalar.getSerializationKey()).toBe(key);\n\n      var pictureVariableRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[$width,$height])\n        }\n      `;\n      var variables = {\n        height: 64,\n        width: 32,\n      };\n      var pictureVariable =\n        getNode(pictureVariableRQL, variables).getChildren()[0];\n      expect(pictureVariable.getSerializationKey()).toBe(key);\n    });\n  });\n\n  describe('getShallowHash()', () => {\n    it('serializes all calls', () => {\n      expect(friendsScalarField.getShallowHash()).toBe(\n        'friends{after:\"offset\",first:\"10\",orderby:\"name\"}'\n      );\n    });\n\n    it('serializes argument literal values', () => {\n      var node = getNode(Relay.QL`\n        fragment on User {\n          profilePicture(size: [\"32\", \"64\"])\n        }\n      `);\n      expect(node.getChildren()[0].getShallowHash()).toBe(\n        'profilePicture{size:[0:\"32\",1:\"64\"]}'\n      );\n    });\n\n    it('serializes argument variable values', () => {\n      var node = getNode(Relay.QL`\n        fragment on User {\n          profilePicture(size: [$width, $height])\n        }\n      `, {\n        width: 32,\n        height: 64,\n      });\n      expect(node.getChildren()[0].getShallowHash()).toBe(\n        'profilePicture{size:[0:32,1:64]}'\n      );\n    });\n  });\n\n  describe('getStorageKey()', () => {\n    it('strips range calls on connections', () => {\n      var connectionField = getNode(Relay.QL`\n        fragment on User {\n          friends(first:\"10\",isViewerFriend:true) {\n            edges { node { id } }\n          }\n        }\n      `).getChildren()[0];\n      expect(connectionField.getStorageKey())\n        .toBe('friends{isViewerFriend:true}');\n    });\n\n    it('preserves range-like calls on non-connections', () => {\n      // NOTE: `segments.edges.node` is scalar.\n      var nonConnectionField = getNode(Relay.QL`\n        fragment on Node {\n          segments(first:\"3\") {\n            edges { node }\n          }\n        }\n      `).getChildren()[0];\n      expect(nonConnectionField.getStorageKey()).toBe('segments{first:\"3\"}');\n    });\n\n    it('strips passing `if` calls', () => {\n      var ifTrue = getNode(Relay.QL`\n        fragment on Node {\n          firstName(if:true)\n        }\n      `).getChildren()[0];\n      expect(ifTrue.getStorageKey()).toBe('firstName');\n\n      var ifFalse = getNode(Relay.QL`\n        fragment on Node {\n          firstName(if:false)\n        }\n      `).getChildren()[0];\n      expect(ifFalse.getStorageKey()).toBe('firstName{if:false}');\n    });\n\n    it('strips failing `unless` calls', () => {\n      var unlessTrue = getNode(Relay.QL`\n        fragment on Node{\n          firstName(unless:true)\n        }\n      `).getChildren()[0];\n      expect(unlessTrue.getStorageKey()).toBe('firstName{unless:true}');\n\n      var unlessFalse = getNode(Relay.QL`\n        fragment on Node{\n          firstName(unless:false)\n        }\n      `).getChildren()[0];\n      expect(unlessFalse.getStorageKey()).toBe('firstName');\n    });\n\n    it('substitutes variable values', () => {\n      var key = 'profilePicture{size:[0:\"32\",1:\"64\"]}';\n      var pictureScalarRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[\"32\",\"64\"])\n        }\n      `;\n      var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n      expect(pictureScalar.getStorageKey()).toBe(key);\n\n      var pictureVariableRQL = Relay.QL`\n        fragment on User {\n          profilePicture(size:[$width,$height])\n        }\n      `;\n      var variables = {\n        height: '64',\n        width: '32',\n      };\n      var pictureVariable =\n        getNode(pictureVariableRQL, variables).getChildren()[0];\n      expect(pictureVariable.getStorageKey()).toBe(key);\n    });\n\n    it('produces stable keys regardless of argument order', () => {\n      var pictureFieldA = getNode(Relay.QL`fragment on User {\n        profilePicture(size: \"32\", preset: SMALL)\n      }`).getChildren()[0];\n      var pictureFieldB = getNode(Relay.QL`fragment on User {\n        profilePicture(preset: SMALL, size: \"32\")\n      }`).getChildren()[0];\n      const expectedKey = 'profilePicture{preset:\"SMALL\",size:\"32\"}';\n      expect(pictureFieldA.getStorageKey()).toBe(expectedKey);\n      expect(pictureFieldB.getStorageKey()).toBe(expectedKey);\n    });\n  });\n\n  it('returns arguments with values', () => {\n    // scalar values are converted to strings\n    expect(friendsScalarField.getCallsWithValues()).toEqual([\n      {name: 'first', value: '10'},\n      {name: 'after', value: 'offset'},\n      {name: 'orderby', value: 'name'},\n    ]);\n    // variables return their values\n    expect(friendsVariableField.getCallsWithValues()).toEqual([\n      {name: 'first', value: 10},\n      {name: 'after', value: 'offset'},\n    ]);\n\n    var pictureScalarRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:[\"32\",\"64\"])\n      }\n    `;\n    var pictureScalar = getNode(pictureScalarRQL).getChildren()[0];\n    expect(pictureScalar.getCallsWithValues()).toEqual([\n      {name: 'size', value: ['32', '64']},\n    ]);\n\n    var pictureVariableRQL = Relay.QL`\n      fragment on User {\n        profilePicture(size:[$width,$height])\n      }\n    `;\n    var variables = {\n      height: '64',\n      width: 32,\n    };\n    var pictureVariable =\n      getNode(pictureVariableRQL, variables).getChildren()[0];\n    expect(pictureVariable.getCallsWithValues()).toEqual([\n      {name: 'size', value: [32, '64']},\n    ]);\n  });\n\n  it('returns arguments with array values', () => {\n    var variables = {vanities: ['a', 'b', 'c']};\n    var usernamesQuery = getNode(Relay.QL`\n      query {\n        usernames(names:$vanities) {\n          id\n        }\n      }\n    `, variables);\n    expect(usernamesQuery.getIdentifyingArg()).toEqual(\n      {name: 'names', value: ['a', 'b', 'c']}\n    );\n  });\n\n  it('clones with different call values', () => {\n    var clonedFeed = friendsVariableField.cloneFieldWithCalls(\n      friendsVariableField.getChildren(),\n      [{name: 'first', value: 25}]\n    );\n    expect(clonedFeed.getSchemaName()).toBe('friends');\n    expect(clonedFeed.getCallsWithValues()).toEqual([\n      {name: 'first', value: 25},\n    ]);\n    expect(clonedFeed.getSerializationKey()).toEqual(\n      generateRQLFieldAlias('friends.first(25)')\n    );\n    expect(clonedFeed.getStorageKey()).toEqual('friends');\n\n    clonedFeed = friendsVariableField.cloneFieldWithCalls(\n      friendsVariableField.getChildren(),\n      [\n        {name: 'first', value: 10},\n        {name: 'after', value: 'offset'},\n      ]\n    );\n    expect(clonedFeed).toBe(friendsVariableField);\n  });\n\n  it('returns isAbstract', () => {\n    expect(getNode(Relay.QL`\n      fragment on Viewer {\n        actor {\n          name\n        }\n      }\n    `).getFieldByStorageKey('actor').isAbstract()).toBe(true);\n    expect(getNode(Relay.QL`\n      fragment on User {\n        address {\n          city\n        }\n      }\n    `).getFieldByStorageKey('address').isAbstract()).toBe(false);\n  });\n\n  it('returns isGenerated', () => {\n    expect(aliasedIdField.isGenerated()).toBe(false);\n    expect(cursorField.isGenerated()).toBe(true);\n    expect(userAddressField.isGenerated()).toBe(false);\n    expect(generatedIdField.isGenerated()).toBe(true);\n    expect(nodeIdField.isGenerated()).toBe(false);\n    expect(pageInfoField.isGenerated()).toBe(true);\n  });\n\n  it('returns isRefQueryDependency', () => {\n    // Not ref query dependencies:\n    expect(aliasedIdField.isRefQueryDependency()).toBe(false);\n    expect(cursorField.isRefQueryDependency()).toBe(false);\n    expect(userAddressField.isRefQueryDependency()).toBe(false);\n    expect(generatedIdField.isRefQueryDependency()).toBe(false);\n    expect(nodeIdField.isRefQueryDependency()).toBe(false);\n    expect(pageInfoField.isRefQueryDependency()).toBe(false);\n\n    // Pretend some of them are ref query dependencies:\n    expect(aliasedIdField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(cursorField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(generatedIdField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(nodeIdField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n    expect(pageInfoField.cloneAsRefQueryDependency().isRefQueryDependency())\n      .toBe(true);\n  });\n\n  it('returns isRequisite', () => {\n    expect(aliasedIdField.isRequisite()).toBe(true);\n    expect(cursorField.isRequisite()).toBe(true);\n    expect(userAddressField.isRequisite()).toBe(false);\n    expect(generatedIdField.isRequisite()).toBe(true);\n    expect(nodeIdField.isRequisite()).toBe(true);\n    expect(pageInfoField.isRequisite()).toBe(true);\n  });\n\n  it('returns isFindable', () => {\n    expect(nodeIdField.isFindable()).toBe(false);\n    expect(friendsScalarField.isFindable()).toBe(true);\n    expect(userAddressField.isFindable()).toBe(false);\n  });\n\n  it('returns the inferred primary key', () => {\n    var field = getNode(Relay.QL`fragment on Story{feedback}`).getChildren()[0];\n    expect(field.getInferredPrimaryKey()).toBe('id');\n\n    expect(friendsScalarField.getInferredPrimaryKey()).toBe(undefined);\n  });\n\n  it('returns the inferred root call name', () => {\n    var field = getNode(Relay.QL`fragment on Story{feedback}`).getChildren()[0];\n    expect(field.getInferredRootCallName()).toBe('node');\n\n    expect(friendsScalarField.getInferredRootCallName()).toBe(undefined);\n  });\n\n  it('creates nodes', () => {\n    var fragmentRQL = Relay.QL`\n      fragment on FeedUnit {\n        actorCount\n      }\n    `;\n    var node = nodeIdField.createNode(fragmentRQL);\n    expect(node instanceof RelayQuery.Fragment).toBe(true);\n    expect(node.getType()).toBe('FeedUnit');\n    expect(node.getRoute()).toBe(nodeIdField.getRoute());\n    expect(node.getVariables()).toBe(nodeIdField.getVariables());\n    expect(node.getFieldByStorageKey('actorCount').getType()).toBe('Int');\n  });\n\n  it('returns directives', () => {\n    var field = getNode(Relay.QL`\n      fragment on Story {\n        feedback @include(if: $cond)\n      }\n    `, {cond: true}).getChildren()[0];\n    expect(field.getDirectives()).toEqual([\n      {\n        args: [\n          {name: 'if', value: true},\n        ],\n        name: 'include',\n      },\n    ]);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQueryField-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQuery-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQuery', () => {\n  var {getNode} = RelayTestUtils;\n\n  function buildIdField() {\n    return RelayQuery.Field.build({\n      fieldName: 'id',\n      type: 'String',\n    });\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('Root', () => {\n    describe('build()', () => {\n      it('creates roots', () => {\n        var field = buildIdField();\n        var root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'node',\n          '4',\n          [field]\n        );\n        expect(root instanceof RelayQuery.Root).toBe(true);\n        expect(root.getChildren().length).toBe(1);\n        expect(root.getChildren()[0]).toBe(field);\n      });\n\n      it('creates deferred roots', () => {\n        var field = buildIdField();\n        var root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'node',\n          '4',\n          [field],\n          {isDeferred: true}\n        );\n        expect(root instanceof RelayQuery.Root).toBe(true);\n        expect(root.getChildren().length).toBe(1);\n        expect(root.getChildren()[0]).toBe(field);\n      });\n\n      it('creates roots with batch calls', () => {\n        var root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'node',\n          QueryBuilder.createBatchCallVariable('q0', '$.*.id'),\n          []\n        );\n        expect(root instanceof RelayQuery.Root).toBe(true);\n        expect(root.getBatchCall()).toEqual({\n          refParamName: 'ref_q0',\n          sourceQueryID: 'q0',\n          sourceQueryPath: '$.*.id',\n        });\n      });\n    });\n\n    describe('getCallsWithValues()', () => {\n      it('returns an empty array when there are no arguments', () => {\n        const root = RelayQuery.Root.build('RelayQueryTest', 'viewer');\n        expect(root.getCallsWithValues()).toEqual([]);\n      });\n\n      it('returns an array including the identifying argument', () => {\n        const root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'foo',\n          '123',\n          null,\n          {identifyingArgName: 'id'}\n        );\n        expect(root.getCallsWithValues()).toEqual([\n          {name: 'id', value: '123'},\n        ]);\n      });\n\n      // it('returns an array of every argument', () => {\n      //   //   TODO: When it's possible to do so, create a root with both\n      //   //         identifying and non-identifying arguments.\n      //   const root;\n      //   expect(root.getCallsWithValues()).toEqual([\n      //     /* all of the arguments */\n      //   ]);\n      // });\n    });\n\n    describe('getFieldName()', () => {\n      it('returns the name of the root field', () => {\n        const root = RelayQuery.Root.build('RelayQueryTest', 'viewer');\n        expect(root.getFieldName()).toBe('viewer');\n      });\n    });\n\n    describe('getIdentifyingArg()', () => {\n      it('returns nothing when there is no identifying argument', () => {\n        const root = RelayQuery.Root.build('RelayQueryTest', 'viewer');\n        expect(root.getIdentifyingArg()).toBeUndefined();\n      });\n\n      it('returns the sole identifying argument', () => {\n        const root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'foo',\n          '123',\n          null,\n          {identifyingArgName: 'id'}\n        );\n        expect(root.getIdentifyingArg()).toEqual({\n          name: 'id',\n          value: '123',\n        });\n      });\n\n      it('returns the identifying argument with type', () => {\n        const root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'foo',\n          '123',\n          null,\n          {identifyingArgName: 'id', identifyingArgType: 'scalar'}\n        );\n        expect(root.getIdentifyingArg()).toEqual({\n          name: 'id',\n          type: 'scalar',\n          value: '123',\n        });\n      });\n\n      // it('returns only the identifying argument', () => {\n      //   TODO: When it's possible to do so, create a root with both\n      //         identifying and non-identifying arguments.\n      //   const root;\n      //   expect(root.getIdentifyingArg()).toBe({\n      //    /* only the identifying one */\n      //   });\n      // });\n    });\n  });\n\n  describe('Fragment', () => {\n    describe('build()', () => {\n      it('creates empty fragments', () => {\n        var fragment = RelayQuery.Fragment.build(\n          'TestFragment',\n          'Node',\n          []\n        );\n        expect(fragment instanceof RelayQuery.Fragment).toBe(true);\n        expect(fragment.getDebugName()).toBe('TestFragment');\n        expect(fragment.getType()).toBe('Node');\n        expect(fragment.getChildren().length).toBe(0);\n        expect(fragment.isPlural()).toBe(false);\n      });\n\n      it('creates fragments', () => {\n        var field = buildIdField();\n        var fragment = RelayQuery.Fragment.build(\n          'TestFragment',\n          'Node',\n          [field],\n          {plural: true}\n        );\n        expect(fragment instanceof RelayQuery.Fragment).toBe(true);\n        expect(fragment.getDebugName()).toBe('TestFragment');\n        expect(fragment.getType()).toBe('Node');\n        expect(fragment.getChildren().length).toBe(1);\n        expect(fragment.getChildren()[0]).toBe(field);\n        expect(fragment.isPlural()).toBe(true);\n      });\n    });\n\n    describe('getConcreteFragmentID()', () => {\n      it('returns the same id for two different RelayQuery nodes', () => {\n        const concreteNode = Relay.QL`fragment on Node { id }`;\n        const fragmentA = getNode(concreteNode);\n        const fragmentB = getNode(concreteNode);\n        expect(fragmentA.getConcreteFragmentID())\n          .toBe(fragmentB.getConcreteFragmentID());\n      });\n\n      it('returns a different id for two different concrete nodes', () => {\n        const fragmentA = getNode(Relay.QL`fragment on Node { id }`);\n        const fragmentB = getNode(Relay.QL`fragment on Node { id }`);\n        expect(fragmentA.getConcreteFragmentID())\n          .not.toBe(fragmentB.getConcreteFragmentID());\n      });\n    });\n\n    describe('getCompositeHash()', () => {\n      it('returns one hash for nodes with the same variables / route', () => {\n        const node = Relay.QL`fragment on Node { id }`;\n        const route = RelayMetaRoute.get('route');\n        const variables = {foo: 123};\n        expect(\n          new RelayQuery.Fragment(node, route, variables).getCompositeHash()\n        ).toBe(\n          new RelayQuery.Fragment(node, route, variables).getCompositeHash()\n        );\n      });\n\n      it('returns different hashes for nodes with different variables', () => {\n        const node = Relay.QL`fragment on Node { id }`;\n        const route = RelayMetaRoute.get('route');\n        const variablesA = {foo: 123};\n        const variablesB = {foo: 456};\n        expect(\n          new RelayQuery.Fragment(node, route, variablesA).getCompositeHash()\n        ).not.toBe(\n          new RelayQuery.Fragment(node, route, variablesB).getCompositeHash()\n        );\n      });\n\n      it('returns different hashes for nodes with different routes', () => {\n        const node = Relay.QL`fragment on Node { id }`;\n        const routeA = RelayMetaRoute.get('routeA');\n        const routeB = RelayMetaRoute.get('routeB');\n        const variables = {foo: 123};\n        expect(\n          new RelayQuery.Fragment(node, routeA, variables).getCompositeHash()\n        ).not.toBe(\n          new RelayQuery.Fragment(node, routeB, variables).getCompositeHash()\n        );\n      });\n\n      it('returns one hash for nodes cloned with the same children', () => {\n        const fragment = getNode(Relay.QL`fragment on Node { id, __typename }`);\n        const fragmentClone = fragment.clone(fragment.getChildren());\n        expect(fragmentClone.getCompositeHash())\n          .toBe(fragment.getCompositeHash());\n      });\n\n      it('returns different hashes for nodes cloned with new children', () => {\n        const fragment = getNode(Relay.QL`fragment on Node { id, __typename }`);\n        const fragmentClone = fragment.clone(fragment.getChildren().slice(1));\n        expect(fragmentClone.getCompositeHash())\n          .not.toBe(fragment.getCompositeHash());\n      });\n    });\n  });\n\n  describe('Field', () => {\n    describe('build()', () => {\n      it('builds scalar fields', () => {\n        var field = buildIdField();\n        expect(field instanceof RelayQuery.Field).toBe(true);\n        expect(field.getSchemaName()).toBe('id');\n        expect(field.getApplicationName()).toBe('id');\n        expect(field.canHaveSubselections()).toBe(false);\n        expect(field.getChildren().length).toBe(0);\n        expect(field.getCallsWithValues()).toEqual([]);\n      });\n\n      it('builds fields with children', () => {\n        var child = buildIdField();\n        var fragment = getNode(Relay.QL`fragment on Node{id}`);\n        var field = RelayQuery.Field.build({\n          fieldName: 'node',\n          children: [child, fragment],\n          metadata: {canHaveSubselections: true},\n          type: 'Node',\n        });\n        expect(field.canHaveSubselections()).toBe(true);\n        var children = field.getChildren();\n        expect(children.length).toBe(2);\n        expect(children[0]).toBe(child);\n        expect(children[1]).toBe(fragment);\n      });\n\n      it('builds fields with calls', () => {\n        var field = RelayQuery.Field.build({\n          fieldName: 'profilePicture',\n          calls: [\n            {name: 'size', value: 32},\n          ],\n          metadata: {canHaveSubselections: true},\n          type: 'ProfilePicture',\n        });\n        expect(field.getCallsWithValues()).toEqual([\n          {name: 'size', value: 32},\n        ]);\n        field = RelayQuery.Field.build({\n          fieldName: 'profilePicture',\n          calls: [\n            {name: 'size', value: ['32']},\n          ],\n          metadata: {canHaveSubselections: true},\n          type: 'ProfilePicture',\n        });\n        expect(field.getCallsWithValues()).toEqual([\n          {name: 'size', value: ['32']},\n        ]);\n      });\n\n      it('builds directives with argument values', () => {\n        const field = RelayQuery.Field.build({\n          directives: [{\n            args: [{\n              name: 'bar',\n              value: 'baz',\n            }],\n            name: 'foo',\n          }],\n          fieldName: 'profilePicture',\n          type: 'ProfilePicture',\n        });\n        expect(field.getDirectives()).toEqual([{\n          args: [{name: 'bar', value: 'baz'}],\n          name: 'foo',\n        }]);\n      });\n    });\n  });\n\n  describe('Mutation', () => {\n    describe('buildMutation()', () => {\n      it('builds mutation with value', () => {\n        var field = RelayQuery.Field.build({\n          fieldName: 'does_viewer_like',\n          type: 'Boolean',\n        });\n        var mutation = RelayQuery.Mutation.build(\n          'FeedbackLikeMutation',\n          'FeedbackLikeResponsePayload',\n          'feedback_like',\n          {feedback_id:'123'},\n          [field]\n        );\n\n        expect(mutation instanceof RelayQuery.Mutation).toBe(true);\n        expect(mutation.getName()).toBe('FeedbackLikeMutation');\n        expect(mutation.getResponseType()).toBe('FeedbackLikeResponsePayload');\n        expect(mutation.getChildren().length).toBe(1);\n        expect(mutation.getChildren()[0]).toBe(field);\n        expect(mutation.getCall())\n          .toEqual({name: 'feedback_like', value: {feedback_id:'123'}});\n        expect(mutation.getCallVariableName()).toEqual('input');\n      });\n\n      it('builds mutation with variable', () => {\n        var field = RelayQuery.Field.build({\n          fieldName: 'does_viewer_like',\n          type: 'Boolean',\n        });\n        var mutation = RelayQuery.Mutation.build(\n          'FeedbackLikeMutation',\n          'FeedbackLikeResponsePayload',\n          'feedback_like',\n          undefined,\n          [field]\n        );\n\n        expect(mutation instanceof RelayQuery.Mutation).toBe(true);\n        expect(mutation.getName()).toBe('FeedbackLikeMutation');\n        expect(mutation.getResponseType()).toBe('FeedbackLikeResponsePayload');\n        expect(mutation.getChildren().length).toBe(1);\n        expect(mutation.getChildren()[0]).toBe(field);\n        expect(mutation.getCall())\n          .toEqual({name: 'feedback_like', value: ''});\n        expect(mutation.getCallVariableName()).toEqual('input');\n      });\n    });\n  });\n\n  describe('isEquivalent()', () => {\n    it('returns false for different concrete nodes', () => {\n      var node1 = getNode(Relay.QL`fragment on Node{id}`);\n      var ndoe2 = getNode(Relay.QL`fragment on Node{id}`);\n      expect(node1.isEquivalent(ndoe2)).toBe(false);\n    });\n\n    it('return false for different variables', () => {\n      var fragment = Relay.QL`fragment on Node{id}`;\n\n      var node1 = getNode(fragment, {a: true});\n      var ndoe2 = getNode(fragment, {a: false});\n      expect(node1.isEquivalent(ndoe2)).toBe(false);\n    });\n\n    it('returns false for different routes', () => {\n      var fragment = Relay.QL`fragment on Node{id}`;\n      var variables = {a: false};\n      var route1 = RelayMetaRoute.get('route1');\n      var route2 = RelayMetaRoute.get('route2');\n\n      var node1 = RelayQuery.Fragment.create(fragment, route1, variables);\n      var node2 = RelayQuery.Fragment.create(fragment, route2, variables);\n      expect(node1.isEquivalent(node2)).toBe(false);\n    });\n\n    it('returns true for identical node, route, and variables', () => {\n      var fragment = Relay.QL`fragment on Node{id}`;\n      var variables = {a: false};\n      var route = RelayMetaRoute.get('route1');\n\n      var node1 = RelayQuery.Fragment.create(fragment, route, variables);\n      var node2 = RelayQuery.Fragment.create(fragment, route, variables);\n      expect(node1.isEquivalent(node2)).toBe(true);\n    });\n  });\n\n  describe('getChildren()', () => {\n    it('expands fragment references', () => {\n      var innerFragment = Relay.QL`\n        fragment on User {\n          id,\n          profilePicture(size:$size) {\n            uri,\n          },\n        }\n      `;\n      var reference = new RelayFragmentReference(\n        () => innerFragment,\n        {\n          size: 'default',\n        },\n        {\n          size: QueryBuilder.createCallVariable('outerSize'),\n        }\n      );\n      var fragment = getNode(Relay.QL`\n        fragment on User {\n          id,\n          ${reference},\n        }\n      `, {\n        outerSize: 'override',\n      });\n      var children = fragment.getChildren();\n      expect(children.length).toBe(2);\n      expect(children[0].getSchemaName()).toBe('id');\n\n      // the reference is expanded with overridden query variables\n      expect(children[1] instanceof RelayQuery.Fragment);\n      expect(children[1].getType()).toBe('User');\n      var grandchildren = children[1].getChildren();\n      expect(grandchildren.length).toBe(2);\n      expect(grandchildren[0].getSchemaName()).toBe('id');\n      expect(grandchildren[1].getSchemaName()).toBe('profilePicture');\n      expect(grandchildren[1].getCallsWithValues()).toEqual([\n        {name: 'size', value: 'override'},\n      ]);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","Relay","RelayFragmentReference","RelayMetaRoute","RelayQuery","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQuery', () => {\n  var {getNode} = RelayTestUtils;\n\n  function buildIdField() {\n    return RelayQuery.Field.build({\n      fieldName: 'id',\n      type: 'String',\n    });\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('Root', () => {\n    describe('build()', () => {\n      it('creates roots', () => {\n        var field = buildIdField();\n        var root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'node',\n          '4',\n          [field]\n        );\n        expect(root instanceof RelayQuery.Root).toBe(true);\n        expect(root.getChildren().length).toBe(1);\n        expect(root.getChildren()[0]).toBe(field);\n      });\n\n      it('creates deferred roots', () => {\n        var field = buildIdField();\n        var root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'node',\n          '4',\n          [field],\n          {isDeferred: true}\n        );\n        expect(root instanceof RelayQuery.Root).toBe(true);\n        expect(root.getChildren().length).toBe(1);\n        expect(root.getChildren()[0]).toBe(field);\n      });\n\n      it('creates roots with batch calls', () => {\n        var root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'node',\n          QueryBuilder.createBatchCallVariable('q0', '$.*.id'),\n          []\n        );\n        expect(root instanceof RelayQuery.Root).toBe(true);\n        expect(root.getBatchCall()).toEqual({\n          refParamName: 'ref_q0',\n          sourceQueryID: 'q0',\n          sourceQueryPath: '$.*.id',\n        });\n      });\n    });\n\n    describe('getCallsWithValues()', () => {\n      it('returns an empty array when there are no arguments', () => {\n        const root = RelayQuery.Root.build('RelayQueryTest', 'viewer');\n        expect(root.getCallsWithValues()).toEqual([]);\n      });\n\n      it('returns an array including the identifying argument', () => {\n        const root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'foo',\n          '123',\n          null,\n          {identifyingArgName: 'id'}\n        );\n        expect(root.getCallsWithValues()).toEqual([\n          {name: 'id', value: '123'},\n        ]);\n      });\n\n      // it('returns an array of every argument', () => {\n      //   //   TODO: When it's possible to do so, create a root with both\n      //   //         identifying and non-identifying arguments.\n      //   const root;\n      //   expect(root.getCallsWithValues()).toEqual([\n      //     /* all of the arguments */\n      //   ]);\n      // });\n    });\n\n    describe('getFieldName()', () => {\n      it('returns the name of the root field', () => {\n        const root = RelayQuery.Root.build('RelayQueryTest', 'viewer');\n        expect(root.getFieldName()).toBe('viewer');\n      });\n    });\n\n    describe('getIdentifyingArg()', () => {\n      it('returns nothing when there is no identifying argument', () => {\n        const root = RelayQuery.Root.build('RelayQueryTest', 'viewer');\n        expect(root.getIdentifyingArg()).toBeUndefined();\n      });\n\n      it('returns the sole identifying argument', () => {\n        const root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'foo',\n          '123',\n          null,\n          {identifyingArgName: 'id'}\n        );\n        expect(root.getIdentifyingArg()).toEqual({\n          name: 'id',\n          value: '123',\n        });\n      });\n\n      it('returns the identifying argument with type', () => {\n        const root = RelayQuery.Root.build(\n          'RelayQueryTest',\n          'foo',\n          '123',\n          null,\n          {identifyingArgName: 'id', identifyingArgType: 'scalar'}\n        );\n        expect(root.getIdentifyingArg()).toEqual({\n          name: 'id',\n          type: 'scalar',\n          value: '123',\n        });\n      });\n\n      // it('returns only the identifying argument', () => {\n      //   TODO: When it's possible to do so, create a root with both\n      //         identifying and non-identifying arguments.\n      //   const root;\n      //   expect(root.getIdentifyingArg()).toBe({\n      //    /* only the identifying one */\n      //   });\n      // });\n    });\n  });\n\n  describe('Fragment', () => {\n    describe('build()', () => {\n      it('creates empty fragments', () => {\n        var fragment = RelayQuery.Fragment.build(\n          'TestFragment',\n          'Node',\n          []\n        );\n        expect(fragment instanceof RelayQuery.Fragment).toBe(true);\n        expect(fragment.getDebugName()).toBe('TestFragment');\n        expect(fragment.getType()).toBe('Node');\n        expect(fragment.getChildren().length).toBe(0);\n        expect(fragment.isPlural()).toBe(false);\n      });\n\n      it('creates fragments', () => {\n        var field = buildIdField();\n        var fragment = RelayQuery.Fragment.build(\n          'TestFragment',\n          'Node',\n          [field],\n          {plural: true}\n        );\n        expect(fragment instanceof RelayQuery.Fragment).toBe(true);\n        expect(fragment.getDebugName()).toBe('TestFragment');\n        expect(fragment.getType()).toBe('Node');\n        expect(fragment.getChildren().length).toBe(1);\n        expect(fragment.getChildren()[0]).toBe(field);\n        expect(fragment.isPlural()).toBe(true);\n      });\n    });\n\n    describe('getConcreteFragmentID()', () => {\n      it('returns the same id for two different RelayQuery nodes', () => {\n        const concreteNode = Relay.QL`fragment on Node { id }`;\n        const fragmentA = getNode(concreteNode);\n        const fragmentB = getNode(concreteNode);\n        expect(fragmentA.getConcreteFragmentID())\n          .toBe(fragmentB.getConcreteFragmentID());\n      });\n\n      it('returns a different id for two different concrete nodes', () => {\n        const fragmentA = getNode(Relay.QL`fragment on Node { id }`);\n        const fragmentB = getNode(Relay.QL`fragment on Node { id }`);\n        expect(fragmentA.getConcreteFragmentID())\n          .not.toBe(fragmentB.getConcreteFragmentID());\n      });\n    });\n\n    describe('getCompositeHash()', () => {\n      it('returns one hash for nodes with the same variables / route', () => {\n        const node = Relay.QL`fragment on Node { id }`;\n        const route = RelayMetaRoute.get('route');\n        const variables = {foo: 123};\n        expect(\n          new RelayQuery.Fragment(node, route, variables).getCompositeHash()\n        ).toBe(\n          new RelayQuery.Fragment(node, route, variables).getCompositeHash()\n        );\n      });\n\n      it('returns different hashes for nodes with different variables', () => {\n        const node = Relay.QL`fragment on Node { id }`;\n        const route = RelayMetaRoute.get('route');\n        const variablesA = {foo: 123};\n        const variablesB = {foo: 456};\n        expect(\n          new RelayQuery.Fragment(node, route, variablesA).getCompositeHash()\n        ).not.toBe(\n          new RelayQuery.Fragment(node, route, variablesB).getCompositeHash()\n        );\n      });\n\n      it('returns different hashes for nodes with different routes', () => {\n        const node = Relay.QL`fragment on Node { id }`;\n        const routeA = RelayMetaRoute.get('routeA');\n        const routeB = RelayMetaRoute.get('routeB');\n        const variables = {foo: 123};\n        expect(\n          new RelayQuery.Fragment(node, routeA, variables).getCompositeHash()\n        ).not.toBe(\n          new RelayQuery.Fragment(node, routeB, variables).getCompositeHash()\n        );\n      });\n\n      it('returns one hash for nodes cloned with the same children', () => {\n        const fragment = getNode(Relay.QL`fragment on Node { id, __typename }`);\n        const fragmentClone = fragment.clone(fragment.getChildren());\n        expect(fragmentClone.getCompositeHash())\n          .toBe(fragment.getCompositeHash());\n      });\n\n      it('returns different hashes for nodes cloned with new children', () => {\n        const fragment = getNode(Relay.QL`fragment on Node { id, __typename }`);\n        const fragmentClone = fragment.clone(fragment.getChildren().slice(1));\n        expect(fragmentClone.getCompositeHash())\n          .not.toBe(fragment.getCompositeHash());\n      });\n    });\n  });\n\n  describe('Field', () => {\n    describe('build()', () => {\n      it('builds scalar fields', () => {\n        var field = buildIdField();\n        expect(field instanceof RelayQuery.Field).toBe(true);\n        expect(field.getSchemaName()).toBe('id');\n        expect(field.getApplicationName()).toBe('id');\n        expect(field.canHaveSubselections()).toBe(false);\n        expect(field.getChildren().length).toBe(0);\n        expect(field.getCallsWithValues()).toEqual([]);\n      });\n\n      it('builds fields with children', () => {\n        var child = buildIdField();\n        var fragment = getNode(Relay.QL`fragment on Node{id}`);\n        var field = RelayQuery.Field.build({\n          fieldName: 'node',\n          children: [child, fragment],\n          metadata: {canHaveSubselections: true},\n          type: 'Node',\n        });\n        expect(field.canHaveSubselections()).toBe(true);\n        var children = field.getChildren();\n        expect(children.length).toBe(2);\n        expect(children[0]).toBe(child);\n        expect(children[1]).toBe(fragment);\n      });\n\n      it('builds fields with calls', () => {\n        var field = RelayQuery.Field.build({\n          fieldName: 'profilePicture',\n          calls: [\n            {name: 'size', value: 32},\n          ],\n          metadata: {canHaveSubselections: true},\n          type: 'ProfilePicture',\n        });\n        expect(field.getCallsWithValues()).toEqual([\n          {name: 'size', value: 32},\n        ]);\n        field = RelayQuery.Field.build({\n          fieldName: 'profilePicture',\n          calls: [\n            {name: 'size', value: ['32']},\n          ],\n          metadata: {canHaveSubselections: true},\n          type: 'ProfilePicture',\n        });\n        expect(field.getCallsWithValues()).toEqual([\n          {name: 'size', value: ['32']},\n        ]);\n      });\n\n      it('builds directives with argument values', () => {\n        const field = RelayQuery.Field.build({\n          directives: [{\n            args: [{\n              name: 'bar',\n              value: 'baz',\n            }],\n            name: 'foo',\n          }],\n          fieldName: 'profilePicture',\n          type: 'ProfilePicture',\n        });\n        expect(field.getDirectives()).toEqual([{\n          args: [{name: 'bar', value: 'baz'}],\n          name: 'foo',\n        }]);\n      });\n    });\n  });\n\n  describe('Mutation', () => {\n    describe('buildMutation()', () => {\n      it('builds mutation with value', () => {\n        var field = RelayQuery.Field.build({\n          fieldName: 'does_viewer_like',\n          type: 'Boolean',\n        });\n        var mutation = RelayQuery.Mutation.build(\n          'FeedbackLikeMutation',\n          'FeedbackLikeResponsePayload',\n          'feedback_like',\n          {feedback_id:'123'},\n          [field]\n        );\n\n        expect(mutation instanceof RelayQuery.Mutation).toBe(true);\n        expect(mutation.getName()).toBe('FeedbackLikeMutation');\n        expect(mutation.getResponseType()).toBe('FeedbackLikeResponsePayload');\n        expect(mutation.getChildren().length).toBe(1);\n        expect(mutation.getChildren()[0]).toBe(field);\n        expect(mutation.getCall())\n          .toEqual({name: 'feedback_like', value: {feedback_id:'123'}});\n        expect(mutation.getCallVariableName()).toEqual('input');\n      });\n\n      it('builds mutation with variable', () => {\n        var field = RelayQuery.Field.build({\n          fieldName: 'does_viewer_like',\n          type: 'Boolean',\n        });\n        var mutation = RelayQuery.Mutation.build(\n          'FeedbackLikeMutation',\n          'FeedbackLikeResponsePayload',\n          'feedback_like',\n          undefined,\n          [field]\n        );\n\n        expect(mutation instanceof RelayQuery.Mutation).toBe(true);\n        expect(mutation.getName()).toBe('FeedbackLikeMutation');\n        expect(mutation.getResponseType()).toBe('FeedbackLikeResponsePayload');\n        expect(mutation.getChildren().length).toBe(1);\n        expect(mutation.getChildren()[0]).toBe(field);\n        expect(mutation.getCall())\n          .toEqual({name: 'feedback_like', value: ''});\n        expect(mutation.getCallVariableName()).toEqual('input');\n      });\n    });\n  });\n\n  describe('isEquivalent()', () => {\n    it('returns false for different concrete nodes', () => {\n      var node1 = getNode(Relay.QL`fragment on Node{id}`);\n      var ndoe2 = getNode(Relay.QL`fragment on Node{id}`);\n      expect(node1.isEquivalent(ndoe2)).toBe(false);\n    });\n\n    it('return false for different variables', () => {\n      var fragment = Relay.QL`fragment on Node{id}`;\n\n      var node1 = getNode(fragment, {a: true});\n      var ndoe2 = getNode(fragment, {a: false});\n      expect(node1.isEquivalent(ndoe2)).toBe(false);\n    });\n\n    it('returns false for different routes', () => {\n      var fragment = Relay.QL`fragment on Node{id}`;\n      var variables = {a: false};\n      var route1 = RelayMetaRoute.get('route1');\n      var route2 = RelayMetaRoute.get('route2');\n\n      var node1 = RelayQuery.Fragment.create(fragment, route1, variables);\n      var node2 = RelayQuery.Fragment.create(fragment, route2, variables);\n      expect(node1.isEquivalent(node2)).toBe(false);\n    });\n\n    it('returns true for identical node, route, and variables', () => {\n      var fragment = Relay.QL`fragment on Node{id}`;\n      var variables = {a: false};\n      var route = RelayMetaRoute.get('route1');\n\n      var node1 = RelayQuery.Fragment.create(fragment, route, variables);\n      var node2 = RelayQuery.Fragment.create(fragment, route, variables);\n      expect(node1.isEquivalent(node2)).toBe(true);\n    });\n  });\n\n  describe('getChildren()', () => {\n    it('expands fragment references', () => {\n      var innerFragment = Relay.QL`\n        fragment on User {\n          id,\n          profilePicture(size:$size) {\n            uri,\n          },\n        }\n      `;\n      var reference = new RelayFragmentReference(\n        () => innerFragment,\n        {\n          size: 'default',\n        },\n        {\n          size: QueryBuilder.createCallVariable('outerSize'),\n        }\n      );\n      var fragment = getNode(Relay.QL`\n        fragment on User {\n          id,\n          ${reference},\n        }\n      `, {\n        outerSize: 'override',\n      });\n      var children = fragment.getChildren();\n      expect(children.length).toBe(2);\n      expect(children[0].getSchemaName()).toBe('id');\n\n      // the reference is expanded with overridden query variables\n      expect(children[1] instanceof RelayQuery.Fragment);\n      expect(children[1].getType()).toBe('User');\n      var grandchildren = children[1].getChildren();\n      expect(grandchildren.length).toBe(2);\n      expect(grandchildren[0].getSchemaName()).toBe('id');\n      expect(grandchildren[1].getSchemaName()).toBe('profilePicture');\n      expect(grandchildren[1].getCallsWithValues()).toEqual([\n        {name: 'size', value: 'override'},\n      ]);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQuery-getCallsWithValues-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryNode.prototype.getCallsWithValues()', function() {\n  var {getNode} = RelayTestUtils;\n\n  function getProfilePicture(callValue, variables) {\n    return getNode(\n      QueryBuilder.createField({\n        calls: [QueryBuilder.createCall('size', callValue)],\n        fieldName: 'profile_picture',\n      }),\n      variables\n    );\n  }\n\n  describe('scalar-valued calls', () => {\n    describe('with inline values', () => {\n      it('are null when empty', () => {\n        var field = getProfilePicture(null);\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: null,\n        }]);\n      });\n\n      it('return singular values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallValue(32));\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: 32,\n        }]);\n      });\n    });\n\n    describe('with variables', () => {\n      it('return `null` for empty values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: null,\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: null,\n        }]);\n      });\n\n      it('return empty arrays', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: [],\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [],\n        }]);\n      });\n\n      it('return singular values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: 32,\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: 32,\n        }]);\n      });\n\n      it('return array values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: [32],\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [32],\n        }]);\n      });\n    });\n  });\n\n  describe('array-valued calls', () => {\n    describe('with inline values', () => {\n      it('return empty arrays', () => {\n        var field = getProfilePicture([]);\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [],\n        }]);\n      });\n\n      it('return an array of values', () => {\n        var field = getProfilePicture([\n          QueryBuilder.createCallValue(64),\n        ]);\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [64],\n        }]);\n      });\n    });\n\n    describe('with variable', () => {\n      it('return `[null]` for empty values', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: null}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [null],\n        }]);\n      });\n\n      it('return empty arrays', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: []}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [[]],\n        }]);\n      });\n\n      it('return arrays for singular values', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: 32}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [32],\n        }]);\n      });\n\n      it('return nested ararys for array values', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: [32]}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [[32]],\n        }]);\n      });\n\n      it('returns flat arrays for scalar values', () => {\n        var field = getProfilePicture([\n          QueryBuilder.createCallVariable('width'),\n          QueryBuilder.createCallVariable('height'),\n        ], {\n          width: 32,\n          height: 64,\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [32, 64],\n        }]);\n      });\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst QueryBuilder = require('QueryBuilder');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQueryNode.prototype.getCallsWithValues()', function() {\n  var {getNode} = RelayTestUtils;\n\n  function getProfilePicture(callValue, variables) {\n    return getNode(\n      QueryBuilder.createField({\n        calls: [QueryBuilder.createCall('size', callValue)],\n        fieldName: 'profile_picture',\n      }),\n      variables\n    );\n  }\n\n  describe('scalar-valued calls', () => {\n    describe('with inline values', () => {\n      it('are null when empty', () => {\n        var field = getProfilePicture(null);\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: null,\n        }]);\n      });\n\n      it('return singular values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallValue(32));\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: 32,\n        }]);\n      });\n    });\n\n    describe('with variables', () => {\n      it('return `null` for empty values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: null,\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: null,\n        }]);\n      });\n\n      it('return empty arrays', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: [],\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [],\n        }]);\n      });\n\n      it('return singular values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: 32,\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: 32,\n        }]);\n      });\n\n      it('return array values', () => {\n        var field = getProfilePicture(QueryBuilder.createCallVariable('size'), {\n          size: [32],\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [32],\n        }]);\n      });\n    });\n  });\n\n  describe('array-valued calls', () => {\n    describe('with inline values', () => {\n      it('return empty arrays', () => {\n        var field = getProfilePicture([]);\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [],\n        }]);\n      });\n\n      it('return an array of values', () => {\n        var field = getProfilePicture([\n          QueryBuilder.createCallValue(64),\n        ]);\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [64],\n        }]);\n      });\n    });\n\n    describe('with variable', () => {\n      it('return `[null]` for empty values', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: null}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [null],\n        }]);\n      });\n\n      it('return empty arrays', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: []}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [[]],\n        }]);\n      });\n\n      it('return arrays for singular values', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: 32}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [32],\n        }]);\n      });\n\n      it('return nested ararys for array values', () => {\n        var field = getProfilePicture(\n          [QueryBuilder.createCallVariable('size')],\n          {size: [32]}\n        );\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [[32]],\n        }]);\n      });\n\n      it('returns flat arrays for scalar values', () => {\n        var field = getProfilePicture([\n          QueryBuilder.createCallVariable('width'),\n          QueryBuilder.createCallVariable('height'),\n        ], {\n          width: 32,\n          height: 64,\n        });\n        expect(field.getCallsWithValues()).toEqual([{\n          name: 'size',\n          value: [32, 64],\n        }]);\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQuery-getCallsWithValues-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQL-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQL', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('throws if not transformed', () => {\n    const badQL = Relay.QL;\n    expect(() => {\n      // Transform cannot find this call site.\n      badQL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Unexpected invocation at runtime. Either the Babel transform ' +\n      'was not set up, or it failed to identify this call site. Make sure it ' +\n      'is being used verbatim as `Relay.QL`.'\n    );\n  });\n\n  it('does not throw if transformed', () => {\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `;\n    }).not.toThrowError();\n  });\n\n  it('permits valid variable substitutions', () => {\n    const SIZE = 42;\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            actor {\n              profilePicture(size: ${SIZE}) {\n                uri\n              }\n            }\n          }\n        }\n      `;\n    }).not.toThrowError();\n  });\n\n  it('wraps variable substituted values in concrete call values', () => {\n    const SIZE = 42;\n    expect(Relay.QL.__var(SIZE)).toEqual({\n      kind: 'CallValue',\n      callValue: SIZE,\n    });\n  });\n\n  it('throws for illegal variable substitutions', () => {\n    const variables = {\n      size: QueryBuilder.createCallVariable('size'),\n    };\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            actor {\n              profilePicture(size: ${variables.size}) {\n                uri\n              }\n            }\n          }\n        }\n      `;\n    }).toThrowError(\n      'RelayQL: Invalid argument `size` supplied via template substitution. ' +\n      'Instead, use an inline variable (e.g. `comments(count: $count)`).'\n    );\n  });\n\n  it('permits fragment substitutions', () => {\n    const fragment = QueryBuilder.createFragment({\n      name: 'Foo',\n      type: 'Bar',\n    });\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${fragment}\n          }\n        }\n      `;\n    }).not.toThrow();\n  });\n\n  it('permits fragment reference substitutions', () => {\n    const fragmentReference = QueryBuilder.createFragmentReference(\n      QueryBuilder.createFragment({\n        name: 'Foo',\n        type: 'Bar',\n      })\n    );\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${fragmentReference}\n          }\n        }\n      `;\n    }).not.toThrow();\n  });\n\n  it('permits an array of fragment substitutions', () => {\n    const fragment = QueryBuilder.createFragment({\n      name: 'Foo',\n      type: 'Bar',\n    });\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${[fragment]}\n          }\n        }\n      `;\n    }).not.toThrow();\n  });\n\n  it('throws for invalid fragment substitutions', () => {\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${'foo'}\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Invalid fragment composition, use ' +\n      '`${Child.getFragment(\\'name\\')}`.'\n    );\n\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${['foo']}\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Invalid fragment composition, use ' +\n      '`${Child.getFragment(\\'name\\')}`.'\n    );\n\n    const fragment = QueryBuilder.createFragment({\n      name: 'Foo',\n      type: 'Bar',\n    });\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${[[fragment]]}\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Invalid fragment composition, use ' +\n      '`${Child.getFragment(\\'name\\')}`.'\n    );\n  });\n});\n","dependencies":["QueryBuilder","Relay","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayQL', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('throws if not transformed', () => {\n    const badQL = Relay.QL;\n    expect(() => {\n      // Transform cannot find this call site.\n      badQL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Unexpected invocation at runtime. Either the Babel transform ' +\n      'was not set up, or it failed to identify this call site. Make sure it ' +\n      'is being used verbatim as `Relay.QL`.'\n    );\n  });\n\n  it('does not throw if transformed', () => {\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            actor {\n              id\n            }\n          }\n        }\n      `;\n    }).not.toThrowError();\n  });\n\n  it('permits valid variable substitutions', () => {\n    const SIZE = 42;\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            actor {\n              profilePicture(size: ${SIZE}) {\n                uri\n              }\n            }\n          }\n        }\n      `;\n    }).not.toThrowError();\n  });\n\n  it('wraps variable substituted values in concrete call values', () => {\n    const SIZE = 42;\n    expect(Relay.QL.__var(SIZE)).toEqual({\n      kind: 'CallValue',\n      callValue: SIZE,\n    });\n  });\n\n  it('throws for illegal variable substitutions', () => {\n    const variables = {\n      size: QueryBuilder.createCallVariable('size'),\n    };\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            actor {\n              profilePicture(size: ${variables.size}) {\n                uri\n              }\n            }\n          }\n        }\n      `;\n    }).toThrowError(\n      'RelayQL: Invalid argument `size` supplied via template substitution. ' +\n      'Instead, use an inline variable (e.g. `comments(count: $count)`).'\n    );\n  });\n\n  it('permits fragment substitutions', () => {\n    const fragment = QueryBuilder.createFragment({\n      name: 'Foo',\n      type: 'Bar',\n    });\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${fragment}\n          }\n        }\n      `;\n    }).not.toThrow();\n  });\n\n  it('permits fragment reference substitutions', () => {\n    const fragmentReference = QueryBuilder.createFragmentReference(\n      QueryBuilder.createFragment({\n        name: 'Foo',\n        type: 'Bar',\n      })\n    );\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${fragmentReference}\n          }\n        }\n      `;\n    }).not.toThrow();\n  });\n\n  it('permits an array of fragment substitutions', () => {\n    const fragment = QueryBuilder.createFragment({\n      name: 'Foo',\n      type: 'Bar',\n    });\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${[fragment]}\n          }\n        }\n      `;\n    }).not.toThrow();\n  });\n\n  it('throws for invalid fragment substitutions', () => {\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${'foo'}\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Invalid fragment composition, use ' +\n      '`${Child.getFragment(\\'name\\')}`.'\n    );\n\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${['foo']}\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Invalid fragment composition, use ' +\n      '`${Child.getFragment(\\'name\\')}`.'\n    );\n\n    const fragment = QueryBuilder.createFragment({\n      name: 'Foo',\n      type: 'Bar',\n    });\n    expect(() => {\n      Relay.QL`\n        query {\n          viewer {\n            ${[[fragment]]}\n          }\n        }\n      `;\n    }).toFailInvariant(\n      'RelayQL: Invalid fragment composition, use ' +\n      '`${Child.getFragment(\\'name\\')}`.'\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayQL-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayFragmentReference-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayFragmentReference', () => {\n  var route;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    route = new RelayMetaRoute('');\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates fragments with default variables', () => {\n    var node = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size) {\n          uri,\n        },\n      }\n    `;\n    // equivalent to `getQuery('foo')` without variables\n    var reference = new RelayFragmentReference(\n      () => node,\n      {\n        size: 'default',\n      }\n    );\n    var variables = {size: 'ignored'};\n    expect(reference instanceof RelayFragmentReference).toBe(true);\n    // size ignored because no variables are passed into the fragment\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({\n      size: 'default',\n    });\n  });\n\n  it('creates fragments with a variable mapping', () => {\n    var node = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size) {\n          uri,\n        },\n      }\n    `;\n    // equivalent to `getQuery('foo', {size: variables.outerSize})`\n    var reference = new RelayFragmentReference(\n      () => node,\n      {\n        size: 'default',\n      },\n      {\n        size: QueryBuilder.createCallVariable('outerSize'),\n      }\n    );\n    // no outer variable, default is used\n    var variables = {};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({\n      size: 'default',\n    });\n\n    // outer variable overrides inner default\n    variables = {outerSize: 'override'};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({\n      size: 'override',\n    });\n  });\n\n  it('creates deferred fragment references', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var reference = new RelayFragmentReference(() => node, {});\n    reference.defer();\n\n    // fragment is the original node, unchanged and not deferred\n    expect(reference.getFragment({})).toBe(node);\n    // but the reference is marked as deferred\n    expect(reference.isDeferred()).toBe(true);\n  });\n\n  it('creates fragments with if/unless conditions', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var reference = new RelayFragmentReference(() => node, {});\n    reference.if(QueryBuilder.createCallVariable('if'));\n    reference.unless(QueryBuilder.createCallVariable('unless'));\n\n    var fragment = reference.getFragment({if: true, unless: false});\n    expect(fragment).toBe(node);\n\n    fragment = reference.getFragment({if: false, unless: false});\n    expect(fragment).toBe(null);\n\n    fragment = reference.getFragment({if: true, unless: true});\n    expect(fragment).toBe(null);\n\n    fragment = reference.getFragment({if: false, unless: true});\n    expect(fragment).toBe(null);\n  });\n\n  it('processes variables using the route', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var prepareVariables = jest.genMockFunction();\n    var reference = new RelayFragmentReference(\n      () => node,\n      {\n        size: 'default',\n      },\n      {},\n      prepareVariables\n    );\n\n    var customVariables = {\n      size: 'override',\n      other: 'custom',\n    };\n    prepareVariables.mockImplementation(() => customVariables);\n\n    var variables = {size: 'default'};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual(customVariables);\n    expect(prepareVariables).toBeCalledWith({size: 'default'}, route);\n  });\n\n  it('warns if a variable is undefined', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var reference = new RelayFragmentReference(\n      () => node,\n      {},\n      {\n        dynamic: QueryBuilder.createCallVariable('dynamic'),\n        static: undefined,\n      }\n    );\n    var variables = {};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({});\n    expect([\n      'RelayFragmentReference: Variable `%s` is undefined in fragment `%s`.',\n      'static',\n      node.name,\n    ]).toBeWarnedNTimes(1);\n    expect([\n      'RelayFragmentReference: Variable `%s` is undefined in fragment `%s`.',\n      'dynamic',\n      node.name,\n    ]).toBeWarnedNTimes(1);\n  });\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","Relay","RelayFragmentReference","RelayMetaRoute","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst QueryBuilder = require('QueryBuilder');\nconst Relay = require('Relay');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayFragmentReference', () => {\n  var route;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    route = new RelayMetaRoute('');\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates fragments with default variables', () => {\n    var node = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size) {\n          uri,\n        },\n      }\n    `;\n    // equivalent to `getQuery('foo')` without variables\n    var reference = new RelayFragmentReference(\n      () => node,\n      {\n        size: 'default',\n      }\n    );\n    var variables = {size: 'ignored'};\n    expect(reference instanceof RelayFragmentReference).toBe(true);\n    // size ignored because no variables are passed into the fragment\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({\n      size: 'default',\n    });\n  });\n\n  it('creates fragments with a variable mapping', () => {\n    var node = Relay.QL`\n      fragment on User {\n        profilePicture(size:$size) {\n          uri,\n        },\n      }\n    `;\n    // equivalent to `getQuery('foo', {size: variables.outerSize})`\n    var reference = new RelayFragmentReference(\n      () => node,\n      {\n        size: 'default',\n      },\n      {\n        size: QueryBuilder.createCallVariable('outerSize'),\n      }\n    );\n    // no outer variable, default is used\n    var variables = {};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({\n      size: 'default',\n    });\n\n    // outer variable overrides inner default\n    variables = {outerSize: 'override'};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({\n      size: 'override',\n    });\n  });\n\n  it('creates deferred fragment references', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var reference = new RelayFragmentReference(() => node, {});\n    reference.defer();\n\n    // fragment is the original node, unchanged and not deferred\n    expect(reference.getFragment({})).toBe(node);\n    // but the reference is marked as deferred\n    expect(reference.isDeferred()).toBe(true);\n  });\n\n  it('creates fragments with if/unless conditions', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var reference = new RelayFragmentReference(() => node, {});\n    reference.if(QueryBuilder.createCallVariable('if'));\n    reference.unless(QueryBuilder.createCallVariable('unless'));\n\n    var fragment = reference.getFragment({if: true, unless: false});\n    expect(fragment).toBe(node);\n\n    fragment = reference.getFragment({if: false, unless: false});\n    expect(fragment).toBe(null);\n\n    fragment = reference.getFragment({if: true, unless: true});\n    expect(fragment).toBe(null);\n\n    fragment = reference.getFragment({if: false, unless: true});\n    expect(fragment).toBe(null);\n  });\n\n  it('processes variables using the route', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var prepareVariables = jest.genMockFunction();\n    var reference = new RelayFragmentReference(\n      () => node,\n      {\n        size: 'default',\n      },\n      {},\n      prepareVariables\n    );\n\n    var customVariables = {\n      size: 'override',\n      other: 'custom',\n    };\n    prepareVariables.mockImplementation(() => customVariables);\n\n    var variables = {size: 'default'};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual(customVariables);\n    expect(prepareVariables).toBeCalledWith({size: 'default'}, route);\n  });\n\n  it('warns if a variable is undefined', () => {\n    var node = Relay.QL`fragment on Node{id}`;\n    var reference = new RelayFragmentReference(\n      () => node,\n      {},\n      {\n        dynamic: QueryBuilder.createCallVariable('dynamic'),\n        static: undefined,\n      }\n    );\n    var variables = {};\n    expect(reference.getFragment(variables)).toBe(node);\n    expect(reference.getVariables(route, variables)).toEqual({});\n    expect([\n      'RelayFragmentReference: Variable `%s` is undefined in fragment `%s`.',\n      'static',\n      node.name,\n    ]).toBeWarnedNTimes(1);\n    expect([\n      'RelayFragmentReference: Variable `%s` is undefined in fragment `%s`.',\n      'dynamic',\n      node.name,\n    ]).toBeWarnedNTimes(1);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayFragmentReference-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/RelayFragmentPointer-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayFragmentPointer');\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst Relay = require('Relay');\nconst RelayRecord = require('RelayRecord');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayFragmentPointer', () => {\n  var {getNode, getRefNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n    jasmine.addMatchers({\n      toEqualPointer() {\n        return {\n          compare(actual, expected) {\n            return {\n              pass: actual.equals(expected),\n            };\n          },\n        };\n      },\n    });\n  });\n\n  describe('create()', () => {\n    const dataID = '123';\n\n    it('creates a fragment prop for a singular fragment', () => {\n      const fragment = getNode(Relay.QL`fragment on Node { id }`);\n      const fragmentProp = RelayFragmentPointer.create(dataID, fragment);\n      expect(fragmentProp).toEqual({\n        __dataID__: dataID,\n        __fragments__: {\n          [fragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n\n    it('adds plural fragments to objects', () => {\n      const pluralFragment = getNode(\n        Relay.QL`fragment on Node @relay(plural:true) { id }`\n      );\n      const fragmentProp = RelayFragmentPointer.create(dataID, pluralFragment);\n      expect(fragmentProp).toEqual({\n        __dataID__: dataID,\n        __fragments__: {\n          [pluralFragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n  });\n\n  describe('createForRoot', () => {\n    var recordStore;\n\n    beforeEach(() => {\n      var records = {};\n      recordStore = new RelayRecordStore({records});\n    });\n\n    it('creates a wrapped fragment pointer', () => {\n      var rootFragment = Relay.QL`fragment on Node{id}`;\n      var root = getNode(Relay.QL`query{node(id:\"123\"){${rootFragment}}}`);\n\n      var result = RelayFragmentPointer.createForRoot(recordStore, root);\n      expect(result).toEqual({\n        __dataID__: '123',\n        __fragments__: {\n          [getNode(rootFragment).getConcreteFragmentID()]: '123',\n        },\n      });\n    });\n\n    it('throws if multiple root fragments are present', () => {\n      var rootFragmentA = Relay.QL`fragment on Node{id}`;\n      var rootFragmentB = Relay.QL`fragment on Node{id}`;\n      var root = getNode(Relay.QL`\n        query {\n          username(name:\"foo\"){${rootFragmentA},${rootFragmentB}}\n        }\n      `);\n\n      expect(() => {\n        RelayFragmentPointer.createForRoot(recordStore, root);\n      }).toFailInvariant(\n        'Queries supplied at the root should contain exactly one fragment ' +\n        '(e.g. `${Component.getFragment(\\'...\\')}`). Query ' +\n        '`RelayFragmentPointer` contains more than one fragment.'\n      );\n    });\n\n    it('throws if non-fragments are present', () => {\n      var root = getNode(Relay.QL`query{username(name:\"foo\"){name}}`);\n\n      expect(() => {\n        RelayFragmentPointer.createForRoot(recordStore, root);\n      }).toFailInvariant(\n        'Queries supplied at the root should contain exactly one fragment ' +\n        'and no fields. Query `RelayFragmentPointer` contains a field, ' +\n        '`name`. If you need to fetch fields, declare them in a Relay ' +\n        'container.',\n      );\n    });\n\n    it('throws for unknown ref queries', () => {\n      var rootFragment = Relay.QL`fragment on Node{id}`;\n      var root = getRefNode(\n        Relay.QL`query{nodes(ids:$ref_q0){${rootFragment}}}`,\n        {path: '$.*.id'}\n      );\n\n      expect(() => {\n        RelayFragmentPointer.createForRoot(recordStore, root);\n      }).toFailInvariant(\n        'Queries supplied at the root cannot have batch call variables. ' +\n        'Query `RelayFragmentPointer` has a batch call variable, `ref_q0`.'\n      );\n    });\n\n    it('returns null when the root call was not fetched', () => {\n      // When a root call is not fetched since it only contained empty\n      // fragments, we shouldn't throw.\n      var ref = Relay.QL`fragment on Viewer { actor { id } }`;\n      var root = getNode(Relay.QL`query{viewer{${ref}}}`);\n\n      expect(\n        RelayFragmentPointer.createForRoot(recordStore, root)\n      ).toBeNull();\n    });\n  });\n\n  describe('addFragment()', () => {\n    const dataID = '123';\n    let obj;\n\n    beforeEach(() => {\n      obj = {foo: 'bar'};\n    });\n\n    it('adds singular fragments to objects', () => {\n      const fragment = getNode(Relay.QL`fragment on Node { id }`);\n      RelayFragmentPointer.addFragment(obj, fragment, dataID);\n\n      expect(obj).toEqual({\n        foo: 'bar',\n        __fragments__: {\n          [fragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n\n    it('adds plural fragments to objects', () => {\n      const pluralFragment = getNode(\n        Relay.QL`fragment on Node @relay(plural:true) { id }`\n      );\n      RelayFragmentPointer.addFragment(obj, pluralFragment, dataID);\n\n      expect(obj).toEqual({\n        foo: 'bar',\n        __fragments__: {\n          [pluralFragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","RelayFragmentPointer","Relay","RelayRecord","RelayRecordStore","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayFragmentPointer');\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst Relay = require('Relay');\nconst RelayRecord = require('RelayRecord');\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayFragmentPointer', () => {\n  var {getNode, getRefNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n    jasmine.addMatchers({\n      toEqualPointer() {\n        return {\n          compare(actual, expected) {\n            return {\n              pass: actual.equals(expected),\n            };\n          },\n        };\n      },\n    });\n  });\n\n  describe('create()', () => {\n    const dataID = '123';\n\n    it('creates a fragment prop for a singular fragment', () => {\n      const fragment = getNode(Relay.QL`fragment on Node { id }`);\n      const fragmentProp = RelayFragmentPointer.create(dataID, fragment);\n      expect(fragmentProp).toEqual({\n        __dataID__: dataID,\n        __fragments__: {\n          [fragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n\n    it('adds plural fragments to objects', () => {\n      const pluralFragment = getNode(\n        Relay.QL`fragment on Node @relay(plural:true) { id }`\n      );\n      const fragmentProp = RelayFragmentPointer.create(dataID, pluralFragment);\n      expect(fragmentProp).toEqual({\n        __dataID__: dataID,\n        __fragments__: {\n          [pluralFragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n  });\n\n  describe('createForRoot', () => {\n    var recordStore;\n\n    beforeEach(() => {\n      var records = {};\n      recordStore = new RelayRecordStore({records});\n    });\n\n    it('creates a wrapped fragment pointer', () => {\n      var rootFragment = Relay.QL`fragment on Node{id}`;\n      var root = getNode(Relay.QL`query{node(id:\"123\"){${rootFragment}}}`);\n\n      var result = RelayFragmentPointer.createForRoot(recordStore, root);\n      expect(result).toEqual({\n        __dataID__: '123',\n        __fragments__: {\n          [getNode(rootFragment).getConcreteFragmentID()]: '123',\n        },\n      });\n    });\n\n    it('throws if multiple root fragments are present', () => {\n      var rootFragmentA = Relay.QL`fragment on Node{id}`;\n      var rootFragmentB = Relay.QL`fragment on Node{id}`;\n      var root = getNode(Relay.QL`\n        query {\n          username(name:\"foo\"){${rootFragmentA},${rootFragmentB}}\n        }\n      `);\n\n      expect(() => {\n        RelayFragmentPointer.createForRoot(recordStore, root);\n      }).toFailInvariant(\n        'Queries supplied at the root should contain exactly one fragment ' +\n        '(e.g. `${Component.getFragment(\\'...\\')}`). Query ' +\n        '`RelayFragmentPointer` contains more than one fragment.'\n      );\n    });\n\n    it('throws if non-fragments are present', () => {\n      var root = getNode(Relay.QL`query{username(name:\"foo\"){name}}`);\n\n      expect(() => {\n        RelayFragmentPointer.createForRoot(recordStore, root);\n      }).toFailInvariant(\n        'Queries supplied at the root should contain exactly one fragment ' +\n        'and no fields. Query `RelayFragmentPointer` contains a field, ' +\n        '`name`. If you need to fetch fields, declare them in a Relay ' +\n        'container.',\n      );\n    });\n\n    it('throws for unknown ref queries', () => {\n      var rootFragment = Relay.QL`fragment on Node{id}`;\n      var root = getRefNode(\n        Relay.QL`query{nodes(ids:$ref_q0){${rootFragment}}}`,\n        {path: '$.*.id'}\n      );\n\n      expect(() => {\n        RelayFragmentPointer.createForRoot(recordStore, root);\n      }).toFailInvariant(\n        'Queries supplied at the root cannot have batch call variables. ' +\n        'Query `RelayFragmentPointer` has a batch call variable, `ref_q0`.'\n      );\n    });\n\n    it('returns null when the root call was not fetched', () => {\n      // When a root call is not fetched since it only contained empty\n      // fragments, we shouldn't throw.\n      var ref = Relay.QL`fragment on Viewer { actor { id } }`;\n      var root = getNode(Relay.QL`query{viewer{${ref}}}`);\n\n      expect(\n        RelayFragmentPointer.createForRoot(recordStore, root)\n      ).toBeNull();\n    });\n  });\n\n  describe('addFragment()', () => {\n    const dataID = '123';\n    let obj;\n\n    beforeEach(() => {\n      obj = {foo: 'bar'};\n    });\n\n    it('adds singular fragments to objects', () => {\n      const fragment = getNode(Relay.QL`fragment on Node { id }`);\n      RelayFragmentPointer.addFragment(obj, fragment, dataID);\n\n      expect(obj).toEqual({\n        foo: 'bar',\n        __fragments__: {\n          [fragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n\n    it('adds plural fragments to objects', () => {\n      const pluralFragment = getNode(\n        Relay.QL`fragment on Node @relay(plural:true) { id }`\n      );\n      RelayFragmentPointer.addFragment(obj, pluralFragment, dataID);\n\n      expect(obj).toEqual({\n        foo: 'bar',\n        __fragments__: {\n          [pluralFragment.getConcreteFragmentID()]: dataID,\n        },\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/RelayFragmentPointer-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/generateRQLFieldAlias-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\n\nvar ALIAS_HEURISTIC = /^[\\w-]+$/;\n\nfunction expectEncode(input) {\n  var encoded = generateRQLFieldAlias(input);\n  expect(ALIAS_HEURISTIC.test(encoded)).toBe(true);\n  expect(encoded).not.toEqual(input);\n}\n\ndescribe('GraphQLFieldEncoder', () => {\n  it('does not encode field names without calls', () => {\n    expect(generateRQLFieldAlias('friends')).toEqual('friends');\n  });\n\n  it('encodes field names with calls', () => {\n    expectEncode('friends.orderby(importance).first(10)');\n  });\n\n  it('encodes field names with call variables', () => {\n    expectEncode('friends.first(<count>)');\n  });\n\n  it('encodes field names with weird characters in calls', () => {\n    expectEncode('friends.orderby(=  e1 \\\\ )');\n  });\n\n  it('returns the same hash for the same input', () => {\n    var input = 'friends.orderby(importance).first(20)';\n    expectEncode(input);\n    expect(generateRQLFieldAlias(input))\n      .toEqual(generateRQLFieldAlias(input));\n  });\n});\n","dependencies":["generateRQLFieldAlias"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\n\nvar ALIAS_HEURISTIC = /^[\\w-]+$/;\n\nfunction expectEncode(input) {\n  var encoded = generateRQLFieldAlias(input);\n  expect(ALIAS_HEURISTIC.test(encoded)).toBe(true);\n  expect(encoded).not.toEqual(input);\n}\n\ndescribe('GraphQLFieldEncoder', () => {\n  it('does not encode field names without calls', () => {\n    expect(generateRQLFieldAlias('friends')).toEqual('friends');\n  });\n\n  it('encodes field names with calls', () => {\n    expectEncode('friends.orderby(importance).first(10)');\n  });\n\n  it('encodes field names with call variables', () => {\n    expectEncode('friends.first(<count>)');\n  });\n\n  it('encodes field names with weird characters in calls', () => {\n    expectEncode('friends.orderby(=  e1 \\\\ )');\n  });\n\n  it('returns the same hash for the same input', () => {\n    var input = 'friends.orderby(importance).first(20)';\n    expectEncode(input);\n    expect(generateRQLFieldAlias(input))\n      .toEqual(generateRQLFieldAlias(input));\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/generateRQLFieldAlias-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/createRelayQuery-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst createRelayQuery = require('createRelayQuery');\n\ndescribe('createRelayQuery', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates queries from GraphQL', () => {\n    var root = createRelayQuery(\n      Relay.QL`\n        query {\n          viewer {\n            newsFeed(first: $count) {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `,\n      {\n        count: 10,\n      }\n    );\n    expect(root instanceof RelayQuery.Root).toBe(true);\n    expect(root.getFieldByStorageKey('newsFeed').getCallsWithValues()).toEqual(\n      [{name: 'first', value: 10}]\n    );\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayTestUtils","createRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst createRelayQuery = require('createRelayQuery');\n\ndescribe('createRelayQuery', () => {\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates queries from GraphQL', () => {\n    var root = createRelayQuery(\n      Relay.QL`\n        query {\n          viewer {\n            newsFeed(first: $count) {\n              edges {\n                node {\n                  id\n                }\n              }\n            }\n          }\n        }\n      `,\n      {\n        count: 10,\n      }\n    );\n    expect(root instanceof RelayQuery.Root).toBe(true);\n    expect(root.getFieldByStorageKey('newsFeed').getCallsWithValues()).toEqual(\n      [{name: 'first', value: 10}]\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/createRelayQuery-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/callsToGraphQL-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst callsToGraphQL = require('callsToGraphQL');\n\ndescribe('callsToGraphQL', function() {\n  it('converts array calls with null values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: null,\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', null)];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n\n  it('converts array calls without values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: [],\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', [])];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n\n  it('converts calls with array values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: [32, 64],\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', [32, 64])];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n\n  it('converts singular calls with null values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: 32,\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', 32)];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n});\n","dependencies":["configureForRelayOSS","RelayTestUtils","callsFromGraphQL","callsToGraphQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst callsToGraphQL = require('callsToGraphQL');\n\ndescribe('callsToGraphQL', function() {\n  it('converts array calls with null values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: null,\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', null)];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n\n  it('converts array calls without values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: [],\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', [])];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n\n  it('converts calls with array values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: [32, 64],\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', [32, 64])];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n\n  it('converts singular calls with null values', () => {\n    var relayCalls = [{\n      name: 'size',\n      value: 32,\n    }];\n    var graphqlCalls = [RelayTestUtils.createCall('size', 32)];\n    expect(callsFromGraphQL(graphqlCalls)).toEqual(relayCalls);\n    expect(callsToGraphQL(relayCalls)).toEqual(graphqlCalls);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/callsToGraphQL-test.js"}},"/Users/cpojer/Projects/relay/src/query/__tests__/buildRQL-test.js":{"metadata":{"mtime":1456974578000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst QueryBuilder = require('QueryBuilder');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst buildRQL = require('buildRQL');\n\ndescribe('buildRQL', () => {\n  var {getNode} = RelayTestUtils;\n\n  var MockComponent;\n  var MockContainer;\n\n  beforeEach(() => {\n    var render = jest.genMockFunction().mockImplementation(function() {\n      // Make it easier to expect prop values.\n      render.mock.calls[render.mock.calls.length - 1].props = this.props;\n      return <div />;\n    });\n    MockComponent = React.createClass({render});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {\n        foo: () => Relay.QL`fragment on Node { name }`,\n      },\n    });\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('Fragment()', () => {\n    it('returns undefined if the node is not a fragment', () => {\n      var builder = () => Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n          }\n        }\n      `;\n      expect(buildRQL.Fragment(builder, [])).toBe(undefined);\n    });\n\n    it('throws if fragment substitutions are invalid', () => {\n      var invalid = {};\n      var builder = () => Relay.QL`\n        fragment on Node {\n          ${invalid},\n        }\n      `;\n      expect(() => buildRQL.Fragment(builder, {})).toFailInvariant(\n        'RelayQL: Invalid fragment composition, use ' +\n        '`${Child.getFragment(\\'name\\')}`.'\n      );\n    });\n\n    it('creates fragments with variables', () => {\n      var builder = () => Relay.QL`\n        fragment on Node {\n          id,\n          profilePicture(size:$sizeVariable) {\n            uri,\n          },\n        }\n      `;\n      var node = buildRQL.Fragment(builder, {sizeVariable: null});\n      expect(!!QueryBuilder.getFragment(node)).toBe(true);\n\n      // Confirm that `${variables.sizeVariable}` is a variable by applying\n      // variable values using `RelayQuery`:\n      var fragment = getNode(node, {\n        sizeVariable: '32',\n      });\n      expect(fragment instanceof RelayQuery.Fragment).toBe(true);\n      var children = fragment.getChildren();\n      expect(children.length).toBe(3);\n      expect(children[1].getSchemaName()).toBe('profilePicture');\n      // Variable has the applied value, not initial value.\n      expect(children[1].getCallsWithValues()).toEqual([\n        {name: 'size', value: '32'},\n      ]);\n    });\n\n    it('returns === fragments', () => {\n      var builder = () => Relay.QL`\n        fragment on Node {\n          id,\n          profilePicture(size:$sizeVariable) {\n            uri,\n          },\n        }\n      `;\n      var node1 = buildRQL.Fragment(builder, {sizeVariable: null});\n      var node2 = buildRQL.Fragment(builder, {sizeVariable: null});\n      expect(node1 === node2).toBe(true);\n    });\n\n    it('generates distinct fragments per fragment builder', () => {\n      var concreteFragment = Relay.QL`fragment on Node { id }`;\n      var builder1 = () => concreteFragment;\n      var builder2 = () => concreteFragment;\n      var node1 = buildRQL.Fragment(builder1);\n      var node2 = buildRQL.Fragment(builder2);\n      expect(node1).toBe(concreteFragment);\n      expect(node1).not.toBe(node2);\n      expect(node1.id).not.toBe(node2.id);\n      expect(getNode(node1)).toEqualQueryNode(getNode(node2));\n      expect(buildRQL.Fragment(builder1)).toBe(node1);\n      expect(buildRQL.Fragment(builder2)).toBe(node2);\n    });\n  });\n\n  describe('Query()', () => {\n    it('returns undefined if the node is not a query', () => {\n      var builder = () => Relay.QL`\n        fragment on Node {\n          id,\n        }\n      `;\n      expect(\n        buildRQL.Query(builder, MockContainer, 'foo', {})\n      ).toBe(undefined);\n    });\n\n    it('creates queries with components and variables', () => {\n      var builder = Component => Relay.QL`\n        query {\n          node(id:$id) {\n            id,\n            ${Component.getFragment('foo')}\n          }\n        }\n      `;\n      var node = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      expect(!!QueryBuilder.getQuery(node)).toBe(true);\n\n      // Confirm that `${variables.id}` is a variable by applying variable\n      // values using `RelayQuery`:\n      var variables = {id: '123'};\n      var query = getNode(node, variables);\n      expect(query instanceof RelayQuery.Root).toBe(true);\n      expect(query.getIdentifyingArg()).toEqual({\n        name: 'id',\n        value: '123',\n      });\n      expect(query.getChildren()[2].equals(\n        getNode(MockContainer.getFragment('foo'), variables)\n      )).toBe(true);\n    });\n\n    it('returns === queries for the same component', () => {\n      var builder = Component => Relay.QL`\n        query {\n          node(id:$id) {\n            ${Component.getFragment('foo')}\n          }\n        }\n      `;\n      var node1 = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      var node2 = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      expect(node1 === node2).toBe(true);\n    });\n\n    it('returns different queries for different components', () => {\n      var MockContainer2 = Relay.createContainer(MockComponent, {\n        fragments: {\n          foo: () => Relay.QL`fragment on Node { name }`,\n        },\n      });\n\n      var builder = Component => Relay.QL`\n        query {\n          node(id:$id) {\n            ${Component.getFragment('foo')}\n          }\n        }\n      `;\n      var node1 = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      var node2 = buildRQL.Query(builder, MockContainer2, 'foo', {id: null});\n      expect(node1 === node2).toBe(false);\n    });\n\n    it('implicitly adds component fragments if not provided', () => {\n      var builder = () => Relay.QL`\n        query {\n          node(id:$id)\n        }\n      `;\n      var node = buildRQL.Query(\n        builder,\n        MockContainer,\n        'foo',\n        {id: null},\n      );\n      expect(!!QueryBuilder.getQuery(node)).toBe(true);\n\n      // Confirm that `${variables.id}` is a variable by applying\n      // variable values using `RelayQuery`:\n      var variables = {id: '123'};\n      var query = getNode(node, variables);\n      expect(query instanceof RelayQuery.Root).toBe(true);\n      expect(query.getIdentifyingArg()).toEqual({\n        name: 'id',\n        value: '123',\n      });\n      expect(query.getChildren()[2].equals(\n        getNode(MockContainer.getFragment('foo'), variables)\n      )).toBe(true);\n    });\n\n    it('produces equal results for implicit and explicit definitions', () => {\n      const MockContainer2 = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          if: null,\n        },\n        fragments: {\n          foo: () => Relay.QL`fragment on Node { firstName(if: $if) }`,\n        },\n      });\n      const implicitBuilder = () => Relay.QL`\n        query {\n          viewer\n        }\n      `;\n      const explicitBuilder = (Component, variables) => Relay.QL`\n        query {\n          viewer {\n            ${Component.getFragment('foo', variables)}\n          }\n        }\n      `;\n      const initialVariables = {if: null};\n      const implicitNode = buildRQL.Query(\n        implicitBuilder,\n        MockContainer2,\n        'foo',\n        initialVariables,\n      );\n      const explicitNode = buildRQL.Query(\n        explicitBuilder,\n        MockContainer2,\n        'foo',\n        initialVariables,\n      );\n      const variables = {if: true};\n      const implicitQuery = getNode(implicitNode, variables);\n      const explicitQuery = getNode(explicitNode, variables);\n      expect(implicitQuery).toEqualQueryRoot(explicitQuery);\n    });\n\n    it('throws if non-scalar fields are given', () => {\n      var builder = () => Relay.QL`\n        query {\n          viewer {\n            actor\n          }\n        }\n      `;\n\n      expect(() => {\n        buildRQL.Query(\n          builder,\n          MockContainer,\n          'foo',\n          {}\n        );\n      }).toFailInvariant(\n        'Relay.QL: Expected query `viewer` to be empty. For example, use ' +\n        '`node(id: $id)`, not `node(id: $id) { ... }`.'\n      );\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","QueryBuilder","React","Relay","RelayQuery","RelayTestUtils","buildRQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst QueryBuilder = require('QueryBuilder');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst buildRQL = require('buildRQL');\n\ndescribe('buildRQL', () => {\n  var {getNode} = RelayTestUtils;\n\n  var MockComponent;\n  var MockContainer;\n\n  beforeEach(() => {\n    var render = jest.genMockFunction().mockImplementation(function() {\n      // Make it easier to expect prop values.\n      render.mock.calls[render.mock.calls.length - 1].props = this.props;\n      return <div />;\n    });\n    MockComponent = React.createClass({render});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {\n        foo: () => Relay.QL`fragment on Node { name }`,\n      },\n    });\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('Fragment()', () => {\n    it('returns undefined if the node is not a fragment', () => {\n      var builder = () => Relay.QL`\n        query {\n          node(id:\"123\") {\n            id,\n          }\n        }\n      `;\n      expect(buildRQL.Fragment(builder, [])).toBe(undefined);\n    });\n\n    it('throws if fragment substitutions are invalid', () => {\n      var invalid = {};\n      var builder = () => Relay.QL`\n        fragment on Node {\n          ${invalid},\n        }\n      `;\n      expect(() => buildRQL.Fragment(builder, {})).toFailInvariant(\n        'RelayQL: Invalid fragment composition, use ' +\n        '`${Child.getFragment(\\'name\\')}`.'\n      );\n    });\n\n    it('creates fragments with variables', () => {\n      var builder = () => Relay.QL`\n        fragment on Node {\n          id,\n          profilePicture(size:$sizeVariable) {\n            uri,\n          },\n        }\n      `;\n      var node = buildRQL.Fragment(builder, {sizeVariable: null});\n      expect(!!QueryBuilder.getFragment(node)).toBe(true);\n\n      // Confirm that `${variables.sizeVariable}` is a variable by applying\n      // variable values using `RelayQuery`:\n      var fragment = getNode(node, {\n        sizeVariable: '32',\n      });\n      expect(fragment instanceof RelayQuery.Fragment).toBe(true);\n      var children = fragment.getChildren();\n      expect(children.length).toBe(3);\n      expect(children[1].getSchemaName()).toBe('profilePicture');\n      // Variable has the applied value, not initial value.\n      expect(children[1].getCallsWithValues()).toEqual([\n        {name: 'size', value: '32'},\n      ]);\n    });\n\n    it('returns === fragments', () => {\n      var builder = () => Relay.QL`\n        fragment on Node {\n          id,\n          profilePicture(size:$sizeVariable) {\n            uri,\n          },\n        }\n      `;\n      var node1 = buildRQL.Fragment(builder, {sizeVariable: null});\n      var node2 = buildRQL.Fragment(builder, {sizeVariable: null});\n      expect(node1 === node2).toBe(true);\n    });\n\n    it('generates distinct fragments per fragment builder', () => {\n      var concreteFragment = Relay.QL`fragment on Node { id }`;\n      var builder1 = () => concreteFragment;\n      var builder2 = () => concreteFragment;\n      var node1 = buildRQL.Fragment(builder1);\n      var node2 = buildRQL.Fragment(builder2);\n      expect(node1).toBe(concreteFragment);\n      expect(node1).not.toBe(node2);\n      expect(node1.id).not.toBe(node2.id);\n      expect(getNode(node1)).toEqualQueryNode(getNode(node2));\n      expect(buildRQL.Fragment(builder1)).toBe(node1);\n      expect(buildRQL.Fragment(builder2)).toBe(node2);\n    });\n  });\n\n  describe('Query()', () => {\n    it('returns undefined if the node is not a query', () => {\n      var builder = () => Relay.QL`\n        fragment on Node {\n          id,\n        }\n      `;\n      expect(\n        buildRQL.Query(builder, MockContainer, 'foo', {})\n      ).toBe(undefined);\n    });\n\n    it('creates queries with components and variables', () => {\n      var builder = Component => Relay.QL`\n        query {\n          node(id:$id) {\n            id,\n            ${Component.getFragment('foo')}\n          }\n        }\n      `;\n      var node = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      expect(!!QueryBuilder.getQuery(node)).toBe(true);\n\n      // Confirm that `${variables.id}` is a variable by applying variable\n      // values using `RelayQuery`:\n      var variables = {id: '123'};\n      var query = getNode(node, variables);\n      expect(query instanceof RelayQuery.Root).toBe(true);\n      expect(query.getIdentifyingArg()).toEqual({\n        name: 'id',\n        value: '123',\n      });\n      expect(query.getChildren()[2].equals(\n        getNode(MockContainer.getFragment('foo'), variables)\n      )).toBe(true);\n    });\n\n    it('returns === queries for the same component', () => {\n      var builder = Component => Relay.QL`\n        query {\n          node(id:$id) {\n            ${Component.getFragment('foo')}\n          }\n        }\n      `;\n      var node1 = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      var node2 = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      expect(node1 === node2).toBe(true);\n    });\n\n    it('returns different queries for different components', () => {\n      var MockContainer2 = Relay.createContainer(MockComponent, {\n        fragments: {\n          foo: () => Relay.QL`fragment on Node { name }`,\n        },\n      });\n\n      var builder = Component => Relay.QL`\n        query {\n          node(id:$id) {\n            ${Component.getFragment('foo')}\n          }\n        }\n      `;\n      var node1 = buildRQL.Query(builder, MockContainer, 'foo', {id: null});\n      var node2 = buildRQL.Query(builder, MockContainer2, 'foo', {id: null});\n      expect(node1 === node2).toBe(false);\n    });\n\n    it('implicitly adds component fragments if not provided', () => {\n      var builder = () => Relay.QL`\n        query {\n          node(id:$id)\n        }\n      `;\n      var node = buildRQL.Query(\n        builder,\n        MockContainer,\n        'foo',\n        {id: null},\n      );\n      expect(!!QueryBuilder.getQuery(node)).toBe(true);\n\n      // Confirm that `${variables.id}` is a variable by applying\n      // variable values using `RelayQuery`:\n      var variables = {id: '123'};\n      var query = getNode(node, variables);\n      expect(query instanceof RelayQuery.Root).toBe(true);\n      expect(query.getIdentifyingArg()).toEqual({\n        name: 'id',\n        value: '123',\n      });\n      expect(query.getChildren()[2].equals(\n        getNode(MockContainer.getFragment('foo'), variables)\n      )).toBe(true);\n    });\n\n    it('produces equal results for implicit and explicit definitions', () => {\n      const MockContainer2 = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          if: null,\n        },\n        fragments: {\n          foo: () => Relay.QL`fragment on Node { firstName(if: $if) }`,\n        },\n      });\n      const implicitBuilder = () => Relay.QL`\n        query {\n          viewer\n        }\n      `;\n      const explicitBuilder = (Component, variables) => Relay.QL`\n        query {\n          viewer {\n            ${Component.getFragment('foo', variables)}\n          }\n        }\n      `;\n      const initialVariables = {if: null};\n      const implicitNode = buildRQL.Query(\n        implicitBuilder,\n        MockContainer2,\n        'foo',\n        initialVariables,\n      );\n      const explicitNode = buildRQL.Query(\n        explicitBuilder,\n        MockContainer2,\n        'foo',\n        initialVariables,\n      );\n      const variables = {if: true};\n      const implicitQuery = getNode(implicitNode, variables);\n      const explicitQuery = getNode(explicitNode, variables);\n      expect(implicitQuery).toEqualQueryRoot(explicitQuery);\n    });\n\n    it('throws if non-scalar fields are given', () => {\n      var builder = () => Relay.QL`\n        query {\n          viewer {\n            actor\n          }\n        }\n      `;\n\n      expect(() => {\n        buildRQL.Query(\n          builder,\n          MockContainer,\n          'foo',\n          {}\n        );\n      }).toFailInvariant(\n        'Relay.QL: Expected query `viewer` to be empty. For example, use ' +\n        '`node(id: $id)`, not `node(id: $id) { ... }`.'\n      );\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/query/__tests__/buildRQL-test.js"}},"/Users/cpojer/Projects/relay/src/network-layer/default/RelayDefaultNetworkLayer.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayDefaultNetworkLayer","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayDefaultNetworkLayer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayMutationRequest from 'RelayMutationRequest';\nimport type RelayQueryRequest from 'RelayQueryRequest';\n\nconst fetch = require('fetch');\nconst fetchWithRetries = require('fetchWithRetries');\nimport type {InitWithRetries} from 'fetchWithRetries';\n\ntype GraphQLError = {\n  message: string;\n  locations: Array<GraphQLErrorLocation>;\n};\ntype GraphQLErrorLocation = {\n  column: number;\n  line: number;\n};\n\nclass RelayDefaultNetworkLayer {\n  _uri: string;\n  _init: $FlowIssue; // InitWithRetries\n\n  constructor(uri: string, init?: ?InitWithRetries) {\n    this._uri = uri;\n    this._init = {...init};\n\n    // Bind instance methods to facilitate reuse when creating custom network\n    // layers.\n    var self: any = this;\n    self.sendMutation = this.sendMutation.bind(this);\n    self.sendQueries = this.sendQueries.bind(this);\n    self.supports = this.supports.bind(this);\n  }\n\n  sendMutation(request: RelayMutationRequest): Promise {\n    return this._sendMutation(request).then(\n      result => result.json()\n    ).then(payload => {\n      if (payload.hasOwnProperty('errors')) {\n        var error = new Error(\n          'Server request for mutation `' + request.getDebugName() + '` ' +\n          'failed for the following reasons:\\n\\n' +\n          formatRequestErrors(request, payload.errors)\n        );\n        (error: any).source = payload;\n        request.reject(error);\n      } else {\n        request.resolve({response: payload.data});\n      }\n    }).catch(\n      error => request.reject(error)\n    );\n  }\n\n  sendQueries(requests: Array<RelayQueryRequest>): Promise {\n    return Promise.all(requests.map(request => (\n      this._sendQuery(request).then(\n        result => result.json()\n      ).then(payload => {\n        if (payload.hasOwnProperty('errors')) {\n          var error = new Error(\n            'Server request for query `' + request.getDebugName() + '` ' +\n            'failed for the following reasons:\\n\\n' +\n            formatRequestErrors(request, payload.errors)\n          );\n          (error: any).source = payload;\n          request.reject(error);\n        } else if (!payload.hasOwnProperty('data')) {\n          request.reject(new Error(\n            'Server response was missing for query `' + request.getDebugName() +\n            '`.'\n          ));\n        } else {\n          request.resolve({response: payload.data});\n        }\n      }).catch(\n        error => request.reject(error)\n      )\n    )));\n  }\n\n  supports(...options: Array<string>): boolean {\n    // Does not support the only defined option, \"defer\".\n    return false;\n  }\n\n  /**\n   * Sends a POST request with optional files.\n   */\n  _sendMutation(request: RelayMutationRequest): Promise {\n    var init;\n    var files = request.getFiles();\n    if (files) {\n      if (!global.FormData) {\n        throw new Error('Uploading files without `FormData` not supported.');\n      }\n      var formData = new FormData();\n      formData.append('query', request.getQueryString());\n      formData.append('variables', JSON.stringify(request.getVariables()));\n      for (var filename in files) {\n        if (files.hasOwnProperty(filename)) {\n          formData.append(filename, files[filename]);\n        }\n      }\n      init = {\n        ...this._init,\n        body: formData,\n        method: 'POST',\n      };\n    } else {\n      init = {\n        ...this._init,\n        body: JSON.stringify({\n          query: request.getQueryString(),\n          variables: request.getVariables(),\n        }),\n        headers: {\n          ...this._init.headers,\n          'Accept': '*/*',\n          'Content-Type': 'application/json',\n        },\n        method: 'POST',\n      };\n    }\n    return fetch(this._uri, init).then(throwOnServerError);\n  }\n\n  /**\n   * Sends a POST request and retries if the request fails or times out.\n   */\n  _sendQuery(request: RelayQueryRequest): Promise {\n    return fetchWithRetries(this._uri, {\n      ...this._init,\n      body: JSON.stringify({\n        query: request.getQueryString(),\n        variables: request.getVariables(),\n      }),\n      headers: {\n        ...this._init.headers,\n        'Accept': '*/*',\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    });\n  }\n}\n\n/**\n * Rejects HTTP responses with a status code that is not >= 200 and < 300.\n * This is done to follow the internal behavior of `fetchWithRetries`.\n */\nfunction throwOnServerError(response: any): any  {\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  } else {\n    throw response;\n  }\n}\n\n/**\n * Formats an error response from GraphQL server request.\n */\nfunction formatRequestErrors(\n  request: RelayMutationRequest | RelayQueryRequest,\n  errors: Array<GraphQLError>\n): string {\n  var CONTEXT_BEFORE = 20;\n  var CONTEXT_LENGTH = 60;\n\n  var queryLines = request.getQueryString().split('\\n');\n  return errors.map(({locations, message}, ii) => {\n    var prefix = (ii + 1) + '. ';\n    var indent = ' '.repeat(prefix.length);\n\n    //custom errors thrown in graphql-server may not have locations\n    var locationMessage = locations ?\n      ('\\n' + locations.map(({column, line}) => {\n        var queryLine = queryLines[line - 1];\n        var offset = Math.min(column - 1, CONTEXT_BEFORE);\n        return [\n          queryLine.substr(column - 1 - offset, CONTEXT_LENGTH),\n          ' '.repeat(offset) + '^^^',\n        ].map(messageLine => indent + messageLine).join('\\n');\n      }).join('\\n')) :\n      '';\n\n    return prefix + message + locationMessage;\n\n  }).join('\\n');\n}\n\nmodule.exports = RelayDefaultNetworkLayer;\n","dependencies":["RelayMutationRequest","RelayQueryRequest","fetchWithRetries","fetch","RelayDefaultNetworkLayer"],"id":"RelayDefaultNetworkLayer","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayDefaultNetworkLayer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayMutationRequest from 'RelayMutationRequest';\nimport type RelayQueryRequest from 'RelayQueryRequest';\n\nconst fetch = require('fetch');\nconst fetchWithRetries = require('fetchWithRetries');\nimport type {InitWithRetries} from 'fetchWithRetries';\n\ntype GraphQLError = {\n  message: string;\n  locations: Array<GraphQLErrorLocation>;\n};\ntype GraphQLErrorLocation = {\n  column: number;\n  line: number;\n};\n\nclass RelayDefaultNetworkLayer {\n  _uri: string;\n  _init: $FlowIssue; // InitWithRetries\n\n  constructor(uri: string, init?: ?InitWithRetries) {\n    this._uri = uri;\n    this._init = {...init};\n\n    // Bind instance methods to facilitate reuse when creating custom network\n    // layers.\n    var self: any = this;\n    self.sendMutation = this.sendMutation.bind(this);\n    self.sendQueries = this.sendQueries.bind(this);\n    self.supports = this.supports.bind(this);\n  }\n\n  sendMutation(request: RelayMutationRequest): Promise {\n    return this._sendMutation(request).then(\n      result => result.json()\n    ).then(payload => {\n      if (payload.hasOwnProperty('errors')) {\n        var error = new Error(\n          'Server request for mutation `' + request.getDebugName() + '` ' +\n          'failed for the following reasons:\\n\\n' +\n          formatRequestErrors(request, payload.errors)\n        );\n        (error: any).source = payload;\n        request.reject(error);\n      } else {\n        request.resolve({response: payload.data});\n      }\n    }).catch(\n      error => request.reject(error)\n    );\n  }\n\n  sendQueries(requests: Array<RelayQueryRequest>): Promise {\n    return Promise.all(requests.map(request => (\n      this._sendQuery(request).then(\n        result => result.json()\n      ).then(payload => {\n        if (payload.hasOwnProperty('errors')) {\n          var error = new Error(\n            'Server request for query `' + request.getDebugName() + '` ' +\n            'failed for the following reasons:\\n\\n' +\n            formatRequestErrors(request, payload.errors)\n          );\n          (error: any).source = payload;\n          request.reject(error);\n        } else if (!payload.hasOwnProperty('data')) {\n          request.reject(new Error(\n            'Server response was missing for query `' + request.getDebugName() +\n            '`.'\n          ));\n        } else {\n          request.resolve({response: payload.data});\n        }\n      }).catch(\n        error => request.reject(error)\n      )\n    )));\n  }\n\n  supports(...options: Array<string>): boolean {\n    // Does not support the only defined option, \"defer\".\n    return false;\n  }\n\n  /**\n   * Sends a POST request with optional files.\n   */\n  _sendMutation(request: RelayMutationRequest): Promise {\n    var init;\n    var files = request.getFiles();\n    if (files) {\n      if (!global.FormData) {\n        throw new Error('Uploading files without `FormData` not supported.');\n      }\n      var formData = new FormData();\n      formData.append('query', request.getQueryString());\n      formData.append('variables', JSON.stringify(request.getVariables()));\n      for (var filename in files) {\n        if (files.hasOwnProperty(filename)) {\n          formData.append(filename, files[filename]);\n        }\n      }\n      init = {\n        ...this._init,\n        body: formData,\n        method: 'POST',\n      };\n    } else {\n      init = {\n        ...this._init,\n        body: JSON.stringify({\n          query: request.getQueryString(),\n          variables: request.getVariables(),\n        }),\n        headers: {\n          ...this._init.headers,\n          'Accept': '*/*',\n          'Content-Type': 'application/json',\n        },\n        method: 'POST',\n      };\n    }\n    return fetch(this._uri, init).then(throwOnServerError);\n  }\n\n  /**\n   * Sends a POST request and retries if the request fails or times out.\n   */\n  _sendQuery(request: RelayQueryRequest): Promise {\n    return fetchWithRetries(this._uri, {\n      ...this._init,\n      body: JSON.stringify({\n        query: request.getQueryString(),\n        variables: request.getVariables(),\n      }),\n      headers: {\n        ...this._init.headers,\n        'Accept': '*/*',\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    });\n  }\n}\n\n/**\n * Rejects HTTP responses with a status code that is not >= 200 and < 300.\n * This is done to follow the internal behavior of `fetchWithRetries`.\n */\nfunction throwOnServerError(response: any): any  {\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  } else {\n    throw response;\n  }\n}\n\n/**\n * Formats an error response from GraphQL server request.\n */\nfunction formatRequestErrors(\n  request: RelayMutationRequest | RelayQueryRequest,\n  errors: Array<GraphQLError>\n): string {\n  var CONTEXT_BEFORE = 20;\n  var CONTEXT_LENGTH = 60;\n\n  var queryLines = request.getQueryString().split('\\n');\n  return errors.map(({locations, message}, ii) => {\n    var prefix = (ii + 1) + '. ';\n    var indent = ' '.repeat(prefix.length);\n\n    //custom errors thrown in graphql-server may not have locations\n    var locationMessage = locations ?\n      ('\\n' + locations.map(({column, line}) => {\n        var queryLine = queryLines[line - 1];\n        var offset = Math.min(column - 1, CONTEXT_BEFORE);\n        return [\n          queryLine.substr(column - 1 - offset, CONTEXT_LENGTH),\n          ' '.repeat(offset) + '^^^',\n        ].map(messageLine => indent + messageLine).join('\\n');\n      }).join('\\n')) :\n      '';\n\n    return prefix + message + locationMessage;\n\n  }).join('\\n');\n}\n\nmodule.exports = RelayDefaultNetworkLayer;\n"}}},"/Users/cpojer/Projects/relay/src/network/__mocks__/RelayQueryRequest.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryRequest');\n","dependencies":["RelayQueryRequest"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayQueryRequest');\n"},"name":"/Users/cpojer/Projects/relay/src/network/__mocks__/RelayQueryRequest.js"}},"/Users/cpojer/Projects/relay/src/network/__mocks__/RelayNetworkLayer.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayNetworkLayer');\n","dependencies":["RelayNetworkLayer"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayNetworkLayer');\n"},"name":"/Users/cpojer/Projects/relay/src/network/__mocks__/RelayNetworkLayer.js"}},"/Users/cpojer/Projects/relay/src/network/__mocks__/RelayMutationRequest.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationRequest');\n","dependencies":["RelayMutationRequest"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationRequest');\n"},"name":"/Users/cpojer/Projects/relay/src/network/__mocks__/RelayMutationRequest.js"}},"/Users/cpojer/Projects/relay/src/network/__mocks__/fetchRelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar fetchRelayQuery = jest.genMockFromModule('fetchRelayQuery');\n\n/**\n * Mock object to simulate the behavior of a request. Example usage:\n *\n *   // Successful fetch.\n *   fetchRelayQuery(queryA);\n *   fetchRelayQuery.mock.requests[0].resolve(response);\n *\n *   // Fetch with partial error.\n *   fetchRelayQuery(queryB);\n *   fetchRelayQuery.mock.requests[0].resolve(response, error);\n *\n *   // Failed fetch.\n *   fetchRelayQuery(queryC);\n *   fetchRelayQuery.mock.requests[0].reject(error);\n *\n */\nfunction genMockRequest(resolve, reject) {\n  fetchRelayQuery.mock.requests.push({\n    resolve(response, error) {\n      resolve({error: error || null, response});\n    },\n    reject,\n  });\n}\n\nfetchRelayQuery.mock.requests = [];\nfetchRelayQuery.mockImplementation(() => new Promise(genMockRequest));\n\nmodule.exports = fetchRelayQuery;\n","dependencies":["fetchRelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar fetchRelayQuery = jest.genMockFromModule('fetchRelayQuery');\n\n/**\n * Mock object to simulate the behavior of a request. Example usage:\n *\n *   // Successful fetch.\n *   fetchRelayQuery(queryA);\n *   fetchRelayQuery.mock.requests[0].resolve(response);\n *\n *   // Fetch with partial error.\n *   fetchRelayQuery(queryB);\n *   fetchRelayQuery.mock.requests[0].resolve(response, error);\n *\n *   // Failed fetch.\n *   fetchRelayQuery(queryC);\n *   fetchRelayQuery.mock.requests[0].reject(error);\n *\n */\nfunction genMockRequest(resolve, reject) {\n  fetchRelayQuery.mock.requests.push({\n    resolve(response, error) {\n      resolve({error: error || null, response});\n    },\n    reject,\n  });\n}\n\nfetchRelayQuery.mock.requests = [];\nfetchRelayQuery.mockImplementation(() => new Promise(genMockRequest));\n\nmodule.exports = fetchRelayQuery;\n"},"name":"/Users/cpojer/Projects/relay/src/network/__mocks__/fetchRelayQuery.js"}},"/Users/cpojer/Projects/relay/src/network/__tests__/RelayNetworkLayer-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Deferred = require('Deferred');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayNetworkLayer', () => {\n  var RelayQuery;\n\n  var injectedNetworkLayer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayQuery = jest.genMockFromModule('RelayQuery');\n    jest.setMock('RelayQuery', RelayQuery);\n\n    injectedNetworkLayer = {\n      sendMutation: jest.genMockFunction(),\n      sendQueries: jest.genMockFunction(),\n      supports: jest.genMockFunction().mockReturnValue(true),\n    };\n    RelayNetworkLayer.injectNetworkLayer(injectedNetworkLayer);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('supports', () => {\n    it('throws when no network layer is injected', () => {\n      RelayNetworkLayer.injectNetworkLayer(null);\n      expect(() => {\n        RelayNetworkLayer.sendQueries([]);\n      }).toFailInvariant(\n        'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network ' +\n        'layer.'\n      );\n    });\n\n    it('delegates to the injected network layer', () => {\n      expect(injectedNetworkLayer.supports).not.toBeCalled();\n      RelayNetworkLayer.supports('foo', 'bar');\n      expect(injectedNetworkLayer.supports).toBeCalledWith('foo', 'bar');\n    });\n  });\n\n  describe('sendQueries', () => {\n    it('throws when no network layer is injected', () => {\n      RelayNetworkLayer.injectNetworkLayer(null);\n      expect(() => {\n        RelayNetworkLayer.sendQueries([]);\n      }).toFailInvariant(\n        'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network ' +\n        'layer.'\n      );\n    });\n\n    it('delegates queries to the injected network layer', () => {\n      var queries = [];\n      expect(injectedNetworkLayer.sendQueries).not.toBeCalled();\n      RelayNetworkLayer.sendQueries(queries);\n      expect(injectedNetworkLayer.sendQueries).toBeCalledWith(queries);\n    });\n  });\n\n  describe('sendMutation', () => {\n    var mutation;\n    var variables;\n    var deferred;\n    var resolvedCallback;\n    var rejectedCallback;\n\n    beforeEach(() => {\n      mutation = {};\n      variables = {};\n      resolvedCallback = jest.genMockFunction();\n      rejectedCallback = jest.genMockFunction();\n      deferred = new Deferred();\n      deferred.getPromise().done(resolvedCallback, rejectedCallback);\n    });\n\n    it('throws when no network layer is injected', () => {\n      RelayNetworkLayer.injectNetworkLayer(null);\n      expect(() => {\n        RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      }).toFailInvariant(\n        'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network ' +\n        'layer.'\n      );\n    });\n\n    it('delegates mutation to the injected network layer', () => {\n      expect(injectedNetworkLayer.sendQueries).not.toBeCalled();\n      RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      expect(injectedNetworkLayer.sendMutation).toBeCalled();\n\n      var pendingMutation = injectedNetworkLayer.sendMutation.mock.calls[0][0];\n      expect(pendingMutation.mutation).toBe(mutation);\n      expect(pendingMutation.variables).toBe(variables);\n    });\n\n    it('resolves the deferred if the mutation succeeds', () => {\n      RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      expect(resolvedCallback).not.toBeCalled();\n      expect(rejectedCallback).not.toBeCalled();\n\n      var pendingMutation = injectedNetworkLayer.sendMutation.mock.calls[0][0];\n      var response = {};\n      pendingMutation.deferred.resolve(response);\n      jest.runAllTimers();\n\n      expect(resolvedCallback).toBeCalledWith(response);\n      expect(rejectedCallback).not.toBeCalled();\n    });\n\n    it('rejects the deferred if the mutation fails', () => {\n      RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      expect(resolvedCallback).not.toBeCalled();\n      expect(rejectedCallback).not.toBeCalled();\n\n      var pendingMutation = injectedNetworkLayer.sendMutation.mock.calls[0][0];\n      var error = new Error('Mutation Error');\n      pendingMutation.deferred.reject(error);\n      jest.runAllTimers();\n\n      expect(resolvedCallback).not.toBeCalled();\n      expect(rejectedCallback).toBeCalledWith(error);\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Deferred","RelayNetworkLayer","RelayTestUtils","RelayQuery"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst Deferred = require('Deferred');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayNetworkLayer', () => {\n  var RelayQuery;\n\n  var injectedNetworkLayer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayQuery = jest.genMockFromModule('RelayQuery');\n    jest.setMock('RelayQuery', RelayQuery);\n\n    injectedNetworkLayer = {\n      sendMutation: jest.genMockFunction(),\n      sendQueries: jest.genMockFunction(),\n      supports: jest.genMockFunction().mockReturnValue(true),\n    };\n    RelayNetworkLayer.injectNetworkLayer(injectedNetworkLayer);\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('supports', () => {\n    it('throws when no network layer is injected', () => {\n      RelayNetworkLayer.injectNetworkLayer(null);\n      expect(() => {\n        RelayNetworkLayer.sendQueries([]);\n      }).toFailInvariant(\n        'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network ' +\n        'layer.'\n      );\n    });\n\n    it('delegates to the injected network layer', () => {\n      expect(injectedNetworkLayer.supports).not.toBeCalled();\n      RelayNetworkLayer.supports('foo', 'bar');\n      expect(injectedNetworkLayer.supports).toBeCalledWith('foo', 'bar');\n    });\n  });\n\n  describe('sendQueries', () => {\n    it('throws when no network layer is injected', () => {\n      RelayNetworkLayer.injectNetworkLayer(null);\n      expect(() => {\n        RelayNetworkLayer.sendQueries([]);\n      }).toFailInvariant(\n        'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network ' +\n        'layer.'\n      );\n    });\n\n    it('delegates queries to the injected network layer', () => {\n      var queries = [];\n      expect(injectedNetworkLayer.sendQueries).not.toBeCalled();\n      RelayNetworkLayer.sendQueries(queries);\n      expect(injectedNetworkLayer.sendQueries).toBeCalledWith(queries);\n    });\n  });\n\n  describe('sendMutation', () => {\n    var mutation;\n    var variables;\n    var deferred;\n    var resolvedCallback;\n    var rejectedCallback;\n\n    beforeEach(() => {\n      mutation = {};\n      variables = {};\n      resolvedCallback = jest.genMockFunction();\n      rejectedCallback = jest.genMockFunction();\n      deferred = new Deferred();\n      deferred.getPromise().done(resolvedCallback, rejectedCallback);\n    });\n\n    it('throws when no network layer is injected', () => {\n      RelayNetworkLayer.injectNetworkLayer(null);\n      expect(() => {\n        RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      }).toFailInvariant(\n        'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network ' +\n        'layer.'\n      );\n    });\n\n    it('delegates mutation to the injected network layer', () => {\n      expect(injectedNetworkLayer.sendQueries).not.toBeCalled();\n      RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      expect(injectedNetworkLayer.sendMutation).toBeCalled();\n\n      var pendingMutation = injectedNetworkLayer.sendMutation.mock.calls[0][0];\n      expect(pendingMutation.mutation).toBe(mutation);\n      expect(pendingMutation.variables).toBe(variables);\n    });\n\n    it('resolves the deferred if the mutation succeeds', () => {\n      RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      expect(resolvedCallback).not.toBeCalled();\n      expect(rejectedCallback).not.toBeCalled();\n\n      var pendingMutation = injectedNetworkLayer.sendMutation.mock.calls[0][0];\n      var response = {};\n      pendingMutation.deferred.resolve(response);\n      jest.runAllTimers();\n\n      expect(resolvedCallback).toBeCalledWith(response);\n      expect(rejectedCallback).not.toBeCalled();\n    });\n\n    it('rejects the deferred if the mutation fails', () => {\n      RelayNetworkLayer.sendMutation({mutation, variables, deferred});\n      expect(resolvedCallback).not.toBeCalled();\n      expect(rejectedCallback).not.toBeCalled();\n\n      var pendingMutation = injectedNetworkLayer.sendMutation.mock.calls[0][0];\n      var error = new Error('Mutation Error');\n      pendingMutation.deferred.reject(error);\n      jest.runAllTimers();\n\n      expect(resolvedCallback).not.toBeCalled();\n      expect(rejectedCallback).toBeCalledWith(error);\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/network/__tests__/RelayNetworkLayer-test.js"}},"/Users/cpojer/Projects/relay/src/mutation/__mocks__/validateMutationConfig.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('validateMutationConfig');\n","dependencies":["validateMutationConfig"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('validateMutationConfig');\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__mocks__/validateMutationConfig.js"}},"/Users/cpojer/Projects/relay/src/mutation/__mocks__/RelayMutationType.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationType');\n","dependencies":["RelayMutationType"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationType');\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__mocks__/RelayMutationType.js"}},"/Users/cpojer/Projects/relay/src/mutation/__mocks__/RelayMutationQueue.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationQueue');\n","dependencies":["RelayMutationQueue"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayMutationQueue');\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__mocks__/RelayMutationQueue.js"}},"/Users/cpojer/Projects/relay/src/mutation/__mocks__/rangeOperationToMetadataKey.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('rangeOperationToMetadataKey');\n","dependencies":["rangeOperationToMetadataKey"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('rangeOperationToMetadataKey');\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__mocks__/rangeOperationToMetadataKey.js"}},"/Users/cpojer/Projects/relay/src/mutation/__tests__/validateMutationConfig-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayTestUtils = require('RelayTestUtils');\nconst validateMutationConfig = require('validateMutationConfig');\n\ndescribe('validateMutationConfig()', () => {\n  let config;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('validating a `FIELDS_CHANGE` config', () => {\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        fieldIDs: {},\n      }, 'MyMutation')).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: `FIELDS_CHANGE` config on `MyMutation` ' +\n        'must have property `fieldIDs`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        fieldIDS: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `fieldIDS` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`; did you mean `fieldIDs`?'\n      );\n\n      // Note that we keep getting warned as edit distance increases...\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        feildIDS: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `feildIDS` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`; did you mean `fieldIDs`?'\n      );\n\n      // ...and increases...\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        feildiDS: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `feildiDS` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`; did you mean `fieldIDs`?'\n      );\n\n      // ...until we go too far.\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        feildidz: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `feildidz` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`.'\n      );\n    });\n  });\n\n  describe('validating a `RANGE_ADD` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'RANGE_ADD',\n        parentName: 'viewer',\n        parentID: 4,\n        connectionName: 'todos',\n        edgeName: 'todoEdge',\n        rangeBehaviors: {\n          '': 'append',\n        },\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `RANGE_ADD` config on `MyMutation` ' +\n        'must have property `connectionName`.'\n      );\n    });\n\n    it('does not complain if optional keys are missing', () => {\n      delete config.parentName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrowError();\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`RANGE_ADD` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig({\n        ...config,\n        connectoinname: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `connectoinname` in ' +\n        '`RANGE_ADD` config for `MyMutation`; did you mean ' +\n        '`connectionName`?'\n      );\n    });\n\n    it('suggests alternatives for optional keys', () => {\n      delete config.parentName;\n      expect(() => validateMutationConfig({\n        ...config,\n        parentaNme: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `parentaNme` in ' +\n        '`RANGE_ADD` config for `MyMutation`; did you mean ' +\n        '`parentName`?'\n      );\n    });\n  });\n\n  describe('validating a `NODE_DELETE` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'NODE_DELETE',\n        connectionName: 'todos',\n        deletedIDFieldName: 'deletedTodoId',\n        parentID: 4,\n        parentName: 'viewer',\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `NODE_DELETE` config on `MyMutation` ' +\n        'must have property `connectionName`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`NODE_DELETE` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig({\n        ...config,\n        connectoinname: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `connectoinname` in ' +\n        '`NODE_DELETE` config for `MyMutation`; did you mean ' +\n        '`connectionName`?'\n      );\n    });\n  });\n\n  describe('validating a `RANGE_DELETE` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'RANGE_DELETE',\n        connectionName: 'friends',\n        deletedIDFieldName: ['formerFriend'],\n        parentID: '4',\n        parentName: 'actor',\n        pathToConnection: ['actor', 'friends'],\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `RANGE_DELETE` config on `MyMutation` ' +\n        'must have property `connectionName`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`RANGE_DELETE` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig({\n        ...config,\n        connectoinname: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `connectoinname` in ' +\n        '`RANGE_DELETE` config for `MyMutation`; did you mean ' +\n        '`connectionName`?'\n      );\n    });\n  });\n\n  describe('validating a `REQUIRED_CHILDREN` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'REQUIRED_CHILDREN',\n        children: [],\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.children;\n      expect(() => validateMutationConfig(\n        config,\n       'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `REQUIRED_CHILDREN` config on `MyMutation` ' +\n        'must have property `children`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`REQUIRED_CHILDREN` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.children;\n      expect(() => validateMutationConfig({\n        ...config,\n        Childan: [],\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `Childan` in ' +\n        '`REQUIRED_CHILDREN` config for `MyMutation`; did you mean `children`?'\n      );\n    });\n  });\n});\n","dependencies":["RelayTestUtils","validateMutationConfig"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst RelayTestUtils = require('RelayTestUtils');\nconst validateMutationConfig = require('validateMutationConfig');\n\ndescribe('validateMutationConfig()', () => {\n  let config;\n\n  beforeEach(() => {\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('validating a `FIELDS_CHANGE` config', () => {\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        fieldIDs: {},\n      }, 'MyMutation')).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: `FIELDS_CHANGE` config on `MyMutation` ' +\n        'must have property `fieldIDs`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        fieldIDS: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `fieldIDS` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`; did you mean `fieldIDs`?'\n      );\n\n      // Note that we keep getting warned as edit distance increases...\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        feildIDS: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `feildIDS` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`; did you mean `fieldIDs`?'\n      );\n\n      // ...and increases...\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        feildiDS: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `feildiDS` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`; did you mean `fieldIDs`?'\n      );\n\n      // ...until we go too far.\n      expect(() => validateMutationConfig({\n        type: 'FIELDS_CHANGE',\n        feildidz: {},\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `feildidz` in ' +\n        '`FIELDS_CHANGE` config for `MyMutation`.'\n      );\n    });\n  });\n\n  describe('validating a `RANGE_ADD` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'RANGE_ADD',\n        parentName: 'viewer',\n        parentID: 4,\n        connectionName: 'todos',\n        edgeName: 'todoEdge',\n        rangeBehaviors: {\n          '': 'append',\n        },\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `RANGE_ADD` config on `MyMutation` ' +\n        'must have property `connectionName`.'\n      );\n    });\n\n    it('does not complain if optional keys are missing', () => {\n      delete config.parentName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrowError();\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`RANGE_ADD` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig({\n        ...config,\n        connectoinname: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `connectoinname` in ' +\n        '`RANGE_ADD` config for `MyMutation`; did you mean ' +\n        '`connectionName`?'\n      );\n    });\n\n    it('suggests alternatives for optional keys', () => {\n      delete config.parentName;\n      expect(() => validateMutationConfig({\n        ...config,\n        parentaNme: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `parentaNme` in ' +\n        '`RANGE_ADD` config for `MyMutation`; did you mean ' +\n        '`parentName`?'\n      );\n    });\n  });\n\n  describe('validating a `NODE_DELETE` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'NODE_DELETE',\n        connectionName: 'todos',\n        deletedIDFieldName: 'deletedTodoId',\n        parentID: 4,\n        parentName: 'viewer',\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `NODE_DELETE` config on `MyMutation` ' +\n        'must have property `connectionName`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`NODE_DELETE` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig({\n        ...config,\n        connectoinname: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `connectoinname` in ' +\n        '`NODE_DELETE` config for `MyMutation`; did you mean ' +\n        '`connectionName`?'\n      );\n    });\n  });\n\n  describe('validating a `RANGE_DELETE` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'RANGE_DELETE',\n        connectionName: 'friends',\n        deletedIDFieldName: ['formerFriend'],\n        parentID: '4',\n        parentName: 'actor',\n        pathToConnection: ['actor', 'friends'],\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `RANGE_DELETE` config on `MyMutation` ' +\n        'must have property `connectionName`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`RANGE_DELETE` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.connectionName;\n      expect(() => validateMutationConfig({\n        ...config,\n        connectoinname: 'todos',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `connectoinname` in ' +\n        '`RANGE_DELETE` config for `MyMutation`; did you mean ' +\n        '`connectionName`?'\n      );\n    });\n  });\n\n  describe('validating a `REQUIRED_CHILDREN` config', () => {\n    beforeEach(() => {\n      config = {\n        type: 'REQUIRED_CHILDREN',\n        children: [],\n      };\n    });\n\n    it('does nothing for a valid config', () => {\n      expect(() => validateMutationConfig(\n        config,\n        'MyMutation'\n      )).not.toThrow();\n    });\n\n    it('complains about missing keys', () => {\n      delete config.children;\n      expect(() => validateMutationConfig(\n        config,\n       'MyMutation'\n      )).toFailInvariant(\n        'validateMutationConfig: `REQUIRED_CHILDREN` config on `MyMutation` ' +\n        'must have property `children`.'\n      );\n    });\n\n    it('complains about extraneous keys', () => {\n      expect(() => validateMutationConfig({\n        ...config,\n        extraneous: '?',\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `extraneous` in ' +\n        '`REQUIRED_CHILDREN` config for `MyMutation`.'\n      );\n    });\n\n    it('suggests an alternative when one is appropriate', () => {\n      delete config.children;\n      expect(() => validateMutationConfig({\n        ...config,\n        Childan: [],\n      }, 'MyMutation')).toFailInvariant(\n        'validateMutationConfig: Unexpected key `Childan` in ' +\n        '`REQUIRED_CHILDREN` config for `MyMutation`; did you mean `children`?'\n      );\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__tests__/validateMutationConfig-test.js"}},"/Users/cpojer/Projects/relay/src/mutation/__tests__/RelayMutationQueue-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayMutationTransaction')\n  .dontMock('RelayMutationTransactionStatus');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutation = require('RelayMutation');\nconst RelayMutationQuery = require('RelayMutationQuery');\nconst RelayMutationTransactionStatus = require('RelayMutationTransactionStatus');\nconst RelayStore = require('RelayStore');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst fromGraphQL = require('fromGraphQL');\n\ndescribe('RelayMutationQueue', () => {\n  var RelayNetworkLayer;\n  var storeData;\n  var mutationQueue;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayNetworkLayer = jest.genMockFromModule('RelayNetworkLayer');\n    jest.setMock('RelayNetworkLayer', RelayNetworkLayer);\n\n    RelayStoreData.prototype.handleUpdatePayload = jest.genMockFunction();\n    storeData = RelayStore.getStoreData();\n    mutationQueue = storeData.getMutationQueue();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('constructor', () => {\n    var mockMutation, mutationNode, fatQuery;\n\n    beforeEach(() => {\n      mutationNode = Relay.QL`mutation{commentCreate(input:$input)}`;\n      fatQuery = Relay.QL`fragment on Comment @relay(pattern: true) {\n        ... on Comment {\n          likers\n          doesViewerLike\n        }\n      }`;\n      mockMutation = new RelayMutation();\n      mockMutation.getFatQuery.mockReturnValue(fatQuery);\n      mockMutation.getMutation.mockReturnValue(mutationNode);\n      mockMutation.getConfigs.mockReturnValue('configs');\n    });\n\n    it('does not update store if there is no optimistic response', () => {\n      var transaction = mutationQueue.createTransaction(mockMutation);\n\n      expect(transaction.getStatus()).toBe(\n        RelayMutationTransactionStatus.UNCOMMITTED\n      );\n      expect(storeData.handleUpdatePayload).not.toBeCalled();\n    });\n\n    it('updates store if there is a optimistic response', () => {\n      var input = {foo: 'bar'};\n      mockMutation.getVariables.mockReturnValue(input);\n      mockMutation.getOptimisticResponse.mockReturnValue({});\n      mockMutation.getOptimisticConfigs.mockReturnValue('optimisticConfigs');\n      RelayMutationQuery.buildQuery.mockReturnValue('optimisticQuery');\n\n      var transaction = mutationQueue.createTransaction(mockMutation);\n\n      expect(transaction.getStatus()).toBe(\n        RelayMutationTransactionStatus.UNCOMMITTED\n      );\n      const buildQueryCalls = RelayMutationQuery.buildQuery.mock.calls;\n      expect(buildQueryCalls.length).toBe(1);\n      expect(buildQueryCalls[0][0].configs).toBe('optimisticConfigs');\n      expect(buildQueryCalls[0][0].input).toEqual({\n        ...input,\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n      });\n      expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);\n      expect(buildQueryCalls[0][0].mutationName).toBe('RelayMutation');\n      expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());\n      expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(\n        flattenRelayQuery(fromGraphQL.Fragment(fatQuery), {\n          preserveEmptyNodes: true,\n          shouldRemoveFragments: true,\n        })\n      );\n      expect(storeData.handleUpdatePayload.mock.calls).toEqual([[\n        'optimisticQuery',\n        {[RelayConnectionInterface.CLIENT_MUTATION_ID]: '0'},\n        {configs: 'optimisticConfigs', isOptimisticUpdate: true},\n      ]]);\n    });\n\n    it('infers optimistic query if mutation does not have one', () => {\n      mockMutation.getOptimisticResponse.mockReturnValue({});\n      RelayMutationQuery.buildQueryForOptimisticUpdate.mockReturnValue(\n        'optimisticQuery'\n      );\n\n      mutationQueue.createTransaction(mockMutation);\n\n      const buildQueryCalls =\n        RelayMutationQuery.buildQueryForOptimisticUpdate.mock.calls;\n      expect(buildQueryCalls.length).toBe(1);\n      expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);\n      expect(buildQueryCalls[0][0].response).toEqual({\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n      });\n      expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());\n      expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(\n        flattenRelayQuery(fromGraphQL.Fragment(fatQuery), {\n          preserveEmptyNodes: true,\n          shouldRemoveFragments: true,\n        })\n      );\n      expect(storeData.handleUpdatePayload.mock.calls).toEqual([[\n        'optimisticQuery',\n        {[RelayConnectionInterface.CLIENT_MUTATION_ID]: '0'},\n        {configs: 'configs', isOptimisticUpdate: true},\n      ]]);\n    });\n  });\n\n  describe('commit', () => {\n    var mockMutation1, mockMutation2, mockMutation3, mutationNode, fatQuery;\n\n    beforeEach(() => {\n      fatQuery = Relay.QL`fragment on Comment @relay(pattern: true) {\n        ... on Comment {\n          doesViewerLike\n        }\n      }`;\n      mutationNode = Relay.QL`mutation{commentCreate(input:$input)}`;\n\n      RelayMutation.prototype.getFatQuery.mockReturnValue(fatQuery);\n      RelayMutation.prototype.getMutation.mockReturnValue(mutationNode);\n      RelayMutation.prototype.getCollisionKey.mockReturnValue(null);\n      RelayMutation.prototype.getVariables.mockReturnValue({});\n      RelayMutation.prototype.getConfigs.mockReturnValue('configs');\n\n      mockMutation1 = new RelayMutation();\n      mockMutation2 = new RelayMutation();\n      mockMutation3 = new RelayMutation();\n      mockMutation1.getCollisionKey.mockReturnValue('key');\n      mockMutation2.getCollisionKey.mockReturnValue('anotherKey');\n    });\n\n    it('throws if commit is called more than once', () => {\n      var transaction = mutationQueue.createTransaction(mockMutation1);\n      transaction.commit();\n      expect(() => transaction.commit()).toThrowError(\n        'RelayMutationTransaction: Only transactions with status ' +\n        '`UNCOMMITTED` can be comitted.'\n      );\n    });\n\n    it('calls `onSuccess` with response', () => {\n      var successCallback1 = jest.genMockFunction();\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onSuccess: successCallback1}\n      );\n      transaction1.commit();\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.resolve({response: {'res': 'ponse'}});\n      jest.runAllTimers();\n      expect(successCallback1.mock.calls).toEqual([[{'res': 'ponse'}]]);\n    });\n\n    it('calls `onFailure` with transaction', () => {\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        transaction => {\n          expect(transaction).toBe(transaction1);\n          expect(transaction.getError()).toBe(mockError);\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback1}\n      );\n      var mockError = new Error('error');\n      transaction1.commit();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(mockError);\n      jest.runAllTimers();\n      expect(failureCallback1).toBeCalled();\n    });\n\n    it('queues commits for colliding transactions', () => {\n      var successCallback1 = jest.genMockFunction();\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onSuccess: successCallback1}\n      );\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n\n      var transaction2 = mutationQueue.createTransaction(mockMutation1);\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.resolve({response: {}});\n      jest.runAllTimers();\n\n      expect(successCallback1).toBeCalled();\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('does not queue commits for non-colliding transactions', () => {\n      var transaction1 = mutationQueue.createTransaction(mockMutation1);\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var transaction2 = mutationQueue.createTransaction(mockMutation2);\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('does not queue commits for `null` collision key transactions', () => {\n      var transaction1 = mutationQueue.createTransaction(mockMutation3);\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var transaction2 = mutationQueue.createTransaction(mockMutation3);\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('empties collision queue after a failure', () => {\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction1);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COMMIT_FAILED\n          );\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback1}\n      );\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var failureCallback2 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction2);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n          );\n\n          preventAutoRollback();\n        }\n      );\n      var transaction2 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback2}\n      );\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(new Error('error'));\n      jest.runAllTimers();\n\n      expect(failureCallback1).toBeCalled();\n      expect(failureCallback2).toBeCalled();\n      expect(() => transaction1.getStatus()).toThrowError(\n        'RelayMutationQueue: `0` is not a valid pending transaction ID.'\n      );\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n      );\n\n      var transaction3 = mutationQueue.createTransaction(mockMutation1);\n      transaction3.commit();\n\n      expect(transaction3.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('rolls back colliding transactions on failure unless prevented', () => {\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction1);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COMMIT_FAILED\n          );\n          preventAutoRollback();\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback1}\n      );\n      transaction1.commit();\n\n      var failureCallback2 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction2);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n          );\n        }\n      );\n      var transaction2 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback2}\n      );\n      transaction2.commit();\n\n      var failureCallback3 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction3);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n          );\n          preventAutoRollback();\n        }\n      );\n      var transaction3 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback3}\n      );\n      transaction3.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(transaction3.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n\n      var failureCallback4 = jest.genMockFunction().mockImplementation();\n      var transaction4 = mutationQueue.createTransaction(\n        mockMutation2,\n        {onFailure: failureCallback4}\n      );\n      transaction4.commit();\n\n      var failureCallback5 = jest.genMockFunction().mockImplementation();\n      var transaction5 = mutationQueue.createTransaction(\n        mockMutation2,\n        {onFailure: failureCallback5}\n      );\n      transaction5.commit();\n\n      expect(transaction4.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(transaction5.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(new Error('error'));\n      jest.runAllTimers();\n\n      expect(failureCallback1).toBeCalled();\n      expect(failureCallback2).toBeCalled();\n      expect(failureCallback3).toBeCalled();\n      expect(failureCallback4).not.toBeCalled();\n      expect(failureCallback5).not.toBeCalled();\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_FAILED\n      );\n      expect(() => transaction2.getStatus()).toThrowError(\n        'RelayMutationQueue: `1` is not a valid pending transaction ID.'\n      );\n      expect(transaction3.getStatus()).toBe(\n        RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n      );\n      expect(transaction4.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(transaction5.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n    });\n  });\n\n  describe('recommit', () => {\n    var mockMutation, mutationNode, fatQuery;\n\n    beforeEach(() => {\n      fatQuery = Relay.QL`fragment on Comment @relay(pattern: true) {\n        ... on Comment {\n          doesViewerLike\n        }\n      }`;\n      mutationNode = Relay.QL`mutation{commentCreate(input:$input)}`;\n      RelayMutation.prototype.getFatQuery.mockReturnValue(fatQuery);\n      RelayMutation.prototype.getMutation.mockReturnValue(mutationNode);\n      RelayMutation.prototype.getCollisionKey.mockReturnValue('key');\n      RelayMutation.prototype.getVariables.mockReturnValue({});\n      RelayMutation.prototype.getConfigs.mockReturnValue('configs');\n\n      mockMutation = new RelayMutation();\n    });\n\n    it('re-queues the transaction', () => {\n      var successCallback1 = jest.genMockFunction();\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          preventAutoRollback();\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation,\n        {\n          onSuccess: successCallback1,\n          onFailure: failureCallback1,\n        }\n      );\n      transaction1.commit();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(new Error('error'));\n      jest.runAllTimers();\n\n      expect(failureCallback1).toBeCalled();\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_FAILED\n      );\n\n      var successCallback2 = jest.genMockFunction();\n      var transaction2 = mutationQueue.createTransaction(\n        mockMutation,\n        {onSuccess: successCallback2}\n      );\n      transaction2.commit();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n\n      transaction1.recommit();\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n\n      request = RelayNetworkLayer.sendMutation.mock.calls[1][0];\n      request.resolve({response: {}});\n      jest.runAllTimers();\n      expect(successCallback2).toBeCalled();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(3);\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n\n      request = RelayNetworkLayer.sendMutation.mock.calls[2][0];\n      request.resolve({response: {}});\n      jest.runAllTimers();\n\n      expect(successCallback1).toBeCalled();\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayConnectionInterface","RelayMutation","RelayMutationQuery","RelayMutationTransactionStatus","RelayStore","RelayStoreData","RelayTestUtils","flattenRelayQuery","fromGraphQL","RelayNetworkLayer"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayMutationTransaction')\n  .dontMock('RelayMutationTransactionStatus');\n\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutation = require('RelayMutation');\nconst RelayMutationQuery = require('RelayMutationQuery');\nconst RelayMutationTransactionStatus = require('RelayMutationTransactionStatus');\nconst RelayStore = require('RelayStore');\nconst RelayStoreData = require('RelayStoreData');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst fromGraphQL = require('fromGraphQL');\n\ndescribe('RelayMutationQueue', () => {\n  var RelayNetworkLayer;\n  var storeData;\n  var mutationQueue;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    RelayNetworkLayer = jest.genMockFromModule('RelayNetworkLayer');\n    jest.setMock('RelayNetworkLayer', RelayNetworkLayer);\n\n    RelayStoreData.prototype.handleUpdatePayload = jest.genMockFunction();\n    storeData = RelayStore.getStoreData();\n    mutationQueue = storeData.getMutationQueue();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('constructor', () => {\n    var mockMutation, mutationNode, fatQuery;\n\n    beforeEach(() => {\n      mutationNode = Relay.QL`mutation{commentCreate(input:$input)}`;\n      fatQuery = Relay.QL`fragment on Comment @relay(pattern: true) {\n        ... on Comment {\n          likers\n          doesViewerLike\n        }\n      }`;\n      mockMutation = new RelayMutation();\n      mockMutation.getFatQuery.mockReturnValue(fatQuery);\n      mockMutation.getMutation.mockReturnValue(mutationNode);\n      mockMutation.getConfigs.mockReturnValue('configs');\n    });\n\n    it('does not update store if there is no optimistic response', () => {\n      var transaction = mutationQueue.createTransaction(mockMutation);\n\n      expect(transaction.getStatus()).toBe(\n        RelayMutationTransactionStatus.UNCOMMITTED\n      );\n      expect(storeData.handleUpdatePayload).not.toBeCalled();\n    });\n\n    it('updates store if there is a optimistic response', () => {\n      var input = {foo: 'bar'};\n      mockMutation.getVariables.mockReturnValue(input);\n      mockMutation.getOptimisticResponse.mockReturnValue({});\n      mockMutation.getOptimisticConfigs.mockReturnValue('optimisticConfigs');\n      RelayMutationQuery.buildQuery.mockReturnValue('optimisticQuery');\n\n      var transaction = mutationQueue.createTransaction(mockMutation);\n\n      expect(transaction.getStatus()).toBe(\n        RelayMutationTransactionStatus.UNCOMMITTED\n      );\n      const buildQueryCalls = RelayMutationQuery.buildQuery.mock.calls;\n      expect(buildQueryCalls.length).toBe(1);\n      expect(buildQueryCalls[0][0].configs).toBe('optimisticConfigs');\n      expect(buildQueryCalls[0][0].input).toEqual({\n        ...input,\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n      });\n      expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);\n      expect(buildQueryCalls[0][0].mutationName).toBe('RelayMutation');\n      expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());\n      expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(\n        flattenRelayQuery(fromGraphQL.Fragment(fatQuery), {\n          preserveEmptyNodes: true,\n          shouldRemoveFragments: true,\n        })\n      );\n      expect(storeData.handleUpdatePayload.mock.calls).toEqual([[\n        'optimisticQuery',\n        {[RelayConnectionInterface.CLIENT_MUTATION_ID]: '0'},\n        {configs: 'optimisticConfigs', isOptimisticUpdate: true},\n      ]]);\n    });\n\n    it('infers optimistic query if mutation does not have one', () => {\n      mockMutation.getOptimisticResponse.mockReturnValue({});\n      RelayMutationQuery.buildQueryForOptimisticUpdate.mockReturnValue(\n        'optimisticQuery'\n      );\n\n      mutationQueue.createTransaction(mockMutation);\n\n      const buildQueryCalls =\n        RelayMutationQuery.buildQueryForOptimisticUpdate.mock.calls;\n      expect(buildQueryCalls.length).toBe(1);\n      expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);\n      expect(buildQueryCalls[0][0].response).toEqual({\n        [RelayConnectionInterface.CLIENT_MUTATION_ID]: '0',\n      });\n      expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());\n      expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(\n        flattenRelayQuery(fromGraphQL.Fragment(fatQuery), {\n          preserveEmptyNodes: true,\n          shouldRemoveFragments: true,\n        })\n      );\n      expect(storeData.handleUpdatePayload.mock.calls).toEqual([[\n        'optimisticQuery',\n        {[RelayConnectionInterface.CLIENT_MUTATION_ID]: '0'},\n        {configs: 'configs', isOptimisticUpdate: true},\n      ]]);\n    });\n  });\n\n  describe('commit', () => {\n    var mockMutation1, mockMutation2, mockMutation3, mutationNode, fatQuery;\n\n    beforeEach(() => {\n      fatQuery = Relay.QL`fragment on Comment @relay(pattern: true) {\n        ... on Comment {\n          doesViewerLike\n        }\n      }`;\n      mutationNode = Relay.QL`mutation{commentCreate(input:$input)}`;\n\n      RelayMutation.prototype.getFatQuery.mockReturnValue(fatQuery);\n      RelayMutation.prototype.getMutation.mockReturnValue(mutationNode);\n      RelayMutation.prototype.getCollisionKey.mockReturnValue(null);\n      RelayMutation.prototype.getVariables.mockReturnValue({});\n      RelayMutation.prototype.getConfigs.mockReturnValue('configs');\n\n      mockMutation1 = new RelayMutation();\n      mockMutation2 = new RelayMutation();\n      mockMutation3 = new RelayMutation();\n      mockMutation1.getCollisionKey.mockReturnValue('key');\n      mockMutation2.getCollisionKey.mockReturnValue('anotherKey');\n    });\n\n    it('throws if commit is called more than once', () => {\n      var transaction = mutationQueue.createTransaction(mockMutation1);\n      transaction.commit();\n      expect(() => transaction.commit()).toThrowError(\n        'RelayMutationTransaction: Only transactions with status ' +\n        '`UNCOMMITTED` can be comitted.'\n      );\n    });\n\n    it('calls `onSuccess` with response', () => {\n      var successCallback1 = jest.genMockFunction();\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onSuccess: successCallback1}\n      );\n      transaction1.commit();\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.resolve({response: {'res': 'ponse'}});\n      jest.runAllTimers();\n      expect(successCallback1.mock.calls).toEqual([[{'res': 'ponse'}]]);\n    });\n\n    it('calls `onFailure` with transaction', () => {\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        transaction => {\n          expect(transaction).toBe(transaction1);\n          expect(transaction.getError()).toBe(mockError);\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback1}\n      );\n      var mockError = new Error('error');\n      transaction1.commit();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(mockError);\n      jest.runAllTimers();\n      expect(failureCallback1).toBeCalled();\n    });\n\n    it('queues commits for colliding transactions', () => {\n      var successCallback1 = jest.genMockFunction();\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onSuccess: successCallback1}\n      );\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n\n      var transaction2 = mutationQueue.createTransaction(mockMutation1);\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.resolve({response: {}});\n      jest.runAllTimers();\n\n      expect(successCallback1).toBeCalled();\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('does not queue commits for non-colliding transactions', () => {\n      var transaction1 = mutationQueue.createTransaction(mockMutation1);\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var transaction2 = mutationQueue.createTransaction(mockMutation2);\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('does not queue commits for `null` collision key transactions', () => {\n      var transaction1 = mutationQueue.createTransaction(mockMutation3);\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var transaction2 = mutationQueue.createTransaction(mockMutation3);\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('empties collision queue after a failure', () => {\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction1);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COMMIT_FAILED\n          );\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback1}\n      );\n      transaction1.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var failureCallback2 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction2);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n          );\n\n          preventAutoRollback();\n        }\n      );\n      var transaction2 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback2}\n      );\n      transaction2.commit();\n\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(new Error('error'));\n      jest.runAllTimers();\n\n      expect(failureCallback1).toBeCalled();\n      expect(failureCallback2).toBeCalled();\n      expect(() => transaction1.getStatus()).toThrowError(\n        'RelayMutationQueue: `0` is not a valid pending transaction ID.'\n      );\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n      );\n\n      var transaction3 = mutationQueue.createTransaction(mockMutation1);\n      transaction3.commit();\n\n      expect(transaction3.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n    });\n\n    it('rolls back colliding transactions on failure unless prevented', () => {\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction1);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COMMIT_FAILED\n          );\n          preventAutoRollback();\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback1}\n      );\n      transaction1.commit();\n\n      var failureCallback2 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction2);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n          );\n        }\n      );\n      var transaction2 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback2}\n      );\n      transaction2.commit();\n\n      var failureCallback3 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          expect(transaction).toBe(transaction3);\n          expect(transaction.getStatus()).toBe(\n            RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n          );\n          preventAutoRollback();\n        }\n      );\n      var transaction3 = mutationQueue.createTransaction(\n        mockMutation1,\n        {onFailure: failureCallback3}\n      );\n      transaction3.commit();\n\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(transaction2.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(transaction3.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n\n      var failureCallback4 = jest.genMockFunction().mockImplementation();\n      var transaction4 = mutationQueue.createTransaction(\n        mockMutation2,\n        {onFailure: failureCallback4}\n      );\n      transaction4.commit();\n\n      var failureCallback5 = jest.genMockFunction().mockImplementation();\n      var transaction5 = mutationQueue.createTransaction(\n        mockMutation2,\n        {onFailure: failureCallback5}\n      );\n      transaction5.commit();\n\n      expect(transaction4.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(transaction5.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(new Error('error'));\n      jest.runAllTimers();\n\n      expect(failureCallback1).toBeCalled();\n      expect(failureCallback2).toBeCalled();\n      expect(failureCallback3).toBeCalled();\n      expect(failureCallback4).not.toBeCalled();\n      expect(failureCallback5).not.toBeCalled();\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_FAILED\n      );\n      expect(() => transaction2.getStatus()).toThrowError(\n        'RelayMutationQueue: `1` is not a valid pending transaction ID.'\n      );\n      expect(transaction3.getStatus()).toBe(\n        RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED\n      );\n      expect(transaction4.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n      expect(transaction5.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n    });\n  });\n\n  describe('recommit', () => {\n    var mockMutation, mutationNode, fatQuery;\n\n    beforeEach(() => {\n      fatQuery = Relay.QL`fragment on Comment @relay(pattern: true) {\n        ... on Comment {\n          doesViewerLike\n        }\n      }`;\n      mutationNode = Relay.QL`mutation{commentCreate(input:$input)}`;\n      RelayMutation.prototype.getFatQuery.mockReturnValue(fatQuery);\n      RelayMutation.prototype.getMutation.mockReturnValue(mutationNode);\n      RelayMutation.prototype.getCollisionKey.mockReturnValue('key');\n      RelayMutation.prototype.getVariables.mockReturnValue({});\n      RelayMutation.prototype.getConfigs.mockReturnValue('configs');\n\n      mockMutation = new RelayMutation();\n    });\n\n    it('re-queues the transaction', () => {\n      var successCallback1 = jest.genMockFunction();\n      var failureCallback1 = jest.genMockFunction().mockImplementation(\n        (transaction, preventAutoRollback) => {\n          preventAutoRollback();\n        }\n      );\n      var transaction1 = mutationQueue.createTransaction(\n        mockMutation,\n        {\n          onSuccess: successCallback1,\n          onFailure: failureCallback1,\n        }\n      );\n      transaction1.commit();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(1);\n      var request = RelayNetworkLayer.sendMutation.mock.calls[0][0];\n      request.reject(new Error('error'));\n      jest.runAllTimers();\n\n      expect(failureCallback1).toBeCalled();\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_FAILED\n      );\n\n      var successCallback2 = jest.genMockFunction();\n      var transaction2 = mutationQueue.createTransaction(\n        mockMutation,\n        {onSuccess: successCallback2}\n      );\n      transaction2.commit();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(2);\n\n      transaction1.recommit();\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMIT_QUEUED\n      );\n\n      request = RelayNetworkLayer.sendMutation.mock.calls[1][0];\n      request.resolve({response: {}});\n      jest.runAllTimers();\n      expect(successCallback2).toBeCalled();\n\n      expect(RelayNetworkLayer.sendMutation.mock.calls.length).toBe(3);\n      expect(transaction1.getStatus()).toBe(\n        RelayMutationTransactionStatus.COMMITTING\n      );\n\n      request = RelayNetworkLayer.sendMutation.mock.calls[2][0];\n      request.resolve({response: {}});\n      jest.runAllTimers();\n\n      expect(successCallback1).toBeCalled();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__tests__/RelayMutationQueue-test.js"}},"/Users/cpojer/Projects/relay/src/mutation/__tests__/RelayMutationQuery-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayMutationQuery');\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutationQuery = require('RelayMutationQuery');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst filterRelayQuery = require('filterRelayQuery');\nconst fromGraphQL = require('fromGraphQL');\nconst intersectRelayQuery = require('intersectRelayQuery');\nconst inferRelayFieldsFromData = require('inferRelayFieldsFromData');\n\ndescribe('RelayMutationQuery', () => {\n  var {filterGeneratedFields, getNode} = RelayTestUtils;\n\n  function getNodeChildren(fragment) {\n    return fromGraphQL.Fragment(fragment).getChildren();\n  }\n  function getNodeWithoutSource(...args) {\n    var filterCallback = RelayConnectionInterface.EDGES_HAVE_SOURCE_FIELD ?\n      () => true :\n      node => !node.getSchemaName || node.getSchemaName() !== 'source';\n    return filterRelayQuery(RelayTestUtils.getNode(...args), filterCallback);\n  }\n\n  var tracker;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    tracker = new RelayQueryTracker();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('fields', () => {\n    it('throws for invalid field names', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on ActorSubscribeResponsePayload {\n          subscribee {\n            subscribers,\n            subscribeStatus\n          }\n        }\n      `);\n      expect(() => {\n        RelayMutationQuery.buildFragmentForFields({\n          fatQuery,\n          tracker,\n          fieldIDs: {\n            unsubscribee: '4',\n          },\n        });\n      }).toFailInvariant(\n        'RelayMutationQuery: Invalid field name on fat query, `unsubscribee`.'\n      );\n    });\n\n    it('maps a field to a single ID', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers,\n          }\n        }\n      `);\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          likers,\n          url\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForFields({\n        fatQuery,\n        tracker,\n        fieldIDs: {\n          feedback: '123',\n        },\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            likers\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n\n    it('maps a plural field to an array of IDs', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on ViewerNotificationsUpdateAllSeenStateResponsePayload {\n          stories {\n            seenState\n          }\n        }\n      `);\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Story {\n          message {\n            text\n          },\n          seenState\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForFields({\n        fatQuery,\n        tracker,\n        fieldIDs: {\n          stories: ['123'],\n        },\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on ViewerNotificationsUpdateAllSeenStateResponsePayload {\n          stories {\n            seenState\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n\n    it('merges tracked nodes for IDs of plural fields', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on ViewerNotificationsUpdateAllSeenStateResponsePayload {\n          stories {\n            seenState\n          }\n        }\n      `);\n      var trackedNodes = {\n        '123': fromGraphQL.Fragment(Relay.QL`\n          fragment on Story {\n            message {\n              text\n            }\n          }\n        `),\n        '456': fromGraphQL.Fragment(Relay.QL`\n          fragment on Story {\n            actors {\n              name\n            },\n            seenState\n          }\n        `),\n      };\n      tracker.getTrackedChildrenForID.mockImplementation(\n        dataID => [trackedNodes[dataID]]\n      );\n      RelayMutationQuery.buildFragmentForFields({\n        fatQuery,\n        tracker,\n        fieldIDs: {\n          stories: ['123', '456'],\n        },\n      });\n      var node = intersectRelayQuery.mock.calls[0][0];\n      var expected = RelayTestUtils.getVerbatimNode(Relay.QL`\n        fragment on Story {\n          ... on Story {\n            id,\n            message {\n              text\n            },\n          },\n          ... on Story {\n            id,\n            actors {\n              __typename,\n              id,\n              name\n            },\n            seenState\n          }\n        }\n      `);\n      // Clone because the root node will differ, but that's okay.\n      expect(expected.clone(node.getChildren()))\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n        ['456'],\n      ]);\n    });\n  });\n\n  describe('edge deletion', () => {\n    var fatQuery;\n    beforeEach(() => {\n      fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          }\n        }\n      `);\n    });\n\n    it('throws for invalid parent name', () => {\n      expect(() => {\n        RelayMutationQuery.buildFragmentForEdgeDeletion({\n          fatQuery,\n          tracker,\n          connectionName: 'comments',\n          parentID: '123',\n          parentName: 'story',\n        });\n      }).toFailInvariant(\n        'RelayMutationQuery: Invalid field name on fat query, `story`.'\n      );\n    });\n\n    it('creates a fragment for connection metadata', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          doesViewerLike,\n          comments(first:\"10\") {\n            count,\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeDeletion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        parentName: 'feedback',\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments(first:\"10\") {\n              count\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n  });\n\n  describe('edge insertion', () => {\n    var fatQuery, rangeBehaviors;\n\n    beforeEach(() => {\n      fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source\n          }\n        }\n      `);\n      rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n        'orderby(toplevel)': GraphQLMutatorConstants.PREPEND,\n      };\n    });\n\n    it('includes edge fields for connections with range config', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(orderby:\"toplevel\",first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedbackCommentEdge {\n            __typename\n            cursor,\n            node {\n              body {\n                text\n              },\n              id\n            },\n            source {\n              id\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n\n    it('includes fields from multiple tracked edges', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            count,\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          },\n          comments(last:10) {\n            edges {\n              node {\n                author {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedbackCommentEdge {\n            __typename\n            cursor,\n            node {\n              author {\n                name\n              },\n              body {\n                text\n              },\n              id\n            },\n            source {\n              id\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('excludes fields from tracked edges with different filters', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            count,\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          },\n          comments(orderby:\"ranked_threaded\",first:\"10\") {\n            edges {\n              node {\n                author {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedbackCommentEdge {\n            __typename\n            cursor,\n            node {\n              body {\n                text\n              },\n              id\n            },\n            source {\n              id\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('refetches connections in the absence of a range config', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(orderby:\"ranked_threaded\",first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        parentName: 'feedback',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments(orderby:\"ranked_threaded\",first:\"10\") {\n              edges {\n                node {\n                  body {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('includes non-edge fields for connections', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments {\n            count\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        parentName: 'feedback',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments {\n              count\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('throws for invalid parent name', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments {\n            count\n          }\n        }\n      `));\n      expect(() => {\n        RelayMutationQuery.buildFragmentForEdgeInsertion({\n          fatQuery,\n          tracker,\n          connectionName: 'comments',\n          parentID: '123',\n          edgeName: 'feedbackCommentEdge',\n          parentName: 'story',\n          rangeBehaviors,\n        });\n      }).toFailInvariant(\n        'RelayMutationQuery: Invalid field name on fat query, `story`.'\n      );\n    });\n  });\n\n  describe('optimistic update', () => {\n    it('infers fields', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers\n          }\n        }\n      `);\n\n      var mockData = {};\n      RelayMutationQuery.buildFragmentForOptimisticUpdate({\n        response: mockData,\n        fatQuery,\n      });\n\n      expect(inferRelayFieldsFromData.mock.calls.length).toBe(1);\n      expect(inferRelayFieldsFromData.mock.calls[0][0]).toBe(mockData);\n    });\n\n    it('builds query', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers,\n          }\n        }\n      `);\n      var mutation = Relay.QL`mutation{feedbackLike(input:$input)}`;\n\n      var query = RelayMutationQuery.buildQueryForOptimisticUpdate({\n        response: {\n          [RelayConnectionInterface.CLIENT_MUTATION_ID]: '1',\n          feedback: {\n            doesViewerLike: true,\n            id: '1',\n            likers: {\n              count: 4,\n            },\n          },\n        },\n        fatQuery,\n        mutation,\n      });\n\n      var variables = {input: ''};\n      var expectedMutationQuery = filterGeneratedFields(\n          getNodeWithoutSource(Relay.QL`\n          mutation {\n            feedbackLike(input:$input) {\n              ${Relay.QL`\n                fragment on FeedbackLikeResponsePayload {\n                  clientMutationId,\n                  feedback {\n                    doesViewerLike,\n                    id,\n                    likers {\n                      count,\n                    },\n                  }\n                }\n              `},\n            }\n          }\n        `, variables)\n      );\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n  });\n\n  describe('query', () => {\n    it('creates a query for RANGE_ADD', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue([getNode(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `)]);\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source,\n          },\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var edgeName = 'feedbackCommentEdge';\n      var rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n      };\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_ADD,\n          parentName,\n          parentID,\n          connectionName,\n          edgeName,\n          rangeBehaviors,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentCreate(input:$input)}`;\n      var mutationName = 'CommentAddMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = filterGeneratedFields(\n        getNodeWithoutSource(Relay.QL`\n          mutation {\n            commentCreate(input:$input) {\n              clientMutationId,\n              ... on CommentCreateResponsePayload {\n                feedback {\n                  ... on Feedback {\n                    id\n                  }\n                }\n                feedbackCommentEdge {\n                  __typename\n                  cursor,\n                  node {\n                    body {\n                      text\n                    },\n                    id\n                  },\n                  source{\n                    id\n                  }\n                }\n              }\n            }\n          }\n        `, variables)\n      );\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for NODE_DELETE', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          }\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var deletedIDFieldName = 'deletedCommentId';\n      var configs = [\n        {\n          type: RelayMutationType.NODE_DELETE,\n          parentName,\n          parentID,\n          connectionName,\n          deletedIDFieldName,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentDelete(input:$input)}`;\n      var mutationName = 'CommentDeleteMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            clientMutationId,\n            deletedCommentId,\n            ${Relay.QL`\n              fragment on CommentDeleteResponsePayload {\n                feedback {\n                  id\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for RANGE_DELETE with a shallow deleted field', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          }\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var deletedIDFieldName = 'deletedCommentId';\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_DELETE,\n          parentName,\n          parentID,\n          connectionName,\n          deletedIDFieldName,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentDelete(input:$input)}`;\n      var mutationName = 'CommentDeleteMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            clientMutationId,\n            deletedCommentId,\n            ${Relay.QL`\n              fragment on CommentDeleteResponsePayload {\n                feedback {\n                  id\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for RANGE_DELETE with a deep deleted field', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            edges {\n              node {\n                name\n              }\n            }\n          }\n        }\n      `));\n      const fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on UnfriendResponsePayload {\n          actor {\n            friends\n          }\n          clientMutationId\n        }\n      `);\n      const configs = [\n        {\n          type: RelayMutationType.RANGE_DELETE,\n          parentName: 'actor',\n          parentID: '123',\n          connectionName: 'friends',\n          deletedIDFieldName: ['formerFriend'],\n          pathToConnection: ['actor', 'friends'],\n        },\n      ];\n\n      const mutation = Relay.QL`mutation{ unfriend(input: $input) }`;\n      const mutationName = 'UnfriendMutation';\n      const variables = {input: ''};\n      const query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      const expectedConcreteNode = Relay.QL`\n        mutation {\n          unfriend(input: $input) {\n            clientMutationId,\n            formerFriend {\n              id\n            }\n            ${Relay.QL`\n              fragment on UnfriendResponsePayload {\n                actor {\n                  id\n                }\n              }\n            `},\n          }\n        }\n      `;\n      expect(query).toEqualQueryNode(\n        getNodeWithoutSource(expectedConcreteNode, variables)\n      );\n    });\n\n    it('creates a query for FIELDS_CHANGE', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          likers,\n          url\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers\n          }\n        }\n      `);\n      var fieldIDs = {\n        feedback: '123',\n      };\n      var configs = [\n        {\n          type: RelayMutationType.FIELDS_CHANGE,\n          fieldIDs,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{feedbackLike(input:$input)}`;\n      var mutationName = 'FeedbackLikeMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          feedbackLike(input:$input) {\n            clientMutationId,\n            ${Relay.QL`\n              fragment on FeedbackLikeResponsePayload {\n                feedback {\n                  id,\n                  likers\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query with additional required fragments', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue([getNode(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `)]);\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source,\n          },\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var edgeName = 'feedbackCommentEdge';\n      var rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n      };\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_ADD,\n          parentName,\n          parentID,\n          connectionName,\n          edgeName,\n          rangeBehaviors,\n        },\n        {\n          type: RelayMutationType.REQUIRED_CHILDREN,\n          children: [Relay.QL`\n            fragment on CommentCreateResponsePayload {\n              feedback {\n                doesViewerLike,\n              },\n            }\n          `],\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentCreate(input:$input)}`;\n      var mutationName = 'CommentAddMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = filterGeneratedFields(\n        getNodeWithoutSource(Relay.QL`\n          mutation {\n            commentCreate(input:$input) {\n              clientMutationId,\n              ... on CommentCreateResponsePayload {\n                feedback {\n                  ... on Feedback {\n                    id\n                  }\n                }\n                feedbackCommentEdge {\n                  __typename\n                  cursor,\n                  node {\n                    body {\n                      text\n                    },\n                    id\n                  },\n                  source {\n                    id\n                  }\n                }\n              }\n              ... on CommentCreateResponsePayload {\n                feedback {\n                  doesViewerLike\n                  id\n                },\n              }\n            }\n          }\n        `, variables)\n      );\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for RANGE_ADD and FIELDS_CHANGE', () => {\n      // Fictitious mutation that does multiple things\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          },\n          likers,\n          url\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n            doesViewerLike,\n            likers\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source,\n          },\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var edgeName = 'feedbackCommentEdge';\n      var rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n      };\n      var fieldIDs = {\n        feedback: '123',\n      };\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_ADD,\n          parentName,\n          parentID,\n          connectionName,\n          edgeName,\n          rangeBehaviors,\n        },\n        {\n          type: RelayMutationType.FIELDS_CHANGE,\n          fieldIDs,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentCreate(input:$input)}`;\n      var mutationName = 'CommentAddAndLikeMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            clientMutationId,\n            ${Relay.QL`\n              fragment on CommentCreateResponsePayload {\n                feedback {\n                  id,\n                  likers,\n                },\n                feedbackCommentEdge {\n                  __typename\n                  cursor,\n                  node {\n                    body {\n                      text\n                    },\n                    id\n                  },\n                  source {\n                    id\n                  }\n                }\n              }\n            `},\n            ${Relay.QL`\n              fragment on CommentCreateResponsePayload {\n                feedback {\n                  comments(first:\"10\") {\n                    edges {\n                      cursor,\n                      node {\n                        body {\n                          text\n                        },\n                        id\n                      }\n                    },\n                    pageInfo {\n                      hasNextPage,\n                      hasPreviousPage\n                    }\n                  },\n                  id,\n                  likers,\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('complains about unknown config types', () => {\n      const fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on UnfriendResponsePayload {\n          clientMutationId\n        }\n      `);\n      const configs = [\n        {\n          type: 'COSMIC_RAY_BIT_FLIP',\n        },\n      ];\n\n      const mutation = Relay.QL`mutation{ unfriend(input: $input) }`;\n      const mutationName = 'UnfriendMutation';\n      expect(() => RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      })).toFailInvariant(\n        'RelayMutationQuery: Unrecognized config key `COSMIC_RAY_BIT_FLIP` ' +\n        'for `UnfriendMutation`.'\n      );\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLMutatorConstants","Relay","RelayConnectionInterface","RelayMutationQuery","RelayMutationType","RelayQueryTracker","RelayTestUtils","filterRelayQuery","fromGraphQL","intersectRelayQuery","inferRelayFieldsFromData"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayMutationQuery');\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst Relay = require('Relay');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutationQuery = require('RelayMutationQuery');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst filterRelayQuery = require('filterRelayQuery');\nconst fromGraphQL = require('fromGraphQL');\nconst intersectRelayQuery = require('intersectRelayQuery');\nconst inferRelayFieldsFromData = require('inferRelayFieldsFromData');\n\ndescribe('RelayMutationQuery', () => {\n  var {filterGeneratedFields, getNode} = RelayTestUtils;\n\n  function getNodeChildren(fragment) {\n    return fromGraphQL.Fragment(fragment).getChildren();\n  }\n  function getNodeWithoutSource(...args) {\n    var filterCallback = RelayConnectionInterface.EDGES_HAVE_SOURCE_FIELD ?\n      () => true :\n      node => !node.getSchemaName || node.getSchemaName() !== 'source';\n    return filterRelayQuery(RelayTestUtils.getNode(...args), filterCallback);\n  }\n\n  var tracker;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    tracker = new RelayQueryTracker();\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('fields', () => {\n    it('throws for invalid field names', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on ActorSubscribeResponsePayload {\n          subscribee {\n            subscribers,\n            subscribeStatus\n          }\n        }\n      `);\n      expect(() => {\n        RelayMutationQuery.buildFragmentForFields({\n          fatQuery,\n          tracker,\n          fieldIDs: {\n            unsubscribee: '4',\n          },\n        });\n      }).toFailInvariant(\n        'RelayMutationQuery: Invalid field name on fat query, `unsubscribee`.'\n      );\n    });\n\n    it('maps a field to a single ID', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers,\n          }\n        }\n      `);\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          likers,\n          url\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForFields({\n        fatQuery,\n        tracker,\n        fieldIDs: {\n          feedback: '123',\n        },\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            likers\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n\n    it('maps a plural field to an array of IDs', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on ViewerNotificationsUpdateAllSeenStateResponsePayload {\n          stories {\n            seenState\n          }\n        }\n      `);\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Story {\n          message {\n            text\n          },\n          seenState\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForFields({\n        fatQuery,\n        tracker,\n        fieldIDs: {\n          stories: ['123'],\n        },\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on ViewerNotificationsUpdateAllSeenStateResponsePayload {\n          stories {\n            seenState\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n\n    it('merges tracked nodes for IDs of plural fields', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on ViewerNotificationsUpdateAllSeenStateResponsePayload {\n          stories {\n            seenState\n          }\n        }\n      `);\n      var trackedNodes = {\n        '123': fromGraphQL.Fragment(Relay.QL`\n          fragment on Story {\n            message {\n              text\n            }\n          }\n        `),\n        '456': fromGraphQL.Fragment(Relay.QL`\n          fragment on Story {\n            actors {\n              name\n            },\n            seenState\n          }\n        `),\n      };\n      tracker.getTrackedChildrenForID.mockImplementation(\n        dataID => [trackedNodes[dataID]]\n      );\n      RelayMutationQuery.buildFragmentForFields({\n        fatQuery,\n        tracker,\n        fieldIDs: {\n          stories: ['123', '456'],\n        },\n      });\n      var node = intersectRelayQuery.mock.calls[0][0];\n      var expected = RelayTestUtils.getVerbatimNode(Relay.QL`\n        fragment on Story {\n          ... on Story {\n            id,\n            message {\n              text\n            },\n          },\n          ... on Story {\n            id,\n            actors {\n              __typename,\n              id,\n              name\n            },\n            seenState\n          }\n        }\n      `);\n      // Clone because the root node will differ, but that's okay.\n      expect(expected.clone(node.getChildren()))\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n        ['456'],\n      ]);\n    });\n  });\n\n  describe('edge deletion', () => {\n    var fatQuery;\n    beforeEach(() => {\n      fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          }\n        }\n      `);\n    });\n\n    it('throws for invalid parent name', () => {\n      expect(() => {\n        RelayMutationQuery.buildFragmentForEdgeDeletion({\n          fatQuery,\n          tracker,\n          connectionName: 'comments',\n          parentID: '123',\n          parentName: 'story',\n        });\n      }).toFailInvariant(\n        'RelayMutationQuery: Invalid field name on fat query, `story`.'\n      );\n    });\n\n    it('creates a fragment for connection metadata', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          doesViewerLike,\n          comments(first:\"10\") {\n            count,\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeDeletion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        parentName: 'feedback',\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments(first:\"10\") {\n              count\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n  });\n\n  describe('edge insertion', () => {\n    var fatQuery, rangeBehaviors;\n\n    beforeEach(() => {\n      fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source\n          }\n        }\n      `);\n      rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n        'orderby(toplevel)': GraphQLMutatorConstants.PREPEND,\n      };\n    });\n\n    it('includes edge fields for connections with range config', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(orderby:\"toplevel\",first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedbackCommentEdge {\n            __typename\n            cursor,\n            node {\n              body {\n                text\n              },\n              id\n            },\n            source {\n              id\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n      expect(tracker.getTrackedChildrenForID.mock.calls).toEqual([\n        ['123'],\n      ]);\n    });\n\n    it('includes fields from multiple tracked edges', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            count,\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          },\n          comments(last:10) {\n            edges {\n              node {\n                author {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedbackCommentEdge {\n            __typename\n            cursor,\n            node {\n              author {\n                name\n              },\n              body {\n                text\n              },\n              id\n            },\n            source {\n              id\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('excludes fields from tracked edges with different filters', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            count,\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          },\n          comments(orderby:\"ranked_threaded\",first:\"10\") {\n            edges {\n              node {\n                author {\n                  name\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedbackCommentEdge {\n            __typename\n            cursor,\n            node {\n              body {\n                text\n              },\n              id\n            },\n            source {\n              id\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('refetches connections in the absence of a range config', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(orderby:\"ranked_threaded\",first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        parentName: 'feedback',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments(orderby:\"ranked_threaded\",first:\"10\") {\n              edges {\n                node {\n                  body {\n                    text\n                  }\n                }\n              }\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('includes non-edge fields for connections', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments {\n            count\n          }\n        }\n      `));\n      var node = RelayMutationQuery.buildFragmentForEdgeInsertion({\n        fatQuery,\n        tracker,\n        connectionName: 'comments',\n        parentID: '123',\n        edgeName: 'feedbackCommentEdge',\n        parentName: 'feedback',\n        rangeBehaviors,\n      });\n      var expected = getNodeWithoutSource(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments {\n              count\n            }\n          }\n        }\n      `);\n      expect(node)\n        .toEqualQueryNode(expected);\n    });\n\n    it('throws for invalid parent name', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments {\n            count\n          }\n        }\n      `));\n      expect(() => {\n        RelayMutationQuery.buildFragmentForEdgeInsertion({\n          fatQuery,\n          tracker,\n          connectionName: 'comments',\n          parentID: '123',\n          edgeName: 'feedbackCommentEdge',\n          parentName: 'story',\n          rangeBehaviors,\n        });\n      }).toFailInvariant(\n        'RelayMutationQuery: Invalid field name on fat query, `story`.'\n      );\n    });\n  });\n\n  describe('optimistic update', () => {\n    it('infers fields', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers\n          }\n        }\n      `);\n\n      var mockData = {};\n      RelayMutationQuery.buildFragmentForOptimisticUpdate({\n        response: mockData,\n        fatQuery,\n      });\n\n      expect(inferRelayFieldsFromData.mock.calls.length).toBe(1);\n      expect(inferRelayFieldsFromData.mock.calls[0][0]).toBe(mockData);\n    });\n\n    it('builds query', () => {\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers,\n          }\n        }\n      `);\n      var mutation = Relay.QL`mutation{feedbackLike(input:$input)}`;\n\n      var query = RelayMutationQuery.buildQueryForOptimisticUpdate({\n        response: {\n          [RelayConnectionInterface.CLIENT_MUTATION_ID]: '1',\n          feedback: {\n            doesViewerLike: true,\n            id: '1',\n            likers: {\n              count: 4,\n            },\n          },\n        },\n        fatQuery,\n        mutation,\n      });\n\n      var variables = {input: ''};\n      var expectedMutationQuery = filterGeneratedFields(\n          getNodeWithoutSource(Relay.QL`\n          mutation {\n            feedbackLike(input:$input) {\n              ${Relay.QL`\n                fragment on FeedbackLikeResponsePayload {\n                  clientMutationId,\n                  feedback {\n                    doesViewerLike,\n                    id,\n                    likers {\n                      count,\n                    },\n                  }\n                }\n              `},\n            }\n          }\n        `, variables)\n      );\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n  });\n\n  describe('query', () => {\n    it('creates a query for RANGE_ADD', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue([getNode(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `)]);\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source,\n          },\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var edgeName = 'feedbackCommentEdge';\n      var rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n      };\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_ADD,\n          parentName,\n          parentID,\n          connectionName,\n          edgeName,\n          rangeBehaviors,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentCreate(input:$input)}`;\n      var mutationName = 'CommentAddMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = filterGeneratedFields(\n        getNodeWithoutSource(Relay.QL`\n          mutation {\n            commentCreate(input:$input) {\n              clientMutationId,\n              ... on CommentCreateResponsePayload {\n                feedback {\n                  ... on Feedback {\n                    id\n                  }\n                }\n                feedbackCommentEdge {\n                  __typename\n                  cursor,\n                  node {\n                    body {\n                      text\n                    },\n                    id\n                  },\n                  source{\n                    id\n                  }\n                }\n              }\n            }\n          }\n        `, variables)\n      );\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for NODE_DELETE', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          }\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var deletedIDFieldName = 'deletedCommentId';\n      var configs = [\n        {\n          type: RelayMutationType.NODE_DELETE,\n          parentName,\n          parentID,\n          connectionName,\n          deletedIDFieldName,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentDelete(input:$input)}`;\n      var mutationName = 'CommentDeleteMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            clientMutationId,\n            deletedCommentId,\n            ${Relay.QL`\n              fragment on CommentDeleteResponsePayload {\n                feedback {\n                  id\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for RANGE_DELETE with a shallow deleted field', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentDeleteResponsePayload {\n          feedback {\n            comments,\n            topLevelComments\n          }\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var deletedIDFieldName = 'deletedCommentId';\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_DELETE,\n          parentName,\n          parentID,\n          connectionName,\n          deletedIDFieldName,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentDelete(input:$input)}`;\n      var mutationName = 'CommentDeleteMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          commentDelete(input:$input) {\n            clientMutationId,\n            deletedCommentId,\n            ${Relay.QL`\n              fragment on CommentDeleteResponsePayload {\n                feedback {\n                  id\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for RANGE_DELETE with a deep deleted field', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Actor {\n          friends(first: \"10\") {\n            edges {\n              node {\n                name\n              }\n            }\n          }\n        }\n      `));\n      const fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on UnfriendResponsePayload {\n          actor {\n            friends\n          }\n          clientMutationId\n        }\n      `);\n      const configs = [\n        {\n          type: RelayMutationType.RANGE_DELETE,\n          parentName: 'actor',\n          parentID: '123',\n          connectionName: 'friends',\n          deletedIDFieldName: ['formerFriend'],\n          pathToConnection: ['actor', 'friends'],\n        },\n      ];\n\n      const mutation = Relay.QL`mutation{ unfriend(input: $input) }`;\n      const mutationName = 'UnfriendMutation';\n      const variables = {input: ''};\n      const query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      const expectedConcreteNode = Relay.QL`\n        mutation {\n          unfriend(input: $input) {\n            clientMutationId,\n            formerFriend {\n              id\n            }\n            ${Relay.QL`\n              fragment on UnfriendResponsePayload {\n                actor {\n                  id\n                }\n              }\n            `},\n          }\n        }\n      `;\n      expect(query).toEqualQueryNode(\n        getNodeWithoutSource(expectedConcreteNode, variables)\n      );\n    });\n\n    it('creates a query for FIELDS_CHANGE', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          likers,\n          url\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on FeedbackLikeResponsePayload {\n          feedback {\n            doesViewerLike,\n            likers\n          }\n        }\n      `);\n      var fieldIDs = {\n        feedback: '123',\n      };\n      var configs = [\n        {\n          type: RelayMutationType.FIELDS_CHANGE,\n          fieldIDs,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{feedbackLike(input:$input)}`;\n      var mutationName = 'FeedbackLikeMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          feedbackLike(input:$input) {\n            clientMutationId,\n            ${Relay.QL`\n              fragment on FeedbackLikeResponsePayload {\n                feedback {\n                  id,\n                  likers\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query with additional required fragments', () => {\n      tracker.getTrackedChildrenForID.mockReturnValue([getNode(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          }\n        }\n      `)]);\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source,\n          },\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var edgeName = 'feedbackCommentEdge';\n      var rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n      };\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_ADD,\n          parentName,\n          parentID,\n          connectionName,\n          edgeName,\n          rangeBehaviors,\n        },\n        {\n          type: RelayMutationType.REQUIRED_CHILDREN,\n          children: [Relay.QL`\n            fragment on CommentCreateResponsePayload {\n              feedback {\n                doesViewerLike,\n              },\n            }\n          `],\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentCreate(input:$input)}`;\n      var mutationName = 'CommentAddMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = filterGeneratedFields(\n        getNodeWithoutSource(Relay.QL`\n          mutation {\n            commentCreate(input:$input) {\n              clientMutationId,\n              ... on CommentCreateResponsePayload {\n                feedback {\n                  ... on Feedback {\n                    id\n                  }\n                }\n                feedbackCommentEdge {\n                  __typename\n                  cursor,\n                  node {\n                    body {\n                      text\n                    },\n                    id\n                  },\n                  source {\n                    id\n                  }\n                }\n              }\n              ... on CommentCreateResponsePayload {\n                feedback {\n                  doesViewerLike\n                  id\n                },\n              }\n            }\n          }\n        `, variables)\n      );\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('creates a query for RANGE_ADD and FIELDS_CHANGE', () => {\n      // Fictitious mutation that does multiple things\n      tracker.getTrackedChildrenForID.mockReturnValue(getNodeChildren(Relay.QL`\n        fragment on Feedback {\n          comments(first:\"10\") {\n            edges {\n              node {\n                body {\n                  text\n                }\n              }\n            }\n          },\n          likers,\n          url\n        }\n      `));\n      var fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on CommentCreateResponsePayload {\n          feedback {\n            comments,\n            doesViewerLike,\n            likers\n          },\n          comment,\n          feedbackCommentEdge {\n            cursor,\n            node,\n            source,\n          },\n        }\n      `);\n      var parentName = 'feedback';\n      var parentID = '123';\n      var connectionName = 'comments';\n      var edgeName = 'feedbackCommentEdge';\n      var rangeBehaviors = {\n        '': GraphQLMutatorConstants.PREPEND,\n      };\n      var fieldIDs = {\n        feedback: '123',\n      };\n      var configs = [\n        {\n          type: RelayMutationType.RANGE_ADD,\n          parentName,\n          parentID,\n          connectionName,\n          edgeName,\n          rangeBehaviors,\n        },\n        {\n          type: RelayMutationType.FIELDS_CHANGE,\n          fieldIDs,\n        },\n      ];\n\n      var mutation = Relay.QL`mutation{commentCreate(input:$input)}`;\n      var mutationName = 'CommentAddAndLikeMutation';\n      var variables = {input: ''};\n      var query = RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      });\n\n      var expectedMutationQuery = getNodeWithoutSource(Relay.QL`\n        mutation {\n          commentCreate(input:$input) {\n            clientMutationId,\n            ${Relay.QL`\n              fragment on CommentCreateResponsePayload {\n                feedback {\n                  id,\n                  likers,\n                },\n                feedbackCommentEdge {\n                  __typename\n                  cursor,\n                  node {\n                    body {\n                      text\n                    },\n                    id\n                  },\n                  source {\n                    id\n                  }\n                }\n              }\n            `},\n            ${Relay.QL`\n              fragment on CommentCreateResponsePayload {\n                feedback {\n                  comments(first:\"10\") {\n                    edges {\n                      cursor,\n                      node {\n                        body {\n                          text\n                        },\n                        id\n                      }\n                    },\n                    pageInfo {\n                      hasNextPage,\n                      hasPreviousPage\n                    }\n                  },\n                  id,\n                  likers,\n                }\n              }\n            `},\n          }\n        }\n      `, variables);\n\n      expect(query)\n        .toEqualQueryNode(expectedMutationQuery);\n    });\n\n    it('complains about unknown config types', () => {\n      const fatQuery = fromGraphQL.Fragment(Relay.QL`\n        fragment on UnfriendResponsePayload {\n          clientMutationId\n        }\n      `);\n      const configs = [\n        {\n          type: 'COSMIC_RAY_BIT_FLIP',\n        },\n      ];\n\n      const mutation = Relay.QL`mutation{ unfriend(input: $input) }`;\n      const mutationName = 'UnfriendMutation';\n      expect(() => RelayMutationQuery.buildQuery({\n        tracker,\n        fatQuery,\n        configs,\n        mutationName,\n        mutation,\n      })).toFailInvariant(\n        'RelayMutationQuery: Unrecognized config key `COSMIC_RAY_BIT_FLIP` ' +\n        'for `UnfriendMutation`.'\n      );\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__tests__/RelayMutationQuery-test.js"}},"/Users/cpojer/Projects/relay/src/mutation/__tests__/RelayMutation-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayMutation');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst buildRQL = require('buildRQL');\n\ndescribe('RelayMutation', function() {\n  let MockMutation;\n  let initialVariables;\n  let mockBarPointer;\n  let mockFooPointer;\n  let mockRoute;\n\n  const {getNode, getPointer} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    initialVariables = {isRelative: false};\n\n    var makeMockMutation = () => {\n      class MockMutationClass extends Relay.Mutation {}\n      MockMutationClass.fragments = {\n        foo: () => Relay.QL`\n          fragment on Comment {\n            url(relative: $isRelative)\n          }\n        `,\n        bar: () => Relay.QL`\n          fragment on Node {\n            id,\n          }\n        `,\n      };\n      MockMutationClass.initialVariables = initialVariables;\n      return MockMutationClass;\n    };\n    MockMutation = makeMockMutation();\n\n    var mockFooRequiredFragment =\n      MockMutation.getFragment('foo').getFragment({});\n    var mockBarRequiredFragment =\n      MockMutation.getFragment('bar').getFragment({});\n    mockFooPointer = getPointer('foo', getNode(mockFooRequiredFragment));\n    mockBarPointer = getPointer('bar', getNode(mockBarRequiredFragment));\n\n    // RelayMetaRoute.get(...)\n    mockRoute = {name: '$RelayMutation_MockMutationClass'};\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('resolves props', () => {\n    /* eslint-disable no-new */\n    new MockMutation({\n      bar: mockBarPointer,\n      foo: mockFooPointer,\n    });\n    /* eslint-enable no-new */\n    const fooFragment = RelayQuery.Fragment.create(\n      buildRQL.Fragment(MockMutation.fragments.foo, initialVariables),\n      mockRoute,\n      initialVariables\n    );\n    const barFragment = RelayQuery.Fragment.create(\n      buildRQL.Fragment(MockMutation.fragments.bar, initialVariables),\n      mockRoute,\n      initialVariables\n    );\n    expect(Relay.Store.read.mock.calls).toEqual([\n      [/* fragment */fooFragment, /* dataID */'foo'],\n      [/* fragment */barFragment, /* dataID */'bar'],\n    ]);\n  });\n\n  it('throws if mutation defines invalid `Relay.QL` fragment', () => {\n    class BadMutation extends Relay.Mutation {}\n    BadMutation.fragments = {\n      foo: () => Relay.QL`query{node(id:\"123\"){id}}`,\n    };\n    var badFragmentReference = BadMutation.getFragment('foo');\n    expect(() => {\n      badFragmentReference.getFragment();\n    }).toFailInvariant(\n      'Relay.QL defined on mutation `BadMutation` named `foo` is not a valid ' +\n      'fragment. A typical fragment is defined using: ' +\n      'Relay.QL`fragment on Type {...}`'\n    );\n  });\n});\n","dependencies":["configureForRelayOSS","Relay","RelayQuery","RelayTestUtils","buildRQL"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayMutation');\n\nconst Relay = require('Relay');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst buildRQL = require('buildRQL');\n\ndescribe('RelayMutation', function() {\n  let MockMutation;\n  let initialVariables;\n  let mockBarPointer;\n  let mockFooPointer;\n  let mockRoute;\n\n  const {getNode, getPointer} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    initialVariables = {isRelative: false};\n\n    var makeMockMutation = () => {\n      class MockMutationClass extends Relay.Mutation {}\n      MockMutationClass.fragments = {\n        foo: () => Relay.QL`\n          fragment on Comment {\n            url(relative: $isRelative)\n          }\n        `,\n        bar: () => Relay.QL`\n          fragment on Node {\n            id,\n          }\n        `,\n      };\n      MockMutationClass.initialVariables = initialVariables;\n      return MockMutationClass;\n    };\n    MockMutation = makeMockMutation();\n\n    var mockFooRequiredFragment =\n      MockMutation.getFragment('foo').getFragment({});\n    var mockBarRequiredFragment =\n      MockMutation.getFragment('bar').getFragment({});\n    mockFooPointer = getPointer('foo', getNode(mockFooRequiredFragment));\n    mockBarPointer = getPointer('bar', getNode(mockBarRequiredFragment));\n\n    // RelayMetaRoute.get(...)\n    mockRoute = {name: '$RelayMutation_MockMutationClass'};\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('resolves props', () => {\n    /* eslint-disable no-new */\n    new MockMutation({\n      bar: mockBarPointer,\n      foo: mockFooPointer,\n    });\n    /* eslint-enable no-new */\n    const fooFragment = RelayQuery.Fragment.create(\n      buildRQL.Fragment(MockMutation.fragments.foo, initialVariables),\n      mockRoute,\n      initialVariables\n    );\n    const barFragment = RelayQuery.Fragment.create(\n      buildRQL.Fragment(MockMutation.fragments.bar, initialVariables),\n      mockRoute,\n      initialVariables\n    );\n    expect(Relay.Store.read.mock.calls).toEqual([\n      [/* fragment */fooFragment, /* dataID */'foo'],\n      [/* fragment */barFragment, /* dataID */'bar'],\n    ]);\n  });\n\n  it('throws if mutation defines invalid `Relay.QL` fragment', () => {\n    class BadMutation extends Relay.Mutation {}\n    BadMutation.fragments = {\n      foo: () => Relay.QL`query{node(id:\"123\"){id}}`,\n    };\n    var badFragmentReference = BadMutation.getFragment('foo');\n    expect(() => {\n      badFragmentReference.getFragment();\n    }).toFailInvariant(\n      'Relay.QL defined on mutation `BadMutation` named `foo` is not a valid ' +\n      'fragment. A typical fragment is defined using: ' +\n      'Relay.QL`fragment on Type {...}`'\n    );\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__tests__/RelayMutation-test.js"}},"/Users/cpojer/Projects/relay/src/mutation/__tests__/rangeOperationToMetadataKey-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst rangeOperationToMetadataKey = require('rangeOperationToMetadataKey');\n\ndescribe('rangeOperationToMetadataKey', () => {\n  it('maps from developer-friendly name to internal metadata key name', () => {\n    expect(rangeOperationToMetadataKey).toEqual({\n      append: '__rangeOperationAppend__',\n      prepend: '__rangeOperationPrepend__',\n      remove: '__rangeOperationRemove__',\n    });\n  });\n\n  it('is frozen', () => {\n    expect(Object.isFrozen(rangeOperationToMetadataKey)).toBe(true);\n  });\n});\n","dependencies":["rangeOperationToMetadataKey"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst rangeOperationToMetadataKey = require('rangeOperationToMetadataKey');\n\ndescribe('rangeOperationToMetadataKey', () => {\n  it('maps from developer-friendly name to internal metadata key name', () => {\n    expect(rangeOperationToMetadataKey).toEqual({\n      append: '__rangeOperationAppend__',\n      prepend: '__rangeOperationPrepend__',\n      remove: '__rangeOperationRemove__',\n    });\n  });\n\n  it('is frozen', () => {\n    expect(Object.isFrozen(rangeOperationToMetadataKey)).toBe(true);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/mutation/__tests__/rangeOperationToMetadataKey-test.js"}},"/Users/cpojer/Projects/relay/src/legacy/mutation/GraphQLMutatorConstants.js":{"metadata":{"mtime":1455679338000},"data":{"name":"GraphQLMutatorConstants","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLMutatorConstants\n * @typechecks\n */\n\n'use strict';\n\nvar GraphQLMutatorConstants = {\n  APPEND: 'append',\n  PREPEND: 'prepend',\n  REMOVE: 'remove',\n\n  NODE_DELETE_HANDLER: 'node_delete',\n  RANGE_ADD_HANDLER: 'range_add',\n  RANGE_DELETE_HANDLER: 'range_delete',\n\n  HANDLER_TYPES: {},\n\n  OPTIMISTIC_UPDATE: 'optimistic',\n  SERVER_UPDATE: 'server',\n  POLLER_UPDATE: 'poller',\n\n  UPDATE_TYPES: {},\n\n  RANGE_OPERATIONS: {},\n};\n\nGraphQLMutatorConstants.HANDLER_TYPES\n  [GraphQLMutatorConstants.NODE_DELETE_HANDLER] = true;\nGraphQLMutatorConstants.HANDLER_TYPES\n  [GraphQLMutatorConstants.RANGE_ADD_HANDLER] = true;\nGraphQLMutatorConstants.HANDLER_TYPES\n  [GraphQLMutatorConstants.RANGE_DELETE_HANDLER] = true;\n\nGraphQLMutatorConstants.UPDATE_TYPES\n  [GraphQLMutatorConstants.OPTIMISTIC_UPDATE] = true;\nGraphQLMutatorConstants.UPDATE_TYPES\n  [GraphQLMutatorConstants.SERVER_UPDATE] = true;\nGraphQLMutatorConstants.UPDATE_TYPES\n  [GraphQLMutatorConstants.POLLER_UPDATE] = true;\n\nGraphQLMutatorConstants.RANGE_OPERATIONS\n  [GraphQLMutatorConstants.APPEND] = true;\nGraphQLMutatorConstants.RANGE_OPERATIONS\n  [GraphQLMutatorConstants.PREPEND] = true;\nGraphQLMutatorConstants.RANGE_OPERATIONS\n  [GraphQLMutatorConstants.REMOVE] = true;\n\nmodule.exports = GraphQLMutatorConstants;\n","dependencies":["GraphQLMutatorConstants"],"id":"GraphQLMutatorConstants","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLMutatorConstants\n * @typechecks\n */\n\n'use strict';\n\nvar GraphQLMutatorConstants = {\n  APPEND: 'append',\n  PREPEND: 'prepend',\n  REMOVE: 'remove',\n\n  NODE_DELETE_HANDLER: 'node_delete',\n  RANGE_ADD_HANDLER: 'range_add',\n  RANGE_DELETE_HANDLER: 'range_delete',\n\n  HANDLER_TYPES: {},\n\n  OPTIMISTIC_UPDATE: 'optimistic',\n  SERVER_UPDATE: 'server',\n  POLLER_UPDATE: 'poller',\n\n  UPDATE_TYPES: {},\n\n  RANGE_OPERATIONS: {},\n};\n\nGraphQLMutatorConstants.HANDLER_TYPES\n  [GraphQLMutatorConstants.NODE_DELETE_HANDLER] = true;\nGraphQLMutatorConstants.HANDLER_TYPES\n  [GraphQLMutatorConstants.RANGE_ADD_HANDLER] = true;\nGraphQLMutatorConstants.HANDLER_TYPES\n  [GraphQLMutatorConstants.RANGE_DELETE_HANDLER] = true;\n\nGraphQLMutatorConstants.UPDATE_TYPES\n  [GraphQLMutatorConstants.OPTIMISTIC_UPDATE] = true;\nGraphQLMutatorConstants.UPDATE_TYPES\n  [GraphQLMutatorConstants.SERVER_UPDATE] = true;\nGraphQLMutatorConstants.UPDATE_TYPES\n  [GraphQLMutatorConstants.POLLER_UPDATE] = true;\n\nGraphQLMutatorConstants.RANGE_OPERATIONS\n  [GraphQLMutatorConstants.APPEND] = true;\nGraphQLMutatorConstants.RANGE_OPERATIONS\n  [GraphQLMutatorConstants.PREPEND] = true;\nGraphQLMutatorConstants.RANGE_OPERATIONS\n  [GraphQLMutatorConstants.REMOVE] = true;\n\nmodule.exports = GraphQLMutatorConstants;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/recycleNodesInto.js":{"metadata":{"mtime":1456103379000},"data":{"name":"recycleNodesInto","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule recycleNodesInto\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * Recycles subtrees from `prevData` by replacing equal subtrees in `nextData`.\n */\nfunction recycleNodesInto<T>(prevData: T, nextData: T): T {\n  if (typeof prevData !== 'object' || !prevData ||\n      typeof nextData !== 'object' || !nextData) {\n    return nextData;\n  }\n  var canRecycle = false;\n  var isPrevArray = Array.isArray(prevData);\n  var isNextArray = Array.isArray(nextData);\n  if (isPrevArray && isNextArray) {\n    // Assign local variables to preserve Flow type refinement.\n    var prevArray = prevData;\n    var nextArray = nextData;\n    canRecycle =\n      nextArray.reduce((wasEqual, nextItem, ii) => {\n        nextArray[ii] = recycleNodesInto(prevArray[ii], nextItem);\n        return wasEqual && nextArray[ii] === prevArray[ii];\n      }, true) &&\n      prevArray.length === nextArray.length;\n  } else if (!isPrevArray && !isNextArray) {\n    // Assign local variables to preserve Flow type refinement.\n    var prevObject = prevData;\n    var nextObject = nextData;\n    var prevKeys = Object.keys(prevObject);\n    var nextKeys = Object.keys(nextObject);\n    canRecycle =\n      nextKeys.reduce((wasEqual, key) => {\n        var nextValue = nextObject[key];\n        nextObject[key] = recycleNodesInto(prevObject[key], nextValue);\n        return wasEqual && nextObject[key] === prevObject[key];\n      }, true) &&\n      prevKeys.length === nextKeys.length;\n  }\n  return canRecycle ? prevData : nextData;\n}\n\nmodule.exports = recycleNodesInto;\n","dependencies":["recycleNodesInto"],"id":"recycleNodesInto","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule recycleNodesInto\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * Recycles subtrees from `prevData` by replacing equal subtrees in `nextData`.\n */\nfunction recycleNodesInto<T>(prevData: T, nextData: T): T {\n  if (typeof prevData !== 'object' || !prevData ||\n      typeof nextData !== 'object' || !nextData) {\n    return nextData;\n  }\n  var canRecycle = false;\n  var isPrevArray = Array.isArray(prevData);\n  var isNextArray = Array.isArray(nextData);\n  if (isPrevArray && isNextArray) {\n    // Assign local variables to preserve Flow type refinement.\n    var prevArray = prevData;\n    var nextArray = nextData;\n    canRecycle =\n      nextArray.reduce((wasEqual, nextItem, ii) => {\n        nextArray[ii] = recycleNodesInto(prevArray[ii], nextItem);\n        return wasEqual && nextArray[ii] === prevArray[ii];\n      }, true) &&\n      prevArray.length === nextArray.length;\n  } else if (!isPrevArray && !isNextArray) {\n    // Assign local variables to preserve Flow type refinement.\n    var prevObject = prevData;\n    var nextObject = nextData;\n    var prevKeys = Object.keys(prevObject);\n    var nextKeys = Object.keys(nextObject);\n    canRecycle =\n      nextKeys.reduce((wasEqual, key) => {\n        var nextValue = nextObject[key];\n        nextObject[key] = recycleNodesInto(prevObject[key], nextValue);\n        return wasEqual && nextObject[key] === prevObject[key];\n      }, true) &&\n      prevKeys.length === nextKeys.length;\n  }\n  return canRecycle ? prevData : nextData;\n}\n\nmodule.exports = recycleNodesInto;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/GraphQLStoreRangeUtils.js":{"metadata":{"mtime":1455679338000},"data":{"name":"GraphQLStoreRangeUtils","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLStoreRangeUtils\n * @typechecks\n */\n\n'use strict';\n\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\n\n/**\n * Utilities used by GraphQLStore for storing ranges\n *\n * GraphQLStore stores all of the parts of a range in a single GraphQLRange\n * object. For example, `node(4808495){friends.first(5){id,name}}` might be\n * stored similar to this (pseudo-code):\n *\n *   \"4808495\": {\n *     \"friends\": { __dataID__: \"client:1\" }\n *   },\n *   \"client:1\": {\n *     \"nodes\": new GraphQLRange(...) // all friends, not just the first 5\n *   }\n *\n * and when that query is run, the store would return a result pointing at\n * a specific part of the range, encoded into the data ID:\n *\n * {\n *   \"4808495\": {\n *     \"friends\": { __dataID__: \"client:1_first(5)\" }\n *   }\n * }\n *\n * That \"client:1_first(5)\" ID can then be used to query for the first 5\n * friends.\n *\n * @internal\n */\nclass GraphQLStoreRangeUtils {\n  constructor() {\n    this._rangeData = {};\n    this._rangeDataKeyMap = {};\n  }\n\n  /**\n   * Returns a token that can be parsed using parseRangeClientID to recover\n   * the attributes needed to retrieve the corresponding items from a\n   * GraphQLRange.\n   *\n   * @param {array<*>} calls\n   * @param {object} callValues\n   * @param {string} dataID\n   * @return {string}\n   */\n  getClientIDForRangeWithID(calls, callValues, dataID) {\n    var callsAsString = callsFromGraphQL(calls, callValues)\n      .map(call => serializeRelayQueryCall(call).substring(1))\n      .join(',');\n    var key = dataID + '_' + callsAsString;\n    var edge = this._rangeData[key];\n    if (!edge) {\n      this._rangeData[key] = {\n        dataID: dataID,\n        calls: calls,\n        callValues: callValues,\n      };\n      let rangeDataKeys = this._rangeDataKeyMap[dataID];\n      if (!rangeDataKeys) {\n        this._rangeDataKeyMap[dataID] = rangeDataKeys = [];\n      }\n      rangeDataKeys.push(key);\n    }\n    return key;\n  }\n\n  /**\n   * Parses an ID back into its data ID and calls\n   *\n   * @param {string} rangeSpecificClientID\n   * @return {?object}\n   */\n  parseRangeClientID(rangeSpecificClientID) {\n    return this._rangeData[rangeSpecificClientID] || null;\n  }\n\n  /**\n   * If given the client id for a range view, returns the canonical client id\n   * for the entire range. e.g. converts \"client:1_first(5)\" to \"client:1\".\n   * Otherwise returns the input.\n   *\n   * @param {string} dataID\n   * @return {string}\n   */\n  getCanonicalClientID(dataID) {\n    return this._rangeData[dataID] ? this._rangeData[dataID].dataID : dataID;\n  }\n\n  removeRecord(dataID) {\n    const rangeDataKeys = this._rangeDataKeyMap[dataID];\n    if (rangeDataKeys) {\n      rangeDataKeys.forEach(key => {\n        delete this._rangeData[key];\n      });\n      delete this._rangeDataKeyMap[dataID];\n    }\n  }\n}\n\nmodule.exports = GraphQLStoreRangeUtils;\n","dependencies":["callsFromGraphQL","serializeRelayQueryCall","GraphQLStoreRangeUtils"],"id":"GraphQLStoreRangeUtils","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLStoreRangeUtils\n * @typechecks\n */\n\n'use strict';\n\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\n\n/**\n * Utilities used by GraphQLStore for storing ranges\n *\n * GraphQLStore stores all of the parts of a range in a single GraphQLRange\n * object. For example, `node(4808495){friends.first(5){id,name}}` might be\n * stored similar to this (pseudo-code):\n *\n *   \"4808495\": {\n *     \"friends\": { __dataID__: \"client:1\" }\n *   },\n *   \"client:1\": {\n *     \"nodes\": new GraphQLRange(...) // all friends, not just the first 5\n *   }\n *\n * and when that query is run, the store would return a result pointing at\n * a specific part of the range, encoded into the data ID:\n *\n * {\n *   \"4808495\": {\n *     \"friends\": { __dataID__: \"client:1_first(5)\" }\n *   }\n * }\n *\n * That \"client:1_first(5)\" ID can then be used to query for the first 5\n * friends.\n *\n * @internal\n */\nclass GraphQLStoreRangeUtils {\n  constructor() {\n    this._rangeData = {};\n    this._rangeDataKeyMap = {};\n  }\n\n  /**\n   * Returns a token that can be parsed using parseRangeClientID to recover\n   * the attributes needed to retrieve the corresponding items from a\n   * GraphQLRange.\n   *\n   * @param {array<*>} calls\n   * @param {object} callValues\n   * @param {string} dataID\n   * @return {string}\n   */\n  getClientIDForRangeWithID(calls, callValues, dataID) {\n    var callsAsString = callsFromGraphQL(calls, callValues)\n      .map(call => serializeRelayQueryCall(call).substring(1))\n      .join(',');\n    var key = dataID + '_' + callsAsString;\n    var edge = this._rangeData[key];\n    if (!edge) {\n      this._rangeData[key] = {\n        dataID: dataID,\n        calls: calls,\n        callValues: callValues,\n      };\n      let rangeDataKeys = this._rangeDataKeyMap[dataID];\n      if (!rangeDataKeys) {\n        this._rangeDataKeyMap[dataID] = rangeDataKeys = [];\n      }\n      rangeDataKeys.push(key);\n    }\n    return key;\n  }\n\n  /**\n   * Parses an ID back into its data ID and calls\n   *\n   * @param {string} rangeSpecificClientID\n   * @return {?object}\n   */\n  parseRangeClientID(rangeSpecificClientID) {\n    return this._rangeData[rangeSpecificClientID] || null;\n  }\n\n  /**\n   * If given the client id for a range view, returns the canonical client id\n   * for the entire range. e.g. converts \"client:1_first(5)\" to \"client:1\".\n   * Otherwise returns the input.\n   *\n   * @param {string} dataID\n   * @return {string}\n   */\n  getCanonicalClientID(dataID) {\n    return this._rangeData[dataID] ? this._rangeData[dataID].dataID : dataID;\n  }\n\n  removeRecord(dataID) {\n    const rangeDataKeys = this._rangeDataKeyMap[dataID];\n    if (rangeDataKeys) {\n      rangeDataKeys.forEach(key => {\n        delete this._rangeData[key];\n      });\n      delete this._rangeDataKeyMap[dataID];\n    }\n  }\n}\n\nmodule.exports = GraphQLStoreRangeUtils;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/GraphQLStoreQueryResolver.js":{"metadata":{"mtime":1456103379000},"data":{"name":"GraphQLStoreQueryResolver","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLStoreQueryResolver\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ChangeSubscription} from 'GraphQLStoreChangeEmitter';\nimport type RelayGarbageCollector from 'RelayGarbageCollector';\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nimport type RelayStoreData from 'RelayStoreData';\nimport type {StoreReaderData} from 'RelayTypes';\n\nconst readRelayQueryData = require('readRelayQueryData');\nconst recycleNodesInto = require('recycleNodesInto');\nconst warning = require('warning');\n\ntype DataIDSet = {[dataID: DataID]: any};\n\n/**\n * @internal\n *\n * Resolves data from fragment pointers.\n *\n * The supplied `callback` will be invoked whenever data returned by the last\n * invocation to `resolve` has changed.\n */\nclass GraphQLStoreQueryResolver {\n  _callback: Function;\n  _fragment: RelayQuery.Fragment;\n  _resolver: ?(\n    GraphQLStorePluralQueryResolver |\n    GraphQLStoreSingleQueryResolver\n  );\n  _storeData: RelayStoreData;\n\n  constructor(\n    storeData: RelayStoreData,\n    fragment: RelayQuery.Fragment,\n    callback: Function\n  ) {\n    this.dispose();\n    this._callback = callback;\n    this._fragment = fragment;\n    this._resolver = null;\n    this._storeData = storeData;\n  }\n\n  /**\n   * disposes the resolver's internal state such that future `resolve()` results\n   * will not be `===` to previous results, and unsubscribes any subscriptions.\n   */\n  dispose(): void {\n    if (this._resolver) {\n      this._resolver.dispose();\n    }\n  }\n\n  resolve(\n    fragment: RelayQuery.Fragment,\n    dataIDs: DataID | Array<DataID>\n  ): ?(StoreReaderData | Array<?StoreReaderData>) {\n    // Warn but don't crash if resolved with the wrong fragment.\n    if (this._fragment.getConcreteFragmentID() !==\n      fragment.getConcreteFragmentID()\n    ) {\n      warning(\n        false,\n        'GraphQLStoreQueryResolver: Expected `resolve` to be called with the ' +\n        'same concrete fragment as the constructor. The resolver was created ' +\n        'with fragment `%s` but resolved with fragment `%s`.',\n        this._fragment.getDebugName(),\n        fragment.getDebugName()\n      );\n    }\n    // Rather than crash on mismatched plurality of fragment/ids just warn\n    // and resolve as if the fragment's pluarity matched the format of the ids.\n    // Note that the inverse - attempt to resolve based on fragment plurarity -\n    // doesn't work because there's no way convert plural ids to singular w/o\n    // losing data.\n    if (Array.isArray(dataIDs)) {\n      // Fragment should be plural if data is pluaral.\n      warning(\n        fragment.isPlural(),\n        'GraphQLStoreQueryResolver: Expected id/fragment plurality to be ' +\n        'consistent: got plural ids for singular fragment `%s`.',\n        fragment.getDebugName()\n      );\n      let resolver = this._resolver;\n      if (resolver instanceof GraphQLStoreSingleQueryResolver) {\n        resolver.dispose();\n        resolver = null;\n      }\n      if (!resolver) {\n        resolver = new GraphQLStorePluralQueryResolver(\n          this._storeData,\n          this._callback\n        );\n      }\n      this._resolver = resolver;\n      return resolver.resolve(fragment, dataIDs);\n    } else {\n      // Fragment should be singular if data is singular.\n      warning(\n        !fragment.isPlural(),\n        'GraphQLStoreQueryResolver: Expected id/fragment plurality to be ' +\n        'consistent: got a singular id for plural fragment `%s`.',\n        fragment.getDebugName()\n      );\n      let resolver = this._resolver;\n      if (resolver instanceof GraphQLStorePluralQueryResolver) {\n        resolver.dispose();\n        resolver = null;\n      }\n      if (!resolver) {\n        resolver = new GraphQLStoreSingleQueryResolver(\n          this._storeData,\n          this._callback\n        );\n      }\n      this._resolver = resolver;\n      return resolver.resolve(fragment, dataIDs);\n    }\n  }\n}\n\n/**\n * Resolves plural fragments.\n */\nclass GraphQLStorePluralQueryResolver {\n  _callback: Function;\n  _resolvers: Array<GraphQLStoreSingleQueryResolver>;\n  _results: Array<?StoreReaderData>;\n  _storeData: RelayStoreData;\n\n  constructor(storeData: RelayStoreData, callback: Function) {\n    this.dispose();\n    this._callback = callback;\n    this._storeData = storeData;\n  }\n\n  dispose(): void {\n    if (this._resolvers) {\n      this._resolvers.forEach(resolver => resolver.dispose());\n    }\n    this._resolvers = [];\n    this._results = [];\n  }\n\n  /**\n   * Resolves a plural fragment pointer into an array of records.\n   *\n   * If the data, order, and number of resolved records has not changed since\n   * the last call to `resolve`, the same array will be returned. Otherwise, a\n   * new array will be returned.\n   */\n  resolve(\n    fragment: RelayQuery.Fragment,\n    nextIDs: Array<DataID>\n  ): Array<?StoreReaderData> {\n    var prevResults = this._results;\n    var nextResults;\n\n    var prevLength = prevResults.length;\n    var nextLength = nextIDs.length;\n    var resolvers = this._resolvers;\n\n    // Ensure that we have exactly `nextLength` resolvers.\n    while (resolvers.length < nextLength) {\n      resolvers.push(\n        new GraphQLStoreSingleQueryResolver(this._storeData, this._callback)\n      );\n    }\n    while (resolvers.length > nextLength) {\n      resolvers.pop().dispose();\n    }\n\n    // Allocate `nextResults` if and only if results have changed.\n    if (prevLength !== nextLength) {\n      nextResults = [];\n    }\n    for (var ii = 0; ii < nextLength; ii++) {\n      var nextResult = resolvers[ii].resolve(fragment, nextIDs[ii]);\n      if (nextResults || ii >= prevLength || nextResult !== prevResults[ii]) {\n        nextResults = nextResults || prevResults.slice(0, ii);\n        nextResults.push(nextResult);\n      }\n    }\n\n    if (nextResults) {\n      this._results = nextResults;\n    }\n    return this._results;\n  }\n}\n\n/**\n * Resolves non-plural fragments.\n */\nclass GraphQLStoreSingleQueryResolver {\n  _callback: Function;\n  _fragment: ?RelayQuery.Fragment;\n  _garbageCollector: ?RelayGarbageCollector;\n  _hasDataChanged: boolean;\n  _result: ?StoreReaderData;\n  _resultID: ?DataID;\n  _storeData: RelayStoreData;\n  _subscribedIDs: DataIDSet;\n  _subscription: ?ChangeSubscription;\n\n  constructor(storeData: RelayStoreData, callback: Function) {\n    this.dispose();\n    this._callback = callback;\n    this._garbageCollector = storeData.getGarbageCollector();\n    this._storeData = storeData;\n    this._subscribedIDs = {};\n  }\n\n  dispose(): void {\n    if (this._subscription) {\n      this._subscription.remove();\n    }\n    this._hasDataChanged = false;\n    this._fragment = null;\n    this._result = null;\n    this._resultID = null;\n    this._subscription = null;\n    this._updateGarbageCollectorSubscriptionCount({});\n    this._subscribedIDs = {};\n  }\n\n  /**\n   * Resolves data for a single fragment pointer.\n   */\n  resolve(\n    nextFragment: RelayQuery.Fragment,\n    nextID: DataID\n  ): ?StoreReaderData {\n    var prevFragment = this._fragment;\n    var prevID = this._resultID;\n    var nextResult;\n    var prevResult = this._result;\n    var subscribedIDs;\n\n    if (\n      prevFragment != null &&\n      prevID != null &&\n      this._getCanonicalID(prevID) === this._getCanonicalID(nextID)\n    ) {\n      if (\n        prevID !== nextID ||\n        this._hasDataChanged ||\n        !nextFragment.isEquivalent(prevFragment)\n      ) {\n        // same canonical ID,\n        // but the data, call(s), route, and/or variables have changed\n        [nextResult, subscribedIDs] = this._resolveFragment(\n          nextFragment,\n          nextID\n        );\n        nextResult = recycleNodesInto(prevResult, nextResult);\n      } else {\n        // same id, route, variables, and data\n        nextResult = prevResult;\n      }\n    } else {\n      // Pointer has a different ID or is/was fake data.\n      [nextResult, subscribedIDs] = this._resolveFragment(\n        nextFragment,\n        nextID\n      );\n    }\n\n    // update subscriptions whenever results change\n    if (prevResult !== nextResult) {\n      if (this._subscription) {\n        this._subscription.remove();\n        this._subscription = null;\n      }\n      if (subscribedIDs) {\n        // always subscribe to the root ID\n        subscribedIDs[nextID] = true;\n        var changeEmitter = this._storeData.getChangeEmitter();\n        this._subscription = changeEmitter.addListenerForIDs(\n          Object.keys(subscribedIDs),\n          this._handleChange.bind(this)\n        );\n        this._updateGarbageCollectorSubscriptionCount(subscribedIDs);\n        this._subscribedIDs = subscribedIDs;\n      }\n      this._resultID = nextID;\n      this._result = nextResult;\n    }\n\n    this._hasDataChanged = false;\n    this._fragment = nextFragment;\n\n    return this._result;\n  }\n\n  /**\n   * Ranges publish events for the entire range, not the specific view of that\n   * range. For example, if \"client:1\" is a range, the event is on \"client:1\",\n   * not \"client:1_first(5)\".\n   */\n  _getCanonicalID(id: DataID): DataID {\n    return this._storeData.getRangeData().getCanonicalClientID(id);\n  }\n\n  _handleChange(): void {\n    if (!this._hasDataChanged) {\n      this._hasDataChanged = true;\n      this._callback();\n    }\n  }\n\n  _resolveFragment(\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): [?StoreReaderData, DataIDSet] {\n    var {data, dataIDs} = readRelayQueryData(this._storeData, fragment, dataID);\n    return [data, dataIDs];\n  }\n\n  /**\n   * Updates bookkeeping about the number of subscribers on each record.\n   */\n  _updateGarbageCollectorSubscriptionCount(\n    nextDataIDs: {[dataID: DataID]: boolean},\n  ): void {\n    if (this._garbageCollector) {\n      const garbageCollector = this._garbageCollector;\n      const rangeData = this._storeData.getRangeData();\n      const prevDataIDs = this._subscribedIDs;\n\n      // Note: the same canonical ID may appear in both removed and added: in\n      // that case, it would have been:\n      // - previous step: canonical ID ref count was incremented\n      // - current step: canonical ID is incremented *and* decremented\n      // Note that the net ref count change is +1.\n      Object.keys(nextDataIDs).forEach(id => {\n        id = rangeData.getCanonicalClientID(id);\n        garbageCollector.incrementReferenceCount(id);\n      });\n      Object.keys(prevDataIDs).forEach(id => {\n        id = rangeData.getCanonicalClientID(id);\n        garbageCollector.decrementReferenceCount(id);\n      });\n    }\n  }\n}\n\nRelayProfiler.instrumentMethods(GraphQLStoreQueryResolver.prototype, {\n  resolve: 'GraphQLStoreQueryResolver.resolve',\n});\n\nmodule.exports = GraphQLStoreQueryResolver;\n","dependencies":["GraphQLStoreChangeEmitter","RelayGarbageCollector","RelayInternalTypes","RelayQuery","RelayStoreData","RelayTypes","RelayProfiler","readRelayQueryData","recycleNodesInto","warning","GraphQLStoreQueryResolver"],"id":"GraphQLStoreQueryResolver","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLStoreQueryResolver\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ChangeSubscription} from 'GraphQLStoreChangeEmitter';\nimport type RelayGarbageCollector from 'RelayGarbageCollector';\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nimport type RelayStoreData from 'RelayStoreData';\nimport type {StoreReaderData} from 'RelayTypes';\n\nconst readRelayQueryData = require('readRelayQueryData');\nconst recycleNodesInto = require('recycleNodesInto');\nconst warning = require('warning');\n\ntype DataIDSet = {[dataID: DataID]: any};\n\n/**\n * @internal\n *\n * Resolves data from fragment pointers.\n *\n * The supplied `callback` will be invoked whenever data returned by the last\n * invocation to `resolve` has changed.\n */\nclass GraphQLStoreQueryResolver {\n  _callback: Function;\n  _fragment: RelayQuery.Fragment;\n  _resolver: ?(\n    GraphQLStorePluralQueryResolver |\n    GraphQLStoreSingleQueryResolver\n  );\n  _storeData: RelayStoreData;\n\n  constructor(\n    storeData: RelayStoreData,\n    fragment: RelayQuery.Fragment,\n    callback: Function\n  ) {\n    this.dispose();\n    this._callback = callback;\n    this._fragment = fragment;\n    this._resolver = null;\n    this._storeData = storeData;\n  }\n\n  /**\n   * disposes the resolver's internal state such that future `resolve()` results\n   * will not be `===` to previous results, and unsubscribes any subscriptions.\n   */\n  dispose(): void {\n    if (this._resolver) {\n      this._resolver.dispose();\n    }\n  }\n\n  resolve(\n    fragment: RelayQuery.Fragment,\n    dataIDs: DataID | Array<DataID>\n  ): ?(StoreReaderData | Array<?StoreReaderData>) {\n    // Warn but don't crash if resolved with the wrong fragment.\n    if (this._fragment.getConcreteFragmentID() !==\n      fragment.getConcreteFragmentID()\n    ) {\n      warning(\n        false,\n        'GraphQLStoreQueryResolver: Expected `resolve` to be called with the ' +\n        'same concrete fragment as the constructor. The resolver was created ' +\n        'with fragment `%s` but resolved with fragment `%s`.',\n        this._fragment.getDebugName(),\n        fragment.getDebugName()\n      );\n    }\n    // Rather than crash on mismatched plurality of fragment/ids just warn\n    // and resolve as if the fragment's pluarity matched the format of the ids.\n    // Note that the inverse - attempt to resolve based on fragment plurarity -\n    // doesn't work because there's no way convert plural ids to singular w/o\n    // losing data.\n    if (Array.isArray(dataIDs)) {\n      // Fragment should be plural if data is pluaral.\n      warning(\n        fragment.isPlural(),\n        'GraphQLStoreQueryResolver: Expected id/fragment plurality to be ' +\n        'consistent: got plural ids for singular fragment `%s`.',\n        fragment.getDebugName()\n      );\n      let resolver = this._resolver;\n      if (resolver instanceof GraphQLStoreSingleQueryResolver) {\n        resolver.dispose();\n        resolver = null;\n      }\n      if (!resolver) {\n        resolver = new GraphQLStorePluralQueryResolver(\n          this._storeData,\n          this._callback\n        );\n      }\n      this._resolver = resolver;\n      return resolver.resolve(fragment, dataIDs);\n    } else {\n      // Fragment should be singular if data is singular.\n      warning(\n        !fragment.isPlural(),\n        'GraphQLStoreQueryResolver: Expected id/fragment plurality to be ' +\n        'consistent: got a singular id for plural fragment `%s`.',\n        fragment.getDebugName()\n      );\n      let resolver = this._resolver;\n      if (resolver instanceof GraphQLStorePluralQueryResolver) {\n        resolver.dispose();\n        resolver = null;\n      }\n      if (!resolver) {\n        resolver = new GraphQLStoreSingleQueryResolver(\n          this._storeData,\n          this._callback\n        );\n      }\n      this._resolver = resolver;\n      return resolver.resolve(fragment, dataIDs);\n    }\n  }\n}\n\n/**\n * Resolves plural fragments.\n */\nclass GraphQLStorePluralQueryResolver {\n  _callback: Function;\n  _resolvers: Array<GraphQLStoreSingleQueryResolver>;\n  _results: Array<?StoreReaderData>;\n  _storeData: RelayStoreData;\n\n  constructor(storeData: RelayStoreData, callback: Function) {\n    this.dispose();\n    this._callback = callback;\n    this._storeData = storeData;\n  }\n\n  dispose(): void {\n    if (this._resolvers) {\n      this._resolvers.forEach(resolver => resolver.dispose());\n    }\n    this._resolvers = [];\n    this._results = [];\n  }\n\n  /**\n   * Resolves a plural fragment pointer into an array of records.\n   *\n   * If the data, order, and number of resolved records has not changed since\n   * the last call to `resolve`, the same array will be returned. Otherwise, a\n   * new array will be returned.\n   */\n  resolve(\n    fragment: RelayQuery.Fragment,\n    nextIDs: Array<DataID>\n  ): Array<?StoreReaderData> {\n    var prevResults = this._results;\n    var nextResults;\n\n    var prevLength = prevResults.length;\n    var nextLength = nextIDs.length;\n    var resolvers = this._resolvers;\n\n    // Ensure that we have exactly `nextLength` resolvers.\n    while (resolvers.length < nextLength) {\n      resolvers.push(\n        new GraphQLStoreSingleQueryResolver(this._storeData, this._callback)\n      );\n    }\n    while (resolvers.length > nextLength) {\n      resolvers.pop().dispose();\n    }\n\n    // Allocate `nextResults` if and only if results have changed.\n    if (prevLength !== nextLength) {\n      nextResults = [];\n    }\n    for (var ii = 0; ii < nextLength; ii++) {\n      var nextResult = resolvers[ii].resolve(fragment, nextIDs[ii]);\n      if (nextResults || ii >= prevLength || nextResult !== prevResults[ii]) {\n        nextResults = nextResults || prevResults.slice(0, ii);\n        nextResults.push(nextResult);\n      }\n    }\n\n    if (nextResults) {\n      this._results = nextResults;\n    }\n    return this._results;\n  }\n}\n\n/**\n * Resolves non-plural fragments.\n */\nclass GraphQLStoreSingleQueryResolver {\n  _callback: Function;\n  _fragment: ?RelayQuery.Fragment;\n  _garbageCollector: ?RelayGarbageCollector;\n  _hasDataChanged: boolean;\n  _result: ?StoreReaderData;\n  _resultID: ?DataID;\n  _storeData: RelayStoreData;\n  _subscribedIDs: DataIDSet;\n  _subscription: ?ChangeSubscription;\n\n  constructor(storeData: RelayStoreData, callback: Function) {\n    this.dispose();\n    this._callback = callback;\n    this._garbageCollector = storeData.getGarbageCollector();\n    this._storeData = storeData;\n    this._subscribedIDs = {};\n  }\n\n  dispose(): void {\n    if (this._subscription) {\n      this._subscription.remove();\n    }\n    this._hasDataChanged = false;\n    this._fragment = null;\n    this._result = null;\n    this._resultID = null;\n    this._subscription = null;\n    this._updateGarbageCollectorSubscriptionCount({});\n    this._subscribedIDs = {};\n  }\n\n  /**\n   * Resolves data for a single fragment pointer.\n   */\n  resolve(\n    nextFragment: RelayQuery.Fragment,\n    nextID: DataID\n  ): ?StoreReaderData {\n    var prevFragment = this._fragment;\n    var prevID = this._resultID;\n    var nextResult;\n    var prevResult = this._result;\n    var subscribedIDs;\n\n    if (\n      prevFragment != null &&\n      prevID != null &&\n      this._getCanonicalID(prevID) === this._getCanonicalID(nextID)\n    ) {\n      if (\n        prevID !== nextID ||\n        this._hasDataChanged ||\n        !nextFragment.isEquivalent(prevFragment)\n      ) {\n        // same canonical ID,\n        // but the data, call(s), route, and/or variables have changed\n        [nextResult, subscribedIDs] = this._resolveFragment(\n          nextFragment,\n          nextID\n        );\n        nextResult = recycleNodesInto(prevResult, nextResult);\n      } else {\n        // same id, route, variables, and data\n        nextResult = prevResult;\n      }\n    } else {\n      // Pointer has a different ID or is/was fake data.\n      [nextResult, subscribedIDs] = this._resolveFragment(\n        nextFragment,\n        nextID\n      );\n    }\n\n    // update subscriptions whenever results change\n    if (prevResult !== nextResult) {\n      if (this._subscription) {\n        this._subscription.remove();\n        this._subscription = null;\n      }\n      if (subscribedIDs) {\n        // always subscribe to the root ID\n        subscribedIDs[nextID] = true;\n        var changeEmitter = this._storeData.getChangeEmitter();\n        this._subscription = changeEmitter.addListenerForIDs(\n          Object.keys(subscribedIDs),\n          this._handleChange.bind(this)\n        );\n        this._updateGarbageCollectorSubscriptionCount(subscribedIDs);\n        this._subscribedIDs = subscribedIDs;\n      }\n      this._resultID = nextID;\n      this._result = nextResult;\n    }\n\n    this._hasDataChanged = false;\n    this._fragment = nextFragment;\n\n    return this._result;\n  }\n\n  /**\n   * Ranges publish events for the entire range, not the specific view of that\n   * range. For example, if \"client:1\" is a range, the event is on \"client:1\",\n   * not \"client:1_first(5)\".\n   */\n  _getCanonicalID(id: DataID): DataID {\n    return this._storeData.getRangeData().getCanonicalClientID(id);\n  }\n\n  _handleChange(): void {\n    if (!this._hasDataChanged) {\n      this._hasDataChanged = true;\n      this._callback();\n    }\n  }\n\n  _resolveFragment(\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): [?StoreReaderData, DataIDSet] {\n    var {data, dataIDs} = readRelayQueryData(this._storeData, fragment, dataID);\n    return [data, dataIDs];\n  }\n\n  /**\n   * Updates bookkeeping about the number of subscribers on each record.\n   */\n  _updateGarbageCollectorSubscriptionCount(\n    nextDataIDs: {[dataID: DataID]: boolean},\n  ): void {\n    if (this._garbageCollector) {\n      const garbageCollector = this._garbageCollector;\n      const rangeData = this._storeData.getRangeData();\n      const prevDataIDs = this._subscribedIDs;\n\n      // Note: the same canonical ID may appear in both removed and added: in\n      // that case, it would have been:\n      // - previous step: canonical ID ref count was incremented\n      // - current step: canonical ID is incremented *and* decremented\n      // Note that the net ref count change is +1.\n      Object.keys(nextDataIDs).forEach(id => {\n        id = rangeData.getCanonicalClientID(id);\n        garbageCollector.incrementReferenceCount(id);\n      });\n      Object.keys(prevDataIDs).forEach(id => {\n        id = rangeData.getCanonicalClientID(id);\n        garbageCollector.decrementReferenceCount(id);\n      });\n    }\n  }\n}\n\nRelayProfiler.instrumentMethods(GraphQLStoreQueryResolver.prototype, {\n  resolve: 'GraphQLStoreQueryResolver.resolve',\n});\n\nmodule.exports = GraphQLStoreQueryResolver;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/GraphQLStoreChangeEmitter.js":{"metadata":{"mtime":1455679338000},"data":{"name":"GraphQLStoreChangeEmitter","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLStoreChangeEmitter\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst ErrorUtils = require('ErrorUtils');\nimport type GraphQLStoreRangeUtils from 'GraphQLStoreRangeUtils';\n\nconst resolveImmediate = require('resolveImmediate');\n\ntype BatchStrategy = (callback: Function) => void;\ntype SubscriptionCallback = () => void;\n\nexport type ChangeSubscription = {\n  remove: SubscriptionCallback;\n};\n\ntype Subscriber = {\n  callback: SubscriptionCallback,\n  subscribedIDs: Array<string>,\n};\n\n/**\n * Asynchronous change emitter for nodes stored in the Relay cache.\n *\n * Changes are produced by `RelayStoreData` after writing query and mutation\n * payloads into the store and consumed by `GraphQLStoreQueryResolver`, which\n * subscribes to all records that are part of an active query result set.\n *\n * @internal\n */\nclass GraphQLStoreChangeEmitter {\n  _batchUpdate: BatchStrategy;\n  _executingIDs: Object;\n  _rangeData: GraphQLStoreRangeUtils;\n  _scheduledIDs: ?Object;\n  _subscribers: Array<Subscriber>;\n\n  constructor(rangeData: GraphQLStoreRangeUtils) {\n    this._batchUpdate = callback => callback();\n    this._executingIDs = {};\n    this._rangeData = rangeData;\n    this._scheduledIDs = null;\n    this._subscribers = [];\n  }\n\n  addListenerForIDs(\n    ids: Array<string>,\n    callback: SubscriptionCallback\n  ): ChangeSubscription {\n    var subscribedIDs = ids.map(id => this._getBroadcastID(id));\n    var index = this._subscribers.length;\n    this._subscribers.push({subscribedIDs, callback});\n    return {\n      remove: () => {\n        delete this._subscribers[index];\n      },\n    };\n  }\n\n  broadcastChangeForID(id: string): void {\n    var scheduledIDs = this._scheduledIDs;\n    if (scheduledIDs == null) {\n      resolveImmediate(() => this._processBroadcasts());\n      scheduledIDs = this._scheduledIDs = {};\n    }\n    // Record index of the last subscriber so we do not later unintentionally\n    // invoke callbacks that were subscribed after this broadcast.\n    scheduledIDs[this._getBroadcastID(id)] = this._subscribers.length - 1;\n  }\n\n  injectBatchingStrategy(batchStrategy: BatchStrategy): void {\n    this._batchUpdate = batchStrategy;\n  }\n\n  _processBroadcasts(): void {\n    if (this._scheduledIDs) {\n      this._executingIDs = this._scheduledIDs;\n      this._scheduledIDs = null;\n      this._batchUpdate(() => this._processSubscribers());\n    }\n  }\n\n  /**\n   * Exposed for profiling reasons.\n   * @private\n   */\n  _processSubscribers(): void {\n    this._subscribers.forEach((subscriber, subscriberIndex) =>\n      this._processSubscriber(subscriber, subscriberIndex)\n    );\n  }\n\n  _processSubscriber(\n    {subscribedIDs, callback}: Subscriber,\n    subscriberIndex: number\n  ): void {\n    for (var broadcastID in this._executingIDs) {\n      if (this._executingIDs.hasOwnProperty(broadcastID)) {\n        var broadcastIndex = this._executingIDs[broadcastID];\n        if (broadcastIndex < subscriberIndex) {\n          // Callback was subscribed after this particular broadcast.\n          break;\n        }\n        if (subscribedIDs.indexOf(broadcastID) >= 0) {\n          ErrorUtils.applyWithGuard(\n            callback,\n            null,\n            null,\n            null,\n            'GraphQLStoreChangeEmitter'\n          );\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Ranges publish events for the entire range, not the specific view of that\n   * range. For example, if \"client:1\" is a range, the event is on \"client:1\",\n   * not \"client:1_first(5)\".\n   */\n  _getBroadcastID(id: string): string {\n    return this._rangeData.getCanonicalClientID(id);\n  }\n}\n\nmodule.exports = GraphQLStoreChangeEmitter;\n","dependencies":["GraphQLStoreRangeUtils","ErrorUtils","resolveImmediate","GraphQLStoreChangeEmitter"],"id":"GraphQLStoreChangeEmitter","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLStoreChangeEmitter\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst ErrorUtils = require('ErrorUtils');\nimport type GraphQLStoreRangeUtils from 'GraphQLStoreRangeUtils';\n\nconst resolveImmediate = require('resolveImmediate');\n\ntype BatchStrategy = (callback: Function) => void;\ntype SubscriptionCallback = () => void;\n\nexport type ChangeSubscription = {\n  remove: SubscriptionCallback;\n};\n\ntype Subscriber = {\n  callback: SubscriptionCallback,\n  subscribedIDs: Array<string>,\n};\n\n/**\n * Asynchronous change emitter for nodes stored in the Relay cache.\n *\n * Changes are produced by `RelayStoreData` after writing query and mutation\n * payloads into the store and consumed by `GraphQLStoreQueryResolver`, which\n * subscribes to all records that are part of an active query result set.\n *\n * @internal\n */\nclass GraphQLStoreChangeEmitter {\n  _batchUpdate: BatchStrategy;\n  _executingIDs: Object;\n  _rangeData: GraphQLStoreRangeUtils;\n  _scheduledIDs: ?Object;\n  _subscribers: Array<Subscriber>;\n\n  constructor(rangeData: GraphQLStoreRangeUtils) {\n    this._batchUpdate = callback => callback();\n    this._executingIDs = {};\n    this._rangeData = rangeData;\n    this._scheduledIDs = null;\n    this._subscribers = [];\n  }\n\n  addListenerForIDs(\n    ids: Array<string>,\n    callback: SubscriptionCallback\n  ): ChangeSubscription {\n    var subscribedIDs = ids.map(id => this._getBroadcastID(id));\n    var index = this._subscribers.length;\n    this._subscribers.push({subscribedIDs, callback});\n    return {\n      remove: () => {\n        delete this._subscribers[index];\n      },\n    };\n  }\n\n  broadcastChangeForID(id: string): void {\n    var scheduledIDs = this._scheduledIDs;\n    if (scheduledIDs == null) {\n      resolveImmediate(() => this._processBroadcasts());\n      scheduledIDs = this._scheduledIDs = {};\n    }\n    // Record index of the last subscriber so we do not later unintentionally\n    // invoke callbacks that were subscribed after this broadcast.\n    scheduledIDs[this._getBroadcastID(id)] = this._subscribers.length - 1;\n  }\n\n  injectBatchingStrategy(batchStrategy: BatchStrategy): void {\n    this._batchUpdate = batchStrategy;\n  }\n\n  _processBroadcasts(): void {\n    if (this._scheduledIDs) {\n      this._executingIDs = this._scheduledIDs;\n      this._scheduledIDs = null;\n      this._batchUpdate(() => this._processSubscribers());\n    }\n  }\n\n  /**\n   * Exposed for profiling reasons.\n   * @private\n   */\n  _processSubscribers(): void {\n    this._subscribers.forEach((subscriber, subscriberIndex) =>\n      this._processSubscriber(subscriber, subscriberIndex)\n    );\n  }\n\n  _processSubscriber(\n    {subscribedIDs, callback}: Subscriber,\n    subscriberIndex: number\n  ): void {\n    for (var broadcastID in this._executingIDs) {\n      if (this._executingIDs.hasOwnProperty(broadcastID)) {\n        var broadcastIndex = this._executingIDs[broadcastID];\n        if (broadcastIndex < subscriberIndex) {\n          // Callback was subscribed after this particular broadcast.\n          break;\n        }\n        if (subscribedIDs.indexOf(broadcastID) >= 0) {\n          ErrorUtils.applyWithGuard(\n            callback,\n            null,\n            null,\n            null,\n            'GraphQLStoreChangeEmitter'\n          );\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Ranges publish events for the entire range, not the specific view of that\n   * range. For example, if \"client:1\" is a range, the event is on \"client:1\",\n   * not \"client:1_first(5)\".\n   */\n  _getBroadcastID(id: string): string {\n    return this._rangeData.getCanonicalClientID(id);\n  }\n}\n\nmodule.exports = GraphQLStoreChangeEmitter;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/GraphQLSegment.js":{"metadata":{"mtime":1455679338000},"data":{"name":"GraphQLSegment","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLSegment\n * @typechecks\n */\n\n'use strict';\n\nconst RelayRecord = require('RelayRecord');\n\n/**\n * Represents one contiguous segment of edges within a `GraphQLRange`. Has\n * methods for adding/removing edges (`appendEdge`, `prependEdge`, `removeEdge`)\n * and working with cursors (`getFirstCursor`, `getLastCursor` etc)\n *\n * Edges are never actually deleted from segments; they are merely marked as\n * being deleted. As such, `GraphQLSegment` offers both a `getCount` method\n * (returning the number of non-deleted edges) and a `getLength` method (which\n * returns the total number, including deleted edges).\n *\n * Used mostly as an implementation detail internal to `GraphQLRange`.\n *\n * @internal\n */\nclass GraphQLSegment {\n  constructor() {\n    // We use a map rather than an array because indices can become negative\n    // when prepending.\n    this._indexToMetadataMap = {};\n\n    // We keep track of past indices to ensure we can delete them completely.\n    this._idToIndicesMap = {};\n    this._cursorToIndexMap = {};\n\n    this._count = 0;\n    this._minIndex = null;\n    this._maxIndex = null;\n  }\n\n  /**\n   * @param {string} cursor\n   * @return {?number}\n   */\n  _getIndexForCursor(cursor) {\n    return this._cursorToIndexMap[cursor];\n  }\n\n  /**\n   * @param {string} id\n   * @return {?number}\n   */\n  _getIndexForID(id) {\n    var indices = this._idToIndicesMap[id];\n    return indices && indices[0];\n  }\n\n  /**\n   * @return {?string} cursor for first non-deleted edge\n   */\n  getFirstCursor() {\n    if (this.getLength()) {\n      for (var ii = this._minIndex; ii <= this._maxIndex; ii++) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.cursor;\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {?string} cursor for last non-deleted edge\n   */\n  getLastCursor() {\n    if (this.getLength()) {\n      for (var ii = this._maxIndex; ii >= this._minIndex; ii--) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.cursor;\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {?string} id for first non-deleted edge\n   */\n  getFirstID() {\n    if (this.getLength()) {\n      for (var ii = this._minIndex; ii <= this._maxIndex; ii++) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.edgeID;\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {?string} id for last non-deleted edge\n   */\n  getLastID() {\n    if (this.getLength()) {\n      for (var ii = this._maxIndex; ii >= this._minIndex; ii--) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.edgeID;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @return {?object} Returns the not-deleted edge at index\n   */\n  _getEdgeAtIndex(index) {\n    var edge = this._indexToMetadataMap[index];\n    return edge && !edge.deleted ? edge : null;\n  }\n\n  /**\n   * Returns whether there is a non-deleted edge for id\n   * @param {string} id\n   * @return {boolean}\n   */\n  containsEdgeWithID(id) {\n    var index = this._getIndexForID(id);\n    if (index === undefined) {\n      return false;\n    }\n    return !!this._getEdgeAtIndex(index);\n  }\n\n  /**\n   * Returns whether there is a non-deleted edge for cursor\n   * @param {string} cursor\n   * @return {boolean}\n   */\n  containsEdgeWithCursor(cursor) {\n    var index = this._getIndexForCursor(cursor);\n    if (index === undefined) {\n      return false;\n    }\n    return !!this._getEdgeAtIndex(index);\n  }\n\n  /**\n   * Returns up to count number of ids and cursors that is after input cursor\n   * @param {number} count\n   * @param {?string} cursor\n   * @return {object} object with arrays of ids and cursors\n   */\n  getMetadataAfterCursor(count, cursor) {\n    if (!this.getLength()) {\n      return {\n        edgeIDs: [],\n        cursors: [],\n      };\n    }\n    var currentIndex = this._minIndex;\n    if (cursor) {\n      var index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return {\n          edgeIDs: [],\n          cursors: [],\n        };\n      }\n      currentIndex = index + 1;\n    }\n    var total = 0;\n    var edgeIDs = [];\n    var cursors = [];\n\n    while (currentIndex <= this._maxIndex && total < count) {\n      var metadata = this._indexToMetadataMap[currentIndex];\n      if (!metadata.deleted) {\n        edgeIDs.push(metadata.edgeID);\n        cursors.push(metadata.cursor);\n        total++;\n      }\n      currentIndex++;\n    }\n    return {\n      edgeIDs: edgeIDs,\n      cursors: cursors,\n    };\n  }\n\n  /**\n   * Returns up to count number of ids and cursors that is before index\n   * @param {number} count\n   * @param {?string} cursor\n   * @return {object} object with arrays of ids and cursors\n   */\n  getMetadataBeforeCursor(count, cursor) {\n    if (!this.getLength()) {\n      return {\n        edgeIDs: [],\n        cursors: [],\n      };\n    }\n    var currentIndex = this._maxIndex;\n    if (cursor) {\n      var index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return {\n          edgeIDs: [],\n          cursors: [],\n        };\n      }\n      currentIndex = index - 1;\n    }\n    var total = 0;\n    var edgeIDs = [];\n    var cursors = [];\n    while (currentIndex >= this._minIndex && total < count) {\n      var metadata = this._indexToMetadataMap[currentIndex];\n      if (!metadata.deleted) {\n        edgeIDs.push(metadata.edgeID);\n        cursors.push(metadata.cursor);\n        total++;\n      }\n      currentIndex--;\n    }\n\n    // Reverse edges because larger index were added first\n    return {\n      edgeIDs: edgeIDs.reverse(),\n      cursors: cursors.reverse(),\n    };\n  }\n\n  /**\n   * @param {object} edge\n   * @param {number} index\n   */\n  _addEdgeAtIndex(edge, index) {\n    var edgeID = RelayRecord.getDataID(edge);\n    var cursor = edge.cursor;\n\n    var idIndex = this._getIndexForID(edgeID);\n    // If the id is has an index and is not deleted\n    if (idIndex !== undefined && this._getEdgeAtIndex(idIndex)) {\n      console.warn(\n        'Attempted to add an ID already in GraphQLSegment: %s',\n        edgeID\n      );\n      return;\n    }\n\n    if (this.getLength() === 0) {\n      this._minIndex = index;\n      this._maxIndex = index;\n    } else if (this._minIndex == index + 1) {\n      this._minIndex = index;\n    } else if (this._maxIndex == index - 1) {\n      this._maxIndex = index;\n    } else {\n      console.warn(\n        `Attempted to add noncontiguous index to GraphQLSegment: ${index} to ` +\n        `(${this._minIndex}, ${this._maxIndex})`\n      );\n\n      return;\n    }\n\n    this._indexToMetadataMap[index] = {\n      edgeID: edgeID,\n      cursor: cursor,\n      deleted: false,\n    };\n    this._idToIndicesMap[edgeID] = this._idToIndicesMap[edgeID] || [];\n    this._idToIndicesMap[edgeID].unshift(index);\n    this._count++;\n\n    if (cursor) {\n      this._cursorToIndexMap[cursor] = index;\n    }\n  }\n\n  /**\n   * @param {object} edge should have cursor and a node with id\n   */\n  prependEdge(edge) {\n    this._addEdgeAtIndex(\n      edge,\n      this._minIndex !== null ? this._minIndex - 1 : 0\n    );\n  }\n\n  /**\n   * @param {object} edge should have cursor and a node with id\n   */\n  appendEdge(edge) {\n    this._addEdgeAtIndex(\n      edge,\n      this._maxIndex !== null ? this._maxIndex + 1 : 0\n    );\n  }\n\n  /**\n   * Mark the currently valid edge with given id to be deleted.\n   *\n   * @param {string} id the id of the edge to be removed\n   */\n  removeEdge(id) {\n    var index = this._getIndexForID(id);\n    if (index === undefined) {\n      console.warn(\n        'Attempted to remove edge with ID that was never in GraphQLSegment: ' +\n        id\n      );\n      return;\n    }\n    var data = this._indexToMetadataMap[index];\n    if (data.deleted) {\n      console.warn(\n        'Attempted to remove edge with ID that was already removed: ' +\n        id\n      );\n      return;\n    }\n    data.deleted = true;\n    this._count--;\n  }\n\n  /**\n   * Mark all edges with given id to be deleted. This is used by\n   * delete mutations to ensure both the current and past edges are no longer\n   * accessible.\n   *\n   * @param {string} id the id of the edge to be removed\n   */\n  removeAllEdges(id) {\n    var indices = this._idToIndicesMap[id];\n    if (!indices) {\n      return;\n    }\n    for (var ii = 0; ii < indices.length; ii++) {\n      var data = this._indexToMetadataMap[indices[ii]];\n      if (!data.deleted) {\n        data.deleted = true;\n        this._count--;\n      }\n    }\n  }\n\n  /**\n   * @param {array} edges\n   * @param {?string} cursor\n   */\n  addEdgesAfterCursor(edges, cursor) {\n    if (!edges.length) {\n      return;\n    }\n    // Default adding after with no cursor to -1\n    // So the first element in the segment is stored at index 0\n    var index = -1;\n    if (cursor) {\n      index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return;\n      }\n    }\n\n    while (this._maxIndex !== null && index < this._maxIndex) {\n      var data = this._indexToMetadataMap[index + 1];\n      // Skip over elements that have been deleted\n      // so we can add new edges on the end.\n      if (data.deleted) {\n        index++;\n      } else {\n        console.warn(\n          'Attempted to do an overwrite to GraphQLSegment: ' +\n          'last index is ' + this._maxIndex +\n          ' trying to add edges before ' + index\n        );\n        return;\n      }\n    }\n\n    var startIndex = index + 1;\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      this._addEdgeAtIndex(\n        edge,\n        startIndex + ii\n      );\n    }\n  }\n\n  /**\n   * @param {array} edges - should be in increasing order of index\n   * @param {?string} cursor\n   */\n  addEdgesBeforeCursor(edges, cursor) {\n    if (!edges.length) {\n      return;\n    }\n    // Default adding before with no cursor to 1\n    // So the first element in the segment is stored at index 0\n    var index = 1;\n    if (cursor) {\n      index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return;\n      }\n    }\n\n    while (this._minIndex !== null && index > this._minIndex) {\n      var data = this._indexToMetadataMap[index - 1];\n      // Skip over elements that have been deleted\n      // so we can add new edges in the front.\n      if (data.deleted) {\n        index--;\n      } else {\n        console.warn(\n          'Attempted to do an overwrite to GraphQLSegment: ' +\n          'first index is ' + this._minIndex +\n          ' trying to add edges after ' + index\n        );\n        return;\n      }\n    }\n\n    // Edges must be added in reverse order since the\n    // segment must be continuous at all times.\n    var startIndex = index - 1;\n    for (var ii = 0; ii < edges.length; ii++) {\n      // Iterates from edges.length - 1 to 0\n      var edge = edges[edges.length - ii - 1];\n      this._addEdgeAtIndex(\n        edge,\n        startIndex - ii\n      );\n    }\n  }\n\n  /**\n   * This is the total length of the segment including the deleted edges.\n   * Non-zero length guarantees value max and min indices.\n   * DO NOT USE THIS TO DETERMINE THE TOTAL NUMBER OF EDGES; use `getCount`\n   * instead.\n   * @return {number}\n   */\n  getLength() {\n    if (this._minIndex === null && this._maxIndex === null) {\n      return 0;\n    }\n\n    return this._maxIndex - this._minIndex + 1;\n  }\n\n  /**\n   * Returns the total number of non-deleted edges in the segment.\n   *\n   * @return {number}\n   */\n  getCount() {\n    return this._count;\n  }\n\n  /**\n   * In the event of a failed `concatSegment` operation, rollback internal\n   * properties to their former values.\n   *\n   * @param {object} cursorRollbackMap\n   * @param {object} idRollbackMap\n   * @param {object} counters\n   */\n  _rollback(cursorRollbackMap, idRollbackMap, counters) {\n    Object.assign(this._cursorToIndexMap, cursorRollbackMap);\n    Object.assign(this._idToIndicesMap, idRollbackMap);\n\n    // no need to reset _indexToMetadataMap; resetting counters is enough\n    this._count = counters.count;\n    this._maxIndex = counters.maxIndex;\n    this._minIndex = counters.minIndex;\n  }\n\n  /**\n   * @return {object} Captured counter state.\n   */\n  _getCounterState() {\n    return {\n      count: this._count,\n      maxIndex: this._maxIndex,\n      minIndex: this._minIndex,\n    };\n  }\n\n  /**\n   * Copies over content of the input segment and add to the current\n   * segment.\n   * @param {GraphQLSegment} segment - the segment to be copied over\n   * @return {boolean} whether or not we successfully concatenated the segments\n   */\n  concatSegment(segment) {\n    if (!segment.getLength()) {\n      return true;\n    }\n    var idRollbackMap = {};\n    var cursorRollbackMap = {};\n    var counterState = this._getCounterState();\n    var newEdges = segment._indexToMetadataMap;\n    for (var ii = segment._minIndex; ii <= segment._maxIndex; ii++) {\n      var index;\n      if (this.getLength()) {\n        index = this._maxIndex + 1;\n      } else {\n        index = 0;\n        this._minIndex = 0;\n      }\n      this._maxIndex = index;\n\n      var newEdge = newEdges[ii];\n      var idIndex = this._getIndexForID(newEdge.edgeID);\n      if (!idRollbackMap.hasOwnProperty(newEdge.edgeID)) {\n        if (this._idToIndicesMap[newEdge.edgeID]) {\n          idRollbackMap[newEdge.edgeID] =\n            this._idToIndicesMap[newEdge.edgeID].slice();\n        } else {\n          idRollbackMap[newEdge.edgeID] = undefined;\n        }\n      }\n      // Check for id collision. Can't have same id twice\n      if (idIndex !== undefined) {\n        var idEdge = this._indexToMetadataMap[idIndex];\n        if (idEdge.deleted && !newEdge.deleted) {\n          // We want to map to most recent edge. Only write to the front of map\n          // if existing edge with id is deleted or have an older deletion\n          // time.\n          this._idToIndicesMap[newEdge.edgeID].unshift(index);\n        } else if (!newEdge.deleted) {\n          console.warn(\n            'Attempt to concat an ID already in GraphQLSegment: %s',\n            newEdge.edgeID\n          );\n          this._rollback(cursorRollbackMap, idRollbackMap, counterState);\n          return false;\n        } else {\n          // We want to keep track of past edges as well. Write these indices\n          // to the end of the array.\n          this._idToIndicesMap[newEdge.edgeID] =\n            this._idToIndicesMap[newEdge.edgeID] || [];\n          this._idToIndicesMap[newEdge.edgeID].push(index);\n        }\n      } else {\n        this._idToIndicesMap[newEdge.edgeID] =\n          this._idToIndicesMap[newEdge.edgeID] || [];\n        this._idToIndicesMap[newEdge.edgeID].unshift(index);\n      }\n      var cursorIndex = this._getIndexForCursor(newEdge.cursor);\n      // Check for cursor collision. Can't have same cursor twice\n      if (cursorIndex !== undefined) {\n        var cursorEdge = this._indexToMetadataMap[cursorIndex];\n        if (cursorEdge.deleted && !newEdge.deleted) {\n          // We want to map to most recent edge. Only write in the cursor map if\n          // existing edge with cursor is deleted or have and older deletion\n          // time.\n          cursorRollbackMap[newEdge.cursor] =\n            this._cursorToIndexMap[newEdge.cursor];\n          this._cursorToIndexMap[newEdge.cursor] = index;\n        } else if (!newEdge.deleted) {\n          console.warn(\n            'Attempt to concat a cursor already in GraphQLSegment: %s',\n            newEdge.cursor\n          );\n          this._rollback(cursorRollbackMap, idRollbackMap, counterState);\n          return false;\n        }\n      } else if (newEdge.cursor) {\n        cursorRollbackMap[newEdge.cursor] =\n          this._cursorToIndexMap[newEdge.cursor];\n        this._cursorToIndexMap[newEdge.cursor] = index;\n      }\n      if (!newEdge.deleted) {\n        this._count++;\n      }\n      this._indexToMetadataMap[index] = Object.assign({}, newEdge);\n    }\n\n    return true;\n  }\n\n  toJSON() {\n    return [\n      this._indexToMetadataMap,\n      this._idToIndicesMap,\n      this._cursorToIndexMap,\n      this._minIndex,\n      this._maxIndex,\n      this._count,\n    ];\n  }\n\n  static fromJSON(descriptor) {\n    var [\n      indexToMetadataMap,\n      idToIndicesMap,\n      cursorToIndexMap,\n      minIndex,\n      maxIndex,\n      count,\n    ] = descriptor;\n    var segment = new GraphQLSegment();\n    segment._indexToMetadataMap = indexToMetadataMap;\n    segment._idToIndicesMap = idToIndicesMap;\n    segment._cursorToIndexMap = cursorToIndexMap;\n    segment._minIndex = minIndex;\n    segment._maxIndex = maxIndex;\n    segment._count = count;\n    return segment;\n  }\n\n  __debug() {\n    return {\n      metadata: this._indexToMetadataMap,\n      idToIndices: this._idToIndicesMap,\n      cursorToIndex:  this._cursorToIndexMap,\n    };\n  }\n\n  /**\n   * Returns a list of all IDs that were registered for this segment. Including\n   * edges that were deleted.\n   */\n  getEdgeIDs() {\n    return Object.keys(this._idToIndicesMap);\n  }\n}\n\nmodule.exports = GraphQLSegment;\n","dependencies":["RelayRecord"],"id":"GraphQLSegment","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLSegment\n * @typechecks\n */\n\n'use strict';\n\nconst RelayRecord = require('RelayRecord');\n\n/**\n * Represents one contiguous segment of edges within a `GraphQLRange`. Has\n * methods for adding/removing edges (`appendEdge`, `prependEdge`, `removeEdge`)\n * and working with cursors (`getFirstCursor`, `getLastCursor` etc)\n *\n * Edges are never actually deleted from segments; they are merely marked as\n * being deleted. As such, `GraphQLSegment` offers both a `getCount` method\n * (returning the number of non-deleted edges) and a `getLength` method (which\n * returns the total number, including deleted edges).\n *\n * Used mostly as an implementation detail internal to `GraphQLRange`.\n *\n * @internal\n */\nclass GraphQLSegment {\n  constructor() {\n    // We use a map rather than an array because indices can become negative\n    // when prepending.\n    this._indexToMetadataMap = {};\n\n    // We keep track of past indices to ensure we can delete them completely.\n    this._idToIndicesMap = {};\n    this._cursorToIndexMap = {};\n\n    this._count = 0;\n    this._minIndex = null;\n    this._maxIndex = null;\n  }\n\n  /**\n   * @param {string} cursor\n   * @return {?number}\n   */\n  _getIndexForCursor(cursor) {\n    return this._cursorToIndexMap[cursor];\n  }\n\n  /**\n   * @param {string} id\n   * @return {?number}\n   */\n  _getIndexForID(id) {\n    var indices = this._idToIndicesMap[id];\n    return indices && indices[0];\n  }\n\n  /**\n   * @return {?string} cursor for first non-deleted edge\n   */\n  getFirstCursor() {\n    if (this.getLength()) {\n      for (var ii = this._minIndex; ii <= this._maxIndex; ii++) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.cursor;\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {?string} cursor for last non-deleted edge\n   */\n  getLastCursor() {\n    if (this.getLength()) {\n      for (var ii = this._maxIndex; ii >= this._minIndex; ii--) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.cursor;\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {?string} id for first non-deleted edge\n   */\n  getFirstID() {\n    if (this.getLength()) {\n      for (var ii = this._minIndex; ii <= this._maxIndex; ii++) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.edgeID;\n        }\n      }\n    }\n  }\n\n  /**\n   * @return {?string} id for last non-deleted edge\n   */\n  getLastID() {\n    if (this.getLength()) {\n      for (var ii = this._maxIndex; ii >= this._minIndex; ii--) {\n        var metadata = this._indexToMetadataMap[ii];\n        if (!metadata.deleted) {\n          return metadata.edgeID;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @return {?object} Returns the not-deleted edge at index\n   */\n  _getEdgeAtIndex(index) {\n    var edge = this._indexToMetadataMap[index];\n    return edge && !edge.deleted ? edge : null;\n  }\n\n  /**\n   * Returns whether there is a non-deleted edge for id\n   * @param {string} id\n   * @return {boolean}\n   */\n  containsEdgeWithID(id) {\n    var index = this._getIndexForID(id);\n    if (index === undefined) {\n      return false;\n    }\n    return !!this._getEdgeAtIndex(index);\n  }\n\n  /**\n   * Returns whether there is a non-deleted edge for cursor\n   * @param {string} cursor\n   * @return {boolean}\n   */\n  containsEdgeWithCursor(cursor) {\n    var index = this._getIndexForCursor(cursor);\n    if (index === undefined) {\n      return false;\n    }\n    return !!this._getEdgeAtIndex(index);\n  }\n\n  /**\n   * Returns up to count number of ids and cursors that is after input cursor\n   * @param {number} count\n   * @param {?string} cursor\n   * @return {object} object with arrays of ids and cursors\n   */\n  getMetadataAfterCursor(count, cursor) {\n    if (!this.getLength()) {\n      return {\n        edgeIDs: [],\n        cursors: [],\n      };\n    }\n    var currentIndex = this._minIndex;\n    if (cursor) {\n      var index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return {\n          edgeIDs: [],\n          cursors: [],\n        };\n      }\n      currentIndex = index + 1;\n    }\n    var total = 0;\n    var edgeIDs = [];\n    var cursors = [];\n\n    while (currentIndex <= this._maxIndex && total < count) {\n      var metadata = this._indexToMetadataMap[currentIndex];\n      if (!metadata.deleted) {\n        edgeIDs.push(metadata.edgeID);\n        cursors.push(metadata.cursor);\n        total++;\n      }\n      currentIndex++;\n    }\n    return {\n      edgeIDs: edgeIDs,\n      cursors: cursors,\n    };\n  }\n\n  /**\n   * Returns up to count number of ids and cursors that is before index\n   * @param {number} count\n   * @param {?string} cursor\n   * @return {object} object with arrays of ids and cursors\n   */\n  getMetadataBeforeCursor(count, cursor) {\n    if (!this.getLength()) {\n      return {\n        edgeIDs: [],\n        cursors: [],\n      };\n    }\n    var currentIndex = this._maxIndex;\n    if (cursor) {\n      var index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return {\n          edgeIDs: [],\n          cursors: [],\n        };\n      }\n      currentIndex = index - 1;\n    }\n    var total = 0;\n    var edgeIDs = [];\n    var cursors = [];\n    while (currentIndex >= this._minIndex && total < count) {\n      var metadata = this._indexToMetadataMap[currentIndex];\n      if (!metadata.deleted) {\n        edgeIDs.push(metadata.edgeID);\n        cursors.push(metadata.cursor);\n        total++;\n      }\n      currentIndex--;\n    }\n\n    // Reverse edges because larger index were added first\n    return {\n      edgeIDs: edgeIDs.reverse(),\n      cursors: cursors.reverse(),\n    };\n  }\n\n  /**\n   * @param {object} edge\n   * @param {number} index\n   */\n  _addEdgeAtIndex(edge, index) {\n    var edgeID = RelayRecord.getDataID(edge);\n    var cursor = edge.cursor;\n\n    var idIndex = this._getIndexForID(edgeID);\n    // If the id is has an index and is not deleted\n    if (idIndex !== undefined && this._getEdgeAtIndex(idIndex)) {\n      console.warn(\n        'Attempted to add an ID already in GraphQLSegment: %s',\n        edgeID\n      );\n      return;\n    }\n\n    if (this.getLength() === 0) {\n      this._minIndex = index;\n      this._maxIndex = index;\n    } else if (this._minIndex == index + 1) {\n      this._minIndex = index;\n    } else if (this._maxIndex == index - 1) {\n      this._maxIndex = index;\n    } else {\n      console.warn(\n        `Attempted to add noncontiguous index to GraphQLSegment: ${index} to ` +\n        `(${this._minIndex}, ${this._maxIndex})`\n      );\n\n      return;\n    }\n\n    this._indexToMetadataMap[index] = {\n      edgeID: edgeID,\n      cursor: cursor,\n      deleted: false,\n    };\n    this._idToIndicesMap[edgeID] = this._idToIndicesMap[edgeID] || [];\n    this._idToIndicesMap[edgeID].unshift(index);\n    this._count++;\n\n    if (cursor) {\n      this._cursorToIndexMap[cursor] = index;\n    }\n  }\n\n  /**\n   * @param {object} edge should have cursor and a node with id\n   */\n  prependEdge(edge) {\n    this._addEdgeAtIndex(\n      edge,\n      this._minIndex !== null ? this._minIndex - 1 : 0\n    );\n  }\n\n  /**\n   * @param {object} edge should have cursor and a node with id\n   */\n  appendEdge(edge) {\n    this._addEdgeAtIndex(\n      edge,\n      this._maxIndex !== null ? this._maxIndex + 1 : 0\n    );\n  }\n\n  /**\n   * Mark the currently valid edge with given id to be deleted.\n   *\n   * @param {string} id the id of the edge to be removed\n   */\n  removeEdge(id) {\n    var index = this._getIndexForID(id);\n    if (index === undefined) {\n      console.warn(\n        'Attempted to remove edge with ID that was never in GraphQLSegment: ' +\n        id\n      );\n      return;\n    }\n    var data = this._indexToMetadataMap[index];\n    if (data.deleted) {\n      console.warn(\n        'Attempted to remove edge with ID that was already removed: ' +\n        id\n      );\n      return;\n    }\n    data.deleted = true;\n    this._count--;\n  }\n\n  /**\n   * Mark all edges with given id to be deleted. This is used by\n   * delete mutations to ensure both the current and past edges are no longer\n   * accessible.\n   *\n   * @param {string} id the id of the edge to be removed\n   */\n  removeAllEdges(id) {\n    var indices = this._idToIndicesMap[id];\n    if (!indices) {\n      return;\n    }\n    for (var ii = 0; ii < indices.length; ii++) {\n      var data = this._indexToMetadataMap[indices[ii]];\n      if (!data.deleted) {\n        data.deleted = true;\n        this._count--;\n      }\n    }\n  }\n\n  /**\n   * @param {array} edges\n   * @param {?string} cursor\n   */\n  addEdgesAfterCursor(edges, cursor) {\n    if (!edges.length) {\n      return;\n    }\n    // Default adding after with no cursor to -1\n    // So the first element in the segment is stored at index 0\n    var index = -1;\n    if (cursor) {\n      index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return;\n      }\n    }\n\n    while (this._maxIndex !== null && index < this._maxIndex) {\n      var data = this._indexToMetadataMap[index + 1];\n      // Skip over elements that have been deleted\n      // so we can add new edges on the end.\n      if (data.deleted) {\n        index++;\n      } else {\n        console.warn(\n          'Attempted to do an overwrite to GraphQLSegment: ' +\n          'last index is ' + this._maxIndex +\n          ' trying to add edges before ' + index\n        );\n        return;\n      }\n    }\n\n    var startIndex = index + 1;\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      this._addEdgeAtIndex(\n        edge,\n        startIndex + ii\n      );\n    }\n  }\n\n  /**\n   * @param {array} edges - should be in increasing order of index\n   * @param {?string} cursor\n   */\n  addEdgesBeforeCursor(edges, cursor) {\n    if (!edges.length) {\n      return;\n    }\n    // Default adding before with no cursor to 1\n    // So the first element in the segment is stored at index 0\n    var index = 1;\n    if (cursor) {\n      index = this._getIndexForCursor(cursor);\n      if (index === undefined) {\n        console.warn('This segment does not have a cursor %s', cursor);\n        return;\n      }\n    }\n\n    while (this._minIndex !== null && index > this._minIndex) {\n      var data = this._indexToMetadataMap[index - 1];\n      // Skip over elements that have been deleted\n      // so we can add new edges in the front.\n      if (data.deleted) {\n        index--;\n      } else {\n        console.warn(\n          'Attempted to do an overwrite to GraphQLSegment: ' +\n          'first index is ' + this._minIndex +\n          ' trying to add edges after ' + index\n        );\n        return;\n      }\n    }\n\n    // Edges must be added in reverse order since the\n    // segment must be continuous at all times.\n    var startIndex = index - 1;\n    for (var ii = 0; ii < edges.length; ii++) {\n      // Iterates from edges.length - 1 to 0\n      var edge = edges[edges.length - ii - 1];\n      this._addEdgeAtIndex(\n        edge,\n        startIndex - ii\n      );\n    }\n  }\n\n  /**\n   * This is the total length of the segment including the deleted edges.\n   * Non-zero length guarantees value max and min indices.\n   * DO NOT USE THIS TO DETERMINE THE TOTAL NUMBER OF EDGES; use `getCount`\n   * instead.\n   * @return {number}\n   */\n  getLength() {\n    if (this._minIndex === null && this._maxIndex === null) {\n      return 0;\n    }\n\n    return this._maxIndex - this._minIndex + 1;\n  }\n\n  /**\n   * Returns the total number of non-deleted edges in the segment.\n   *\n   * @return {number}\n   */\n  getCount() {\n    return this._count;\n  }\n\n  /**\n   * In the event of a failed `concatSegment` operation, rollback internal\n   * properties to their former values.\n   *\n   * @param {object} cursorRollbackMap\n   * @param {object} idRollbackMap\n   * @param {object} counters\n   */\n  _rollback(cursorRollbackMap, idRollbackMap, counters) {\n    Object.assign(this._cursorToIndexMap, cursorRollbackMap);\n    Object.assign(this._idToIndicesMap, idRollbackMap);\n\n    // no need to reset _indexToMetadataMap; resetting counters is enough\n    this._count = counters.count;\n    this._maxIndex = counters.maxIndex;\n    this._minIndex = counters.minIndex;\n  }\n\n  /**\n   * @return {object} Captured counter state.\n   */\n  _getCounterState() {\n    return {\n      count: this._count,\n      maxIndex: this._maxIndex,\n      minIndex: this._minIndex,\n    };\n  }\n\n  /**\n   * Copies over content of the input segment and add to the current\n   * segment.\n   * @param {GraphQLSegment} segment - the segment to be copied over\n   * @return {boolean} whether or not we successfully concatenated the segments\n   */\n  concatSegment(segment) {\n    if (!segment.getLength()) {\n      return true;\n    }\n    var idRollbackMap = {};\n    var cursorRollbackMap = {};\n    var counterState = this._getCounterState();\n    var newEdges = segment._indexToMetadataMap;\n    for (var ii = segment._minIndex; ii <= segment._maxIndex; ii++) {\n      var index;\n      if (this.getLength()) {\n        index = this._maxIndex + 1;\n      } else {\n        index = 0;\n        this._minIndex = 0;\n      }\n      this._maxIndex = index;\n\n      var newEdge = newEdges[ii];\n      var idIndex = this._getIndexForID(newEdge.edgeID);\n      if (!idRollbackMap.hasOwnProperty(newEdge.edgeID)) {\n        if (this._idToIndicesMap[newEdge.edgeID]) {\n          idRollbackMap[newEdge.edgeID] =\n            this._idToIndicesMap[newEdge.edgeID].slice();\n        } else {\n          idRollbackMap[newEdge.edgeID] = undefined;\n        }\n      }\n      // Check for id collision. Can't have same id twice\n      if (idIndex !== undefined) {\n        var idEdge = this._indexToMetadataMap[idIndex];\n        if (idEdge.deleted && !newEdge.deleted) {\n          // We want to map to most recent edge. Only write to the front of map\n          // if existing edge with id is deleted or have an older deletion\n          // time.\n          this._idToIndicesMap[newEdge.edgeID].unshift(index);\n        } else if (!newEdge.deleted) {\n          console.warn(\n            'Attempt to concat an ID already in GraphQLSegment: %s',\n            newEdge.edgeID\n          );\n          this._rollback(cursorRollbackMap, idRollbackMap, counterState);\n          return false;\n        } else {\n          // We want to keep track of past edges as well. Write these indices\n          // to the end of the array.\n          this._idToIndicesMap[newEdge.edgeID] =\n            this._idToIndicesMap[newEdge.edgeID] || [];\n          this._idToIndicesMap[newEdge.edgeID].push(index);\n        }\n      } else {\n        this._idToIndicesMap[newEdge.edgeID] =\n          this._idToIndicesMap[newEdge.edgeID] || [];\n        this._idToIndicesMap[newEdge.edgeID].unshift(index);\n      }\n      var cursorIndex = this._getIndexForCursor(newEdge.cursor);\n      // Check for cursor collision. Can't have same cursor twice\n      if (cursorIndex !== undefined) {\n        var cursorEdge = this._indexToMetadataMap[cursorIndex];\n        if (cursorEdge.deleted && !newEdge.deleted) {\n          // We want to map to most recent edge. Only write in the cursor map if\n          // existing edge with cursor is deleted or have and older deletion\n          // time.\n          cursorRollbackMap[newEdge.cursor] =\n            this._cursorToIndexMap[newEdge.cursor];\n          this._cursorToIndexMap[newEdge.cursor] = index;\n        } else if (!newEdge.deleted) {\n          console.warn(\n            'Attempt to concat a cursor already in GraphQLSegment: %s',\n            newEdge.cursor\n          );\n          this._rollback(cursorRollbackMap, idRollbackMap, counterState);\n          return false;\n        }\n      } else if (newEdge.cursor) {\n        cursorRollbackMap[newEdge.cursor] =\n          this._cursorToIndexMap[newEdge.cursor];\n        this._cursorToIndexMap[newEdge.cursor] = index;\n      }\n      if (!newEdge.deleted) {\n        this._count++;\n      }\n      this._indexToMetadataMap[index] = Object.assign({}, newEdge);\n    }\n\n    return true;\n  }\n\n  toJSON() {\n    return [\n      this._indexToMetadataMap,\n      this._idToIndicesMap,\n      this._cursorToIndexMap,\n      this._minIndex,\n      this._maxIndex,\n      this._count,\n    ];\n  }\n\n  static fromJSON(descriptor) {\n    var [\n      indexToMetadataMap,\n      idToIndicesMap,\n      cursorToIndexMap,\n      minIndex,\n      maxIndex,\n      count,\n    ] = descriptor;\n    var segment = new GraphQLSegment();\n    segment._indexToMetadataMap = indexToMetadataMap;\n    segment._idToIndicesMap = idToIndicesMap;\n    segment._cursorToIndexMap = cursorToIndexMap;\n    segment._minIndex = minIndex;\n    segment._maxIndex = maxIndex;\n    segment._count = count;\n    return segment;\n  }\n\n  __debug() {\n    return {\n      metadata: this._indexToMetadataMap,\n      idToIndices: this._idToIndicesMap,\n      cursorToIndex:  this._cursorToIndexMap,\n    };\n  }\n\n  /**\n   * Returns a list of all IDs that were registered for this segment. Including\n   * edges that were deleted.\n   */\n  getEdgeIDs() {\n    return Object.keys(this._idToIndicesMap);\n  }\n}\n\nmodule.exports = GraphQLSegment;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/GraphQLRange.js":{"metadata":{"mtime":1455679338000},"data":{"name":"GraphQLRange","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLRange\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst GraphQLSegment = require('GraphQLSegment');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayRecord = require('RelayRecord');\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst rangeOperationToMetadataKey = require('rangeOperationToMetadataKey');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\nconst warning = require('warning');\n\nvar {\n  END_CURSOR,\n  HAS_NEXT_PAGE,\n  HAS_PREV_PAGE,\n  START_CURSOR,\n} = RelayConnectionInterface;\n\n/**\n * @param {array<object>} queryCalls\n * @return {object}\n */\nfunction callsArrayToObject(queryCalls) {\n  var calls = {};\n  for (var ii = 0; ii < queryCalls.length; ii++) {\n    if (RelayConnectionInterface.isConnectionCall(queryCalls[ii])) {\n      var {name, value} = queryCalls[ii];\n      // assuming that range calls will only have a single argument\n      if (Array.isArray(value) && value.length) {\n        value = value[0];\n      }\n      // Ignore the whole call when the value is null\n      if (value === null) {\n        continue;\n      }\n      calls[name] = value;\n    }\n  }\n  // update first and last call values to be numbers\n  if (calls.first) {\n    invariant(\n      !isNaN(calls.first),\n      'GraphQLRange: Expected `first` argument to be a number, got ' +\n      '`%s`.',\n      calls.first\n    );\n    calls.first = +calls.first;\n  } else if (calls.last) {\n    invariant(\n      !isNaN(calls.last),\n      'GraphQLRange: Expected `last` argument to be a number, got ' +\n      '`%s`.',\n      calls.last\n    );\n    calls.last = +calls.last;\n  }\n  return calls;\n}\n\n/**\n * Returns whether this is currently a set of static calls that GraphQLRange\n * supports. Static calls define ranges that do not change over a period\n * of time, given the same set of arguments.\n *\n * @param {object} calls\n * @return {?boolean}\n */\nfunction isStaticCall(calls) {\n  return calls.hasOwnProperty('surrounds') || calls.hasOwnProperty('find');\n}\n\n/**\n * Returns whether this is currently a set of calls that GraphQLRange\n * supports\n *\n * @param {object} calls\n * @return {boolean}\n */\nfunction isValidRangeCall(calls) {\n  var hasFirst = calls.hasOwnProperty('first');\n  var hasLast = calls.hasOwnProperty('last');\n\n  // Currently only supports: first(), after().first(), last(), before().last()\n  // before().first(), after().last(), after().before().first(), and\n  // after().before().last()\n  // first() can never be called with last().\n  return ((hasFirst || hasLast) && !(hasFirst && hasLast));\n}\n\n/**\n * Returns whether the call values are supported by GraphQLRange\n *\n * @param {object} calls\n * @return {boolean}\n */\nfunction isValidRangeCallValues(calls) {\n  return (calls.hasOwnProperty('first') && calls.first > 0) ||\n         (calls.hasOwnProperty('last') && calls.last > 0);\n}\n\n/**\n * Validates edge to ensure it has all the fields needed to be store properly.\n *\n * @param {object} edge\n */\nfunction validateEdge(edge) {\n  invariant(\n    RelayRecord.getDataID(edge) !== undefined,\n    'GraphQLStore: `edge` must have a data id'\n  );\n  invariant(\n    edge.node !== undefined,\n    'GraphQLStore: `edge` must have `node` field'\n  );\n}\n\n/**\n * @param {array<object>} edges\n */\nfunction validateEdges(edges) {\n  edges.forEach(validateEdge);\n}\n\n/**\n * A range represents an ordered set of edges. Methods are provided for adding\n * edges (`appendEdge`, `prependEdge`, `addItems`) and removing them\n * (`removeEdgeWithID`).\n *\n * Within a range, each contiguous group of edges is modeled using a\n * `GraphQLSegment`, but this is an implementation detail that `GraphQLRange`\n * hides from its callers.\n *\n * Ranges model GraphQL connections, which are the means of traversing from a\n * node to a set of associated objects; for example, in the following query the\n * \"friends\" connection produces a range containing edges that lead to the\n * requested friend nodes:\n *\n *     node(4) {\n *       friends.first(2) {\n *         edges {\n *           node {\n *             id,\n *             name,\n *           },\n *         },\n *       },\n *     }\n *\n * @see `GraphQLSegment`\n * @see \"Connections\" in https://fburl.com/graphql-connections\n * @internal\n */\nclass GraphQLRange {\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    // List of segments where each segment is a continuous chunk.\n    // There are gaps in between the segments. The first segment in the list\n    // should be cursors beginning at the top of the range (i.e. first(N)).\n    // The last segment in the list should be cursors at the bottom of\n    // the range (i.e. last(N)).\n    this._orderedSegments = [\n      new GraphQLSegment(),\n      new GraphQLSegment(),\n    ];\n\n    // GraphQLRange nodes can also support static queries like surrounds,\n    // find, whose contents won't ever change for a given set of arguments.\n    // Store these queries' results in this map, since you can't do first()\n    // or last() queries on these ranges.\n    this._staticQueriesMap = {};\n\n    this._hasFirst = false;\n    this._hasLast = false;\n  }\n\n  /**\n   * @param {number} index\n   */\n  _resetSegment(index) {\n    invariant(\n      index >= 0 && index < this._orderedSegments.length,\n      'cannot reset non-existent segment'\n    );\n    this._orderedSegments[index] = new GraphQLSegment();\n  }\n\n  /**\n   * @param {string} cursor\n   * @return {?number}\n   */\n  _getSegmentIndexByCursor(cursor) {\n    // TODO: revisit if we end up having too many segments\n    for (var ii = 0; ii < this._orderedSegments.length; ii++) {\n      if (this._orderedSegments[ii].containsEdgeWithCursor(cursor)) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {string} id\n   * @return {?number}\n   */\n  _getSegmentIndexByID(id) {\n    // TODO: revisit if we end up having too many segments\n    for (var ii = 0; ii < this._orderedSegments.length; ii++) {\n      if (this._orderedSegments[ii].containsEdgeWithID(id)) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add edges' data into the static queries map for the query calls,\n   * overwriting any previously existing data for these calls.\n   * @param {array<object>} queryCalls\n   * @param {array} edges\n   */\n  _addStaticEdges(queryCalls, edges) {\n    var calls = _callsToString(queryCalls);\n    var edgeIDsToStore = [];\n    var cursorsToStore = [];\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      edgeIDsToStore.push(RelayRecord.getDataID(edge));\n      cursorsToStore.push(edge.cursor);\n    }\n\n    this._staticQueriesMap[calls] = {\n      edgeIDs: edgeIDsToStore,\n      cursors: cursorsToStore,\n    };\n  }\n\n  /**\n   * Add edges into the range based on the query calls. New edges will replace\n   * previous edges in the range.\n   * @param {array<object>} queryCalls\n   * @param {array} edges\n   * @param {object} pageInfo\n   */\n  addItems(queryCalls, edges, pageInfo) {\n    validateEdges(edges);\n    var calls = callsArrayToObject(queryCalls);\n    var segmentCount, segmentIndex;\n\n    if (isStaticCall(calls)) {\n      this._addStaticEdges(queryCalls, edges);\n      return;\n    }\n\n    if (!isValidRangeCall(calls)) {\n      console.error(\n        'GraphQLRange currently only handles first(<count>), ' +\n        'after(<cursor>).first(<count>), last(<count>), ' +\n        'before(<cursor>).last(<count>), before(<cursor>).first(<count>), ' +\n        'and after(<cursor>).last(<count>)'\n      );\n      return;\n    }\n\n    // Skip the update if cursors are invalid\n    if (calls.before === null || calls.after === null) {\n      console.error(\n        'GraphQLRange received null as a cursor.'\n      );\n      return;\n    }\n\n    if (calls.first) {\n      // before().first() calls can produce gaps\n      if (calls.before && !calls.after) {\n        // make a new segment if there is a gap\n        if (pageInfo[HAS_NEXT_PAGE] === true) {\n          if (this._getSegmentIndexByCursor(calls.before) === 0) {\n            this._orderedSegments.unshift(\n              new GraphQLSegment()\n            );\n          }\n          // When there is a gap from before().first() query, this is the same\n          // as just storing a first().\n          this._addAfterFirstItems(\n            edges, pageInfo[HAS_NEXT_PAGE], undefined, calls.before\n          );\n        } else {\n          // Since there is no gap, we can stitch into the beginning\n          // of existing segment\n          this._addBeforeLastItems(\n            edges,\n            pageInfo[HAS_PREV_PAGE],\n            calls.before\n          );\n        }\n      } else {\n        // These elements are added from paging to extend the the range.\n        if (!calls.after) {\n          segmentIndex = 0;\n          segmentCount = this.getFirstSegment().getCount();\n          if (\n            segmentCount &&\n            (calls.first > segmentCount || edges.length > segmentCount) &&\n            !this.getFirstSegment().getFirstCursor()\n          ) {\n            // this is a range for which we don't have a cursor, and we've\n            // fetched more data by increasing the `first(N)` variable; we\n            // blow away and replace the first segment in order to side-step\n            // issues where the order of IDs in the range may change between\n            // queries\n            this._resetSegment(segmentIndex);\n          }\n        }\n        this._addAfterFirstItems(\n          edges, pageInfo[HAS_NEXT_PAGE], calls.after, calls.before\n        );\n      }\n    } else if (calls.last) {\n      // after().last() calls can produce gaps\n      if (calls.after && !calls.before) {\n        // make a new segment if there is a gap\n        if (pageInfo[HAS_PREV_PAGE] === true) {\n          if (this._getSegmentIndexByCursor(calls.after) ===\n              this._orderedSegments.length - 1) {\n            this._orderedSegments.push(new GraphQLSegment());\n          }\n          // When there is a gap from after().last() query, this is the same as\n          // just storing a last().\n          this._addBeforeLastItems(\n            edges, pageInfo[HAS_PREV_PAGE], undefined, calls.after\n          );\n        } else {\n          // Since there is no gap, we can stitch to the end\n          // of existing segment\n          this._addAfterFirstItems(\n            edges,\n            pageInfo[HAS_NEXT_PAGE],\n            calls.after\n          );\n        }\n      } else {\n        // These elements are added from paging to extend the the range.\n        if (!calls.before) {\n          segmentIndex = this._orderedSegments.length - 1;\n          segmentCount = this.getLastSegment().getCount();\n          if (\n            segmentCount &&\n            (calls.last > segmentCount || edges.length > segmentCount) &&\n            !this.getLastSegment().getLastCursor()\n          ) {\n            // this is a range for which we don't have a cursor, and we've\n            // fetched more data by increasing the `last(N)` variable; we\n            // blow away and replace the last segment in order to side-step\n            // issues where the order of IDs in the range may change between\n            // queries\n            this._resetSegment(segmentIndex);\n          }\n        }\n        this._addBeforeLastItems(\n          edges, pageInfo[HAS_PREV_PAGE], calls.before, calls.after\n        );\n      }\n    }\n  }\n\n  /**\n   * @return {GraphQLSegment}\n   */\n  getFirstSegment() {\n    return this._orderedSegments[0];\n  }\n\n  /**\n   * @return {GraphQLSegment}\n   */\n  getLastSegment() {\n    return this._orderedSegments[this._orderedSegments.length - 1];\n  }\n\n  /**\n   * Tries to concat segments at segmentIndex and segmentIndex + 1.\n   * This is an all or nothing operation.\n   * If concat is successful, we'll remove the segment at segmentIndex + 1\n   * from the orderedSegments after all elements has been added to the segment\n   * at segmentIndex.\n   * If concat is unsuccessful, nothing will be changed.\n   * @param {number} segmentIndex\n   */\n  _concatSegments(segmentIndex) {\n    invariant(\n      (segmentIndex + 1) < this._orderedSegments.length &&\n      segmentIndex >= 0,\n      'GraphQLRange cannot concat segments outside the range ' +\n      'of orderedSegments'\n    );\n    var firstSegment = this._orderedSegments[segmentIndex];\n    var secondSegment = this._orderedSegments[segmentIndex + 1];\n    if (firstSegment.concatSegment(secondSegment)) {\n      this._orderedSegments.splice(segmentIndex + 1, 1);\n    } else {\n      console.warn(\n        'GraphQLRange was unable to concat segment %d and segment %d',\n        segmentIndex,\n        segmentIndex + 1\n      );\n    }\n  }\n\n  /**\n   * Adds the edge to the front of the range. New edge will replace previous\n   * edge that have the same id.\n   * @param {object} edge\n   */\n  prependEdge(edge) {\n    validateEdge(edge);\n    this._hasFirst = true;\n    this._removeEdgeIfApplicable(edge);\n    var segment = this.getFirstSegment();\n    segment.prependEdge(edge);\n  }\n\n  /**\n   * Adds the edge to the end of the range. New edge will replace previous\n   * edge that have the same id.\n   * @param {object} edge\n   */\n  appendEdge(edge) {\n    validateEdge(edge);\n    this._hasLast = true;\n    this._removeEdgeIfApplicable(edge);\n    var segment = this.getLastSegment();\n    segment.appendEdge(edge);\n  }\n\n  /**\n   * Removes edge in range if it matches id in input edge.\n   * @param {object} edge\n   */\n  _removeEdgeIfApplicable(edge) {\n    var id = RelayRecord.getDataID(edge);\n    var index = this._getSegmentIndexByID(id);\n    if (index != null) {\n      this._orderedSegments[index].removeEdge(id);\n    }\n  }\n\n  /**\n   * Remove any edges in the range if it matches any of the ids in the input.\n   * This function is used to prevent us from adding any id that already exist\n   * in the range.\n   *\n   * @param {array} edges\n   */\n  _removeEdgesIfApplicable(edges) {\n    for (var ii = 0; ii < edges.length; ii++) {\n      this._removeEdgeIfApplicable(edges[ii]);\n    }\n  }\n\n  /**\n   * Add items into the correct segment with the cursor. If no cursor\n   * is present, items are added to the very first segment.\n   *\n   * @param {array} edges\n   * @param {boolean} hasNextPage\n   * @param {?string} afterCursor\n   * @param {?string} beforeCursor\n   */\n  _addAfterFirstItems(\n    edges,\n    hasNextPage,\n    afterCursor,\n    beforeCursor\n  ) {\n    var segment;\n    var segmentIndex;\n    var lastCursor;\n    if (afterCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(afterCursor);\n      if (segmentIndex == null) {\n        warning(\n          false,\n          'GraphQLRange cannot find a segment that has the cursor: %s',\n          afterCursor\n        );\n        return;\n      }\n      segment = this._orderedSegments[segmentIndex];\n      lastCursor = segment.getLastCursor();\n      if (lastCursor !== afterCursor) {\n        edges = this._reconcileAfterFirstEdges(segment, edges, afterCursor);\n        afterCursor = lastCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    } else {\n      segmentIndex = 0;\n      segment = this._orderedSegments[segmentIndex];\n      lastCursor = segment.getLastCursor();\n      if (lastCursor !== undefined) {\n        edges = this._reconcileAfterFirstEdges(segment, edges);\n        afterCursor = lastCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    }\n    if (beforeCursor !== undefined) {\n      if (segmentIndex === this._orderedSegments.length - 1) {\n        console.warn(\n          'GraphQLRange cannot add because there is no next segment'\n        );\n        return;\n      } else if (this._orderedSegments[segmentIndex + 1].getFirstCursor() !==\n                 beforeCursor) {\n        warning(\n          false,\n          'GraphQLRange cannot add because beforeCursor does not match first ' +\n          'cursor of the next segment'\n        );\n        return;\n      }\n    }\n\n    if (afterCursor === undefined) {\n      this._hasFirst = true;\n    }\n\n    this._removeEdgesIfApplicable(edges);\n    segment.addEdgesAfterCursor(edges, afterCursor);\n    if (!hasNextPage) {\n      if (beforeCursor !== undefined) {\n        // If we have a beforeCursor and there is no next page,\n        // then there is no gap between the current segment and the next.\n        // We can concat the two segments when there is no gap.\n        this._concatSegments(segmentIndex);\n      } else {\n        this._hasLast = true;\n        // If this segment already has the last element, we don't\n        // need any segments after this.\n        this._orderedSegments.splice(\n          segmentIndex + 1,\n          this._orderedSegments.length - 1 - segmentIndex\n        );\n      }\n    }\n  }\n\n  /**\n   * In the case the cursor does not correspond last cursor,\n   * walk through the edges to see if we can trim edges to\n   * only those after the last cursor. Returns undefined when\n   * the input cannot be reconciled.\n   *\n   * @param {GraphQLSegment} segment\n   * @param {array} edges\n   * @param {?string} cursor\n   * @return {?array} trimmed edges\n   */\n  _reconcileAfterFirstEdges(segment, edges, cursor) {\n    var metadata = segment.getMetadataAfterCursor(edges.length + 1, cursor);\n    var edgeIDs = metadata.edgeIDs;\n    if (edgeIDs.length > edges.length) {\n      // Already have more edges than the input.\n      return undefined;\n    }\n\n    for (var ii = 0; ii < edgeIDs.length; ii++) {\n      if (edgeIDs[ii] !== RelayRecord.getDataID(edges[ii])) {\n        warning(\n          false,\n          'Relay was unable to reconcile edges on a connection. This most ' +\n          'likely occurred while trying to handle a server response that ' +\n          'includes connection edges with nodes that lack an `id` field.'\n        );\n        return undefined;\n      }\n    }\n    return edges.slice(edgeIDs.length);\n  }\n\n  /**\n   * Add items into the correct segment with the cursor. If no cursor\n   * is present, items are added to the very last segment.\n   * @param {array} edges\n   * @param {boolean} hasPrevPage\n   * @param {?string} beforeCursor\n   * @param {?string} afterCursor\n   */\n  _addBeforeLastItems(\n    edges,\n    hasPrevPage,\n    beforeCursor,\n    afterCursor\n  ) {\n    var segment;\n    var segmentIndex;\n    var firstCursor;\n    if (beforeCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(beforeCursor);\n      if (segmentIndex == null) {\n        warning(\n          false,\n          'GraphQLRange cannot find a segment that has the cursor: %s',\n          beforeCursor\n        );\n        return;\n      }\n      segment = this._orderedSegments[segmentIndex];\n      firstCursor = segment.getFirstCursor();\n      if (firstCursor !== beforeCursor) {\n        edges = this._reconcileBeforeLastEdges(segment, edges, beforeCursor);\n        beforeCursor = firstCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    } else {\n      segmentIndex = this._orderedSegments.length - 1;\n      segment = this._orderedSegments[segmentIndex];\n      firstCursor = segment.getFirstCursor();\n      if (firstCursor !== undefined) {\n        edges = this._reconcileBeforeLastEdges(segment, edges, beforeCursor);\n        beforeCursor = firstCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    }\n\n    if (afterCursor !== undefined) {\n      if (segmentIndex === 0) {\n        console.warn(\n          'GraphQLRange cannot add because there is no previous segment'\n        );\n        return;\n      } else if (this._orderedSegments[segmentIndex - 1].getLastCursor() !==\n                 afterCursor) {\n        warning(\n          false,\n          'GraphQLRange cannot add because afterCursor does not match last ' +\n          'cursor of the previous segment'\n        );\n        return;\n      }\n    }\n\n    if (beforeCursor === undefined) {\n      this._hasLast = true;\n    }\n\n    this._removeEdgesIfApplicable(edges);\n    segment.addEdgesBeforeCursor(edges, beforeCursor);\n    if (!hasPrevPage) {\n      if (afterCursor !== undefined) {\n        // If we have an afterCursor and there is no previous page,\n        // then there is no gap between the current segment and the previous.\n        // We can concat the two segments when there is no gap.\n        this._concatSegments(segmentIndex - 1);\n      } else {\n        this._hasFirst = true;\n        // If this segment already has the first element, we don't\n        // need any segments before this.\n        this._orderedSegments.splice(0, segmentIndex);\n      }\n    }\n  }\n\n  /**\n   * In the case the cursor does not correspond first cursor,\n   * walk through the edges to see if we can trim edges to\n   * only those before the first cursor. Returns undefined when\n   * the input cannot be reconciled.\n   *\n   * @param {GraphQLSegment} segment\n   * @param {array} edges\n   * @param {?string} cursor\n   * @return {?array} trimmed edges\n   */\n  _reconcileBeforeLastEdges(segment, edges, cursor) {\n    var metadata = segment.getMetadataBeforeCursor(edges.length + 1, cursor);\n    var edgeIDs = metadata.edgeIDs;\n    if (edgeIDs.length > edges.length) {\n      // Already have more edges than the input.\n      return undefined;\n    }\n\n    for (var ii = 1; ii <= edgeIDs.length; ii++) {\n      if (edgeIDs[edgeIDs.length - ii] !==\n          RelayRecord.getDataID(edges[edges.length - ii])) {\n        warning(\n          false,\n          'Relay was unable to reconcile edges on a connection. This most ' +\n          'likely occurred while trying to handle a server response that ' +\n          'includes connection edges with nodes that lack an `id` field.'\n        );\n        return undefined;\n      }\n    }\n    return edges.slice(0, edges.length - edgeIDs.length);\n  }\n\n  /**\n   * Removes an edge from this range such that the edge will never be reachable\n   * regardless of the client session. This is used by delete mutations.\n   *\n   * @param {string} id\n   */\n  removeEdgeWithID(id) {\n    for (var ii = 0; ii < this._orderedSegments.length; ii++) {\n      this._orderedSegments[ii].removeAllEdges(id);\n    }\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @param {?object} queuedRecord\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  retrieveRangeInfoForQuery(queryCalls, queuedRecord) {\n    var calls = callsArrayToObject(queryCalls);\n\n    if (isStaticCall(calls)) {\n      return this._retrieveRangeInfoForStaticCalls(\n        queryCalls,\n      );\n    }\n\n    // Convert to name => true, so we can test for whether the key exists\n    // without comparing to undefined\n    if (!isValidRangeCall(calls)) {\n      console.error(\n        'GraphQLRange currently only handles first(<count>), ' +\n        'after(<cursor>).first(<count>), last(<count>), ' +\n        'before(<cursor>).last(<count>), before(<cursor>).first(<count>), ' +\n        'and after(<cursor>).last(<count>)'\n      );\n      return {\n        requestedEdgeIDs: [],\n        diffCalls: [],\n        pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n      };\n    }\n    if ((calls.first && calls.before) || (calls.last && calls.after)) {\n      // TODO #7556678: add support for first/before and last/after\n      return {\n        requestedEdgeIDs: [],\n        diffCalls: [],\n        pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n      };\n    }\n    if (!isValidRangeCallValues(calls)) {\n      console.error(\n        'GraphQLRange only supports first(<count>) or last(<count>) ' +\n        'where count is greater than 0'\n      );\n      return {\n        requestedEdgeIDs: [],\n        diffCalls: [],\n        pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n      };\n    }\n    if (calls.first) {\n      return this._retrieveRangeInfoForFirstQuery(\n        queryCalls,\n        queuedRecord\n      );\n    } else if (calls.last) {\n      return this._retrieveRangeInfoForLastQuery(\n        queryCalls,\n        queuedRecord\n      );\n    }\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  _retrieveRangeInfoForStaticCalls(queryCalls) {\n    var calls = _callsToString(queryCalls);\n    var storedInfo = this._staticQueriesMap[calls];\n\n    if (storedInfo) {\n      return {\n        requestedEdgeIDs: storedInfo.edgeIDs,\n        diffCalls: [],\n        pageInfo: {\n          [START_CURSOR]: storedInfo.cursors[0],\n          [END_CURSOR]: storedInfo.cursors[storedInfo.cursors.length - 1],\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: true,\n        },\n      };\n    }\n\n    // if we don't have the data for this static call already,\n    // return empty arrays with the corresponding diffCalls\n    return {\n      requestedEdgeIDs: [],\n      diffCalls: queryCalls,\n      pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n    };\n  }\n\n  /**\n   * @param {object} queuedRecord\n   * @return {?array<string>}\n   */\n  _getAppendedIDsForQueuedRecord(queuedRecord) {\n    return queuedRecord[\n      rangeOperationToMetadataKey[GraphQLMutatorConstants.APPEND]\n    ];\n  }\n\n  /**\n   * @param {object} queuedRecord\n   * @return {?array<string>}\n   */\n  _getRemovedIDsForQueuedRecord(queuedRecord) {\n    return queuedRecord[\n      rangeOperationToMetadataKey[GraphQLMutatorConstants.REMOVE]\n    ];\n  }\n\n  /**\n   * @param {object} queuedRecord\n   * @return {?array<string>}\n   */\n  _getPrependedIDsForQueuedRecord(queuedRecord) {\n    return queuedRecord[\n      rangeOperationToMetadataKey[GraphQLMutatorConstants.PREPEND]\n    ];\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @param {?object} queuedRecord\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  _retrieveRangeInfoForFirstQuery(\n    queryCalls,\n    queuedRecord\n  ) {\n    let appendEdgeIDs;\n    let prependEdgeIDs;\n    let removeIDs;\n    if (queuedRecord) {\n      appendEdgeIDs = this._getAppendedIDsForQueuedRecord(queuedRecord);\n      prependEdgeIDs = this._getPrependedIDsForQueuedRecord(queuedRecord);\n      removeIDs = this._getRemovedIDsForQueuedRecord(queuedRecord);\n    }\n    var calls = callsArrayToObject(queryCalls);\n    let countNeeded = calls.first + (removeIDs ? removeIDs.length : 0);\n    var segment;\n    var segmentIndex;\n    var pageInfo = {\n      ...RelayConnectionInterface.getDefaultPageInfo(),\n    };\n\n    var afterCursor = calls.after;\n    if (afterCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(afterCursor);\n      if (segmentIndex == null) {\n        console.warn(\n          'GraphQLRange cannot find a segment that has the cursor: ' +\n          afterCursor\n        );\n        return {\n          requestedEdgeIDs: [],\n          diffCalls: [],\n          pageInfo: pageInfo,\n        };\n      }\n      segment = this._orderedSegments[segmentIndex];\n    } else {\n      const prependEdgesCount = prependEdgeIDs ? prependEdgeIDs.length : 0;\n      countNeeded -= prependEdgesCount;\n\n      segmentIndex = 0;\n      segment = this._orderedSegments[segmentIndex];\n    }\n\n    var requestedMetadata =\n      segment.getMetadataAfterCursor(countNeeded, afterCursor);\n    var requestedEdgeIDs = requestedMetadata.edgeIDs;\n    var requestedCursors = requestedMetadata.cursors;\n    var diffCalls = [];\n    if (requestedCursors.length) {\n      pageInfo[START_CURSOR] = requestedCursors[0];\n      pageInfo[END_CURSOR] = requestedCursors[requestedCursors.length - 1];\n    }\n    var lastID = requestedEdgeIDs[requestedEdgeIDs.length - 1];\n    // Only requested segment that does not include very last item from\n    // the range can have next page and diff calls\n    if (!this._hasLast ||\n        segmentIndex !== this._orderedSegments.length - 1 ||\n        (lastID && lastID !== segment.getLastID())) {\n      pageInfo[HAS_NEXT_PAGE] = true;\n      if (requestedEdgeIDs.length < countNeeded) {\n        countNeeded -= requestedEdgeIDs.length;\n        var lastCursor = segment.getLastCursor();\n        // If segment has null cursors, retrieve whole range.\n        if (lastCursor === null) {\n          diffCalls.push({name: 'first', value: calls.first});\n        } else {\n          if (lastCursor !== undefined) {\n            diffCalls.push({name: 'after', value: lastCursor});\n          }\n          // If this is not the last segment, we should not request edges\n          // that would overlap the first element of the next segment.\n          if (segmentIndex !== this._orderedSegments.length - 1) {\n            var nextSegment = this._orderedSegments[segmentIndex + 1];\n            var firstCursor = nextSegment.getFirstCursor();\n            if (firstCursor !== undefined) {\n              diffCalls.push({name: 'before', value: firstCursor});\n            }\n          }\n          diffCalls.push({name: 'first', value: countNeeded});\n        }\n      }\n    }\n\n    if (queuedRecord) {\n      if (prependEdgeIDs && prependEdgeIDs.length && !calls.after) {\n        requestedEdgeIDs = prependEdgeIDs.concat(requestedEdgeIDs);\n      }\n      if (appendEdgeIDs && appendEdgeIDs.length && !pageInfo[HAS_NEXT_PAGE]) {\n        requestedEdgeIDs = requestedEdgeIDs.concat(appendEdgeIDs);\n      }\n      if (removeIDs && removeIDs.length) {\n        requestedEdgeIDs = requestedEdgeIDs.filter(function(edgeID) {\n          return (removeIDs.indexOf(edgeID) == -1);\n        });\n      }\n      if (requestedEdgeIDs.length > calls.first) {\n        requestedEdgeIDs = requestedEdgeIDs.slice(0, calls.first);\n      }\n    }\n\n    return {\n      requestedEdgeIDs: requestedEdgeIDs,\n      diffCalls: diffCalls,\n      pageInfo: pageInfo,\n    };\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @param {?object} queuedRecord\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  _retrieveRangeInfoForLastQuery(\n    queryCalls,\n    queuedRecord\n  ) {\n    let appendEdgeIDs;\n    let prependEdgeIDs;\n    let removeIDs;\n    if (queuedRecord) {\n      appendEdgeIDs = this._getAppendedIDsForQueuedRecord(queuedRecord);\n      prependEdgeIDs = this._getPrependedIDsForQueuedRecord(queuedRecord);\n      removeIDs = this._getRemovedIDsForQueuedRecord(queuedRecord);\n    }\n    var calls = callsArrayToObject(queryCalls);\n    let countNeeded = calls.last + (removeIDs ? removeIDs.length : 0);\n    var segment;\n    var segmentIndex;\n    var pageInfo = {\n      ...RelayConnectionInterface.getDefaultPageInfo(),\n    };\n\n    var beforeCursor = calls.before;\n    if (beforeCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(beforeCursor);\n      if (segmentIndex == null) {\n        console.warn(\n          'GraphQLRange cannot find a segment that has the cursor: ' +\n          beforeCursor\n        );\n        return {\n          requestedEdgeIDs: [],\n          diffCalls: [],\n          pageInfo: pageInfo,\n        };\n      }\n      segment = this._orderedSegments[segmentIndex];\n    } else {\n      const appendEdgesCount = appendEdgeIDs ? appendEdgeIDs.length : 0;\n      countNeeded -= appendEdgesCount;\n\n      segmentIndex = this._orderedSegments.length - 1;\n      segment = this._orderedSegments[segmentIndex];\n    }\n\n    var requestedMetadata =\n      segment.getMetadataBeforeCursor(countNeeded, beforeCursor);\n    var requestedEdgeIDs = requestedMetadata.edgeIDs;\n    var requestedCursors = requestedMetadata.cursors;\n    var diffCalls = [];\n    if (requestedCursors.length) {\n      pageInfo[START_CURSOR] = requestedCursors[0];\n      pageInfo[END_CURSOR] = requestedCursors[requestedCursors.length - 1];\n    }\n    var firstID = requestedEdgeIDs[0];\n    // Only requested segment that does not include very first item from\n    // the range can have next page and diff calls\n    if (!this._hasFirst ||\n        segmentIndex !== 0 ||\n        (firstID && firstID !== segment.getFirstID())) {\n      pageInfo[HAS_PREV_PAGE] = true;\n      if (requestedEdgeIDs.length < countNeeded) {\n        countNeeded -= requestedEdgeIDs.length;\n        var firstCursor = segment.getFirstCursor();\n        // If segment has null cursors, retrieve whole range.\n        if (firstCursor === null) {\n          diffCalls.push({name: 'last', value: calls.last});\n        } else {\n          if (firstCursor !== undefined) {\n            diffCalls.push({name: 'before', value: firstCursor});\n          }\n          // If this is not the first segment, we should not request edges\n          // that would overlap the last element of the previous segment.\n          if (segmentIndex !== 0) {\n            var prevSegment = this._orderedSegments[segmentIndex - 1];\n            var lastCursor = prevSegment.getLastCursor();\n            if (lastCursor !== undefined) {\n              diffCalls.push({name: 'after', value: lastCursor});\n            }\n          }\n          diffCalls.push({name: 'last', value: countNeeded});\n        }\n      }\n    }\n\n    if (queuedRecord) {\n      if (appendEdgeIDs && appendEdgeIDs.length && !calls.before) {\n        requestedEdgeIDs = requestedEdgeIDs.concat(appendEdgeIDs);\n      }\n      if (prependEdgeIDs && prependEdgeIDs.length && !pageInfo[HAS_PREV_PAGE]) {\n        requestedEdgeIDs = prependEdgeIDs.concat(requestedEdgeIDs);\n      }\n      if (removeIDs && removeIDs.length) {\n        requestedEdgeIDs = requestedEdgeIDs.filter(function(edgeID) {\n          return (removeIDs.indexOf(edgeID) == -1);\n        });\n      }\n      if (requestedEdgeIDs.length > calls.last) {\n        var length = requestedEdgeIDs.length;\n        requestedEdgeIDs = requestedEdgeIDs.slice(length - calls.last, length);\n      }\n    }\n\n    return {\n      requestedEdgeIDs: requestedEdgeIDs,\n      diffCalls: diffCalls,\n      pageInfo: pageInfo,\n    };\n  }\n\n  static fromJSON(descriptor) {\n    var [\n      hasFirst,\n      hasLast,\n      staticQueriesMap,\n      orderedSegments,\n    ] = descriptor;\n    var range = new GraphQLRange();\n    range._hasFirst = hasFirst;\n    range._hasLast = hasLast;\n    range._staticQueriesMap = staticQueriesMap;\n    range._orderedSegments =\n      orderedSegments.map(descriptor => GraphQLSegment.fromJSON(descriptor));\n    return range;\n  }\n\n  toJSON() {\n    return [\n      this._hasFirst,\n      this._hasLast,\n      this._staticQueriesMap,\n      this._orderedSegments,\n    ];\n  }\n\n  __debug() {\n    return {\n      orderedSegments: this._orderedSegments,\n    };\n  }\n\n  getEdgeIDs() {\n    var edgeIDs = [];\n    this._orderedSegments.forEach(segment => {\n      edgeIDs.push(...segment.getEdgeIDs());\n    });\n    forEachObject(this._staticQueriesMap, (query) => {\n      edgeIDs.push(...query.edgeIDs);\n    });\n    return edgeIDs;\n  }\n}\n\n/**\n * @param {array<object>} calls\n * @return {string}\n */\nfunction _callsToString(calls) {\n  return calls.map(\n    call => serializeRelayQueryCall(call).substring(1)\n  ).join(',');\n}\n\nmodule.exports = GraphQLRange;\n","dependencies":["GraphQLMutatorConstants","GraphQLSegment","RelayConnectionInterface","RelayRecord","forEachObject","invariant","rangeOperationToMetadataKey","serializeRelayQueryCall","warning"],"id":"GraphQLRange","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLRange\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst GraphQLSegment = require('GraphQLSegment');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayRecord = require('RelayRecord');\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst rangeOperationToMetadataKey = require('rangeOperationToMetadataKey');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\nconst warning = require('warning');\n\nvar {\n  END_CURSOR,\n  HAS_NEXT_PAGE,\n  HAS_PREV_PAGE,\n  START_CURSOR,\n} = RelayConnectionInterface;\n\n/**\n * @param {array<object>} queryCalls\n * @return {object}\n */\nfunction callsArrayToObject(queryCalls) {\n  var calls = {};\n  for (var ii = 0; ii < queryCalls.length; ii++) {\n    if (RelayConnectionInterface.isConnectionCall(queryCalls[ii])) {\n      var {name, value} = queryCalls[ii];\n      // assuming that range calls will only have a single argument\n      if (Array.isArray(value) && value.length) {\n        value = value[0];\n      }\n      // Ignore the whole call when the value is null\n      if (value === null) {\n        continue;\n      }\n      calls[name] = value;\n    }\n  }\n  // update first and last call values to be numbers\n  if (calls.first) {\n    invariant(\n      !isNaN(calls.first),\n      'GraphQLRange: Expected `first` argument to be a number, got ' +\n      '`%s`.',\n      calls.first\n    );\n    calls.first = +calls.first;\n  } else if (calls.last) {\n    invariant(\n      !isNaN(calls.last),\n      'GraphQLRange: Expected `last` argument to be a number, got ' +\n      '`%s`.',\n      calls.last\n    );\n    calls.last = +calls.last;\n  }\n  return calls;\n}\n\n/**\n * Returns whether this is currently a set of static calls that GraphQLRange\n * supports. Static calls define ranges that do not change over a period\n * of time, given the same set of arguments.\n *\n * @param {object} calls\n * @return {?boolean}\n */\nfunction isStaticCall(calls) {\n  return calls.hasOwnProperty('surrounds') || calls.hasOwnProperty('find');\n}\n\n/**\n * Returns whether this is currently a set of calls that GraphQLRange\n * supports\n *\n * @param {object} calls\n * @return {boolean}\n */\nfunction isValidRangeCall(calls) {\n  var hasFirst = calls.hasOwnProperty('first');\n  var hasLast = calls.hasOwnProperty('last');\n\n  // Currently only supports: first(), after().first(), last(), before().last()\n  // before().first(), after().last(), after().before().first(), and\n  // after().before().last()\n  // first() can never be called with last().\n  return ((hasFirst || hasLast) && !(hasFirst && hasLast));\n}\n\n/**\n * Returns whether the call values are supported by GraphQLRange\n *\n * @param {object} calls\n * @return {boolean}\n */\nfunction isValidRangeCallValues(calls) {\n  return (calls.hasOwnProperty('first') && calls.first > 0) ||\n         (calls.hasOwnProperty('last') && calls.last > 0);\n}\n\n/**\n * Validates edge to ensure it has all the fields needed to be store properly.\n *\n * @param {object} edge\n */\nfunction validateEdge(edge) {\n  invariant(\n    RelayRecord.getDataID(edge) !== undefined,\n    'GraphQLStore: `edge` must have a data id'\n  );\n  invariant(\n    edge.node !== undefined,\n    'GraphQLStore: `edge` must have `node` field'\n  );\n}\n\n/**\n * @param {array<object>} edges\n */\nfunction validateEdges(edges) {\n  edges.forEach(validateEdge);\n}\n\n/**\n * A range represents an ordered set of edges. Methods are provided for adding\n * edges (`appendEdge`, `prependEdge`, `addItems`) and removing them\n * (`removeEdgeWithID`).\n *\n * Within a range, each contiguous group of edges is modeled using a\n * `GraphQLSegment`, but this is an implementation detail that `GraphQLRange`\n * hides from its callers.\n *\n * Ranges model GraphQL connections, which are the means of traversing from a\n * node to a set of associated objects; for example, in the following query the\n * \"friends\" connection produces a range containing edges that lead to the\n * requested friend nodes:\n *\n *     node(4) {\n *       friends.first(2) {\n *         edges {\n *           node {\n *             id,\n *             name,\n *           },\n *         },\n *       },\n *     }\n *\n * @see `GraphQLSegment`\n * @see \"Connections\" in https://fburl.com/graphql-connections\n * @internal\n */\nclass GraphQLRange {\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    // List of segments where each segment is a continuous chunk.\n    // There are gaps in between the segments. The first segment in the list\n    // should be cursors beginning at the top of the range (i.e. first(N)).\n    // The last segment in the list should be cursors at the bottom of\n    // the range (i.e. last(N)).\n    this._orderedSegments = [\n      new GraphQLSegment(),\n      new GraphQLSegment(),\n    ];\n\n    // GraphQLRange nodes can also support static queries like surrounds,\n    // find, whose contents won't ever change for a given set of arguments.\n    // Store these queries' results in this map, since you can't do first()\n    // or last() queries on these ranges.\n    this._staticQueriesMap = {};\n\n    this._hasFirst = false;\n    this._hasLast = false;\n  }\n\n  /**\n   * @param {number} index\n   */\n  _resetSegment(index) {\n    invariant(\n      index >= 0 && index < this._orderedSegments.length,\n      'cannot reset non-existent segment'\n    );\n    this._orderedSegments[index] = new GraphQLSegment();\n  }\n\n  /**\n   * @param {string} cursor\n   * @return {?number}\n   */\n  _getSegmentIndexByCursor(cursor) {\n    // TODO: revisit if we end up having too many segments\n    for (var ii = 0; ii < this._orderedSegments.length; ii++) {\n      if (this._orderedSegments[ii].containsEdgeWithCursor(cursor)) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {string} id\n   * @return {?number}\n   */\n  _getSegmentIndexByID(id) {\n    // TODO: revisit if we end up having too many segments\n    for (var ii = 0; ii < this._orderedSegments.length; ii++) {\n      if (this._orderedSegments[ii].containsEdgeWithID(id)) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add edges' data into the static queries map for the query calls,\n   * overwriting any previously existing data for these calls.\n   * @param {array<object>} queryCalls\n   * @param {array} edges\n   */\n  _addStaticEdges(queryCalls, edges) {\n    var calls = _callsToString(queryCalls);\n    var edgeIDsToStore = [];\n    var cursorsToStore = [];\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      edgeIDsToStore.push(RelayRecord.getDataID(edge));\n      cursorsToStore.push(edge.cursor);\n    }\n\n    this._staticQueriesMap[calls] = {\n      edgeIDs: edgeIDsToStore,\n      cursors: cursorsToStore,\n    };\n  }\n\n  /**\n   * Add edges into the range based on the query calls. New edges will replace\n   * previous edges in the range.\n   * @param {array<object>} queryCalls\n   * @param {array} edges\n   * @param {object} pageInfo\n   */\n  addItems(queryCalls, edges, pageInfo) {\n    validateEdges(edges);\n    var calls = callsArrayToObject(queryCalls);\n    var segmentCount, segmentIndex;\n\n    if (isStaticCall(calls)) {\n      this._addStaticEdges(queryCalls, edges);\n      return;\n    }\n\n    if (!isValidRangeCall(calls)) {\n      console.error(\n        'GraphQLRange currently only handles first(<count>), ' +\n        'after(<cursor>).first(<count>), last(<count>), ' +\n        'before(<cursor>).last(<count>), before(<cursor>).first(<count>), ' +\n        'and after(<cursor>).last(<count>)'\n      );\n      return;\n    }\n\n    // Skip the update if cursors are invalid\n    if (calls.before === null || calls.after === null) {\n      console.error(\n        'GraphQLRange received null as a cursor.'\n      );\n      return;\n    }\n\n    if (calls.first) {\n      // before().first() calls can produce gaps\n      if (calls.before && !calls.after) {\n        // make a new segment if there is a gap\n        if (pageInfo[HAS_NEXT_PAGE] === true) {\n          if (this._getSegmentIndexByCursor(calls.before) === 0) {\n            this._orderedSegments.unshift(\n              new GraphQLSegment()\n            );\n          }\n          // When there is a gap from before().first() query, this is the same\n          // as just storing a first().\n          this._addAfterFirstItems(\n            edges, pageInfo[HAS_NEXT_PAGE], undefined, calls.before\n          );\n        } else {\n          // Since there is no gap, we can stitch into the beginning\n          // of existing segment\n          this._addBeforeLastItems(\n            edges,\n            pageInfo[HAS_PREV_PAGE],\n            calls.before\n          );\n        }\n      } else {\n        // These elements are added from paging to extend the the range.\n        if (!calls.after) {\n          segmentIndex = 0;\n          segmentCount = this.getFirstSegment().getCount();\n          if (\n            segmentCount &&\n            (calls.first > segmentCount || edges.length > segmentCount) &&\n            !this.getFirstSegment().getFirstCursor()\n          ) {\n            // this is a range for which we don't have a cursor, and we've\n            // fetched more data by increasing the `first(N)` variable; we\n            // blow away and replace the first segment in order to side-step\n            // issues where the order of IDs in the range may change between\n            // queries\n            this._resetSegment(segmentIndex);\n          }\n        }\n        this._addAfterFirstItems(\n          edges, pageInfo[HAS_NEXT_PAGE], calls.after, calls.before\n        );\n      }\n    } else if (calls.last) {\n      // after().last() calls can produce gaps\n      if (calls.after && !calls.before) {\n        // make a new segment if there is a gap\n        if (pageInfo[HAS_PREV_PAGE] === true) {\n          if (this._getSegmentIndexByCursor(calls.after) ===\n              this._orderedSegments.length - 1) {\n            this._orderedSegments.push(new GraphQLSegment());\n          }\n          // When there is a gap from after().last() query, this is the same as\n          // just storing a last().\n          this._addBeforeLastItems(\n            edges, pageInfo[HAS_PREV_PAGE], undefined, calls.after\n          );\n        } else {\n          // Since there is no gap, we can stitch to the end\n          // of existing segment\n          this._addAfterFirstItems(\n            edges,\n            pageInfo[HAS_NEXT_PAGE],\n            calls.after\n          );\n        }\n      } else {\n        // These elements are added from paging to extend the the range.\n        if (!calls.before) {\n          segmentIndex = this._orderedSegments.length - 1;\n          segmentCount = this.getLastSegment().getCount();\n          if (\n            segmentCount &&\n            (calls.last > segmentCount || edges.length > segmentCount) &&\n            !this.getLastSegment().getLastCursor()\n          ) {\n            // this is a range for which we don't have a cursor, and we've\n            // fetched more data by increasing the `last(N)` variable; we\n            // blow away and replace the last segment in order to side-step\n            // issues where the order of IDs in the range may change between\n            // queries\n            this._resetSegment(segmentIndex);\n          }\n        }\n        this._addBeforeLastItems(\n          edges, pageInfo[HAS_PREV_PAGE], calls.before, calls.after\n        );\n      }\n    }\n  }\n\n  /**\n   * @return {GraphQLSegment}\n   */\n  getFirstSegment() {\n    return this._orderedSegments[0];\n  }\n\n  /**\n   * @return {GraphQLSegment}\n   */\n  getLastSegment() {\n    return this._orderedSegments[this._orderedSegments.length - 1];\n  }\n\n  /**\n   * Tries to concat segments at segmentIndex and segmentIndex + 1.\n   * This is an all or nothing operation.\n   * If concat is successful, we'll remove the segment at segmentIndex + 1\n   * from the orderedSegments after all elements has been added to the segment\n   * at segmentIndex.\n   * If concat is unsuccessful, nothing will be changed.\n   * @param {number} segmentIndex\n   */\n  _concatSegments(segmentIndex) {\n    invariant(\n      (segmentIndex + 1) < this._orderedSegments.length &&\n      segmentIndex >= 0,\n      'GraphQLRange cannot concat segments outside the range ' +\n      'of orderedSegments'\n    );\n    var firstSegment = this._orderedSegments[segmentIndex];\n    var secondSegment = this._orderedSegments[segmentIndex + 1];\n    if (firstSegment.concatSegment(secondSegment)) {\n      this._orderedSegments.splice(segmentIndex + 1, 1);\n    } else {\n      console.warn(\n        'GraphQLRange was unable to concat segment %d and segment %d',\n        segmentIndex,\n        segmentIndex + 1\n      );\n    }\n  }\n\n  /**\n   * Adds the edge to the front of the range. New edge will replace previous\n   * edge that have the same id.\n   * @param {object} edge\n   */\n  prependEdge(edge) {\n    validateEdge(edge);\n    this._hasFirst = true;\n    this._removeEdgeIfApplicable(edge);\n    var segment = this.getFirstSegment();\n    segment.prependEdge(edge);\n  }\n\n  /**\n   * Adds the edge to the end of the range. New edge will replace previous\n   * edge that have the same id.\n   * @param {object} edge\n   */\n  appendEdge(edge) {\n    validateEdge(edge);\n    this._hasLast = true;\n    this._removeEdgeIfApplicable(edge);\n    var segment = this.getLastSegment();\n    segment.appendEdge(edge);\n  }\n\n  /**\n   * Removes edge in range if it matches id in input edge.\n   * @param {object} edge\n   */\n  _removeEdgeIfApplicable(edge) {\n    var id = RelayRecord.getDataID(edge);\n    var index = this._getSegmentIndexByID(id);\n    if (index != null) {\n      this._orderedSegments[index].removeEdge(id);\n    }\n  }\n\n  /**\n   * Remove any edges in the range if it matches any of the ids in the input.\n   * This function is used to prevent us from adding any id that already exist\n   * in the range.\n   *\n   * @param {array} edges\n   */\n  _removeEdgesIfApplicable(edges) {\n    for (var ii = 0; ii < edges.length; ii++) {\n      this._removeEdgeIfApplicable(edges[ii]);\n    }\n  }\n\n  /**\n   * Add items into the correct segment with the cursor. If no cursor\n   * is present, items are added to the very first segment.\n   *\n   * @param {array} edges\n   * @param {boolean} hasNextPage\n   * @param {?string} afterCursor\n   * @param {?string} beforeCursor\n   */\n  _addAfterFirstItems(\n    edges,\n    hasNextPage,\n    afterCursor,\n    beforeCursor\n  ) {\n    var segment;\n    var segmentIndex;\n    var lastCursor;\n    if (afterCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(afterCursor);\n      if (segmentIndex == null) {\n        warning(\n          false,\n          'GraphQLRange cannot find a segment that has the cursor: %s',\n          afterCursor\n        );\n        return;\n      }\n      segment = this._orderedSegments[segmentIndex];\n      lastCursor = segment.getLastCursor();\n      if (lastCursor !== afterCursor) {\n        edges = this._reconcileAfterFirstEdges(segment, edges, afterCursor);\n        afterCursor = lastCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    } else {\n      segmentIndex = 0;\n      segment = this._orderedSegments[segmentIndex];\n      lastCursor = segment.getLastCursor();\n      if (lastCursor !== undefined) {\n        edges = this._reconcileAfterFirstEdges(segment, edges);\n        afterCursor = lastCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    }\n    if (beforeCursor !== undefined) {\n      if (segmentIndex === this._orderedSegments.length - 1) {\n        console.warn(\n          'GraphQLRange cannot add because there is no next segment'\n        );\n        return;\n      } else if (this._orderedSegments[segmentIndex + 1].getFirstCursor() !==\n                 beforeCursor) {\n        warning(\n          false,\n          'GraphQLRange cannot add because beforeCursor does not match first ' +\n          'cursor of the next segment'\n        );\n        return;\n      }\n    }\n\n    if (afterCursor === undefined) {\n      this._hasFirst = true;\n    }\n\n    this._removeEdgesIfApplicable(edges);\n    segment.addEdgesAfterCursor(edges, afterCursor);\n    if (!hasNextPage) {\n      if (beforeCursor !== undefined) {\n        // If we have a beforeCursor and there is no next page,\n        // then there is no gap between the current segment and the next.\n        // We can concat the two segments when there is no gap.\n        this._concatSegments(segmentIndex);\n      } else {\n        this._hasLast = true;\n        // If this segment already has the last element, we don't\n        // need any segments after this.\n        this._orderedSegments.splice(\n          segmentIndex + 1,\n          this._orderedSegments.length - 1 - segmentIndex\n        );\n      }\n    }\n  }\n\n  /**\n   * In the case the cursor does not correspond last cursor,\n   * walk through the edges to see if we can trim edges to\n   * only those after the last cursor. Returns undefined when\n   * the input cannot be reconciled.\n   *\n   * @param {GraphQLSegment} segment\n   * @param {array} edges\n   * @param {?string} cursor\n   * @return {?array} trimmed edges\n   */\n  _reconcileAfterFirstEdges(segment, edges, cursor) {\n    var metadata = segment.getMetadataAfterCursor(edges.length + 1, cursor);\n    var edgeIDs = metadata.edgeIDs;\n    if (edgeIDs.length > edges.length) {\n      // Already have more edges than the input.\n      return undefined;\n    }\n\n    for (var ii = 0; ii < edgeIDs.length; ii++) {\n      if (edgeIDs[ii] !== RelayRecord.getDataID(edges[ii])) {\n        warning(\n          false,\n          'Relay was unable to reconcile edges on a connection. This most ' +\n          'likely occurred while trying to handle a server response that ' +\n          'includes connection edges with nodes that lack an `id` field.'\n        );\n        return undefined;\n      }\n    }\n    return edges.slice(edgeIDs.length);\n  }\n\n  /**\n   * Add items into the correct segment with the cursor. If no cursor\n   * is present, items are added to the very last segment.\n   * @param {array} edges\n   * @param {boolean} hasPrevPage\n   * @param {?string} beforeCursor\n   * @param {?string} afterCursor\n   */\n  _addBeforeLastItems(\n    edges,\n    hasPrevPage,\n    beforeCursor,\n    afterCursor\n  ) {\n    var segment;\n    var segmentIndex;\n    var firstCursor;\n    if (beforeCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(beforeCursor);\n      if (segmentIndex == null) {\n        warning(\n          false,\n          'GraphQLRange cannot find a segment that has the cursor: %s',\n          beforeCursor\n        );\n        return;\n      }\n      segment = this._orderedSegments[segmentIndex];\n      firstCursor = segment.getFirstCursor();\n      if (firstCursor !== beforeCursor) {\n        edges = this._reconcileBeforeLastEdges(segment, edges, beforeCursor);\n        beforeCursor = firstCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    } else {\n      segmentIndex = this._orderedSegments.length - 1;\n      segment = this._orderedSegments[segmentIndex];\n      firstCursor = segment.getFirstCursor();\n      if (firstCursor !== undefined) {\n        edges = this._reconcileBeforeLastEdges(segment, edges, beforeCursor);\n        beforeCursor = firstCursor;\n        if (!edges) {\n          return;\n        }\n      }\n    }\n\n    if (afterCursor !== undefined) {\n      if (segmentIndex === 0) {\n        console.warn(\n          'GraphQLRange cannot add because there is no previous segment'\n        );\n        return;\n      } else if (this._orderedSegments[segmentIndex - 1].getLastCursor() !==\n                 afterCursor) {\n        warning(\n          false,\n          'GraphQLRange cannot add because afterCursor does not match last ' +\n          'cursor of the previous segment'\n        );\n        return;\n      }\n    }\n\n    if (beforeCursor === undefined) {\n      this._hasLast = true;\n    }\n\n    this._removeEdgesIfApplicable(edges);\n    segment.addEdgesBeforeCursor(edges, beforeCursor);\n    if (!hasPrevPage) {\n      if (afterCursor !== undefined) {\n        // If we have an afterCursor and there is no previous page,\n        // then there is no gap between the current segment and the previous.\n        // We can concat the two segments when there is no gap.\n        this._concatSegments(segmentIndex - 1);\n      } else {\n        this._hasFirst = true;\n        // If this segment already has the first element, we don't\n        // need any segments before this.\n        this._orderedSegments.splice(0, segmentIndex);\n      }\n    }\n  }\n\n  /**\n   * In the case the cursor does not correspond first cursor,\n   * walk through the edges to see if we can trim edges to\n   * only those before the first cursor. Returns undefined when\n   * the input cannot be reconciled.\n   *\n   * @param {GraphQLSegment} segment\n   * @param {array} edges\n   * @param {?string} cursor\n   * @return {?array} trimmed edges\n   */\n  _reconcileBeforeLastEdges(segment, edges, cursor) {\n    var metadata = segment.getMetadataBeforeCursor(edges.length + 1, cursor);\n    var edgeIDs = metadata.edgeIDs;\n    if (edgeIDs.length > edges.length) {\n      // Already have more edges than the input.\n      return undefined;\n    }\n\n    for (var ii = 1; ii <= edgeIDs.length; ii++) {\n      if (edgeIDs[edgeIDs.length - ii] !==\n          RelayRecord.getDataID(edges[edges.length - ii])) {\n        warning(\n          false,\n          'Relay was unable to reconcile edges on a connection. This most ' +\n          'likely occurred while trying to handle a server response that ' +\n          'includes connection edges with nodes that lack an `id` field.'\n        );\n        return undefined;\n      }\n    }\n    return edges.slice(0, edges.length - edgeIDs.length);\n  }\n\n  /**\n   * Removes an edge from this range such that the edge will never be reachable\n   * regardless of the client session. This is used by delete mutations.\n   *\n   * @param {string} id\n   */\n  removeEdgeWithID(id) {\n    for (var ii = 0; ii < this._orderedSegments.length; ii++) {\n      this._orderedSegments[ii].removeAllEdges(id);\n    }\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @param {?object} queuedRecord\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  retrieveRangeInfoForQuery(queryCalls, queuedRecord) {\n    var calls = callsArrayToObject(queryCalls);\n\n    if (isStaticCall(calls)) {\n      return this._retrieveRangeInfoForStaticCalls(\n        queryCalls,\n      );\n    }\n\n    // Convert to name => true, so we can test for whether the key exists\n    // without comparing to undefined\n    if (!isValidRangeCall(calls)) {\n      console.error(\n        'GraphQLRange currently only handles first(<count>), ' +\n        'after(<cursor>).first(<count>), last(<count>), ' +\n        'before(<cursor>).last(<count>), before(<cursor>).first(<count>), ' +\n        'and after(<cursor>).last(<count>)'\n      );\n      return {\n        requestedEdgeIDs: [],\n        diffCalls: [],\n        pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n      };\n    }\n    if ((calls.first && calls.before) || (calls.last && calls.after)) {\n      // TODO #7556678: add support for first/before and last/after\n      return {\n        requestedEdgeIDs: [],\n        diffCalls: [],\n        pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n      };\n    }\n    if (!isValidRangeCallValues(calls)) {\n      console.error(\n        'GraphQLRange only supports first(<count>) or last(<count>) ' +\n        'where count is greater than 0'\n      );\n      return {\n        requestedEdgeIDs: [],\n        diffCalls: [],\n        pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n      };\n    }\n    if (calls.first) {\n      return this._retrieveRangeInfoForFirstQuery(\n        queryCalls,\n        queuedRecord\n      );\n    } else if (calls.last) {\n      return this._retrieveRangeInfoForLastQuery(\n        queryCalls,\n        queuedRecord\n      );\n    }\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  _retrieveRangeInfoForStaticCalls(queryCalls) {\n    var calls = _callsToString(queryCalls);\n    var storedInfo = this._staticQueriesMap[calls];\n\n    if (storedInfo) {\n      return {\n        requestedEdgeIDs: storedInfo.edgeIDs,\n        diffCalls: [],\n        pageInfo: {\n          [START_CURSOR]: storedInfo.cursors[0],\n          [END_CURSOR]: storedInfo.cursors[storedInfo.cursors.length - 1],\n          [HAS_NEXT_PAGE]: true,\n          [HAS_PREV_PAGE]: true,\n        },\n      };\n    }\n\n    // if we don't have the data for this static call already,\n    // return empty arrays with the corresponding diffCalls\n    return {\n      requestedEdgeIDs: [],\n      diffCalls: queryCalls,\n      pageInfo: RelayConnectionInterface.getDefaultPageInfo(),\n    };\n  }\n\n  /**\n   * @param {object} queuedRecord\n   * @return {?array<string>}\n   */\n  _getAppendedIDsForQueuedRecord(queuedRecord) {\n    return queuedRecord[\n      rangeOperationToMetadataKey[GraphQLMutatorConstants.APPEND]\n    ];\n  }\n\n  /**\n   * @param {object} queuedRecord\n   * @return {?array<string>}\n   */\n  _getRemovedIDsForQueuedRecord(queuedRecord) {\n    return queuedRecord[\n      rangeOperationToMetadataKey[GraphQLMutatorConstants.REMOVE]\n    ];\n  }\n\n  /**\n   * @param {object} queuedRecord\n   * @return {?array<string>}\n   */\n  _getPrependedIDsForQueuedRecord(queuedRecord) {\n    return queuedRecord[\n      rangeOperationToMetadataKey[GraphQLMutatorConstants.PREPEND]\n    ];\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @param {?object} queuedRecord\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  _retrieveRangeInfoForFirstQuery(\n    queryCalls,\n    queuedRecord\n  ) {\n    let appendEdgeIDs;\n    let prependEdgeIDs;\n    let removeIDs;\n    if (queuedRecord) {\n      appendEdgeIDs = this._getAppendedIDsForQueuedRecord(queuedRecord);\n      prependEdgeIDs = this._getPrependedIDsForQueuedRecord(queuedRecord);\n      removeIDs = this._getRemovedIDsForQueuedRecord(queuedRecord);\n    }\n    var calls = callsArrayToObject(queryCalls);\n    let countNeeded = calls.first + (removeIDs ? removeIDs.length : 0);\n    var segment;\n    var segmentIndex;\n    var pageInfo = {\n      ...RelayConnectionInterface.getDefaultPageInfo(),\n    };\n\n    var afterCursor = calls.after;\n    if (afterCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(afterCursor);\n      if (segmentIndex == null) {\n        console.warn(\n          'GraphQLRange cannot find a segment that has the cursor: ' +\n          afterCursor\n        );\n        return {\n          requestedEdgeIDs: [],\n          diffCalls: [],\n          pageInfo: pageInfo,\n        };\n      }\n      segment = this._orderedSegments[segmentIndex];\n    } else {\n      const prependEdgesCount = prependEdgeIDs ? prependEdgeIDs.length : 0;\n      countNeeded -= prependEdgesCount;\n\n      segmentIndex = 0;\n      segment = this._orderedSegments[segmentIndex];\n    }\n\n    var requestedMetadata =\n      segment.getMetadataAfterCursor(countNeeded, afterCursor);\n    var requestedEdgeIDs = requestedMetadata.edgeIDs;\n    var requestedCursors = requestedMetadata.cursors;\n    var diffCalls = [];\n    if (requestedCursors.length) {\n      pageInfo[START_CURSOR] = requestedCursors[0];\n      pageInfo[END_CURSOR] = requestedCursors[requestedCursors.length - 1];\n    }\n    var lastID = requestedEdgeIDs[requestedEdgeIDs.length - 1];\n    // Only requested segment that does not include very last item from\n    // the range can have next page and diff calls\n    if (!this._hasLast ||\n        segmentIndex !== this._orderedSegments.length - 1 ||\n        (lastID && lastID !== segment.getLastID())) {\n      pageInfo[HAS_NEXT_PAGE] = true;\n      if (requestedEdgeIDs.length < countNeeded) {\n        countNeeded -= requestedEdgeIDs.length;\n        var lastCursor = segment.getLastCursor();\n        // If segment has null cursors, retrieve whole range.\n        if (lastCursor === null) {\n          diffCalls.push({name: 'first', value: calls.first});\n        } else {\n          if (lastCursor !== undefined) {\n            diffCalls.push({name: 'after', value: lastCursor});\n          }\n          // If this is not the last segment, we should not request edges\n          // that would overlap the first element of the next segment.\n          if (segmentIndex !== this._orderedSegments.length - 1) {\n            var nextSegment = this._orderedSegments[segmentIndex + 1];\n            var firstCursor = nextSegment.getFirstCursor();\n            if (firstCursor !== undefined) {\n              diffCalls.push({name: 'before', value: firstCursor});\n            }\n          }\n          diffCalls.push({name: 'first', value: countNeeded});\n        }\n      }\n    }\n\n    if (queuedRecord) {\n      if (prependEdgeIDs && prependEdgeIDs.length && !calls.after) {\n        requestedEdgeIDs = prependEdgeIDs.concat(requestedEdgeIDs);\n      }\n      if (appendEdgeIDs && appendEdgeIDs.length && !pageInfo[HAS_NEXT_PAGE]) {\n        requestedEdgeIDs = requestedEdgeIDs.concat(appendEdgeIDs);\n      }\n      if (removeIDs && removeIDs.length) {\n        requestedEdgeIDs = requestedEdgeIDs.filter(function(edgeID) {\n          return (removeIDs.indexOf(edgeID) == -1);\n        });\n      }\n      if (requestedEdgeIDs.length > calls.first) {\n        requestedEdgeIDs = requestedEdgeIDs.slice(0, calls.first);\n      }\n    }\n\n    return {\n      requestedEdgeIDs: requestedEdgeIDs,\n      diffCalls: diffCalls,\n      pageInfo: pageInfo,\n    };\n  }\n\n  /**\n   * @param {array<object>} queryCalls\n   * @param {?object} queuedRecord\n   * @return {object} includes fields: requestedEdgeIDs, diffCalls\n   */\n  _retrieveRangeInfoForLastQuery(\n    queryCalls,\n    queuedRecord\n  ) {\n    let appendEdgeIDs;\n    let prependEdgeIDs;\n    let removeIDs;\n    if (queuedRecord) {\n      appendEdgeIDs = this._getAppendedIDsForQueuedRecord(queuedRecord);\n      prependEdgeIDs = this._getPrependedIDsForQueuedRecord(queuedRecord);\n      removeIDs = this._getRemovedIDsForQueuedRecord(queuedRecord);\n    }\n    var calls = callsArrayToObject(queryCalls);\n    let countNeeded = calls.last + (removeIDs ? removeIDs.length : 0);\n    var segment;\n    var segmentIndex;\n    var pageInfo = {\n      ...RelayConnectionInterface.getDefaultPageInfo(),\n    };\n\n    var beforeCursor = calls.before;\n    if (beforeCursor !== undefined) {\n      segmentIndex = this._getSegmentIndexByCursor(beforeCursor);\n      if (segmentIndex == null) {\n        console.warn(\n          'GraphQLRange cannot find a segment that has the cursor: ' +\n          beforeCursor\n        );\n        return {\n          requestedEdgeIDs: [],\n          diffCalls: [],\n          pageInfo: pageInfo,\n        };\n      }\n      segment = this._orderedSegments[segmentIndex];\n    } else {\n      const appendEdgesCount = appendEdgeIDs ? appendEdgeIDs.length : 0;\n      countNeeded -= appendEdgesCount;\n\n      segmentIndex = this._orderedSegments.length - 1;\n      segment = this._orderedSegments[segmentIndex];\n    }\n\n    var requestedMetadata =\n      segment.getMetadataBeforeCursor(countNeeded, beforeCursor);\n    var requestedEdgeIDs = requestedMetadata.edgeIDs;\n    var requestedCursors = requestedMetadata.cursors;\n    var diffCalls = [];\n    if (requestedCursors.length) {\n      pageInfo[START_CURSOR] = requestedCursors[0];\n      pageInfo[END_CURSOR] = requestedCursors[requestedCursors.length - 1];\n    }\n    var firstID = requestedEdgeIDs[0];\n    // Only requested segment that does not include very first item from\n    // the range can have next page and diff calls\n    if (!this._hasFirst ||\n        segmentIndex !== 0 ||\n        (firstID && firstID !== segment.getFirstID())) {\n      pageInfo[HAS_PREV_PAGE] = true;\n      if (requestedEdgeIDs.length < countNeeded) {\n        countNeeded -= requestedEdgeIDs.length;\n        var firstCursor = segment.getFirstCursor();\n        // If segment has null cursors, retrieve whole range.\n        if (firstCursor === null) {\n          diffCalls.push({name: 'last', value: calls.last});\n        } else {\n          if (firstCursor !== undefined) {\n            diffCalls.push({name: 'before', value: firstCursor});\n          }\n          // If this is not the first segment, we should not request edges\n          // that would overlap the last element of the previous segment.\n          if (segmentIndex !== 0) {\n            var prevSegment = this._orderedSegments[segmentIndex - 1];\n            var lastCursor = prevSegment.getLastCursor();\n            if (lastCursor !== undefined) {\n              diffCalls.push({name: 'after', value: lastCursor});\n            }\n          }\n          diffCalls.push({name: 'last', value: countNeeded});\n        }\n      }\n    }\n\n    if (queuedRecord) {\n      if (appendEdgeIDs && appendEdgeIDs.length && !calls.before) {\n        requestedEdgeIDs = requestedEdgeIDs.concat(appendEdgeIDs);\n      }\n      if (prependEdgeIDs && prependEdgeIDs.length && !pageInfo[HAS_PREV_PAGE]) {\n        requestedEdgeIDs = prependEdgeIDs.concat(requestedEdgeIDs);\n      }\n      if (removeIDs && removeIDs.length) {\n        requestedEdgeIDs = requestedEdgeIDs.filter(function(edgeID) {\n          return (removeIDs.indexOf(edgeID) == -1);\n        });\n      }\n      if (requestedEdgeIDs.length > calls.last) {\n        var length = requestedEdgeIDs.length;\n        requestedEdgeIDs = requestedEdgeIDs.slice(length - calls.last, length);\n      }\n    }\n\n    return {\n      requestedEdgeIDs: requestedEdgeIDs,\n      diffCalls: diffCalls,\n      pageInfo: pageInfo,\n    };\n  }\n\n  static fromJSON(descriptor) {\n    var [\n      hasFirst,\n      hasLast,\n      staticQueriesMap,\n      orderedSegments,\n    ] = descriptor;\n    var range = new GraphQLRange();\n    range._hasFirst = hasFirst;\n    range._hasLast = hasLast;\n    range._staticQueriesMap = staticQueriesMap;\n    range._orderedSegments =\n      orderedSegments.map(descriptor => GraphQLSegment.fromJSON(descriptor));\n    return range;\n  }\n\n  toJSON() {\n    return [\n      this._hasFirst,\n      this._hasLast,\n      this._staticQueriesMap,\n      this._orderedSegments,\n    ];\n  }\n\n  __debug() {\n    return {\n      orderedSegments: this._orderedSegments,\n    };\n  }\n\n  getEdgeIDs() {\n    var edgeIDs = [];\n    this._orderedSegments.forEach(segment => {\n      edgeIDs.push(...segment.getEdgeIDs());\n    });\n    forEachObject(this._staticQueriesMap, (query) => {\n      edgeIDs.push(...query.edgeIDs);\n    });\n    return edgeIDs;\n  }\n}\n\n/**\n * @param {array<object>} calls\n * @return {string}\n */\nfunction _callsToString(calls) {\n  return calls.map(\n    call => serializeRelayQueryCall(call).substring(1)\n  ).join(',');\n}\n\nmodule.exports = GraphQLRange;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/GraphQLQueryRunner.js":{"metadata":{"mtime":1456974578000},"data":{"name":"GraphQLQueryRunner","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLQueryRunner\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayFetchMode = require('RelayFetchMode');\nimport type {FetchMode} from 'RelayFetchMode';\nimport type {RelayQuerySet} from 'RelayInternalTypes';\nimport type {PendingFetch} from 'RelayPendingQueryTracker';\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nconst RelayReadyState = require('RelayReadyState');\nimport type RelayStoreData from 'RelayStoreData';\nconst RelayTaskScheduler = require('RelayTaskScheduler');\n\nconst checkRelayQueryData = require('checkRelayQueryData');\nconst diffRelayQuery = require('diffRelayQuery');\nconst everyObject = require('everyObject');\nconst flattenSplitRelayQueries = require('flattenSplitRelayQueries');\nconst forEachObject = require('forEachObject');\nconst generateForceIndex = require('generateForceIndex');\nconst mapObject = require('mapObject');\nconst resolveImmediate = require('resolveImmediate');\nconst someObject = require('someObject');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\nconst warning = require('warning');\n\nimport type {\n  Abortable,\n  ReadyStateChangeCallback,\n} from 'RelayTypes';\n\n/**\n * This is the high-level entry point for sending queries to the GraphQL\n * endpoint. It provides methods for scheduling queries (`run`), force-fetching\n * queries (ie. ignoring the cache; `forceFetch`).\n *\n * In order to send minimal queries and avoid re-retrieving data,\n * `GraphQLQueryRunner` maintains a registry of pending (in-flight) queries, and\n * \"subtracts\" those from any new queries that callers enqueue.\n *\n * @internal\n */\nclass GraphQLQueryRunner {\n  _storeData: RelayStoreData;\n\n  constructor(storeData: RelayStoreData) {\n    this._storeData = storeData;\n  }\n\n  /**\n   * Fetches data required to resolve a set of queries. See the `RelayStore`\n   * module for documentation on the callback.\n   */\n  run(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback,\n    fetchMode?: FetchMode = RelayFetchMode.CLIENT\n  ): Abortable {\n    return runQueries(this._storeData, querySet, callback, fetchMode);\n  }\n\n  /**\n   * Ignores the cache and fetches data required to resolve a set of queries.\n   * Uses the data we get back from the server to overwrite data in the cache.\n   *\n   * Even though we're ignoring the cache, we will still invoke the callback\n   * immediately with `ready: true` if `querySet` can be resolved by the cache.\n   */\n  forceFetch(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback\n  ): Abortable {\n    const fetchMode = RelayFetchMode.REFETCH;\n    return runQueries(this._storeData, querySet, callback, fetchMode);\n  }\n}\n\nfunction hasItems(map: Object): boolean {\n  return !!Object.keys(map).length;\n}\n\nfunction splitAndFlattenQueries(\n  queries: Array<RelayQuery.Root>\n): Array<RelayQuery.Root> {\n  if (!RelayNetworkLayer.supports('defer')) {\n    if (__DEV__) {\n      queries.forEach(query => {\n        warning(\n          !query.hasDeferredDescendant(),\n          'Relay: Query `%s` contains a deferred fragment (e.g. ' +\n          '`getFragment(\\'foo\\').defer()`) which is not supported by the ' +\n          'default network layer. This query will be sent without deferral.',\n          query.getName()\n        );\n      });\n    }\n    return queries;\n  }\n\n  var flattenedQueries = [];\n  queries.forEach(query => {\n    return flattenedQueries.push(\n      ...flattenSplitRelayQueries(\n        splitDeferredRelayQueries(query)\n      )\n    );\n  });\n  return flattenedQueries;\n}\n\nfunction runQueries(\n  storeData: RelayStoreData,\n  querySet: RelayQuerySet,\n  callback: ReadyStateChangeCallback,\n  fetchMode: FetchMode\n): Abortable {\n  const profiler = fetchMode === RelayFetchMode.REFETCH ?\n    RelayProfiler.profile('GraphQLQueryRunner.forceFetch') :\n    RelayProfiler.profile('GraphQLQueryRunner.primeCache');\n\n  const readyState = new RelayReadyState(callback);\n\n  var remainingFetchMap: {[queryID: string]: PendingFetch} = {};\n  var remainingRequiredFetchMap: {[queryID: string]: PendingFetch} = {};\n\n  function onResolved(pendingFetch: PendingFetch) {\n    var pendingQuery = pendingFetch.getQuery();\n    var pendingQueryID = pendingQuery.getID();\n    delete remainingFetchMap[pendingQueryID];\n    if (!pendingQuery.isDeferred()) {\n      delete remainingRequiredFetchMap[pendingQueryID];\n    }\n\n    if (hasItems(remainingRequiredFetchMap)) {\n      return;\n    }\n\n    if (someObject(remainingFetchMap, query => query.isResolvable())) {\n      // The other resolvable query will resolve imminently and call\n      // `readyState.update` instead.\n      return;\n    }\n\n    if (hasItems(remainingFetchMap)) {\n      readyState.update({done: false, ready: true, stale: false});\n    } else {\n      readyState.update({done: true, ready: true, stale: false});\n    }\n  }\n\n  function onRejected(pendingFetch: PendingFetch, error: Error) {\n    readyState.update({error});\n\n    var pendingQuery = pendingFetch.getQuery();\n    var pendingQueryID = pendingQuery.getID();\n    delete remainingFetchMap[pendingQueryID];\n    if (!pendingQuery.isDeferred()) {\n      delete remainingRequiredFetchMap[pendingQueryID];\n    }\n  }\n\n  function canResolve(fetch: PendingFetch): boolean {\n    return checkRelayQueryData(\n      storeData.getQueuedStore(),\n      fetch.getQuery()\n    );\n  }\n\n  RelayTaskScheduler.enqueue(() => {\n    const forceIndex = fetchMode === RelayFetchMode.REFETCH ?\n      generateForceIndex() :\n      null;\n\n    const queries = [];\n    if (fetchMode === RelayFetchMode.CLIENT) {\n      forEachObject(querySet, query => {\n        if (query) {\n          queries.push(...diffRelayQuery(\n            query,\n            storeData.getRecordStore(),\n            storeData.getQueryTracker()\n          ));\n        }\n      });\n    } else {\n      forEachObject(querySet, query => {\n        if (query) {\n          queries.push(query);\n        }\n      });\n    }\n\n    splitAndFlattenQueries(queries).forEach(query => {\n      var pendingFetch = storeData.getPendingQueryTracker().add(\n        {query, fetchMode, forceIndex, storeData}\n      );\n      var queryID = query.getID();\n      remainingFetchMap[queryID] = pendingFetch;\n      if (!query.isDeferred()) {\n        remainingRequiredFetchMap[queryID] = pendingFetch;\n      }\n      pendingFetch.getResolvedPromise().then(\n        onResolved.bind(null, pendingFetch),\n        onRejected.bind(null, pendingFetch)\n      );\n    });\n\n    if (!hasItems(remainingFetchMap)) {\n      readyState.update({done: true, ready: true});\n    } else {\n      if (!hasItems(remainingRequiredFetchMap)) {\n        readyState.update({ready: true});\n      } else {\n        readyState.update({ready: false});\n        resolveImmediate(() => {\n          if (storeData.hasCacheManager()) {\n            var requiredQueryMap = mapObject(\n              remainingRequiredFetchMap,\n              value => value.getQuery()\n            );\n            storeData.readFromDiskCache(requiredQueryMap, {\n              onSuccess: () => {\n                if (hasItems(remainingRequiredFetchMap)) {\n                  readyState.update({ready: true, stale: true});\n                }\n              },\n            });\n          } else {\n            if (everyObject(remainingRequiredFetchMap, canResolve)) {\n              if (hasItems(remainingRequiredFetchMap)) {\n                readyState.update({ready: true, stale: true});\n              }\n            }\n          }\n        });\n      }\n    }\n    // Stop profiling when queries have been sent to the network layer.\n    profiler.stop();\n  }).done();\n\n  return {\n    abort(): void {\n      readyState.update({aborted: true});\n    },\n  };\n}\n\nmodule.exports = GraphQLQueryRunner;\n","dependencies":["RelayFetchMode","RelayInternalTypes","RelayPendingQueryTracker","RelayQuery","RelayStoreData","RelayTypes","RelayNetworkLayer","RelayProfiler","RelayReadyState","RelayTaskScheduler","checkRelayQueryData","diffRelayQuery","everyObject","flattenSplitRelayQueries","forEachObject","generateForceIndex","mapObject","resolveImmediate","someObject","splitDeferredRelayQueries","warning","GraphQLQueryRunner"],"id":"GraphQLQueryRunner","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule GraphQLQueryRunner\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayFetchMode = require('RelayFetchMode');\nimport type {FetchMode} from 'RelayFetchMode';\nimport type {RelayQuerySet} from 'RelayInternalTypes';\nimport type {PendingFetch} from 'RelayPendingQueryTracker';\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nconst RelayReadyState = require('RelayReadyState');\nimport type RelayStoreData from 'RelayStoreData';\nconst RelayTaskScheduler = require('RelayTaskScheduler');\n\nconst checkRelayQueryData = require('checkRelayQueryData');\nconst diffRelayQuery = require('diffRelayQuery');\nconst everyObject = require('everyObject');\nconst flattenSplitRelayQueries = require('flattenSplitRelayQueries');\nconst forEachObject = require('forEachObject');\nconst generateForceIndex = require('generateForceIndex');\nconst mapObject = require('mapObject');\nconst resolveImmediate = require('resolveImmediate');\nconst someObject = require('someObject');\nconst splitDeferredRelayQueries = require('splitDeferredRelayQueries');\nconst warning = require('warning');\n\nimport type {\n  Abortable,\n  ReadyStateChangeCallback,\n} from 'RelayTypes';\n\n/**\n * This is the high-level entry point for sending queries to the GraphQL\n * endpoint. It provides methods for scheduling queries (`run`), force-fetching\n * queries (ie. ignoring the cache; `forceFetch`).\n *\n * In order to send minimal queries and avoid re-retrieving data,\n * `GraphQLQueryRunner` maintains a registry of pending (in-flight) queries, and\n * \"subtracts\" those from any new queries that callers enqueue.\n *\n * @internal\n */\nclass GraphQLQueryRunner {\n  _storeData: RelayStoreData;\n\n  constructor(storeData: RelayStoreData) {\n    this._storeData = storeData;\n  }\n\n  /**\n   * Fetches data required to resolve a set of queries. See the `RelayStore`\n   * module for documentation on the callback.\n   */\n  run(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback,\n    fetchMode?: FetchMode = RelayFetchMode.CLIENT\n  ): Abortable {\n    return runQueries(this._storeData, querySet, callback, fetchMode);\n  }\n\n  /**\n   * Ignores the cache and fetches data required to resolve a set of queries.\n   * Uses the data we get back from the server to overwrite data in the cache.\n   *\n   * Even though we're ignoring the cache, we will still invoke the callback\n   * immediately with `ready: true` if `querySet` can be resolved by the cache.\n   */\n  forceFetch(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback\n  ): Abortable {\n    const fetchMode = RelayFetchMode.REFETCH;\n    return runQueries(this._storeData, querySet, callback, fetchMode);\n  }\n}\n\nfunction hasItems(map: Object): boolean {\n  return !!Object.keys(map).length;\n}\n\nfunction splitAndFlattenQueries(\n  queries: Array<RelayQuery.Root>\n): Array<RelayQuery.Root> {\n  if (!RelayNetworkLayer.supports('defer')) {\n    if (__DEV__) {\n      queries.forEach(query => {\n        warning(\n          !query.hasDeferredDescendant(),\n          'Relay: Query `%s` contains a deferred fragment (e.g. ' +\n          '`getFragment(\\'foo\\').defer()`) which is not supported by the ' +\n          'default network layer. This query will be sent without deferral.',\n          query.getName()\n        );\n      });\n    }\n    return queries;\n  }\n\n  var flattenedQueries = [];\n  queries.forEach(query => {\n    return flattenedQueries.push(\n      ...flattenSplitRelayQueries(\n        splitDeferredRelayQueries(query)\n      )\n    );\n  });\n  return flattenedQueries;\n}\n\nfunction runQueries(\n  storeData: RelayStoreData,\n  querySet: RelayQuerySet,\n  callback: ReadyStateChangeCallback,\n  fetchMode: FetchMode\n): Abortable {\n  const profiler = fetchMode === RelayFetchMode.REFETCH ?\n    RelayProfiler.profile('GraphQLQueryRunner.forceFetch') :\n    RelayProfiler.profile('GraphQLQueryRunner.primeCache');\n\n  const readyState = new RelayReadyState(callback);\n\n  var remainingFetchMap: {[queryID: string]: PendingFetch} = {};\n  var remainingRequiredFetchMap: {[queryID: string]: PendingFetch} = {};\n\n  function onResolved(pendingFetch: PendingFetch) {\n    var pendingQuery = pendingFetch.getQuery();\n    var pendingQueryID = pendingQuery.getID();\n    delete remainingFetchMap[pendingQueryID];\n    if (!pendingQuery.isDeferred()) {\n      delete remainingRequiredFetchMap[pendingQueryID];\n    }\n\n    if (hasItems(remainingRequiredFetchMap)) {\n      return;\n    }\n\n    if (someObject(remainingFetchMap, query => query.isResolvable())) {\n      // The other resolvable query will resolve imminently and call\n      // `readyState.update` instead.\n      return;\n    }\n\n    if (hasItems(remainingFetchMap)) {\n      readyState.update({done: false, ready: true, stale: false});\n    } else {\n      readyState.update({done: true, ready: true, stale: false});\n    }\n  }\n\n  function onRejected(pendingFetch: PendingFetch, error: Error) {\n    readyState.update({error});\n\n    var pendingQuery = pendingFetch.getQuery();\n    var pendingQueryID = pendingQuery.getID();\n    delete remainingFetchMap[pendingQueryID];\n    if (!pendingQuery.isDeferred()) {\n      delete remainingRequiredFetchMap[pendingQueryID];\n    }\n  }\n\n  function canResolve(fetch: PendingFetch): boolean {\n    return checkRelayQueryData(\n      storeData.getQueuedStore(),\n      fetch.getQuery()\n    );\n  }\n\n  RelayTaskScheduler.enqueue(() => {\n    const forceIndex = fetchMode === RelayFetchMode.REFETCH ?\n      generateForceIndex() :\n      null;\n\n    const queries = [];\n    if (fetchMode === RelayFetchMode.CLIENT) {\n      forEachObject(querySet, query => {\n        if (query) {\n          queries.push(...diffRelayQuery(\n            query,\n            storeData.getRecordStore(),\n            storeData.getQueryTracker()\n          ));\n        }\n      });\n    } else {\n      forEachObject(querySet, query => {\n        if (query) {\n          queries.push(query);\n        }\n      });\n    }\n\n    splitAndFlattenQueries(queries).forEach(query => {\n      var pendingFetch = storeData.getPendingQueryTracker().add(\n        {query, fetchMode, forceIndex, storeData}\n      );\n      var queryID = query.getID();\n      remainingFetchMap[queryID] = pendingFetch;\n      if (!query.isDeferred()) {\n        remainingRequiredFetchMap[queryID] = pendingFetch;\n      }\n      pendingFetch.getResolvedPromise().then(\n        onResolved.bind(null, pendingFetch),\n        onRejected.bind(null, pendingFetch)\n      );\n    });\n\n    if (!hasItems(remainingFetchMap)) {\n      readyState.update({done: true, ready: true});\n    } else {\n      if (!hasItems(remainingRequiredFetchMap)) {\n        readyState.update({ready: true});\n      } else {\n        readyState.update({ready: false});\n        resolveImmediate(() => {\n          if (storeData.hasCacheManager()) {\n            var requiredQueryMap = mapObject(\n              remainingRequiredFetchMap,\n              value => value.getQuery()\n            );\n            storeData.readFromDiskCache(requiredQueryMap, {\n              onSuccess: () => {\n                if (hasItems(remainingRequiredFetchMap)) {\n                  readyState.update({ready: true, stale: true});\n                }\n              },\n            });\n          } else {\n            if (everyObject(remainingRequiredFetchMap, canResolve)) {\n              if (hasItems(remainingRequiredFetchMap)) {\n                readyState.update({ready: true, stale: true});\n              }\n            }\n          }\n        });\n      }\n    }\n    // Stop profiling when queries have been sent to the network layer.\n    profiler.stop();\n  }).done();\n\n  return {\n    abort(): void {\n      readyState.update({aborted: true});\n    },\n  };\n}\n\nmodule.exports = GraphQLQueryRunner;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/generateForceIndex.js":{"metadata":{"mtime":1455679338000},"data":{"name":"generateForceIndex","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateForceIndex\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nvar _index = 1;\n\n/**\n * Generate a new force index used to write GraphQL data in the store. A new\n * force index can be used to overwrite previous ranges.\n *\n * @internal\n */\nfunction generateForceIndex(): number {\n  return _index++;\n}\n\nmodule.exports = generateForceIndex;\n","dependencies":["generateForceIndex"],"id":"generateForceIndex","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateForceIndex\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nvar _index = 1;\n\n/**\n * Generate a new force index used to write GraphQL data in the store. A new\n * force index can be used to overwrite previous ranges.\n *\n * @internal\n */\nfunction generateForceIndex(): number {\n  return _index++;\n}\n\nmodule.exports = generateForceIndex;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/generateClientID.js":{"metadata":{"mtime":1455679338000},"data":{"name":"generateClientID","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateClientID\n * @typechecks\n */\n\n'use strict';\n\nconst crc32 = require('crc32');\nconst performanceNow = require('performanceNow');\n\nvar _clientID = 1;\nvar _prefix = 'client:' + crc32('' + performanceNow());\n\n/**\n * Generate a unique clientID for GraphQL data objects that do not already have\n * an ID or their ID = null\n *\n * @internal\n */\nfunction generateClientID() {\n  return _prefix + _clientID++;\n}\n\nmodule.exports = generateClientID;\n","dependencies":["crc32","performanceNow","generateClientID"],"id":"generateClientID","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateClientID\n * @typechecks\n */\n\n'use strict';\n\nconst crc32 = require('crc32');\nconst performanceNow = require('performanceNow');\n\nvar _clientID = 1;\nvar _prefix = 'client:' + crc32('' + performanceNow());\n\n/**\n * Generate a unique clientID for GraphQL data objects that do not already have\n * an ID or their ID = null\n *\n * @internal\n */\nfunction generateClientID() {\n  return _prefix + _clientID++;\n}\n\nmodule.exports = generateClientID;\n"}}},"/Users/cpojer/Projects/relay/src/legacy/store/generateClientEdgeID.js":{"metadata":{"mtime":1455679338000},"data":{"name":"generateClientEdgeID","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateClientEdgeID\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Generate an edge client id for edges on connections based on the range it\n * belongs to and the node it contains.\n *\n * @internal\n */\nfunction generateClientEdgeID(rangeID: string, nodeID: string): string {\n  return 'client:' + rangeID + ':' +  nodeID;\n}\n\nmodule.exports = generateClientEdgeID;\n","dependencies":["generateClientEdgeID"],"id":"generateClientEdgeID","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateClientEdgeID\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Generate an edge client id for edges on connections based on the range it\n * belongs to and the node it contains.\n *\n * @internal\n */\nfunction generateClientEdgeID(rangeID: string, nodeID: string): string {\n  return 'client:' + rangeID + ':' +  nodeID;\n}\n\nmodule.exports = generateClientEdgeID;\n"}}},"/Users/cpojer/Projects/relay/src/interface/__mocks__/RelayOSSNodeInterface.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayOSSNodeInterface');\n","dependencies":["RelayOSSNodeInterface"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayOSSNodeInterface');\n"},"name":"/Users/cpojer/Projects/relay/src/interface/__mocks__/RelayOSSNodeInterface.js"}},"/Users/cpojer/Projects/relay/src/interface/__mocks__/RelayOSSConnectionInterface.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayOSSConnectionInterface');\n","dependencies":["RelayOSSConnectionInterface"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayOSSConnectionInterface');\n"},"name":"/Users/cpojer/Projects/relay/src/interface/__mocks__/RelayOSSConnectionInterface.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/RelayPropTypes.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayPropTypes');\n","dependencies":["RelayPropTypes"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayPropTypes');\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/RelayPropTypes.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/RelayOSSContainerProxy.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayOSSContainerProxy');\n","dependencies":["RelayOSSContainerProxy"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayOSSContainerProxy');\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/RelayOSSContainerProxy.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/RelayContainer.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayContainer');\n","dependencies":["RelayContainer"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayContainer');\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/RelayContainer.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/prepareRelayOSSContainerProps.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('prepareRelayOSSContainerProps');\n","dependencies":["prepareRelayOSSContainerProps"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('prepareRelayOSSContainerProps');\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/prepareRelayOSSContainerProps.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/isRelayContainer.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isRelayContainer');\n","dependencies":["isRelayContainer"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isRelayContainer');\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/isRelayContainer.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/isReactComponent.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isReactComponent');\n","dependencies":["isReactComponent"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('isReactComponent');\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/isReactComponent.js"}},"/Users/cpojer/Projects/relay/src/container/__mocks__/getRelayQueries.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar getRelayQueries = require.requireActual('getRelayQueries');\n\nmodule.exports = jest.genMockFunction().mockImplementation(getRelayQueries);\n","dependencies":["getRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nvar getRelayQueries = require.requireActual('getRelayQueries');\n\nmodule.exports = jest.genMockFunction().mockImplementation(getRelayQueries);\n"},"name":"/Users/cpojer/Projects/relay/src/container/__mocks__/getRelayQueries.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_validation-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactTestUtils = require('ReactTestUtils');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayRenderer.validation', () => {\n  let MockComponent;\n  let MockContainer;\n  let ShallowRenderer;\n\n  let queryConfig;\n  const {error} = console;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n    ShallowRenderer = ReactTestUtils.createRenderer();\n\n    queryConfig = RelayQueryConfig.genMockInstance();\n\n    console.error = jest.genMockFunction().mockImplementation(message => {\n      throw new Error(message.replace(/Composite propType/, 'propType'));\n    });\n  });\n\n  afterEach(() => {\n    console.error = error;\n  });\n\n  it('requires a valid `Container` prop', () => {\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer queryConfig={queryConfig} />\n    )).toThrowError(\n      'Warning: Failed propType: Required prop `Container` was not specified ' +\n      'in `RelayRenderer`.'\n    );\n\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer Container={MockComponent} queryConfig={queryConfig} />\n    )).toThrowError(\n      'Warning: Failed propType: Invalid prop `Container` supplied to ' +\n      '`RelayRenderer`, expected a RelayContainer.'\n    );\n  });\n\n  it('requires a valid `queryConfig` prop', () => {\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer Container={MockContainer} />\n    )).toThrowError(\n      'Warning: Failed propType: Required prop `queryConfig` was not ' +\n      'specified in `RelayRenderer`.'\n    );\n\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer Container={MockContainer} queryConfig={{}} />\n    )).toThrowError(\n      'Warning: Failed propType: Required prop `queryConfig.name` was not ' +\n      'specified in `RelayRenderer`.'\n    );\n  });\n\n});\n","dependencies":["configureForRelayOSS","React","ReactTestUtils","Relay","RelayQueryConfig","RelayRenderer","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactTestUtils = require('ReactTestUtils');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayRenderer.validation', () => {\n  let MockComponent;\n  let MockContainer;\n  let ShallowRenderer;\n\n  let queryConfig;\n  const {error} = console;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n    jasmine.addMatchers(RelayTestUtils.matchers);\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n    ShallowRenderer = ReactTestUtils.createRenderer();\n\n    queryConfig = RelayQueryConfig.genMockInstance();\n\n    console.error = jest.genMockFunction().mockImplementation(message => {\n      throw new Error(message.replace(/Composite propType/, 'propType'));\n    });\n  });\n\n  afterEach(() => {\n    console.error = error;\n  });\n\n  it('requires a valid `Container` prop', () => {\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer queryConfig={queryConfig} />\n    )).toThrowError(\n      'Warning: Failed propType: Required prop `Container` was not specified ' +\n      'in `RelayRenderer`.'\n    );\n\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer Container={MockComponent} queryConfig={queryConfig} />\n    )).toThrowError(\n      'Warning: Failed propType: Invalid prop `Container` supplied to ' +\n      '`RelayRenderer`, expected a RelayContainer.'\n    );\n  });\n\n  it('requires a valid `queryConfig` prop', () => {\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer Container={MockContainer} />\n    )).toThrowError(\n      'Warning: Failed propType: Required prop `queryConfig` was not ' +\n      'specified in `RelayRenderer`.'\n    );\n\n    expect(() => ShallowRenderer.render(\n      <RelayRenderer Container={MockContainer} queryConfig={{}} />\n    )).toThrowError(\n      'Warning: Failed propType: Required prop `queryConfig.name` was not ' +\n      'specified in `RelayRenderer`.'\n    );\n  });\n\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_validation-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_server-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOMServer = require('ReactDOMServer');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer', function() {\n  let MockComponent;\n  let MockContainer;\n\n  let queryConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    queryConfig = RelayQueryConfig.genMockInstance();\n  });\n\n  it('does not run queries on the server', () => {\n    ReactDOMServer.renderToString(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    expect(RelayStore.forceFetch).not.toBeCalled();\n    expect(RelayStore.primeCache).not.toBeCalled();\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOMServer","Relay","RelayQueryConfig","RelayRenderer","RelayStore"],"source":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOMServer = require('ReactDOMServer');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer', function() {\n  let MockComponent;\n  let MockContainer;\n\n  let queryConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    queryConfig = RelayQueryConfig.genMockInstance();\n  });\n\n  it('does not run queries on the server', () => {\n    ReactDOMServer.renderToString(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    expect(RelayStore.forceFetch).not.toBeCalled();\n    expect(RelayStore.primeCache).not.toBeCalled();\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_server-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_requests-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\nconst getRelayQueries = require('getRelayQueries');\n\ndescribe('RelayRenderer', function() {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n    ReactDOM.render(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n      container\n    );\n  });\n\n  it('primes queries created from `Component` and `queryConfig`', () => {\n    expect(getRelayQueries).toBeCalledWith(MockContainer, queryConfig);\n    expect(RelayStore.primeCache).toBeCalled();\n  });\n\n  it('does nothing when `Component` and `queryConfig` are unchanged', () => {\n    ReactDOM.render(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([[MockContainer, queryConfig]]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(1);\n  });\n\n  it('does nothing when `Component` and `queryConfig` are resolved', () => {\n    RelayStore.primeCache.mock.requests[0].succeed();\n\n    ReactDOM.render(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([[MockContainer, queryConfig]]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(1);\n  });\n\n  it('primes new queries when `Component` changes', () => {\n    const AnotherComponent = React.createClass({render: () => <div />});\n    const AnotherContainer = Relay.createContainer(AnotherComponent, {\n      fragments: {},\n    });\n    ReactDOM.render(\n      <RelayRenderer\n        Container={AnotherContainer}\n        queryConfig={queryConfig}\n      />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([\n      [MockContainer, queryConfig],\n      [AnotherContainer, queryConfig],\n    ]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(2);\n  });\n\n  it('primes new queries when `queryConfig` changes', () => {\n    const anotherQueryConfig = RelayQueryConfig.genMockInstance();\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={anotherQueryConfig}\n      />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([\n      [MockContainer, queryConfig],\n      [MockContainer, anotherQueryConfig],\n    ]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(2);\n  });\n\n  it('force fetches when the `forceFetch` prop is true', () => {\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        forceFetch={true}\n      />,\n      container\n    );\n    expect(getRelayQueries).toBeCalledWith(MockContainer, queryConfig);\n    expect(RelayStore.forceFetch).toBeCalled();\n  });\n\n  it('calls `onForceFetch` hook if supplied', () => {\n    const onForceFetch = jest.genMockFunction();\n    const onPrimeCache = jest.genMockFunction();\n\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        forceFetch={true}\n        onForceFetch={onForceFetch}\n        onPrimeCache={onPrimeCache}\n      />,\n      container\n    );\n    expect(onForceFetch).toBeCalled();\n    expect(onPrimeCache).not.toBeCalled();\n  });\n\n  it('calls `onPrimeCache` hook if supplied', () => {\n    const anotherQueryConfig = RelayQueryConfig.genMockInstance();\n    const onForceFetch = jest.genMockFunction();\n    const onPrimeCache = jest.genMockFunction();\n\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={anotherQueryConfig}\n        onForceFetch={onForceFetch}\n        onPrimeCache={onPrimeCache}\n      />,\n      container\n    );\n    expect(onForceFetch).not.toBeCalled();\n    expect(onPrimeCache).toBeCalled();\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOM","Relay","RelayQueryConfig","RelayRenderer","RelayStore","getRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\nconst getRelayQueries = require('getRelayQueries');\n\ndescribe('RelayRenderer', function() {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n    ReactDOM.render(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n      container\n    );\n  });\n\n  it('primes queries created from `Component` and `queryConfig`', () => {\n    expect(getRelayQueries).toBeCalledWith(MockContainer, queryConfig);\n    expect(RelayStore.primeCache).toBeCalled();\n  });\n\n  it('does nothing when `Component` and `queryConfig` are unchanged', () => {\n    ReactDOM.render(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([[MockContainer, queryConfig]]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(1);\n  });\n\n  it('does nothing when `Component` and `queryConfig` are resolved', () => {\n    RelayStore.primeCache.mock.requests[0].succeed();\n\n    ReactDOM.render(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([[MockContainer, queryConfig]]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(1);\n  });\n\n  it('primes new queries when `Component` changes', () => {\n    const AnotherComponent = React.createClass({render: () => <div />});\n    const AnotherContainer = Relay.createContainer(AnotherComponent, {\n      fragments: {},\n    });\n    ReactDOM.render(\n      <RelayRenderer\n        Container={AnotherContainer}\n        queryConfig={queryConfig}\n      />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([\n      [MockContainer, queryConfig],\n      [AnotherContainer, queryConfig],\n    ]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(2);\n  });\n\n  it('primes new queries when `queryConfig` changes', () => {\n    const anotherQueryConfig = RelayQueryConfig.genMockInstance();\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={anotherQueryConfig}\n      />,\n      container\n    );\n    expect(getRelayQueries.mock.calls).toEqual([\n      [MockContainer, queryConfig],\n      [MockContainer, anotherQueryConfig],\n    ]);\n    expect(RelayStore.primeCache.mock.calls.length).toBe(2);\n  });\n\n  it('force fetches when the `forceFetch` prop is true', () => {\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        forceFetch={true}\n      />,\n      container\n    );\n    expect(getRelayQueries).toBeCalledWith(MockContainer, queryConfig);\n    expect(RelayStore.forceFetch).toBeCalled();\n  });\n\n  it('calls `onForceFetch` hook if supplied', () => {\n    const onForceFetch = jest.genMockFunction();\n    const onPrimeCache = jest.genMockFunction();\n\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        forceFetch={true}\n        onForceFetch={onForceFetch}\n        onPrimeCache={onPrimeCache}\n      />,\n      container\n    );\n    expect(onForceFetch).toBeCalled();\n    expect(onPrimeCache).not.toBeCalled();\n  });\n\n  it('calls `onPrimeCache` hook if supplied', () => {\n    const anotherQueryConfig = RelayQueryConfig.genMockInstance();\n    const onForceFetch = jest.genMockFunction();\n    const onPrimeCache = jest.genMockFunction();\n\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={anotherQueryConfig}\n        onForceFetch={onForceFetch}\n        onPrimeCache={onPrimeCache}\n      />,\n      container\n    );\n    expect(onForceFetch).not.toBeCalled();\n    expect(onPrimeCache).toBeCalled();\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_requests-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_renderArgs-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.renderArgs', () => {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n  let render;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n\n    render = jest.genMockFunction();\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />,\n      container\n    );\n    jasmine.addMatchers({\n      toRenderWithArgs() {\n        return {\n          compare(actual, expected) {\n            // Assume that if `forceFetch` requests exist, they were last.\n            const requests = RelayStore.forceFetch.mock.requests.length > 0 ?\n              RelayStore.forceFetch.mock.requests :\n              RelayStore.primeCache.mock.requests;\n            actual(requests[requests.length - 1]);\n            const renders = render.mock.calls;\n            const renderArgs = renders[renders.length - 1][0];\n            return {\n              pass: Object.keys(expected).every(argName => {\n                expect(renderArgs[argName]).toEqual(expected[argName]);\n                return true;\n              }),\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('has default values before request is sent', () => {\n    expect(() => {\n      // Nothing.\n    }).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n  });\n\n  it('has no `props` until request is resolved', () => {\n    expect(request => request.block()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n    expect(request => request.resolve()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('is not `done` until request succeeds', () => {\n    expect(request => request.block()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n    expect(request => request.succeed()).toRenderWithArgs({\n      done: true,\n      error: null,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('has `error` when request fails before request is sent', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.fail(error)).toRenderWithArgs({\n      done: false,\n      error,\n      props: null,\n      stale: false,\n    });\n  });\n\n  it('has `error` when request fails after request is sent', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.block()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n    expect(request => request.fail(error)).toRenderWithArgs({\n      done: false,\n      error,\n      props: null,\n      stale: false,\n    });\n  });\n\n  it('has `error` and `props` when request is resolved and fails', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.resolve()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: false,\n    });\n    expect(request => request.fail(error)).toRenderWithArgs({\n      done: false,\n      error,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('is `stale` if force fetching when data is fulfillable', () => {\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        forceFetch={true}\n        render={render}\n      />,\n      container\n    );\n    expect(request => request.resolve({stale: true})).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: true,\n    });\n    expect(request => request.resolve({stale: false})).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: false,\n    });\n    expect(request => request.succeed()).toRenderWithArgs({\n      done: true,\n      error: null,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('has a `retry` function that retries the request', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.fail(error)).toRenderWithArgs({error});\n\n    const {retry} = render.mock.calls[1][0];\n    expect(typeof retry).toBe('function');\n    expect(RelayStore.primeCache.mock.calls.length).toBe(1);\n    retry();\n    expect(RelayStore.primeCache.mock.calls.length).toBe(2);\n  });\n\n  it('has a `retry` function that throws if called without failure', () => {\n    expect(request => request.block()).toRenderWithArgs({error: null});\n\n    const {retry} = render.mock.calls[1][0];\n    expect(typeof retry).toBe('function');\n    expect(() => retry()).toThrowError(\n      'RelayRenderer: You tried to call `retry`, but the last request did ' +\n      'not fail. You can only call this when the last request has failed.'\n    );\n  });\n\n  it('passes query config variables as props', () => {\n    const MockQueryConfig = RelayQueryConfig.genMock();\n    queryConfig = new MockQueryConfig({foo: 123, bar: 456});\n\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />,\n      container\n    );\n    expect(request => request.resolve()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {foo: 123, bar: 456},\n      stale: false,\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOM","Relay","RelayQueryConfig","RelayRenderer","RelayStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.renderArgs', () => {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n  let render;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n\n    render = jest.genMockFunction();\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />,\n      container\n    );\n    jasmine.addMatchers({\n      toRenderWithArgs() {\n        return {\n          compare(actual, expected) {\n            // Assume that if `forceFetch` requests exist, they were last.\n            const requests = RelayStore.forceFetch.mock.requests.length > 0 ?\n              RelayStore.forceFetch.mock.requests :\n              RelayStore.primeCache.mock.requests;\n            actual(requests[requests.length - 1]);\n            const renders = render.mock.calls;\n            const renderArgs = renders[renders.length - 1][0];\n            return {\n              pass: Object.keys(expected).every(argName => {\n                expect(renderArgs[argName]).toEqual(expected[argName]);\n                return true;\n              }),\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('has default values before request is sent', () => {\n    expect(() => {\n      // Nothing.\n    }).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n  });\n\n  it('has no `props` until request is resolved', () => {\n    expect(request => request.block()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n    expect(request => request.resolve()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('is not `done` until request succeeds', () => {\n    expect(request => request.block()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n    expect(request => request.succeed()).toRenderWithArgs({\n      done: true,\n      error: null,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('has `error` when request fails before request is sent', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.fail(error)).toRenderWithArgs({\n      done: false,\n      error,\n      props: null,\n      stale: false,\n    });\n  });\n\n  it('has `error` when request fails after request is sent', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.block()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: null,\n      stale: false,\n    });\n    expect(request => request.fail(error)).toRenderWithArgs({\n      done: false,\n      error,\n      props: null,\n      stale: false,\n    });\n  });\n\n  it('has `error` and `props` when request is resolved and fails', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.resolve()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: false,\n    });\n    expect(request => request.fail(error)).toRenderWithArgs({\n      done: false,\n      error,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('is `stale` if force fetching when data is fulfillable', () => {\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        forceFetch={true}\n        render={render}\n      />,\n      container\n    );\n    expect(request => request.resolve({stale: true})).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: true,\n    });\n    expect(request => request.resolve({stale: false})).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {},\n      stale: false,\n    });\n    expect(request => request.succeed()).toRenderWithArgs({\n      done: true,\n      error: null,\n      props: {},\n      stale: false,\n    });\n  });\n\n  it('has a `retry` function that retries the request', () => {\n    const error = new Error('Expected error.');\n    expect(request => request.fail(error)).toRenderWithArgs({error});\n\n    const {retry} = render.mock.calls[1][0];\n    expect(typeof retry).toBe('function');\n    expect(RelayStore.primeCache.mock.calls.length).toBe(1);\n    retry();\n    expect(RelayStore.primeCache.mock.calls.length).toBe(2);\n  });\n\n  it('has a `retry` function that throws if called without failure', () => {\n    expect(request => request.block()).toRenderWithArgs({error: null});\n\n    const {retry} = render.mock.calls[1][0];\n    expect(typeof retry).toBe('function');\n    expect(() => retry()).toThrowError(\n      'RelayRenderer: You tried to call `retry`, but the last request did ' +\n      'not fail. You can only call this when the last request has failed.'\n    );\n  });\n\n  it('passes query config variables as props', () => {\n    const MockQueryConfig = RelayQueryConfig.genMock();\n    queryConfig = new MockQueryConfig({foo: 123, bar: 456});\n\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />,\n      container\n    );\n    expect(request => request.resolve()).toRenderWithArgs({\n      done: false,\n      error: null,\n      props: {foo: 123, bar: 456},\n      stale: false,\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_renderArgs-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_render-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst ReactTestUtils = require('ReactTestUtils');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\nconst StaticContainer = require('StaticContainer.react');\n\ndescribe('RelayRenderer.render', () => {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n  let renderedComponent;\n\n  function renderElement(element) {\n    renderedComponent = ReactDOM.render(element, container);\n  }\n\n  function getRenderOutput() {\n    return ReactTestUtils.findRenderedComponentWithType(\n      renderedComponent,\n      StaticContainer\n    );\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n\n    jasmine.addMatchers({\n      toBeUpdated() {\n        return {\n          compare(actual) {\n            return {\n              pass: actual.props.shouldUpdate,\n            };\n          },\n        };\n      },\n      toBeRenderedChild() {\n        return {\n          compare(actual) {\n            return {\n              pass: getRenderOutput().props.children === actual,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('defaults to null if unready and `render` is not supplied', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    expect(null).toBeRenderedChild();\n  });\n\n  it('defaults to component if ready and `render` is not supplied', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    RelayStore.primeCache.mock.requests[0].resolve();\n\n    const output = getRenderOutput().props.children;\n    expect(output.type).toBe(MockContainer);\n    expect(output.props).toEqual({});\n  });\n\n  it('renders null if `render` returns null', () => {\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => null}\n      />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n    expect(null).toBeRenderedChild();\n  });\n\n  it('renders previous view if `render` returns undefined', () => {\n    const prevView = <span />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => prevView}\n      />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n    expect(prevView).toBeRenderedChild();\n\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => undefined}\n      />\n    );\n    expect(getRenderOutput()).not.toBeUpdated();\n  });\n\n  it('renders new view if `render` return a new view', () => {\n    const prevView = <span />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => prevView}\n      />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n    expect(prevView).toBeRenderedChild();\n\n    const nextView = <div />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => nextView}\n      />\n    );\n    expect(nextView).toBeRenderedChild();\n  });\n\n  it('renders when mounted before a request is sent', () => {\n    const initialView = <div />;\n    const render = jest.genMockFunction().mockReturnValue(initialView);\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />\n    );\n    expect(render).toBeCalled();\n    expect(initialView).toBeRenderedChild();\n  });\n\n  it('renders when updated before the initial request is sent', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    const loadingView = <div />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={RelayQueryConfig.genMockInstance()}\n        render={() => loadingView}\n      />\n    );\n    // Since RelayRenderer has not yet sent a request, view gets to update.\n    expect(getRenderOutput()).toBeUpdated();\n  });\n\n  it('does not render when updated after the initial request is sent', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n\n    const loadingView = <div />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={RelayQueryConfig.genMockInstance()}\n        render={() => loadingView}\n      />\n    );\n    // RelayRenderer does not synchronously update because the ready state (and\n    // therefore render arguments) for the new `queryConfig` is not yet known.\n    expect(getRenderOutput()).not.toBeUpdated();\n    RelayStore.primeCache.mock.requests[1].block();\n    expect(loadingView).toBeRenderedChild();\n  });\n\n  it('renders whenever updated after request is sent', () => {\n    const render = jest.genMockFunction();\n    function update() {\n      renderElement(\n        <RelayRenderer\n          Container={MockContainer}\n          queryConfig={queryConfig}\n          render={render}\n        />\n      );\n    }\n    update();\n    RelayStore.primeCache.mock.requests[0].block();\n\n    expect(render.mock.calls.length).toBe(2);\n\n    update();\n    update();\n    update();\n\n    expect(render.mock.calls.length).toBe(5);\n  });\n\n  it('renders once after each ready state change', () => {\n    const render = jest.genMockFunction();\n\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />\n    );\n\n    const request = RelayStore.primeCache.mock.requests[0];\n\n    expect(render.mock.calls.length).toBe(1);\n\n    request.block();\n    expect(render.mock.calls.length).toBe(2);\n\n    request.resolve();\n    expect(render.mock.calls.length).toBe(3);\n\n    request.succeed();\n    expect(render.mock.calls.length).toBe(4);\n  });\n\n  describe('GC integration', () => {\n    let garbageCollector;\n\n    beforeEach(() => {\n      const storeData = RelayStore.getStoreData();\n      storeData.initializeGarbageCollector(jest.genMockFunction());\n      garbageCollector = storeData.getGarbageCollector();\n    });\n\n    it('acquires a GC hold when mounted', () => {\n      garbageCollector.acquireHold = jest.genMockFunction();\n      renderElement(\n        <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n      );\n      expect(garbageCollector.acquireHold).toBeCalled();\n    });\n\n    it('releases its GC hold when unmounted', () => {\n      const release = jest.genMockFunction();\n      garbageCollector.acquireHold =\n        jest.genMockFunction().mockReturnValue({release});\n      renderElement(\n        <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n      );\n      expect(release).not.toBeCalled();\n      ReactDOM.unmountComponentAtNode(container);\n      expect(release).toBeCalled();\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOM","ReactTestUtils","Relay","RelayQueryConfig","RelayRenderer","RelayStore","StaticContainer.react"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst ReactTestUtils = require('ReactTestUtils');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\nconst StaticContainer = require('StaticContainer.react');\n\ndescribe('RelayRenderer.render', () => {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n  let renderedComponent;\n\n  function renderElement(element) {\n    renderedComponent = ReactDOM.render(element, container);\n  }\n\n  function getRenderOutput() {\n    return ReactTestUtils.findRenderedComponentWithType(\n      renderedComponent,\n      StaticContainer\n    );\n  }\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n\n    jasmine.addMatchers({\n      toBeUpdated() {\n        return {\n          compare(actual) {\n            return {\n              pass: actual.props.shouldUpdate,\n            };\n          },\n        };\n      },\n      toBeRenderedChild() {\n        return {\n          compare(actual) {\n            return {\n              pass: getRenderOutput().props.children === actual,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('defaults to null if unready and `render` is not supplied', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    expect(null).toBeRenderedChild();\n  });\n\n  it('defaults to component if ready and `render` is not supplied', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    RelayStore.primeCache.mock.requests[0].resolve();\n\n    const output = getRenderOutput().props.children;\n    expect(output.type).toBe(MockContainer);\n    expect(output.props).toEqual({});\n  });\n\n  it('renders null if `render` returns null', () => {\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => null}\n      />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n    expect(null).toBeRenderedChild();\n  });\n\n  it('renders previous view if `render` returns undefined', () => {\n    const prevView = <span />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => prevView}\n      />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n    expect(prevView).toBeRenderedChild();\n\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => undefined}\n      />\n    );\n    expect(getRenderOutput()).not.toBeUpdated();\n  });\n\n  it('renders new view if `render` return a new view', () => {\n    const prevView = <span />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => prevView}\n      />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n    expect(prevView).toBeRenderedChild();\n\n    const nextView = <div />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={() => nextView}\n      />\n    );\n    expect(nextView).toBeRenderedChild();\n  });\n\n  it('renders when mounted before a request is sent', () => {\n    const initialView = <div />;\n    const render = jest.genMockFunction().mockReturnValue(initialView);\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />\n    );\n    expect(render).toBeCalled();\n    expect(initialView).toBeRenderedChild();\n  });\n\n  it('renders when updated before the initial request is sent', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    const loadingView = <div />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={RelayQueryConfig.genMockInstance()}\n        render={() => loadingView}\n      />\n    );\n    // Since RelayRenderer has not yet sent a request, view gets to update.\n    expect(getRenderOutput()).toBeUpdated();\n  });\n\n  it('does not render when updated after the initial request is sent', () => {\n    renderElement(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    );\n    RelayStore.primeCache.mock.requests[0].block();\n\n    const loadingView = <div />;\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={RelayQueryConfig.genMockInstance()}\n        render={() => loadingView}\n      />\n    );\n    // RelayRenderer does not synchronously update because the ready state (and\n    // therefore render arguments) for the new `queryConfig` is not yet known.\n    expect(getRenderOutput()).not.toBeUpdated();\n    RelayStore.primeCache.mock.requests[1].block();\n    expect(loadingView).toBeRenderedChild();\n  });\n\n  it('renders whenever updated after request is sent', () => {\n    const render = jest.genMockFunction();\n    function update() {\n      renderElement(\n        <RelayRenderer\n          Container={MockContainer}\n          queryConfig={queryConfig}\n          render={render}\n        />\n      );\n    }\n    update();\n    RelayStore.primeCache.mock.requests[0].block();\n\n    expect(render.mock.calls.length).toBe(2);\n\n    update();\n    update();\n    update();\n\n    expect(render.mock.calls.length).toBe(5);\n  });\n\n  it('renders once after each ready state change', () => {\n    const render = jest.genMockFunction();\n\n    renderElement(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        render={render}\n      />\n    );\n\n    const request = RelayStore.primeCache.mock.requests[0];\n\n    expect(render.mock.calls.length).toBe(1);\n\n    request.block();\n    expect(render.mock.calls.length).toBe(2);\n\n    request.resolve();\n    expect(render.mock.calls.length).toBe(3);\n\n    request.succeed();\n    expect(render.mock.calls.length).toBe(4);\n  });\n\n  describe('GC integration', () => {\n    let garbageCollector;\n\n    beforeEach(() => {\n      const storeData = RelayStore.getStoreData();\n      storeData.initializeGarbageCollector(jest.genMockFunction());\n      garbageCollector = storeData.getGarbageCollector();\n    });\n\n    it('acquires a GC hold when mounted', () => {\n      garbageCollector.acquireHold = jest.genMockFunction();\n      renderElement(\n        <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n      );\n      expect(garbageCollector.acquireHold).toBeCalled();\n    });\n\n    it('releases its GC hold when unmounted', () => {\n      const release = jest.genMockFunction();\n      garbageCollector.acquireHold =\n        jest.genMockFunction().mockReturnValue({release});\n      renderElement(\n        <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n      );\n      expect(release).not.toBeCalled();\n      ReactDOM.unmountComponentAtNode(container);\n      expect(release).toBeCalled();\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_render-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_onReadyStateChange-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.onReadyStateChange', () => {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n  });\n\n  let onReadyStateChange;\n\n  beforeEach(() => {\n    onReadyStateChange = jest.genMockFunction();\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        onReadyStateChange={onReadyStateChange}\n      />,\n      container\n    );\n    const defaultState = {\n      aborted: false,\n      done: false,\n      error: null,\n      mounted: true,\n      ready: false,\n      stale: false,\n    };\n    jasmine.addMatchers({\n      toTriggerReadyStateChanges() {\n        return {\n          compare(requestCallback, expected) {\n            const request = RelayStore.primeCache.mock.requests[0];\n            requestCallback(request);\n            jest.runAllTimers();\n\n            expect(onReadyStateChange.mock.calls.map(args => args[0])).toEqual(\n              expected.map(deltaState => ({...defaultState, ...deltaState}))\n            );\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('does nothing before `prime` starts', () => {\n    expect(() => {\n      // Nothing.\n    }).toTriggerReadyStateChanges([\n      // Nothing.\n    ]);\n  });\n\n  it('is not ready or done after a request', () => {\n    expect(request => {\n      request.block();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: false},\n    ]);\n  });\n\n  it('is ready but not done when required data is resolved', () => {\n    expect(request => {\n      request.block();\n      request.resolve();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: false},\n      {done: false, ready: true},\n    ]);\n  });\n\n  it('is ready and done when request succeeds', () => {\n    expect(request => {\n      request.block();\n      request.resolve();\n      request.succeed();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: false},\n      {done: false, ready: true},\n      {done: true, ready: true},\n    ]);\n  });\n\n  it('is ready and done if data is resolved without a request', () => {\n    expect(request => {\n      request.resolve();\n      request.succeed();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: true},\n      {done: true, ready: true},\n    ]);\n  });\n\n  it('is ready with an error when a failure occurs with required data', () => {\n    const error = new Error('Expected error.');\n    expect(request => {\n      request.block();\n      request.resolve();\n      request.fail(error);\n    }).toTriggerReadyStateChanges([\n      {done: false, error: null, ready: false},\n      {done: false, error: null, ready: true},\n      {done: false, error, ready: true},\n    ]);\n  });\n\n  it('has an error when a failure occurs without required data', () => {\n    const error = new Error('Expected error.');\n    expect(request => {\n      request.block();\n      request.fail(error);\n    }).toTriggerReadyStateChanges([\n      {done: false, error: null, ready: false},\n      {done: false, error, ready: false},\n    ]);\n  });\n\n  it('has an error when a failure occurs before sending a request', () => {\n    const error = new Error('Expected error.');\n    expect(request => {\n      request.fail(error);\n    }).toTriggerReadyStateChanges([\n      {done: false, error, ready: false},\n    ]);\n  });\n\n  it('does nothing when aborted from query configuration change', () => {\n    expect(request => {\n      ReactDOM.render(\n        <RelayRenderer\n          Container={MockContainer}\n          queryConfig={RelayQueryConfig.genMockInstance()}\n          onReadyStateChange={onReadyStateChange}\n        />,\n        container\n      );\n    }).toTriggerReadyStateChanges([\n      // Nothing.\n    ]);\n  });\n\n  it('is aborted and not mounted when aborted from unmounting', () => {\n    expect(request => {\n      ReactDOM.unmountComponentAtNode(container);\n    }).toTriggerReadyStateChanges([\n      {aborted: true, mounted: false},\n    ]);\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOM","Relay","RelayQueryConfig","RelayRenderer","RelayStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.onReadyStateChange', () => {\n  let MockComponent;\n  let MockContainer;\n\n  let container;\n  let queryConfig;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    container = document.createElement('div');\n    queryConfig = RelayQueryConfig.genMockInstance();\n  });\n\n  let onReadyStateChange;\n\n  beforeEach(() => {\n    onReadyStateChange = jest.genMockFunction();\n    ReactDOM.render(\n      <RelayRenderer\n        Container={MockContainer}\n        queryConfig={queryConfig}\n        onReadyStateChange={onReadyStateChange}\n      />,\n      container\n    );\n    const defaultState = {\n      aborted: false,\n      done: false,\n      error: null,\n      mounted: true,\n      ready: false,\n      stale: false,\n    };\n    jasmine.addMatchers({\n      toTriggerReadyStateChanges() {\n        return {\n          compare(requestCallback, expected) {\n            const request = RelayStore.primeCache.mock.requests[0];\n            requestCallback(request);\n            jest.runAllTimers();\n\n            expect(onReadyStateChange.mock.calls.map(args => args[0])).toEqual(\n              expected.map(deltaState => ({...defaultState, ...deltaState}))\n            );\n            return {\n              pass: true,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('does nothing before `prime` starts', () => {\n    expect(() => {\n      // Nothing.\n    }).toTriggerReadyStateChanges([\n      // Nothing.\n    ]);\n  });\n\n  it('is not ready or done after a request', () => {\n    expect(request => {\n      request.block();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: false},\n    ]);\n  });\n\n  it('is ready but not done when required data is resolved', () => {\n    expect(request => {\n      request.block();\n      request.resolve();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: false},\n      {done: false, ready: true},\n    ]);\n  });\n\n  it('is ready and done when request succeeds', () => {\n    expect(request => {\n      request.block();\n      request.resolve();\n      request.succeed();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: false},\n      {done: false, ready: true},\n      {done: true, ready: true},\n    ]);\n  });\n\n  it('is ready and done if data is resolved without a request', () => {\n    expect(request => {\n      request.resolve();\n      request.succeed();\n    }).toTriggerReadyStateChanges([\n      {done: false, ready: true},\n      {done: true, ready: true},\n    ]);\n  });\n\n  it('is ready with an error when a failure occurs with required data', () => {\n    const error = new Error('Expected error.');\n    expect(request => {\n      request.block();\n      request.resolve();\n      request.fail(error);\n    }).toTriggerReadyStateChanges([\n      {done: false, error: null, ready: false},\n      {done: false, error: null, ready: true},\n      {done: false, error, ready: true},\n    ]);\n  });\n\n  it('has an error when a failure occurs without required data', () => {\n    const error = new Error('Expected error.');\n    expect(request => {\n      request.block();\n      request.fail(error);\n    }).toTriggerReadyStateChanges([\n      {done: false, error: null, ready: false},\n      {done: false, error, ready: false},\n    ]);\n  });\n\n  it('has an error when a failure occurs before sending a request', () => {\n    const error = new Error('Expected error.');\n    expect(request => {\n      request.fail(error);\n    }).toTriggerReadyStateChanges([\n      {done: false, error, ready: false},\n    ]);\n  });\n\n  it('does nothing when aborted from query configuration change', () => {\n    expect(request => {\n      ReactDOM.render(\n        <RelayRenderer\n          Container={MockContainer}\n          queryConfig={RelayQueryConfig.genMockInstance()}\n          onReadyStateChange={onReadyStateChange}\n        />,\n        container\n      );\n    }).toTriggerReadyStateChanges([\n      // Nothing.\n    ]);\n  });\n\n  it('is aborted and not mounted when aborted from unmounting', () => {\n    expect(request => {\n      ReactDOM.unmountComponentAtNode(container);\n    }).toTriggerReadyStateChanges([\n      {aborted: true, mounted: false},\n    ]);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_onReadyStateChange-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_context-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.context', () => {\n  let MockComponent;\n  let MockContainer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    const container = document.createElement('div');\n    const contextTypes = {\n      relay: Relay.PropTypes.Context,\n      route: Relay.PropTypes.QueryConfig.isRequired,\n    };\n    jasmine.addMatchers({\n      toRenderQueryConfig() {\n        return {\n          compare(actual, expected) {\n            let context;\n            class MockChild extends React.Component {\n              render() {\n                context = this.context;\n                return null;\n              }\n            }\n            MockChild.contextTypes = contextTypes;\n            const element = React.cloneElement(actual, {\n              render() {\n                return <MockChild />;\n              },\n            });\n            ReactDOM.render(element, container);\n            const mockRequests = RelayStore.primeCache.mock.requests;\n            mockRequests[mockRequests.length - 1].block();\n            return {\n              pass: context.relay === RelayStore && context.route === expected,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('sets query config on context', () => {\n    const queryConfig = RelayQueryConfig.genMockInstance();\n    expect(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    ).toRenderQueryConfig(queryConfig);\n  });\n\n  it('updates query config on context', () => {\n    const queryConfigA = RelayQueryConfig.genMockInstance();\n    expect(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfigA} />\n    ).toRenderQueryConfig(queryConfigA);\n\n    const queryConfigB = RelayQueryConfig.genMockInstance();\n    expect(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfigB} />\n    ).toRenderQueryConfig(queryConfigB);\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOM","Relay","RelayQueryConfig","RelayRenderer","RelayStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.context', () => {\n  let MockComponent;\n  let MockContainer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    const container = document.createElement('div');\n    const contextTypes = {\n      relay: Relay.PropTypes.Context,\n      route: Relay.PropTypes.QueryConfig.isRequired,\n    };\n    jasmine.addMatchers({\n      toRenderQueryConfig() {\n        return {\n          compare(actual, expected) {\n            let context;\n            class MockChild extends React.Component {\n              render() {\n                context = this.context;\n                return null;\n              }\n            }\n            MockChild.contextTypes = contextTypes;\n            const element = React.cloneElement(actual, {\n              render() {\n                return <MockChild />;\n              },\n            });\n            ReactDOM.render(element, container);\n            const mockRequests = RelayStore.primeCache.mock.requests;\n            mockRequests[mockRequests.length - 1].block();\n            return {\n              pass: context.relay === RelayStore && context.route === expected,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('sets query config on context', () => {\n    const queryConfig = RelayQueryConfig.genMockInstance();\n    expect(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />\n    ).toRenderQueryConfig(queryConfig);\n  });\n\n  it('updates query config on context', () => {\n    const queryConfigA = RelayQueryConfig.genMockInstance();\n    expect(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfigA} />\n    ).toRenderQueryConfig(queryConfigA);\n\n    const queryConfigB = RelayQueryConfig.genMockInstance();\n    expect(\n      <RelayRenderer Container={MockContainer} queryConfig={queryConfigB} />\n    ).toRenderQueryConfig(queryConfigB);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_context-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_abort-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.abort', () => {\n  let MockComponent;\n  let MockContainer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    const container = document.createElement('div');\n\n    function render() {\n      const queryConfig = RelayQueryConfig.genMockInstance();\n      ReactDOM.render(\n        <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n        container\n      );\n      const index = RelayStore.primeCache.mock.calls.length - 1;\n      return {\n        abort: RelayStore.primeCache.mock.abort[index],\n        request: RelayStore.primeCache.mock.requests[index],\n      };\n    }\n    jasmine.addMatchers({\n      toAbortOnUpdate() {\n        return {\n          compare(actual) {\n            const {abort, request} = render();\n            actual(request);\n            render();\n            return {\n              pass: abort.mock.calls.length > 0,\n            };\n          },\n        };\n      },\n      toAbortOnUnmount() {\n        return {\n          compare(actual) {\n            const {abort, request} = render();\n            actual(request);\n            ReactDOM.unmountComponentAtNode(container);\n            return {\n              pass: abort.mock.calls.length > 0,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('aborts synchronously initiated queries', () => {\n    function synchronousQueries(request) {\n      // Requests are always asynchronous, so do nothing.\n    }\n    expect(synchronousQueries).toAbortOnUpdate();\n    expect(synchronousQueries).toAbortOnUnmount();\n  });\n\n  it('aborts blocked queries', () => {\n    function blockedQueries(request) {\n      // Queries are blocked on asynchronous requests.\n      request.block();\n    }\n    expect(blockedQueries).toAbortOnUpdate();\n    expect(blockedQueries).toAbortOnUnmount();\n  });\n\n  it('aborts queries with fulfilled dependencies', () => {\n    function readyQueries(request) {\n      request.block();\n      request.resolve();\n    }\n    expect(readyQueries).toAbortOnUpdate();\n    expect(readyQueries).toAbortOnUnmount();\n  });\n\n  it('does not abort failed queries', () => {\n    function failedQueries(request) {\n      request.fail(new Error());\n    }\n    expect(failedQueries).not.toAbortOnUpdate();\n    expect(failedQueries).not.toAbortOnUnmount();\n  });\n\n  it('does not abort completed queries', () => {\n    function completedQueries(request) {\n      request.block();\n      request.resolve();\n      request.succeed();\n    }\n    expect(completedQueries).not.toAbortOnUpdate();\n    expect(completedQueries).not.toAbortOnUnmount();\n  });\n});\n","dependencies":["configureForRelayOSS","React","ReactDOM","Relay","RelayQueryConfig","RelayRenderer","RelayStore"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayRenderer');\n\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayQueryConfig = require('RelayQueryConfig');\nconst RelayRenderer = require('RelayRenderer');\nconst RelayStore = require('RelayStore');\n\ndescribe('RelayRenderer.abort', () => {\n  let MockComponent;\n  let MockContainer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({render: () => <div />});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n\n    const container = document.createElement('div');\n\n    function render() {\n      const queryConfig = RelayQueryConfig.genMockInstance();\n      ReactDOM.render(\n        <RelayRenderer Container={MockContainer} queryConfig={queryConfig} />,\n        container\n      );\n      const index = RelayStore.primeCache.mock.calls.length - 1;\n      return {\n        abort: RelayStore.primeCache.mock.abort[index],\n        request: RelayStore.primeCache.mock.requests[index],\n      };\n    }\n    jasmine.addMatchers({\n      toAbortOnUpdate() {\n        return {\n          compare(actual) {\n            const {abort, request} = render();\n            actual(request);\n            render();\n            return {\n              pass: abort.mock.calls.length > 0,\n            };\n          },\n        };\n      },\n      toAbortOnUnmount() {\n        return {\n          compare(actual) {\n            const {abort, request} = render();\n            actual(request);\n            ReactDOM.unmountComponentAtNode(container);\n            return {\n              pass: abort.mock.calls.length > 0,\n            };\n          },\n        };\n      },\n    });\n  });\n\n  it('aborts synchronously initiated queries', () => {\n    function synchronousQueries(request) {\n      // Requests are always asynchronous, so do nothing.\n    }\n    expect(synchronousQueries).toAbortOnUpdate();\n    expect(synchronousQueries).toAbortOnUnmount();\n  });\n\n  it('aborts blocked queries', () => {\n    function blockedQueries(request) {\n      // Queries are blocked on asynchronous requests.\n      request.block();\n    }\n    expect(blockedQueries).toAbortOnUpdate();\n    expect(blockedQueries).toAbortOnUnmount();\n  });\n\n  it('aborts queries with fulfilled dependencies', () => {\n    function readyQueries(request) {\n      request.block();\n      request.resolve();\n    }\n    expect(readyQueries).toAbortOnUpdate();\n    expect(readyQueries).toAbortOnUnmount();\n  });\n\n  it('does not abort failed queries', () => {\n    function failedQueries(request) {\n      request.fail(new Error());\n    }\n    expect(failedQueries).not.toAbortOnUpdate();\n    expect(failedQueries).not.toAbortOnUnmount();\n  });\n\n  it('does not abort completed queries', () => {\n    function completedQueries(request) {\n      request.block();\n      request.resolve();\n      request.succeed();\n    }\n    expect(completedQueries).not.toAbortOnUpdate();\n    expect(completedQueries).not.toAbortOnUnmount();\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayRenderer_abort-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_setVariables-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst QueryBuilder = require('QueryBuilder');\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer.setVariables', function() {\n  var MockComponent;\n  var MockContainer;\n\n  var defaultState;\n  var domContainer;\n  var entityQuery;\n  var mockInstance;\n  var relayContext;\n  var render;\n\n  const {getNode} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    const fragment = Relay.QL`fragment on Node{url(site:$site)}`;\n    entityQuery = jest.genMockFunction().mockImplementation(\n      () => fragment\n    );\n    render = jest.genMockFunction().mockImplementation(() => <div />);\n\n    // Make RQLTransform ignore this call.\n    MockComponent = React.createClass({render});\n    var createContainer = Relay.createContainer;\n    MockContainer = createContainer(MockComponent, {\n      fragments: {\n        entity: entityQuery,\n      },\n      initialVariables: {site: 'mobile'},\n    });\n\n    relayContext = new RelayContext();\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      expect(dataID).toBe('42');\n      return {\n        __dataID__: '42',\n        __fragments__: {\n          [getNode(fragment).getConcreteFragmentID()]: '42',\n        },\n        id: '42',\n        url: '//url',\n        profilePicture: {\n          uri: '//url',\n        },\n      };\n    });\n    defaultState = {\n      aborted: false,\n      done: false,\n      error: null,\n      mounted: true,\n      ready: false,\n      stale: false,\n    };\n    domContainer = document.createElement('div');\n    mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n      genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n      relayContext\n    );\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('plural fragments', () => {\n    var getNode;\n    var getPointer;\n\n    beforeEach(() => {\n      ({getNode, getPointer} = RelayTestUtils);\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(pointer => {\n        return [{\n          __dataID__: '42',\n          id: '42',\n          url: '//url',\n          profilePicture: {\n            uri: '//url',\n          },\n        }];\n      });\n      var pluralEntityQuery = jest.genMockFunction().mockImplementation(\n        () => Relay.QL`\n          fragment on Node @relay(plural:true) {\n            url(site: $site)\n          }\n        `\n      );\n      MockContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          entity: pluralEntityQuery,\n        },\n        initialVariables: {site: 'mobile'},\n      });\n\n      // Return an array\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, ids) => {\n        expect(ids).toEqual(['21', '42']);\n        return [\n          {\n            __dataID__: '21',\n            id: '21',\n            url: '//url',\n            profilePicture: {\n              uri: '//url',\n            },\n          },\n          {\n            __dataID__: '42',\n            id: '42',\n            url: '//url',\n            profilePicture: {\n              uri: '//url',\n            },\n          },\n        ];\n      });\n\n      var fragment = getNode(MockContainer.getFragment('entity').getFragment());\n      var mockPointers = [\n        getPointer('21', fragment),\n        getPointer('42', fragment),\n      ];\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => (\n          <MockContainer entity={mockPointers} />\n        ),\n        relayContext\n      );\n    });\n\n    it('creates multiple queries for plural fragments', () => {\n      jest.runAllTimers();\n\n      mockInstance.forceFetch();\n\n      expect(relayContext.forceFetch).toBeCalled();\n      var querySet = relayContext.forceFetch.mock.calls[0][0];\n      expect(Object.keys(querySet)).toEqual(['entity0', 'entity1']);\n    });\n\n    it('creates queries only for records with dataIDs', () => {\n      var updatedQueryData = [\n        {__dataID__: '21', id: '21', url: '//www'},\n        {id:'1336', name: 'Fake data', url: '//www'},\n      ];\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(pointer => {\n        return updatedQueryData;\n      });\n\n      // Change the query data that is stored by the container to\n      // `updatedQueryData`\n      mockInstance.forceFetch();\n      relayContext.forceFetch.mock.requests[0].succeed();\n      mockInstance.forceFetch();\n      var querySet = relayContext.forceFetch.mock.calls[1][0];\n      expect(Object.keys(querySet)).toEqual(['entity0']);\n    });\n\n    it('resolves data using updated `variables`', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      var updatedQueryData = [\n        {__dataID__: '21', id: '21', url: '//www'},\n        {__dataID__: '42', id: '42', url: '//www'},\n      ];\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(fragment => {\n        expect(fragment.getVariables()).toEqual({site: 'www'});\n        return updatedQueryData;\n      });\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(mockInstance.state.queryData.entity).toBe(updatedQueryData);\n    });\n\n    it('throws when the queryData is not an array', () => {\n      var updatedQueryData = {__dataID__: '21', id: '21', url: '//www'};\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(pointer => {\n        return updatedQueryData;\n      });\n\n      // Change the query data that is stored by the container to\n      // `updatedQueryData`\n      mockInstance.forceFetch();\n      relayContext.forceFetch.mock.requests[0].succeed();\n      expect(() => mockInstance.forceFetch()).toFailInvariant(\n        'RelayContainer: Invalid queryData for `entity`, expected an array ' +\n        'of records because the corresponding fragment is plural.',\n      );\n    });\n  });\n\n  describe('query builders', () => {\n    it('are called with variables for variables', () => {\n      expect(entityQuery.mock.calls.length).toBe(1);\n      expect(entityQuery.mock.calls[0][0].site).toEqual(\n        QueryBuilder.createCallVariable('site')\n      );\n    });\n\n    it('are only called once', () => {\n      expect(entityQuery.mock.calls.length).toBe(1);\n\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n      expect(entityQuery.mock.calls.length).toBe(1);\n    });\n  });\n\n  describe('mount', () => {\n    it('renders with default variables', () => {\n      expect(mockInstance.state.variables.site).toBe('mobile');\n    });\n\n    it('lets props override default variables', () => {\n      var anotherInstance = RelayTestUtils.createRenderer().render(\n        genMockPointer => (\n          <MockContainer entity={genMockPointer('42')} site=\"www\" />\n        ),\n        relayContext\n      );\n      expect(anotherInstance.state.variables.site).toBe('www');\n    });\n  });\n\n  describe('update', () => {\n    it('does not update `variables` until data is ready', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      mockInstance.forceUpdate();\n\n      expect(mockInstance.state.variables.site).toBe('mobile');\n    });\n\n    it('updates `variables` after callback when data is ready', () => {\n      var mockCallback = jest.genMockFunction();\n      mockInstance.setVariables({site: 'www'}, mockCallback);\n      jest.runAllTimers();\n\n      mockCallback.mockImplementation(() => {\n        expect(mockInstance.state.variables.site).toBe('mobile');\n      });\n      relayContext.primeCache.mock.requests[0].succeed();\n      expect(mockCallback.mock.calls.length).toBe(1);\n\n      expect(mockInstance.state.variables.site).toBe('www');\n    });\n\n    it('resolves data using updated `variables`', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      var updatedQueryData = {__dataID__: '42', id: '42', url: '//www'};\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(fragment => {\n        expect(fragment.getVariables()).toEqual({site: 'www'});\n        return updatedQueryData;\n      });\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(mockInstance.state.queryData.entity).toBe(updatedQueryData);\n    });\n\n    it('aborts pending requests before creating a new request', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n\n      mockInstance.setVariables({site: 'mobile'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n    });\n\n    it('invokes callback for a request that aborts a pending request', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].block();\n\n      var mockCallback = jest.genMockFunction();\n      mockInstance.setVariables({site: 'mobile'}, mockCallback);\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[1].block();\n      expect(mockCallback).toBeCalled();\n    });\n\n    it('does not re-request the last variables', () => {\n      mockInstance.setVariables({site: 'mobile'});\n      jest.runAllTimers();\n\n      var {mock} = relayContext.primeCache;\n      expect(mock.calls.length).toBe(1);\n      expect(Object.keys(mock.calls[0][0]).length).toBe(0);\n    });\n\n    it('re-requests currently pending variables', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n      expect(relayContext.primeCache.mock.calls.length).toBe(2);\n    });\n\n    it('re-requests the last variables for `forceFetch`', () => {\n      mockInstance.forceFetch({site: 'mobile'});\n      jest.runAllTimers();\n\n      var {mock} = relayContext.forceFetch;\n      expect(mock.calls.length).toBe(1);\n      expect(Object.keys(mock.calls[0][0]).length).toBe(1);\n    });\n\n    it('does not re-request the last variables with a pending request', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n      mockInstance.setVariables({site: 'mobile'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n\n      expect(relayContext.primeCache.mock.calls.length).toBe(2);\n      expect(relayContext.primeCache.mock.calls[1][0]).toEqual({});\n    });\n\n    it('invokes the callback as many times as ready state changes', () => {\n      var mockFunction = jest.genMockFunction().mockImplementation(function() {\n        expect(this.constructor).toBe(MockComponent);\n      });\n      mockInstance.setVariables({site: 'www'}, mockFunction);\n      jest.runAllTimers();\n\n      var request = relayContext.primeCache.mock.requests[0];\n      request.block();\n      request.succeed();\n\n      expect(mockFunction.mock.calls).toEqual([\n        [{...defaultState, done: false, ready: false}],\n        [{...defaultState, done: true, ready: true}],\n      ]);\n    });\n\n    it('invokes the callback with the component as `this`', () => {\n      var mockFunction = jest.genMockFunction().mockImplementation(function() {\n        expect(this.constructor).toBe(MockComponent);\n      });\n      mockInstance.setVariables({site: 'www'}, mockFunction);\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].block();\n\n      expect(mockFunction).toBeCalled();\n    });\n\n    it('reconciles only once even if callback calls `setState`', () => {\n      var before = render.mock.calls.length;\n\n      mockInstance.setVariables({site: 'www'}, function() {\n        this.setState({isLoaded: true});\n      });\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(render.mock.calls.length - before).toBe(1);\n    });\n\n    it('does not mutate previous `variables`', () => {\n      var prevVariables = mockInstance.state.variables;\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(prevVariables).toEqual({site: 'mobile'});\n      expect(mockInstance.state.variables).not.toBe(prevVariables);\n    });\n  });\n\n  describe('prepareVariables()', () => {\n    var prepareVariables;\n\n    beforeEach(() => {\n      entityQuery = jest.genMockFunction().mockImplementation(\n        () => Relay.QL`fragment on Node{url(site:$site)}`\n      );\n      render = jest.genMockFunction().mockImplementation(() => <div />);\n      prepareVariables = jest.genMockFunction().mockImplementation(\n        (variables, route) => variables\n      );\n\n      // Make RQLTransform ignore this call.\n      MockComponent = React.createClass({render});\n      var createContainer = Relay.createContainer;\n      MockContainer = createContainer(MockComponent, {\n        fragments: {\n          entity: entityQuery,\n        },\n        initialVariables: {site: 'mobile'},\n        prepareVariables,\n      });\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n        relayContext\n      );\n    });\n\n    it('calls `prepareVariables` when `setVariables` is called', () => {\n      var nextVariables = {site: 'mobile'};\n      prepareVariables.mockImplementation((variables, route) => nextVariables);\n      mockInstance.setVariables({site: 'www'});\n\n      var calls = prepareVariables.mock.calls[1];\n      expect(calls[0]).toEqual({site: 'www'});\n      expect(calls[1]).toBe(\n        RelayMetaRoute.get(mockInstance.context.route.name)\n      );\n\n      // `prepareVariables` output is used to prime the cache...\n      var queries = relayContext.primeCache.mock.calls[0][0];\n      var query = queries[Object.keys(queries)[0]];\n      var fragment = query.getChildren().find(\n        child => child instanceof RelayQuery.Fragment\n      );\n      expect(fragment.getVariables()).toEqual(nextVariables);\n\n      jest.runAllTimers();\n      relayContext.primeCache.mock.requests[0].succeed();\n      // ...but is invisible to the component\n      expect(mockInstance.state.variables).toEqual({site: 'www'});\n    });\n  });\n\n  describe('unmount', () => {\n    it('aborts pending requests when unmounted', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n      ReactDOM.unmountComponentAtNode(domContainer);\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n    });\n\n    it('ignores `setState` from callback when request aborts', () => {\n      var mockCallback = jest.genMockFunction()\n        .mockImplementation(readyState => {\n          if (readyState.mounted) {\n            this.setState({isAborted: true});\n          }\n        });\n      mockInstance.setVariables({site: 'www'}, mockCallback);\n      jest.runAllTimers();\n\n      expect(mockCallback).not.toBeCalled();\n      expect(() => {\n        ReactDOM.unmountComponentAtNode(domContainer);\n        jest.runAllTimers();\n      }).not.toThrow();\n\n      expect(mockCallback.mock.calls).toEqual([\n        [{...defaultState, aborted: true, mounted: false}],\n      ]);\n    });\n  });\n\n  describe('prop variable updates', () => {\n    it('updates variables if props are updated', () => {\n      class MockInnerComponent extends React.Component {\n        render() {\n          return <div />;\n        }\n      }\n\n      var MockInnerContainer = Relay.createContainer(MockInnerComponent, {\n        fragments: {\n          entity: () => Relay.QL`fragment on Node{url(site:$site)}`,\n        },\n        initialVariables: {site: undefined},\n      });\n\n      class MockWrapperComponent extends React.Component {\n        render() {\n          return (\n            <MockInnerContainer\n              ref=\"inner\"\n              site={this.props.relay.variables.site}\n              entity={this.props.entity}\n            />\n          );\n        }\n      }\n\n      MockContainer = Relay.createContainer(MockWrapperComponent, {\n        fragments: {\n          entity: variables => Relay.QL`  fragment on Node{\n            ${MockInnerContainer.getFragment('entity', {site: variables.site})}\n          }`,\n        },\n        initialVariables: {site: 'mobile'},\n      });\n\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n        relayContext\n      );\n      var innerComponent = mockInstance.refs.component.refs.inner;\n      expect(innerComponent.state.variables.site).toBe('mobile');\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].succeed();\n      expect(mockInstance.state.variables.site).toBe('www');\n\n      expect(innerComponent.state.variables.site).toBe('www');\n    });\n\n    it('resets variables if outside variable props are updated', () => {\n      class MockInnerComponent extends React.Component {\n        render() {\n          return <div />;\n        }\n      }\n\n      var MockInnerContainer = Relay.createContainer(MockInnerComponent, {\n        fragments: {\n          entity: () => Relay.QL`  fragment on Actor {\n                        url(site:$site),\n                        profilePicture(size:$size) {\n                          uri,\n                        },\n                      }`,\n        },\n        initialVariables: {\n          site: undefined,\n          size: 48,\n        },\n      });\n\n      class MockWrapperComponent extends React.Component {\n        render() {\n          return (\n            <MockInnerContainer\n              ref=\"inner\"\n              site={this.props.relay.variables.site}\n              entity={this.props.entity}\n            />\n          );\n        }\n      }\n\n      MockContainer = Relay.createContainer(MockWrapperComponent, {\n        fragments: {\n          entity: variables => Relay.QL`  fragment on Actor {\n            ${MockInnerContainer.getFragment('entity', {site: variables.site})}\n          }`,\n        },\n        initialVariables: {site: 'mobile'},\n      });\n\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n        relayContext\n      );\n      var innerComponent = mockInstance.refs.component.refs.inner;\n      expect(innerComponent.state.variables.site).toBe('mobile');\n\n      innerComponent.setVariables({size: 32});\n      jest.runAllTimers();\n      relayContext.primeCache.mock.requests[0].succeed();\n      expect(innerComponent.state.variables).toEqual({\n        site: 'mobile',\n        size: 32,\n      });\n\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[1].succeed();\n      expect(mockInstance.state.variables).toEqual({\n        site: 'www',\n      });\n\n      expect(innerComponent.state.variables).toEqual({\n        site: 'www',\n        size: 48,\n      });\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","QueryBuilder","React","ReactDOM","Relay","RelayContext","RelayMetaRoute","RelayQuery","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst QueryBuilder = require('QueryBuilder');\nconst React = require('React');\nconst ReactDOM = require('ReactDOM');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer.setVariables', function() {\n  var MockComponent;\n  var MockContainer;\n\n  var defaultState;\n  var domContainer;\n  var entityQuery;\n  var mockInstance;\n  var relayContext;\n  var render;\n\n  const {getNode} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    const fragment = Relay.QL`fragment on Node{url(site:$site)}`;\n    entityQuery = jest.genMockFunction().mockImplementation(\n      () => fragment\n    );\n    render = jest.genMockFunction().mockImplementation(() => <div />);\n\n    // Make RQLTransform ignore this call.\n    MockComponent = React.createClass({render});\n    var createContainer = Relay.createContainer;\n    MockContainer = createContainer(MockComponent, {\n      fragments: {\n        entity: entityQuery,\n      },\n      initialVariables: {site: 'mobile'},\n    });\n\n    relayContext = new RelayContext();\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      expect(dataID).toBe('42');\n      return {\n        __dataID__: '42',\n        __fragments__: {\n          [getNode(fragment).getConcreteFragmentID()]: '42',\n        },\n        id: '42',\n        url: '//url',\n        profilePicture: {\n          uri: '//url',\n        },\n      };\n    });\n    defaultState = {\n      aborted: false,\n      done: false,\n      error: null,\n      mounted: true,\n      ready: false,\n      stale: false,\n    };\n    domContainer = document.createElement('div');\n    mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n      genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n      relayContext\n    );\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('plural fragments', () => {\n    var getNode;\n    var getPointer;\n\n    beforeEach(() => {\n      ({getNode, getPointer} = RelayTestUtils);\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(pointer => {\n        return [{\n          __dataID__: '42',\n          id: '42',\n          url: '//url',\n          profilePicture: {\n            uri: '//url',\n          },\n        }];\n      });\n      var pluralEntityQuery = jest.genMockFunction().mockImplementation(\n        () => Relay.QL`\n          fragment on Node @relay(plural:true) {\n            url(site: $site)\n          }\n        `\n      );\n      MockContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          entity: pluralEntityQuery,\n        },\n        initialVariables: {site: 'mobile'},\n      });\n\n      // Return an array\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, ids) => {\n        expect(ids).toEqual(['21', '42']);\n        return [\n          {\n            __dataID__: '21',\n            id: '21',\n            url: '//url',\n            profilePicture: {\n              uri: '//url',\n            },\n          },\n          {\n            __dataID__: '42',\n            id: '42',\n            url: '//url',\n            profilePicture: {\n              uri: '//url',\n            },\n          },\n        ];\n      });\n\n      var fragment = getNode(MockContainer.getFragment('entity').getFragment());\n      var mockPointers = [\n        getPointer('21', fragment),\n        getPointer('42', fragment),\n      ];\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => (\n          <MockContainer entity={mockPointers} />\n        ),\n        relayContext\n      );\n    });\n\n    it('creates multiple queries for plural fragments', () => {\n      jest.runAllTimers();\n\n      mockInstance.forceFetch();\n\n      expect(relayContext.forceFetch).toBeCalled();\n      var querySet = relayContext.forceFetch.mock.calls[0][0];\n      expect(Object.keys(querySet)).toEqual(['entity0', 'entity1']);\n    });\n\n    it('creates queries only for records with dataIDs', () => {\n      var updatedQueryData = [\n        {__dataID__: '21', id: '21', url: '//www'},\n        {id:'1336', name: 'Fake data', url: '//www'},\n      ];\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(pointer => {\n        return updatedQueryData;\n      });\n\n      // Change the query data that is stored by the container to\n      // `updatedQueryData`\n      mockInstance.forceFetch();\n      relayContext.forceFetch.mock.requests[0].succeed();\n      mockInstance.forceFetch();\n      var querySet = relayContext.forceFetch.mock.calls[1][0];\n      expect(Object.keys(querySet)).toEqual(['entity0']);\n    });\n\n    it('resolves data using updated `variables`', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      var updatedQueryData = [\n        {__dataID__: '21', id: '21', url: '//www'},\n        {__dataID__: '42', id: '42', url: '//www'},\n      ];\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(fragment => {\n        expect(fragment.getVariables()).toEqual({site: 'www'});\n        return updatedQueryData;\n      });\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(mockInstance.state.queryData.entity).toBe(updatedQueryData);\n    });\n\n    it('throws when the queryData is not an array', () => {\n      var updatedQueryData = {__dataID__: '21', id: '21', url: '//www'};\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(pointer => {\n        return updatedQueryData;\n      });\n\n      // Change the query data that is stored by the container to\n      // `updatedQueryData`\n      mockInstance.forceFetch();\n      relayContext.forceFetch.mock.requests[0].succeed();\n      expect(() => mockInstance.forceFetch()).toFailInvariant(\n        'RelayContainer: Invalid queryData for `entity`, expected an array ' +\n        'of records because the corresponding fragment is plural.',\n      );\n    });\n  });\n\n  describe('query builders', () => {\n    it('are called with variables for variables', () => {\n      expect(entityQuery.mock.calls.length).toBe(1);\n      expect(entityQuery.mock.calls[0][0].site).toEqual(\n        QueryBuilder.createCallVariable('site')\n      );\n    });\n\n    it('are only called once', () => {\n      expect(entityQuery.mock.calls.length).toBe(1);\n\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n      expect(entityQuery.mock.calls.length).toBe(1);\n    });\n  });\n\n  describe('mount', () => {\n    it('renders with default variables', () => {\n      expect(mockInstance.state.variables.site).toBe('mobile');\n    });\n\n    it('lets props override default variables', () => {\n      var anotherInstance = RelayTestUtils.createRenderer().render(\n        genMockPointer => (\n          <MockContainer entity={genMockPointer('42')} site=\"www\" />\n        ),\n        relayContext\n      );\n      expect(anotherInstance.state.variables.site).toBe('www');\n    });\n  });\n\n  describe('update', () => {\n    it('does not update `variables` until data is ready', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      mockInstance.forceUpdate();\n\n      expect(mockInstance.state.variables.site).toBe('mobile');\n    });\n\n    it('updates `variables` after callback when data is ready', () => {\n      var mockCallback = jest.genMockFunction();\n      mockInstance.setVariables({site: 'www'}, mockCallback);\n      jest.runAllTimers();\n\n      mockCallback.mockImplementation(() => {\n        expect(mockInstance.state.variables.site).toBe('mobile');\n      });\n      relayContext.primeCache.mock.requests[0].succeed();\n      expect(mockCallback.mock.calls.length).toBe(1);\n\n      expect(mockInstance.state.variables.site).toBe('www');\n    });\n\n    it('resolves data using updated `variables`', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      var updatedQueryData = {__dataID__: '42', id: '42', url: '//www'};\n      GraphQLStoreQueryResolver.mockDefaultResolveImplementation(fragment => {\n        expect(fragment.getVariables()).toEqual({site: 'www'});\n        return updatedQueryData;\n      });\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(mockInstance.state.queryData.entity).toBe(updatedQueryData);\n    });\n\n    it('aborts pending requests before creating a new request', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n\n      mockInstance.setVariables({site: 'mobile'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n    });\n\n    it('invokes callback for a request that aborts a pending request', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].block();\n\n      var mockCallback = jest.genMockFunction();\n      mockInstance.setVariables({site: 'mobile'}, mockCallback);\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[1].block();\n      expect(mockCallback).toBeCalled();\n    });\n\n    it('does not re-request the last variables', () => {\n      mockInstance.setVariables({site: 'mobile'});\n      jest.runAllTimers();\n\n      var {mock} = relayContext.primeCache;\n      expect(mock.calls.length).toBe(1);\n      expect(Object.keys(mock.calls[0][0]).length).toBe(0);\n    });\n\n    it('re-requests currently pending variables', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n      expect(relayContext.primeCache.mock.calls.length).toBe(2);\n    });\n\n    it('re-requests the last variables for `forceFetch`', () => {\n      mockInstance.forceFetch({site: 'mobile'});\n      jest.runAllTimers();\n\n      var {mock} = relayContext.forceFetch;\n      expect(mock.calls.length).toBe(1);\n      expect(Object.keys(mock.calls[0][0]).length).toBe(1);\n    });\n\n    it('does not re-request the last variables with a pending request', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n      mockInstance.setVariables({site: 'mobile'});\n      jest.runAllTimers();\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n\n      expect(relayContext.primeCache.mock.calls.length).toBe(2);\n      expect(relayContext.primeCache.mock.calls[1][0]).toEqual({});\n    });\n\n    it('invokes the callback as many times as ready state changes', () => {\n      var mockFunction = jest.genMockFunction().mockImplementation(function() {\n        expect(this.constructor).toBe(MockComponent);\n      });\n      mockInstance.setVariables({site: 'www'}, mockFunction);\n      jest.runAllTimers();\n\n      var request = relayContext.primeCache.mock.requests[0];\n      request.block();\n      request.succeed();\n\n      expect(mockFunction.mock.calls).toEqual([\n        [{...defaultState, done: false, ready: false}],\n        [{...defaultState, done: true, ready: true}],\n      ]);\n    });\n\n    it('invokes the callback with the component as `this`', () => {\n      var mockFunction = jest.genMockFunction().mockImplementation(function() {\n        expect(this.constructor).toBe(MockComponent);\n      });\n      mockInstance.setVariables({site: 'www'}, mockFunction);\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].block();\n\n      expect(mockFunction).toBeCalled();\n    });\n\n    it('reconciles only once even if callback calls `setState`', () => {\n      var before = render.mock.calls.length;\n\n      mockInstance.setVariables({site: 'www'}, function() {\n        this.setState({isLoaded: true});\n      });\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(render.mock.calls.length - before).toBe(1);\n    });\n\n    it('does not mutate previous `variables`', () => {\n      var prevVariables = mockInstance.state.variables;\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].succeed();\n\n      expect(prevVariables).toEqual({site: 'mobile'});\n      expect(mockInstance.state.variables).not.toBe(prevVariables);\n    });\n  });\n\n  describe('prepareVariables()', () => {\n    var prepareVariables;\n\n    beforeEach(() => {\n      entityQuery = jest.genMockFunction().mockImplementation(\n        () => Relay.QL`fragment on Node{url(site:$site)}`\n      );\n      render = jest.genMockFunction().mockImplementation(() => <div />);\n      prepareVariables = jest.genMockFunction().mockImplementation(\n        (variables, route) => variables\n      );\n\n      // Make RQLTransform ignore this call.\n      MockComponent = React.createClass({render});\n      var createContainer = Relay.createContainer;\n      MockContainer = createContainer(MockComponent, {\n        fragments: {\n          entity: entityQuery,\n        },\n        initialVariables: {site: 'mobile'},\n        prepareVariables,\n      });\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n        relayContext\n      );\n    });\n\n    it('calls `prepareVariables` when `setVariables` is called', () => {\n      var nextVariables = {site: 'mobile'};\n      prepareVariables.mockImplementation((variables, route) => nextVariables);\n      mockInstance.setVariables({site: 'www'});\n\n      var calls = prepareVariables.mock.calls[1];\n      expect(calls[0]).toEqual({site: 'www'});\n      expect(calls[1]).toBe(\n        RelayMetaRoute.get(mockInstance.context.route.name)\n      );\n\n      // `prepareVariables` output is used to prime the cache...\n      var queries = relayContext.primeCache.mock.calls[0][0];\n      var query = queries[Object.keys(queries)[0]];\n      var fragment = query.getChildren().find(\n        child => child instanceof RelayQuery.Fragment\n      );\n      expect(fragment.getVariables()).toEqual(nextVariables);\n\n      jest.runAllTimers();\n      relayContext.primeCache.mock.requests[0].succeed();\n      // ...but is invisible to the component\n      expect(mockInstance.state.variables).toEqual({site: 'www'});\n    });\n  });\n\n  describe('unmount', () => {\n    it('aborts pending requests when unmounted', () => {\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      expect(relayContext.primeCache.mock.abort[0]).not.toBeCalled();\n      ReactDOM.unmountComponentAtNode(domContainer);\n      expect(relayContext.primeCache.mock.abort[0]).toBeCalled();\n    });\n\n    it('ignores `setState` from callback when request aborts', () => {\n      var mockCallback = jest.genMockFunction()\n        .mockImplementation(readyState => {\n          if (readyState.mounted) {\n            this.setState({isAborted: true});\n          }\n        });\n      mockInstance.setVariables({site: 'www'}, mockCallback);\n      jest.runAllTimers();\n\n      expect(mockCallback).not.toBeCalled();\n      expect(() => {\n        ReactDOM.unmountComponentAtNode(domContainer);\n        jest.runAllTimers();\n      }).not.toThrow();\n\n      expect(mockCallback.mock.calls).toEqual([\n        [{...defaultState, aborted: true, mounted: false}],\n      ]);\n    });\n  });\n\n  describe('prop variable updates', () => {\n    it('updates variables if props are updated', () => {\n      class MockInnerComponent extends React.Component {\n        render() {\n          return <div />;\n        }\n      }\n\n      var MockInnerContainer = Relay.createContainer(MockInnerComponent, {\n        fragments: {\n          entity: () => Relay.QL`fragment on Node{url(site:$site)}`,\n        },\n        initialVariables: {site: undefined},\n      });\n\n      class MockWrapperComponent extends React.Component {\n        render() {\n          return (\n            <MockInnerContainer\n              ref=\"inner\"\n              site={this.props.relay.variables.site}\n              entity={this.props.entity}\n            />\n          );\n        }\n      }\n\n      MockContainer = Relay.createContainer(MockWrapperComponent, {\n        fragments: {\n          entity: variables => Relay.QL`  fragment on Node{\n            ${MockInnerContainer.getFragment('entity', {site: variables.site})}\n          }`,\n        },\n        initialVariables: {site: 'mobile'},\n      });\n\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n        relayContext\n      );\n      var innerComponent = mockInstance.refs.component.refs.inner;\n      expect(innerComponent.state.variables.site).toBe('mobile');\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[0].succeed();\n      expect(mockInstance.state.variables.site).toBe('www');\n\n      expect(innerComponent.state.variables.site).toBe('www');\n    });\n\n    it('resets variables if outside variable props are updated', () => {\n      class MockInnerComponent extends React.Component {\n        render() {\n          return <div />;\n        }\n      }\n\n      var MockInnerContainer = Relay.createContainer(MockInnerComponent, {\n        fragments: {\n          entity: () => Relay.QL`  fragment on Actor {\n                        url(site:$site),\n                        profilePicture(size:$size) {\n                          uri,\n                        },\n                      }`,\n        },\n        initialVariables: {\n          site: undefined,\n          size: 48,\n        },\n      });\n\n      class MockWrapperComponent extends React.Component {\n        render() {\n          return (\n            <MockInnerContainer\n              ref=\"inner\"\n              site={this.props.relay.variables.site}\n              entity={this.props.entity}\n            />\n          );\n        }\n      }\n\n      MockContainer = Relay.createContainer(MockWrapperComponent, {\n        fragments: {\n          entity: variables => Relay.QL`  fragment on Actor {\n            ${MockInnerContainer.getFragment('entity', {site: variables.site})}\n          }`,\n        },\n        initialVariables: {site: 'mobile'},\n      });\n\n      mockInstance = RelayTestUtils.createRenderer(domContainer).render(\n        genMockPointer => <MockContainer entity={genMockPointer('42')} />,\n        relayContext\n      );\n      var innerComponent = mockInstance.refs.component.refs.inner;\n      expect(innerComponent.state.variables.site).toBe('mobile');\n\n      innerComponent.setVariables({size: 32});\n      jest.runAllTimers();\n      relayContext.primeCache.mock.requests[0].succeed();\n      expect(innerComponent.state.variables).toEqual({\n        site: 'mobile',\n        size: 32,\n      });\n\n      mockInstance.setVariables({site: 'www'});\n      jest.runAllTimers();\n\n      relayContext.primeCache.mock.requests[1].succeed();\n      expect(mockInstance.state.variables).toEqual({\n        site: 'www',\n      });\n\n      expect(innerComponent.state.variables).toEqual({\n        site: 'www',\n        size: 48,\n      });\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_setVariables-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_hasPartialData-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayContainer');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer.hasPartialData', () => {\n  var MockContainer;\n  var relayContext;\n  var RelayTestRenderer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    class MockComponent extends React.Component {\n      render() {\n        return <div />;\n      }\n    }\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {foo: () => Relay.QL`fragment on Node{id}`},\n    });\n    relayContext = new RelayContext();\n    RelayTestRenderer = RelayTestUtils.createRenderer();\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      return {__dataID__: dataID, id: dataID};\n    });\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns true for records with partial data bit set', () => {\n    const instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n    const prop = {\n      __dataID__: '123',\n      __status__: RelayRecordStatusMap.setPartialStatus(0, true),\n    };\n    expect(instance.hasPartialData(prop)).toBe(true);\n  });\n\n  it('returns false for records without partial data bit set', () => {\n    const instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n    expect(instance.hasPartialData({__dataID__: '123'})).toBe(false);\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","React","Relay","RelayContext","RelayRecordStatusMap","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayContainer');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer.hasPartialData', () => {\n  var MockContainer;\n  var relayContext;\n  var RelayTestRenderer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    class MockComponent extends React.Component {\n      render() {\n        return <div />;\n      }\n    }\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {foo: () => Relay.QL`fragment on Node{id}`},\n    });\n    relayContext = new RelayContext();\n    RelayTestRenderer = RelayTestUtils.createRenderer();\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      return {__dataID__: dataID, id: dataID};\n    });\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('returns true for records with partial data bit set', () => {\n    const instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n    const prop = {\n      __dataID__: '123',\n      __status__: RelayRecordStatusMap.setPartialStatus(0, true),\n    };\n    expect(instance.hasPartialData(prop)).toBe(true);\n  });\n\n  it('returns false for records without partial data bit set', () => {\n    const instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n    expect(instance.hasPartialData({__dataID__: '123'})).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_hasPartialData-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_hasOptimisticUpdate-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayContainer');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer.hasOptimisticUpdate', () => {\n  var MockContainer;\n  var relayContext;\n  var RelayTestRenderer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    class MockComponent extends React.Component {\n      render() {\n        return <div />;\n      }\n    }\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {foo: () => Relay.QL`fragment on Node{id}`},\n    });\n    relayContext = new RelayContext();\n    RelayTestRenderer = RelayTestUtils.createRenderer();\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      return {__dataID__: dataID, id: dataID};\n    });\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('throws for invalid records', () => {\n    var instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n\n    expect(() => {\n      instance.hasOptimisticUpdate({});\n    }).toFailInvariant(\n      'RelayContainer.hasOptimisticUpdate(): Expected a record in ' +\n      '`MockComponent`.',\n    );\n  });\n\n  it('is only true for queued records', () => {\n    var storeData = relayContext.getStoreData();\n    var recordWriter =\n      storeData.getRecordWriterForOptimisticMutation('mutation');\n    recordWriter.putRecord('123', 'Type');\n    var instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n\n    expect(instance.hasOptimisticUpdate({__dataID__: '123'})).toBe(true);\n  });\n\n  it('is false for non-queued records', () => {\n    relayContext.getStoreData().getRecordWriter()\n      .putRecord('123', 'Type');\n\n    var instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n    expect(instance.hasOptimisticUpdate({__dataID__: '123'})).toBe(false);\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","React","Relay","RelayContext","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.dontMock('RelayContainer');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer.hasOptimisticUpdate', () => {\n  var MockContainer;\n  var relayContext;\n  var RelayTestRenderer;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    class MockComponent extends React.Component {\n      render() {\n        return <div />;\n      }\n    }\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {foo: () => Relay.QL`fragment on Node{id}`},\n    });\n    relayContext = new RelayContext();\n    RelayTestRenderer = RelayTestUtils.createRenderer();\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      return {__dataID__: dataID, id: dataID};\n    });\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('throws for invalid records', () => {\n    var instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n\n    expect(() => {\n      instance.hasOptimisticUpdate({});\n    }).toFailInvariant(\n      'RelayContainer.hasOptimisticUpdate(): Expected a record in ' +\n      '`MockComponent`.',\n    );\n  });\n\n  it('is only true for queued records', () => {\n    var storeData = relayContext.getStoreData();\n    var recordWriter =\n      storeData.getRecordWriterForOptimisticMutation('mutation');\n    recordWriter.putRecord('123', 'Type');\n    var instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n\n    expect(instance.hasOptimisticUpdate({__dataID__: '123'})).toBe(true);\n  });\n\n  it('is false for non-queued records', () => {\n    relayContext.getStoreData().getRecordWriter()\n      .putRecord('123', 'Type');\n\n    var instance = RelayTestRenderer.render(\n      genMockPointer => <MockContainer foo={genMockPointer('123')} />,\n      relayContext\n    );\n    expect(instance.hasOptimisticUpdate({__dataID__: '123'})).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_hasOptimisticUpdate-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_hasFragmentData-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer', () => {\n  describe('hasFragmentData()', () => {\n    let mockContainerInstance;\n    let mockFragmentReference;\n    let mockPointer;\n    let pendingQueryTracker;\n    let store;\n\n    beforeEach(() => {\n      jest.resetModuleRegistry();\n      const MockComponent = React.createClass({render: () => <div />});\n      const MockContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          foo: () => Relay.QL`fragment on Node{id}`,\n        },\n      });\n      const relayContext = new RelayContext();\n      const RelayTestRenderer = RelayTestUtils.createRenderer();\n      mockContainerInstance = RelayTestRenderer.render(\n        genMockPointer => <MockContainer foo={genMockPointer('42')} />,\n        relayContext\n      );\n      mockFragmentReference = MockContainer.getFragment('foo');\n      mockPointer = {__dataID__: '42'};\n      const storeData = relayContext.getStoreData();\n      pendingQueryTracker = storeData.getPendingQueryTracker();\n      store = storeData.getCachedStore();\n    });\n\n    it('returns true when there are no pending queries', () => {\n      pendingQueryTracker.hasPendingQueries =\n        jest.genMockFn().mockImplementation(() => false);\n      const hasData = mockContainerInstance.hasFragmentData(\n        mockFragmentReference,\n        mockPointer\n      );\n      expect(hasData).toBe(true);\n    });\n\n    it('returns true when there are pending queries, but the fragment we are ' +\n       'interested in has resolved', () => {\n      pendingQueryTracker.hasPendingQueries =\n        jest.genMockFn().mockImplementation(() => true);\n      store.hasDeferredFragmentData =\n        jest.genMockFn().mockReturnValue(true);\n      const hasData = mockContainerInstance.hasFragmentData(\n        mockFragmentReference,\n        mockPointer\n      );\n      expect(hasData).toBe(true);\n      expect(store.hasDeferredFragmentData.mock.calls[0][0]).toBe('42');\n      // FIXME: If you can get the fragment ID, implement this expectation!\n      // expect(store.hasDeferredFragmentData.mock.calls[0][1]).toBe('???');\n    });\n\n    it('returns false when there are pending queries, but the fragment we ' +\n       'are interested in has not resolved', () => {\n      pendingQueryTracker.hasPendingQueries =\n        jest.genMockFn().mockImplementation(() => true);\n      store.hasDeferredFragmentData =\n        jest.genMockFn().mockReturnValue(false);\n      const hasData = mockContainerInstance.hasFragmentData(\n       mockFragmentReference,\n       mockPointer\n      );\n      expect(hasData).toBe(false);\n      expect(store.hasDeferredFragmentData.mock.calls[0][0]).toBe('42');\n      // FIXME: If you can get the fragment ID, implement this expectation!\n      // expect(store.hasDeferredFragmentData.mock.calls[0][1]).toBe('???');\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","React","Relay","RelayContext","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer', () => {\n  describe('hasFragmentData()', () => {\n    let mockContainerInstance;\n    let mockFragmentReference;\n    let mockPointer;\n    let pendingQueryTracker;\n    let store;\n\n    beforeEach(() => {\n      jest.resetModuleRegistry();\n      const MockComponent = React.createClass({render: () => <div />});\n      const MockContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          foo: () => Relay.QL`fragment on Node{id}`,\n        },\n      });\n      const relayContext = new RelayContext();\n      const RelayTestRenderer = RelayTestUtils.createRenderer();\n      mockContainerInstance = RelayTestRenderer.render(\n        genMockPointer => <MockContainer foo={genMockPointer('42')} />,\n        relayContext\n      );\n      mockFragmentReference = MockContainer.getFragment('foo');\n      mockPointer = {__dataID__: '42'};\n      const storeData = relayContext.getStoreData();\n      pendingQueryTracker = storeData.getPendingQueryTracker();\n      store = storeData.getCachedStore();\n    });\n\n    it('returns true when there are no pending queries', () => {\n      pendingQueryTracker.hasPendingQueries =\n        jest.genMockFn().mockImplementation(() => false);\n      const hasData = mockContainerInstance.hasFragmentData(\n        mockFragmentReference,\n        mockPointer\n      );\n      expect(hasData).toBe(true);\n    });\n\n    it('returns true when there are pending queries, but the fragment we are ' +\n       'interested in has resolved', () => {\n      pendingQueryTracker.hasPendingQueries =\n        jest.genMockFn().mockImplementation(() => true);\n      store.hasDeferredFragmentData =\n        jest.genMockFn().mockReturnValue(true);\n      const hasData = mockContainerInstance.hasFragmentData(\n        mockFragmentReference,\n        mockPointer\n      );\n      expect(hasData).toBe(true);\n      expect(store.hasDeferredFragmentData.mock.calls[0][0]).toBe('42');\n      // FIXME: If you can get the fragment ID, implement this expectation!\n      // expect(store.hasDeferredFragmentData.mock.calls[0][1]).toBe('???');\n    });\n\n    it('returns false when there are pending queries, but the fragment we ' +\n       'are interested in has not resolved', () => {\n      pendingQueryTracker.hasPendingQueries =\n        jest.genMockFn().mockImplementation(() => true);\n      store.hasDeferredFragmentData =\n        jest.genMockFn().mockReturnValue(false);\n      const hasData = mockContainerInstance.hasFragmentData(\n       mockFragmentReference,\n       mockPointer\n      );\n      expect(hasData).toBe(false);\n      expect(store.hasDeferredFragmentData.mock.calls[0][0]).toBe('42');\n      // FIXME: If you can get the fragment ID, implement this expectation!\n      // expect(store.hasDeferredFragmentData.mock.calls[0][1]).toBe('???');\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_hasFragmentData-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_Component-test.js":{"metadata":{"mtime":1456103379000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayTestUtils = require('RelayTestUtils');\nconst reactComponentExpect = require('reactComponentExpect');\n\ndescribe('RelayContainer', function() {\n  var MockComponent;\n  var MockContainer;\n  var mockCreateContainer;\n  var mockRender;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({\n      render: jest.genMockFunction().mockImplementation(() => <div />),\n    });\n\n    mockCreateContainer = component => {\n      MockContainer = Relay.createContainer(component, {\n        initialVariables: {site: 'mobile'},\n        fragments: {\n          foo: jest.genMockFunction().mockImplementation(\n            () => Relay.QL`fragment on Node{id,url(site:$site)}`\n          ),\n        },\n      });\n    };\n\n    // Create default container for tests\n    mockCreateContainer(MockComponent);\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      expect(dataID).toBe('42');\n      return {__dataID__: '42', id: '42', url: null};\n    });\n\n    const relayContext = new RelayContext();\n    var RelayTestRenderer = RelayTestUtils.createRenderer();\n    mockRender = () => {\n      return RelayTestRenderer.render(\n        genMockPointer => <MockContainer foo={genMockPointer('42')} />,\n        relayContext\n      );\n    };\n  });\n\n  it('creates and instance and renders', () => {\n    var instance;\n    expect(() => {\n      instance = mockRender();\n    }).not.toThrow();\n\n    reactComponentExpect(instance)\n      .toBeCompositeComponentWithType(MockContainer)\n      .expectRenderedChild()\n      .toBeCompositeComponentWithType(MockComponent)\n      .expectRenderedChild()\n      .toBeDOMComponentWithTag('div');\n  });\n\n  it('provides Relay statics', () => {\n    // The correct implementation of these is asserted in other tests. This\n    // test merely checks if the public API exists.\n    expect(typeof MockContainer.getFragmentNames).toEqual('function');\n    expect(typeof MockContainer.getFragment).toEqual('function');\n  });\n\n  it('has the correct displayName based on the inner component', () => {\n    expect(MockContainer.displayName).toEqual('Relay(MockComponent)');\n  });\n\n  it('works with ES6 classes', () => {\n    class MyComponent extends React.Component {\n      render() {\n        return <span />;\n      }\n    }\n\n    mockCreateContainer(MyComponent);\n\n    var instance = mockRender();\n\n    reactComponentExpect(instance)\n      .toBeCompositeComponentWithType(MockContainer)\n      .expectRenderedChild()\n      .toBeCompositeComponentWithType(MyComponent)\n      .expectRenderedChild()\n      .toBeDOMComponentWithTag('span');\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","React","Relay","RelayContext","RelayTestUtils","reactComponentExpect"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayTestUtils = require('RelayTestUtils');\nconst reactComponentExpect = require('reactComponentExpect');\n\ndescribe('RelayContainer', function() {\n  var MockComponent;\n  var MockContainer;\n  var mockCreateContainer;\n  var mockRender;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({\n      render: jest.genMockFunction().mockImplementation(() => <div />),\n    });\n\n    mockCreateContainer = component => {\n      MockContainer = Relay.createContainer(component, {\n        initialVariables: {site: 'mobile'},\n        fragments: {\n          foo: jest.genMockFunction().mockImplementation(\n            () => Relay.QL`fragment on Node{id,url(site:$site)}`\n          ),\n        },\n      });\n    };\n\n    // Create default container for tests\n    mockCreateContainer(MockComponent);\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation((_, dataID) => {\n      expect(dataID).toBe('42');\n      return {__dataID__: '42', id: '42', url: null};\n    });\n\n    const relayContext = new RelayContext();\n    var RelayTestRenderer = RelayTestUtils.createRenderer();\n    mockRender = () => {\n      return RelayTestRenderer.render(\n        genMockPointer => <MockContainer foo={genMockPointer('42')} />,\n        relayContext\n      );\n    };\n  });\n\n  it('creates and instance and renders', () => {\n    var instance;\n    expect(() => {\n      instance = mockRender();\n    }).not.toThrow();\n\n    reactComponentExpect(instance)\n      .toBeCompositeComponentWithType(MockContainer)\n      .expectRenderedChild()\n      .toBeCompositeComponentWithType(MockComponent)\n      .expectRenderedChild()\n      .toBeDOMComponentWithTag('div');\n  });\n\n  it('provides Relay statics', () => {\n    // The correct implementation of these is asserted in other tests. This\n    // test merely checks if the public API exists.\n    expect(typeof MockContainer.getFragmentNames).toEqual('function');\n    expect(typeof MockContainer.getFragment).toEqual('function');\n  });\n\n  it('has the correct displayName based on the inner component', () => {\n    expect(MockContainer.displayName).toEqual('Relay(MockComponent)');\n  });\n\n  it('works with ES6 classes', () => {\n    class MyComponent extends React.Component {\n      render() {\n        return <span />;\n      }\n    }\n\n    mockCreateContainer(MyComponent);\n\n    var instance = mockRender();\n\n    reactComponentExpect(instance)\n      .toBeCompositeComponentWithType(MockContainer)\n      .expectRenderedChild()\n      .toBeCompositeComponentWithType(MyComponent)\n      .expectRenderedChild()\n      .toBeDOMComponentWithTag('span');\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer_Component-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer-test.js":{"metadata":{"mtime":1456300207000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayContainerComparators')\n  .mock('warning');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst GraphQLStoreTestUtils = require('GraphQLStoreTestUtils');\nconst QueryBuilder = require('QueryBuilder');\nconst React = require('React');\nconst ReactTestUtils = require('ReactTestUtils');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayQuery = require('RelayQuery');\nconst RelayRoute = require('RelayRoute');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer', function() {\n  var MockContainer;\n  var MockComponent;\n  var RelayTestRenderer;\n\n  var mockBarFragment;\n  var mockBarPointer;\n  var mockFooFragment;\n  var mockFooPointer;\n  var mockRoute;\n  var relayContext;\n\n  var {getNode, getPointer} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    var render = jest.genMockFunction().mockImplementation(function() {\n      // Make it easier to expect prop values.\n      render.mock.calls[render.mock.calls.length - 1].props = this.props;\n      return <div />;\n    });\n    MockComponent = React.createClass({render});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {\n        foo: jest.genMockFunction().mockImplementation(\n          () => Relay.QL`fragment on Node{id,name}`\n        ),\n        bar: jest.genMockFunction().mockImplementation(\n          () => Relay.QL`fragment on Node @relay(plural:true){id,name}`\n        ),\n      },\n    });\n    MockContainer.mock = {render};\n\n    relayContext = new RelayContext();\n    mockRoute = RelayRoute.genMockInstance();\n    mockFooFragment = getNode(MockContainer.getFragment('foo').getFragment({}));\n    mockFooPointer = getPointer('42', mockFooFragment);\n    mockBarFragment = getNode(MockContainer.getFragment('bar').getFragment());\n    mockBarPointer = getPointer(['42'], mockBarFragment);\n\n    RelayTestRenderer = RelayTestUtils.createRenderer();\n\n    // TODO: #6524377 - migrate to RelayTestUtils matchers\n    jasmine.addMatchers(GraphQLStoreTestUtils.matchers);\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('fragments', () => {\n    it('throws if fragments are missing from spec', () => {\n      expect(() => {\n        Relay.createContainer(MockComponent, {});\n      }).toFailInvariant(\n        'Relay.createContainer(MockComponent, ...): Missing `fragments`, ' +\n        'which is expected to be an object mapping from `propName` to: ' +\n        '() => Relay.QL`...`'\n      );\n    });\n\n    it('throws if container defines invalid `Relay.QL` fragment', () => {\n      var BadContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          viewer: () => Relay.QL`query{node(id:\"123\"){id}}`,\n        },\n      });\n      var badFragmentReference = BadContainer.getFragment('viewer');\n      expect(() => {\n        badFragmentReference.getFragment();\n      }).toFailInvariant(\n        'Relay.QL defined on container `Relay(MockComponent)` named `viewer` ' +\n        'is not a valid fragment. A typical fragment is defined using: ' +\n        'Relay.QL`fragment on Type {...}`'\n      );\n    });\n\n    it('throws if container defines a fragment without function', () => {\n      var BadContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          viewer: Relay.QL`\n            fragment on Viewer {\n              newsFeed,\n            }\n          `,\n        },\n      });\n      expect(() => {\n        BadContainer.getFragment('viewer');\n      }).toFailInvariant(\n        'RelayContainer: Expected `Relay(MockComponent).fragments.viewer` to ' +\n        'be a function returning a fragment. Example: ' +\n        '`viewer: () => Relay.QL`fragment on ...`'\n      );\n    });\n\n    it('creates query for a container without fragments', () => {\n      // Test that scalar constants are substituted, not only query fragments.\n      var MockProfilePhoto = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          testPhotoSize: '100',\n        },\n        fragments: {\n          photo: () => Relay.QL`\n            fragment on Actor {\n              profilePicture(size:$testPhotoSize) {\n                uri\n              }\n            }\n          `,\n        },\n      });\n      var fragment = getNode(\n        MockProfilePhoto.getFragment('photo'),\n        {}\n      );\n      expect(fragment).toEqualQueryNode(getNode(Relay.QL`\n        fragment on Actor {\n          profilePicture(size: \"100\") {\n            uri\n          }\n        }\n      `));\n    });\n\n    it('creates query for a container with fragments', () => {\n      var anotherComponent = React.createClass({render: () => null});\n      var MockProfile = Relay.createContainer(MockComponent, {\n        fragments: {\n          user: () => Relay.QL`\n            fragment on Actor {\n              id,\n              name,\n              ${MockProfileLink.getFragment('user')}\n            }\n          `,\n        },\n      });\n      var MockProfileLink = Relay.createContainer(anotherComponent, {\n        fragments: {\n          user: () => Relay.QL`\n            fragment on Actor {\n              id,\n              url\n            }\n          `,\n        },\n      });\n      var fragment = getNode(\n        MockProfile.getFragment('user'),\n        {}\n      );\n      expect(fragment).toEqualQueryNode(getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          __typename,\n          name,\n          ${Relay.QL`\n            fragment on Actor {\n              id,\n              __typename,\n              url,\n            }\n          `},\n        }\n      `));\n    });\n\n    it('returns whether a named fragment is defined', () => {\n      expect(MockContainer.hasFragment('foo')).toBe(true);\n      expect(MockContainer.hasFragment('bar')).toBe(true);\n      expect(MockContainer.hasFragment('baz')).toBe(false);\n    });\n  });\n\n  describe('conditional fragments', () => {\n    let MockProfile;\n    let profileFragment;\n\n    beforeEach(() => {\n      MockProfile = Relay.createContainer(MockComponent, {\n        fragments: {\n          viewer: () => Relay.QL`\n            fragment on Viewer {\n              primaryEmail\n            }\n          `,\n        },\n      });\n      profileFragment = QueryBuilder.createFragment({\n        name: 'Test',\n        type: 'Viewer',\n        children: [QueryBuilder.createField({fieldName: 'primaryEmail'})],\n      });\n    });\n\n    it('can conditionally include a fragment based on variables', () => {\n      var MockSideshow = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          hasSideshow: null,\n        },\n        fragments: {\n          viewer: variables => Relay.QL`\n            fragment on Viewer {\n              ${MockProfile.getFragment('viewer').if(variables.hasSideshow)},\n            }\n          `,\n        },\n      });\n\n      // hasSideshow: true\n      var fragment = getNode(\n        MockSideshow.getFragment('viewer', {\n          hasSideshow: QueryBuilder.createCallVariable('sideshow'),\n        }),\n        {sideshow: true}\n      );\n      var expected = RelayQuery.Fragment.build(\n        'Test',\n        'Viewer',\n        [getNode(profileFragment)]\n      );\n      expect(fragment).toEqualQueryNode(expected);\n\n      // hasSideshow: false\n      fragment = getNode(\n        MockSideshow.getFragment('viewer', {\n          hasSideshow: QueryBuilder.createCallVariable('sideshow'),\n        }),\n        {sideshow: false}\n      );\n      expect(fragment.getChildren().length).toBe(0);\n    });\n\n    it('can conditionally exclude a fragment based on variables', () => {\n      var MockSideshow = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          hasSideshow: null,\n        },\n        fragments: {\n          viewer: variables => Relay.QL`\n            fragment on Viewer {\n              ${MockProfile\n                .getFragment('viewer')\n                .unless(variables.hasSideshow)},\n            }\n          `,\n        },\n      });\n\n      // hasSideshow: true\n      var fragment = getNode(\n        MockSideshow.getFragment('viewer', {hasSideshow: true}),\n        {}\n      );\n      expect(fragment.getChildren().length).toBe(0);\n\n      // hasSideshow: false\n      fragment = getNode(\n        MockSideshow.getFragment('viewer', {hasSideshow: false}),\n        {}\n      );\n      var expected = RelayQuery.Fragment.build(\n        'Test',\n        'Viewer',\n        [getNode(profileFragment)],\n      );\n      expect(fragment).toEqualQueryNode(expected);\n    });\n  });\n\n  it('throws if rendered without a relay context', () => {\n    var ShallowRenderer = ReactTestUtils.createRenderer();\n    expect(() => ShallowRenderer.render(\n      <MockContainer foo={mockFooPointer} />\n    )).toFailInvariant(\n      'RelayContainer: `Relay(MockComponent)` was rendered with invalid ' +\n      'Relay context `undefined`. Make sure the `relay` property on the ' +\n      'React context conforms to the `RelayContext` interface.'\n    );\n  });\n\n  it('throws if rendered with an invalid relay context', () => {\n    const fakeContext = {\n      getStoreData: null,\n      getFragmentResolver: null,\n    };\n    const ShallowRenderer = ReactTestUtils.createRenderer();\n    expect(() => ShallowRenderer.render(\n      <MockContainer foo={mockFooPointer} />,\n      {relay: fakeContext}\n    )).toFailInvariant(\n      'RelayContainer: `Relay(MockComponent)` was rendered with invalid ' +\n      'Relay context `[object Object]`. Make sure the `relay` property on ' +\n      'the React context conforms to the `RelayContext` interface.'\n    );\n  });\n\n  it('throws if rendered without a route', () => {\n    var ShallowRenderer = ReactTestUtils.createRenderer();\n    expect(() => ShallowRenderer.render(\n      <MockContainer foo={mockFooPointer} />,\n      {relay: relayContext}\n    )).toFailInvariant(\n      'RelayContainer: `Relay(MockComponent)` was rendered without a valid ' +\n      'route. Make sure the route is valid, and make sure that it is ' +\n      'correctly set on the parent component\\'s context ' +\n      '(e.g. using <RelayRootContainer>).'\n    );\n  });\n\n  it('creates resolvers for each query prop with a fragment pointer', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    expect(GraphQLStoreQueryResolver.mock.instances.length).toBe(1);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} bar={[mockBarPointer]} />,\n      relayContext,\n      mockRoute\n    );\n    // `foo` resolver is re-used, `bar` is added\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(2);\n    expect(GraphQLStoreQueryResolver.mock.instances.length).toBe(2);\n  });\n\n  it('recreates resolvers when relay context changes', () => {\n    var relayContextA = new RelayContext();\n    var relayContextB = new RelayContext();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextA,\n      mockRoute\n    );\n\n    expect(relayContextA.getFragmentResolver.mock.calls.length).toBe(1);\n    const mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].dispose).not.toBeCalled();\n    relayContextA.getFragmentResolver.mockClear();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextB,\n      mockRoute\n    );\n\n    expect(relayContextA.getFragmentResolver.mock.calls.length).toBe(0);\n    expect(relayContextB.getFragmentResolver.mock.calls.length).toBe(1);\n    expect(mockResolvers.length).toBe(2);\n    expect(mockResolvers[1].mock.store).toBe(relayContextB.getStoreData());\n    expect(mockResolvers[0].dispose).toBeCalled();\n    expect(mockResolvers[1].dispose).not.toBeCalled();\n  });\n\n  it('reuses resolvers even if route changes', () => {\n    var MockRouteA = RelayRoute.genMock();\n    var MockRouteB = RelayRoute.genMock();\n\n    var mockRouteA = new MockRouteA();\n    var mockRouteB = new MockRouteB();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteA\n    );\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteB\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    expect(GraphQLStoreQueryResolver.mock.instances.length).toBe(1);\n    expect(GraphQLStoreQueryResolver.mock.instances[0].dispose).not.toBeCalled();\n  });\n\n  it('resolves each prop with a query', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n    var fragment = getNode(MockContainer.getFragment('foo'));\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].resolve.mock.calls[0][0])\n      .toEqualQueryNode(fragment);\n    expect(mockResolvers[0].resolve.mock.calls[0][1])\n      .toEqual(mockFooPointer.__dataID__);\n  });\n\n  it('re-resolves props when notified of changes', () => {\n    var mockData = {__dataID__: '42', id: '42', name: 'Tim'};\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation(() => mockData);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    mockResolvers[0].mock.callback();\n\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].dispose.mock.calls.length).toBe(0);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(2);\n  });\n\n  it('re-resolves props when relay context changes', () => {\n    var relayContextA = new RelayContext();\n    var relayContextB = new RelayContext();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextA,\n      mockRoute\n    );\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextB,\n      mockRoute\n    );\n\n    const mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(2);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(1);\n    expect(mockResolvers[1].resolve.mock.calls.length).toBe(1);\n  });\n\n  it('re-resolves props when route changes', () => {\n    var MockRouteA = RelayRoute.genMock();\n    var MockRouteB = RelayRoute.genMock();\n\n    var mockRouteA = new MockRouteA();\n    var mockRouteB = new MockRouteB();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteA\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    const mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(1);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteB\n    );\n\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(2);\n  });\n\n  it('resolves with most recent props', () => {\n    var fooFragment = getNode(MockContainer.getFragment('foo'));\n    var mockPointerA = getPointer('42', mockFooFragment);\n    var mockPointerB = getPointer('43', mockFooFragment);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockPointerA} />,\n      relayContext,\n      mockRoute\n    );\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockPointerB} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].dispose.mock.calls.length).toBe(0);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(2);\n    expect(mockResolvers[0].resolve.mock.calls[0][0])\n      .toEqualQueryNode(fooFragment);\n    expect(mockResolvers[0].resolve.mock.calls[0][1])\n      .toEqual(mockPointerA.__dataID__);\n    expect(mockResolvers[0].resolve.mock.calls[1][0])\n      .toEqualQueryNode(fooFragment);\n    expect(mockResolvers[0].resolve.mock.calls[1][1])\n      .toEqual(mockPointerB.__dataID__);\n  });\n\n  it('does not create resolvers for null/undefined props', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={null} bar={undefined} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(0);\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(undefined);\n    expect(props.foo).toBe(null);\n  });\n\n  it('warns if props are missing fragment pointers', () => {\n    var mockData = {};\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockData} bar={null} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(null);\n    expect(props.foo).toBe(mockData);\n\n    expect([\n      'RelayContainer: Expected prop `%s` supplied to `%s` to ' +\n      'be data fetched by Relay. This is likely an error unless ' +\n      'you are purposely passing in mock data that conforms to ' +\n      'the shape of this component\\'s fragment.',\n      'foo',\n      'MockComponent',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('warns if fragment pointer exists on a different prop', () => {\n    var mockFooPointer = getPointer('42', mockFooFragment);\n\n    RelayTestRenderer.render(\n      () => <MockContainer baz={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect([\n      'RelayContainer: Expected record data for prop `%s` on `%s`, ' +\n      'but it was instead on prop `%s`. Did you misspell a prop or ' +\n      'pass record data into the wrong prop?',\n      'foo',\n      'MockComponent',\n      'baz',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('does not warn if fragment hash exists on a different prop', () => {\n    const deceptiveArray = [];\n    deceptiveArray[Object.keys(mockFooPointer)[0]] = {};\n\n    RelayTestRenderer.render(\n      () => <MockContainer baz={deceptiveArray} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect([\n      'RelayContainer: Expected record data for prop `%s` on `%s`, ' +\n      'but it was instead on prop `%s`. Did you misspell a prop or ' +\n      'pass record data into the wrong prop?',\n      'foo',\n      'MockComponent',\n      'baz',\n    ]).toBeWarnedNTimes(0);\n  });\n\n  it('warns if a fragment is not passed in', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={null} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(undefined);\n    expect(props.foo).toBe(null);\n\n    expect([\n      'RelayContainer: Expected prop `%s` to be supplied to `%s`, but ' +\n      'got `undefined`. Pass an explicit `null` if this is intentional.',\n      'bar',\n      'MockComponent',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('warns if a fragment prop is not an object', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={''} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(undefined);\n    expect(props.foo).toBe('');\n\n    expect([\n      'RelayContainer: Expected prop `%s` supplied to `%s` to be an ' +\n      'object, got `%s`.',\n      'foo',\n      'MockComponent',\n      '',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('throws if non-plural fragment receives an array', () => {\n    var mockData = [];\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer foo={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `foo` supplied to `MockComponent`, ' +\n      'expected a single record because the corresponding fragment is not ' +\n      'plural (i.e. does not have `@relay(plural: true)`).'\n    );\n  });\n\n  it('throws if plural fragment receives a non-array', () => {\n    var mockData = {};\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer bar={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `bar` supplied to `MockComponent`, ' +\n      'expected an array of records because the corresponding fragment has ' +\n      '`@relay(plural: true)`.'\n    );\n  });\n\n  it('warns if plural fragment array item is missing fragment pointers', () => {\n    var mockData = [{}];\n    RelayTestRenderer.render(\n      () => <MockContainer bar={mockData} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect([\n      'RelayContainer: Expected prop `%s` supplied to `%s` to ' +\n      'be data fetched by Relay. This is likely an error unless ' +\n      'you are purposely passing in mock data that conforms to ' +\n      'the shape of this component\\'s fragment.',\n      'bar',\n      'MockComponent',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('throws if some plural fragment items are null', () => {\n    var mockData = [mockBarPointer, null];\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer bar={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `bar` supplied to `MockComponent`. Some ' +\n      'array items contain data fetched by Relay and some items contain ' +\n      'null/mock data.'\n    );\n  });\n\n  it('throws if some but not all plural fragment items are mocked', () => {\n    var mockData = [mockBarPointer, {}];\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer bar={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `bar` supplied to `MockComponent`. Some ' +\n      'array items contain data fetched by Relay and some items contain ' +\n      'null/mock data.'\n    );\n  });\n\n  it('passes through empty arrays for plural fragments', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer bar={[]} />,\n      relayContext,\n      mockRoute\n    );\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n    expect(MockContainer.mock.render.mock.calls[0].props.bar).toEqual([]);\n    expect(relayContext.getFragmentResolver).not.toBeCalled();\n  });\n\n  it('does not re-render if props resolve to the same object', () => {\n    var mockData = {__dataID__: '42', id: '42', name: 'Tim'};\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation(() => mockData);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n    expect(MockContainer.mock.render.mock.calls[0].props.foo).toEqual(mockData);\n\n    GraphQLStoreQueryResolver.mock.instances[0].mock.callback();\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n  });\n\n  it('re-renders if props resolve to different objects', () => {\n    var mockDataList = [\n      {__dataID__: '42', id: '42', name: 'Tim', ...mockFooPointer},\n      {__dataID__: '42', id: '42', name: 'Tee', ...mockFooPointer},\n    ];\n\n    GraphQLStoreQueryResolver.mockResolveImplementation(0, function() {\n      return mockDataList[this.resolve.mock.calls.length - 1];\n    });\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n    expect(MockContainer.mock.render.mock.calls[0].props.foo).toEqual(\n      mockDataList[0]\n    );\n\n    GraphQLStoreQueryResolver.mock.instances[0].mock.callback();\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(2);\n    expect(MockContainer.mock.render.mock.calls[1].props.foo).toEqual(\n      mockDataList[1]\n    );\n  });\n\n  it('applies `shouldComponentUpdate` properly', () => {\n    var mockDataSet = {\n      '42': {__dataID__: '42', name: 'Tim'},\n      '43': {__dataID__: '43', name: 'Tee'},\n      '44': {__dataID__: '44', name: 'Toe'},\n    };\n    var render = jest.genMockFunction().mockImplementation(() => <div />);\n    var shouldComponentUpdate = jest.genMockFunction();\n\n    var MockFastComponent = React.createClass({render, shouldComponentUpdate});\n\n    var MockFastContainer = Relay.createContainer(MockFastComponent, {\n      fragments: {\n        foo: jest.genMockFunction().mockImplementation(\n          () => Relay.QL`fragment on Node{id,name}`\n        ),\n      },\n    });\n\n    GraphQLStoreQueryResolver.mockResolveImplementation(0, (_, dataID) => {\n      return mockDataSet[dataID];\n    });\n    mockFooFragment =\n      getNode(MockFastContainer.getFragment('foo').getFragment({}));\n    var mockPointerA = getPointer('42', mockFooFragment);\n    var mockPointerB = getPointer('43', mockFooFragment);\n    var mockPointerC = getPointer('44', mockFooFragment);\n\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerA} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(1);\n\n    shouldComponentUpdate.mockReturnValue(true);\n\n    // Component wants to update, RelayContainer doesn't.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerA} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(1);\n\n    // Component wants to update, RelayContainer does too.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerB} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(2);\n\n    shouldComponentUpdate.mockReturnValue(false);\n\n    // Component doesn't want to update, RelayContainer does.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerC} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(2);\n\n    // Component doesn't want to update, RelayContainer doesn't either.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerC} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(2);\n\n    shouldComponentUpdate.mockReturnValue(true);\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerC} thing=\"scalar\" />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(3);\n  });\n});\n","dependencies":["configureForRelayOSS","GraphQLStoreQueryResolver","GraphQLStoreTestUtils","QueryBuilder","React","ReactTestUtils","Relay","RelayContext","RelayQuery","RelayRoute","RelayTestUtils"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest\n  .dontMock('RelayContainerComparators')\n  .mock('warning');\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nconst GraphQLStoreTestUtils = require('GraphQLStoreTestUtils');\nconst QueryBuilder = require('QueryBuilder');\nconst React = require('React');\nconst ReactTestUtils = require('ReactTestUtils');\nconst Relay = require('Relay');\nconst RelayContext = require('RelayContext');\nconst RelayQuery = require('RelayQuery');\nconst RelayRoute = require('RelayRoute');\nconst RelayTestUtils = require('RelayTestUtils');\n\ndescribe('RelayContainer', function() {\n  var MockContainer;\n  var MockComponent;\n  var RelayTestRenderer;\n\n  var mockBarFragment;\n  var mockBarPointer;\n  var mockFooFragment;\n  var mockFooPointer;\n  var mockRoute;\n  var relayContext;\n\n  var {getNode, getPointer} = RelayTestUtils;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    var render = jest.genMockFunction().mockImplementation(function() {\n      // Make it easier to expect prop values.\n      render.mock.calls[render.mock.calls.length - 1].props = this.props;\n      return <div />;\n    });\n    MockComponent = React.createClass({render});\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {\n        foo: jest.genMockFunction().mockImplementation(\n          () => Relay.QL`fragment on Node{id,name}`\n        ),\n        bar: jest.genMockFunction().mockImplementation(\n          () => Relay.QL`fragment on Node @relay(plural:true){id,name}`\n        ),\n      },\n    });\n    MockContainer.mock = {render};\n\n    relayContext = new RelayContext();\n    mockRoute = RelayRoute.genMockInstance();\n    mockFooFragment = getNode(MockContainer.getFragment('foo').getFragment({}));\n    mockFooPointer = getPointer('42', mockFooFragment);\n    mockBarFragment = getNode(MockContainer.getFragment('bar').getFragment());\n    mockBarPointer = getPointer(['42'], mockBarFragment);\n\n    RelayTestRenderer = RelayTestUtils.createRenderer();\n\n    // TODO: #6524377 - migrate to RelayTestUtils matchers\n    jasmine.addMatchers(GraphQLStoreTestUtils.matchers);\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  describe('fragments', () => {\n    it('throws if fragments are missing from spec', () => {\n      expect(() => {\n        Relay.createContainer(MockComponent, {});\n      }).toFailInvariant(\n        'Relay.createContainer(MockComponent, ...): Missing `fragments`, ' +\n        'which is expected to be an object mapping from `propName` to: ' +\n        '() => Relay.QL`...`'\n      );\n    });\n\n    it('throws if container defines invalid `Relay.QL` fragment', () => {\n      var BadContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          viewer: () => Relay.QL`query{node(id:\"123\"){id}}`,\n        },\n      });\n      var badFragmentReference = BadContainer.getFragment('viewer');\n      expect(() => {\n        badFragmentReference.getFragment();\n      }).toFailInvariant(\n        'Relay.QL defined on container `Relay(MockComponent)` named `viewer` ' +\n        'is not a valid fragment. A typical fragment is defined using: ' +\n        'Relay.QL`fragment on Type {...}`'\n      );\n    });\n\n    it('throws if container defines a fragment without function', () => {\n      var BadContainer = Relay.createContainer(MockComponent, {\n        fragments: {\n          viewer: Relay.QL`\n            fragment on Viewer {\n              newsFeed,\n            }\n          `,\n        },\n      });\n      expect(() => {\n        BadContainer.getFragment('viewer');\n      }).toFailInvariant(\n        'RelayContainer: Expected `Relay(MockComponent).fragments.viewer` to ' +\n        'be a function returning a fragment. Example: ' +\n        '`viewer: () => Relay.QL`fragment on ...`'\n      );\n    });\n\n    it('creates query for a container without fragments', () => {\n      // Test that scalar constants are substituted, not only query fragments.\n      var MockProfilePhoto = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          testPhotoSize: '100',\n        },\n        fragments: {\n          photo: () => Relay.QL`\n            fragment on Actor {\n              profilePicture(size:$testPhotoSize) {\n                uri\n              }\n            }\n          `,\n        },\n      });\n      var fragment = getNode(\n        MockProfilePhoto.getFragment('photo'),\n        {}\n      );\n      expect(fragment).toEqualQueryNode(getNode(Relay.QL`\n        fragment on Actor {\n          profilePicture(size: \"100\") {\n            uri\n          }\n        }\n      `));\n    });\n\n    it('creates query for a container with fragments', () => {\n      var anotherComponent = React.createClass({render: () => null});\n      var MockProfile = Relay.createContainer(MockComponent, {\n        fragments: {\n          user: () => Relay.QL`\n            fragment on Actor {\n              id,\n              name,\n              ${MockProfileLink.getFragment('user')}\n            }\n          `,\n        },\n      });\n      var MockProfileLink = Relay.createContainer(anotherComponent, {\n        fragments: {\n          user: () => Relay.QL`\n            fragment on Actor {\n              id,\n              url\n            }\n          `,\n        },\n      });\n      var fragment = getNode(\n        MockProfile.getFragment('user'),\n        {}\n      );\n      expect(fragment).toEqualQueryNode(getNode(Relay.QL`\n        fragment on Actor {\n          id,\n          __typename,\n          name,\n          ${Relay.QL`\n            fragment on Actor {\n              id,\n              __typename,\n              url,\n            }\n          `},\n        }\n      `));\n    });\n\n    it('returns whether a named fragment is defined', () => {\n      expect(MockContainer.hasFragment('foo')).toBe(true);\n      expect(MockContainer.hasFragment('bar')).toBe(true);\n      expect(MockContainer.hasFragment('baz')).toBe(false);\n    });\n  });\n\n  describe('conditional fragments', () => {\n    let MockProfile;\n    let profileFragment;\n\n    beforeEach(() => {\n      MockProfile = Relay.createContainer(MockComponent, {\n        fragments: {\n          viewer: () => Relay.QL`\n            fragment on Viewer {\n              primaryEmail\n            }\n          `,\n        },\n      });\n      profileFragment = QueryBuilder.createFragment({\n        name: 'Test',\n        type: 'Viewer',\n        children: [QueryBuilder.createField({fieldName: 'primaryEmail'})],\n      });\n    });\n\n    it('can conditionally include a fragment based on variables', () => {\n      var MockSideshow = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          hasSideshow: null,\n        },\n        fragments: {\n          viewer: variables => Relay.QL`\n            fragment on Viewer {\n              ${MockProfile.getFragment('viewer').if(variables.hasSideshow)},\n            }\n          `,\n        },\n      });\n\n      // hasSideshow: true\n      var fragment = getNode(\n        MockSideshow.getFragment('viewer', {\n          hasSideshow: QueryBuilder.createCallVariable('sideshow'),\n        }),\n        {sideshow: true}\n      );\n      var expected = RelayQuery.Fragment.build(\n        'Test',\n        'Viewer',\n        [getNode(profileFragment)]\n      );\n      expect(fragment).toEqualQueryNode(expected);\n\n      // hasSideshow: false\n      fragment = getNode(\n        MockSideshow.getFragment('viewer', {\n          hasSideshow: QueryBuilder.createCallVariable('sideshow'),\n        }),\n        {sideshow: false}\n      );\n      expect(fragment.getChildren().length).toBe(0);\n    });\n\n    it('can conditionally exclude a fragment based on variables', () => {\n      var MockSideshow = Relay.createContainer(MockComponent, {\n        initialVariables: {\n          hasSideshow: null,\n        },\n        fragments: {\n          viewer: variables => Relay.QL`\n            fragment on Viewer {\n              ${MockProfile\n                .getFragment('viewer')\n                .unless(variables.hasSideshow)},\n            }\n          `,\n        },\n      });\n\n      // hasSideshow: true\n      var fragment = getNode(\n        MockSideshow.getFragment('viewer', {hasSideshow: true}),\n        {}\n      );\n      expect(fragment.getChildren().length).toBe(0);\n\n      // hasSideshow: false\n      fragment = getNode(\n        MockSideshow.getFragment('viewer', {hasSideshow: false}),\n        {}\n      );\n      var expected = RelayQuery.Fragment.build(\n        'Test',\n        'Viewer',\n        [getNode(profileFragment)],\n      );\n      expect(fragment).toEqualQueryNode(expected);\n    });\n  });\n\n  it('throws if rendered without a relay context', () => {\n    var ShallowRenderer = ReactTestUtils.createRenderer();\n    expect(() => ShallowRenderer.render(\n      <MockContainer foo={mockFooPointer} />\n    )).toFailInvariant(\n      'RelayContainer: `Relay(MockComponent)` was rendered with invalid ' +\n      'Relay context `undefined`. Make sure the `relay` property on the ' +\n      'React context conforms to the `RelayContext` interface.'\n    );\n  });\n\n  it('throws if rendered with an invalid relay context', () => {\n    const fakeContext = {\n      getStoreData: null,\n      getFragmentResolver: null,\n    };\n    const ShallowRenderer = ReactTestUtils.createRenderer();\n    expect(() => ShallowRenderer.render(\n      <MockContainer foo={mockFooPointer} />,\n      {relay: fakeContext}\n    )).toFailInvariant(\n      'RelayContainer: `Relay(MockComponent)` was rendered with invalid ' +\n      'Relay context `[object Object]`. Make sure the `relay` property on ' +\n      'the React context conforms to the `RelayContext` interface.'\n    );\n  });\n\n  it('throws if rendered without a route', () => {\n    var ShallowRenderer = ReactTestUtils.createRenderer();\n    expect(() => ShallowRenderer.render(\n      <MockContainer foo={mockFooPointer} />,\n      {relay: relayContext}\n    )).toFailInvariant(\n      'RelayContainer: `Relay(MockComponent)` was rendered without a valid ' +\n      'route. Make sure the route is valid, and make sure that it is ' +\n      'correctly set on the parent component\\'s context ' +\n      '(e.g. using <RelayRootContainer>).'\n    );\n  });\n\n  it('creates resolvers for each query prop with a fragment pointer', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    expect(GraphQLStoreQueryResolver.mock.instances.length).toBe(1);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} bar={[mockBarPointer]} />,\n      relayContext,\n      mockRoute\n    );\n    // `foo` resolver is re-used, `bar` is added\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(2);\n    expect(GraphQLStoreQueryResolver.mock.instances.length).toBe(2);\n  });\n\n  it('recreates resolvers when relay context changes', () => {\n    var relayContextA = new RelayContext();\n    var relayContextB = new RelayContext();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextA,\n      mockRoute\n    );\n\n    expect(relayContextA.getFragmentResolver.mock.calls.length).toBe(1);\n    const mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].dispose).not.toBeCalled();\n    relayContextA.getFragmentResolver.mockClear();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextB,\n      mockRoute\n    );\n\n    expect(relayContextA.getFragmentResolver.mock.calls.length).toBe(0);\n    expect(relayContextB.getFragmentResolver.mock.calls.length).toBe(1);\n    expect(mockResolvers.length).toBe(2);\n    expect(mockResolvers[1].mock.store).toBe(relayContextB.getStoreData());\n    expect(mockResolvers[0].dispose).toBeCalled();\n    expect(mockResolvers[1].dispose).not.toBeCalled();\n  });\n\n  it('reuses resolvers even if route changes', () => {\n    var MockRouteA = RelayRoute.genMock();\n    var MockRouteB = RelayRoute.genMock();\n\n    var mockRouteA = new MockRouteA();\n    var mockRouteB = new MockRouteB();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteA\n    );\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteB\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    expect(GraphQLStoreQueryResolver.mock.instances.length).toBe(1);\n    expect(GraphQLStoreQueryResolver.mock.instances[0].dispose).not.toBeCalled();\n  });\n\n  it('resolves each prop with a query', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n    var fragment = getNode(MockContainer.getFragment('foo'));\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].resolve.mock.calls[0][0])\n      .toEqualQueryNode(fragment);\n    expect(mockResolvers[0].resolve.mock.calls[0][1])\n      .toEqual(mockFooPointer.__dataID__);\n  });\n\n  it('re-resolves props when notified of changes', () => {\n    var mockData = {__dataID__: '42', id: '42', name: 'Tim'};\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation(() => mockData);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    mockResolvers[0].mock.callback();\n\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].dispose.mock.calls.length).toBe(0);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(2);\n  });\n\n  it('re-resolves props when relay context changes', () => {\n    var relayContextA = new RelayContext();\n    var relayContextB = new RelayContext();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextA,\n      mockRoute\n    );\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContextB,\n      mockRoute\n    );\n\n    const mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(2);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(1);\n    expect(mockResolvers[1].resolve.mock.calls.length).toBe(1);\n  });\n\n  it('re-resolves props when route changes', () => {\n    var MockRouteA = RelayRoute.genMock();\n    var MockRouteB = RelayRoute.genMock();\n\n    var mockRouteA = new MockRouteA();\n    var mockRouteB = new MockRouteB();\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteA\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(1);\n    const mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(1);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRouteB\n    );\n\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(2);\n  });\n\n  it('resolves with most recent props', () => {\n    var fooFragment = getNode(MockContainer.getFragment('foo'));\n    var mockPointerA = getPointer('42', mockFooFragment);\n    var mockPointerB = getPointer('43', mockFooFragment);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockPointerA} />,\n      relayContext,\n      mockRoute\n    );\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockPointerB} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n\n    expect(mockResolvers.length).toBe(1);\n    expect(mockResolvers[0].dispose.mock.calls.length).toBe(0);\n    expect(mockResolvers[0].resolve.mock.calls.length).toBe(2);\n    expect(mockResolvers[0].resolve.mock.calls[0][0])\n      .toEqualQueryNode(fooFragment);\n    expect(mockResolvers[0].resolve.mock.calls[0][1])\n      .toEqual(mockPointerA.__dataID__);\n    expect(mockResolvers[0].resolve.mock.calls[1][0])\n      .toEqualQueryNode(fooFragment);\n    expect(mockResolvers[0].resolve.mock.calls[1][1])\n      .toEqual(mockPointerB.__dataID__);\n  });\n\n  it('does not create resolvers for null/undefined props', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={null} bar={undefined} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(relayContext.getFragmentResolver.mock.calls.length).toBe(0);\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(undefined);\n    expect(props.foo).toBe(null);\n  });\n\n  it('warns if props are missing fragment pointers', () => {\n    var mockData = {};\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockData} bar={null} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(null);\n    expect(props.foo).toBe(mockData);\n\n    expect([\n      'RelayContainer: Expected prop `%s` supplied to `%s` to ' +\n      'be data fetched by Relay. This is likely an error unless ' +\n      'you are purposely passing in mock data that conforms to ' +\n      'the shape of this component\\'s fragment.',\n      'foo',\n      'MockComponent',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('warns if fragment pointer exists on a different prop', () => {\n    var mockFooPointer = getPointer('42', mockFooFragment);\n\n    RelayTestRenderer.render(\n      () => <MockContainer baz={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect([\n      'RelayContainer: Expected record data for prop `%s` on `%s`, ' +\n      'but it was instead on prop `%s`. Did you misspell a prop or ' +\n      'pass record data into the wrong prop?',\n      'foo',\n      'MockComponent',\n      'baz',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('does not warn if fragment hash exists on a different prop', () => {\n    const deceptiveArray = [];\n    deceptiveArray[Object.keys(mockFooPointer)[0]] = {};\n\n    RelayTestRenderer.render(\n      () => <MockContainer baz={deceptiveArray} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect([\n      'RelayContainer: Expected record data for prop `%s` on `%s`, ' +\n      'but it was instead on prop `%s`. Did you misspell a prop or ' +\n      'pass record data into the wrong prop?',\n      'foo',\n      'MockComponent',\n      'baz',\n    ]).toBeWarnedNTimes(0);\n  });\n\n  it('warns if a fragment is not passed in', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={null} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(undefined);\n    expect(props.foo).toBe(null);\n\n    expect([\n      'RelayContainer: Expected prop `%s` to be supplied to `%s`, but ' +\n      'got `undefined`. Pass an explicit `null` if this is intentional.',\n      'bar',\n      'MockComponent',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('warns if a fragment prop is not an object', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer foo={''} />,\n      relayContext,\n      mockRoute\n    );\n\n    var mockResolvers = GraphQLStoreQueryResolver.mock.instances;\n    expect(mockResolvers.length).toBe(0);\n    var props = MockContainer.mock.render.mock.calls[0].props;\n    expect(props.bar).toBe(undefined);\n    expect(props.foo).toBe('');\n\n    expect([\n      'RelayContainer: Expected prop `%s` supplied to `%s` to be an ' +\n      'object, got `%s`.',\n      'foo',\n      'MockComponent',\n      '',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('throws if non-plural fragment receives an array', () => {\n    var mockData = [];\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer foo={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `foo` supplied to `MockComponent`, ' +\n      'expected a single record because the corresponding fragment is not ' +\n      'plural (i.e. does not have `@relay(plural: true)`).'\n    );\n  });\n\n  it('throws if plural fragment receives a non-array', () => {\n    var mockData = {};\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer bar={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `bar` supplied to `MockComponent`, ' +\n      'expected an array of records because the corresponding fragment has ' +\n      '`@relay(plural: true)`.'\n    );\n  });\n\n  it('warns if plural fragment array item is missing fragment pointers', () => {\n    var mockData = [{}];\n    RelayTestRenderer.render(\n      () => <MockContainer bar={mockData} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect([\n      'RelayContainer: Expected prop `%s` supplied to `%s` to ' +\n      'be data fetched by Relay. This is likely an error unless ' +\n      'you are purposely passing in mock data that conforms to ' +\n      'the shape of this component\\'s fragment.',\n      'bar',\n      'MockComponent',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('throws if some plural fragment items are null', () => {\n    var mockData = [mockBarPointer, null];\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer bar={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `bar` supplied to `MockComponent`. Some ' +\n      'array items contain data fetched by Relay and some items contain ' +\n      'null/mock data.'\n    );\n  });\n\n  it('throws if some but not all plural fragment items are mocked', () => {\n    var mockData = [mockBarPointer, {}];\n    expect(() => {\n      RelayTestRenderer.render(\n        () => <MockContainer bar={mockData} />,\n        relayContext,\n        mockRoute\n      );\n    }).toFailInvariant(\n      'RelayContainer: Invalid prop `bar` supplied to `MockComponent`. Some ' +\n      'array items contain data fetched by Relay and some items contain ' +\n      'null/mock data.'\n    );\n  });\n\n  it('passes through empty arrays for plural fragments', () => {\n    RelayTestRenderer.render(\n      () => <MockContainer bar={[]} />,\n      relayContext,\n      mockRoute\n    );\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n    expect(MockContainer.mock.render.mock.calls[0].props.bar).toEqual([]);\n    expect(relayContext.getFragmentResolver).not.toBeCalled();\n  });\n\n  it('does not re-render if props resolve to the same object', () => {\n    var mockData = {__dataID__: '42', id: '42', name: 'Tim'};\n\n    GraphQLStoreQueryResolver.mockDefaultResolveImplementation(() => mockData);\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n    expect(MockContainer.mock.render.mock.calls[0].props.foo).toEqual(mockData);\n\n    GraphQLStoreQueryResolver.mock.instances[0].mock.callback();\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n  });\n\n  it('re-renders if props resolve to different objects', () => {\n    var mockDataList = [\n      {__dataID__: '42', id: '42', name: 'Tim', ...mockFooPointer},\n      {__dataID__: '42', id: '42', name: 'Tee', ...mockFooPointer},\n    ];\n\n    GraphQLStoreQueryResolver.mockResolveImplementation(0, function() {\n      return mockDataList[this.resolve.mock.calls.length - 1];\n    });\n\n    RelayTestRenderer.render(\n      () => <MockContainer foo={mockFooPointer} />,\n      relayContext,\n      mockRoute\n    );\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(1);\n    expect(MockContainer.mock.render.mock.calls[0].props.foo).toEqual(\n      mockDataList[0]\n    );\n\n    GraphQLStoreQueryResolver.mock.instances[0].mock.callback();\n\n    expect(MockContainer.mock.render.mock.calls.length).toBe(2);\n    expect(MockContainer.mock.render.mock.calls[1].props.foo).toEqual(\n      mockDataList[1]\n    );\n  });\n\n  it('applies `shouldComponentUpdate` properly', () => {\n    var mockDataSet = {\n      '42': {__dataID__: '42', name: 'Tim'},\n      '43': {__dataID__: '43', name: 'Tee'},\n      '44': {__dataID__: '44', name: 'Toe'},\n    };\n    var render = jest.genMockFunction().mockImplementation(() => <div />);\n    var shouldComponentUpdate = jest.genMockFunction();\n\n    var MockFastComponent = React.createClass({render, shouldComponentUpdate});\n\n    var MockFastContainer = Relay.createContainer(MockFastComponent, {\n      fragments: {\n        foo: jest.genMockFunction().mockImplementation(\n          () => Relay.QL`fragment on Node{id,name}`\n        ),\n      },\n    });\n\n    GraphQLStoreQueryResolver.mockResolveImplementation(0, (_, dataID) => {\n      return mockDataSet[dataID];\n    });\n    mockFooFragment =\n      getNode(MockFastContainer.getFragment('foo').getFragment({}));\n    var mockPointerA = getPointer('42', mockFooFragment);\n    var mockPointerB = getPointer('43', mockFooFragment);\n    var mockPointerC = getPointer('44', mockFooFragment);\n\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerA} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(1);\n\n    shouldComponentUpdate.mockReturnValue(true);\n\n    // Component wants to update, RelayContainer doesn't.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerA} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(1);\n\n    // Component wants to update, RelayContainer does too.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerB} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(2);\n\n    shouldComponentUpdate.mockReturnValue(false);\n\n    // Component doesn't want to update, RelayContainer does.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerC} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(2);\n\n    // Component doesn't want to update, RelayContainer doesn't either.\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerC} />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(2);\n\n    shouldComponentUpdate.mockReturnValue(true);\n    RelayTestRenderer.render(\n      () => <MockFastContainer foo={mockPointerC} thing=\"scalar\" />,\n      relayContext,\n      mockRoute\n    );\n    expect(render.mock.calls.length).toBe(3);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/RelayContainer-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/isRelayContainer-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst React = require('React');\nconst Relay = require('Relay');\n\ndescribe('isRelayContainer', function() {\n  var MockComponent;\n  var MockContainer;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({\n      render: () => <div />,\n    });\n\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n  });\n\n  it('identifies Relay containers correctly', () => {\n    expect(Relay.isContainer(MockContainer)).toBe(true);\n\n    expect(Relay.isContainer(MockComponent)).toBe(false);\n  });\n});\n","dependencies":["React","Relay"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst React = require('React');\nconst Relay = require('Relay');\n\ndescribe('isRelayContainer', function() {\n  var MockComponent;\n  var MockContainer;\n\n  beforeEach(function() {\n    jest.resetModuleRegistry();\n\n    MockComponent = React.createClass({\n      render: () => <div />,\n    });\n\n    MockContainer = Relay.createContainer(MockComponent, {\n      fragments: {},\n    });\n  });\n\n  it('identifies Relay containers correctly', () => {\n    expect(Relay.isContainer(MockContainer)).toBe(true);\n\n    expect(Relay.isContainer(MockComponent)).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/isRelayContainer-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/isReactComponent-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst React = require('React');\nconst isReactComponent = require('isReactComponent');\n\ndescribe('isReactComponent', function() {\n  it('identifies components that extends React.Component', function() {\n    class MockComponent extends React.Component {\n      render() {\n        return <div />;\n      }\n    }\n    expect(isReactComponent(MockComponent)).toBe(true);\n  });\n\n  it('identifies components created by React.createClass()', function() {\n    var MockComponent = React.createClass({\n      render: () => <div />,\n    });\n    expect(isReactComponent(MockComponent)).toBe(true);\n  });\n\n  it('does not identify function components', function() {\n    var MockComponent = () => <div />;\n    expect(isReactComponent(MockComponent)).toBe(false);\n  });\n});\n","dependencies":["React","isReactComponent"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nconst React = require('React');\nconst isReactComponent = require('isReactComponent');\n\ndescribe('isReactComponent', function() {\n  it('identifies components that extends React.Component', function() {\n    class MockComponent extends React.Component {\n      render() {\n        return <div />;\n      }\n    }\n    expect(isReactComponent(MockComponent)).toBe(true);\n  });\n\n  it('identifies components created by React.createClass()', function() {\n    var MockComponent = React.createClass({\n      render: () => <div />,\n    });\n    expect(isReactComponent(MockComponent)).toBe(true);\n  });\n\n  it('does not identify function components', function() {\n    var MockComponent = () => <div />;\n    expect(isReactComponent(MockComponent)).toBe(false);\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/isReactComponent-test.js"}},"/Users/cpojer/Projects/relay/src/container/__tests__/getRelayQueries-test.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst getRelayQueries = require('getRelayQueries');\n\ndescribe('getRelayQueries', () => {\n  var MockPageContainer;\n  var MockPageComponent;\n\n  var makeRoute;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockPageComponent = class MockPageComponent extends React.Component {\n      render() {\n        return <div/>;\n      }\n    };\n\n    MockPageContainer = Relay.createContainer(MockPageComponent, {\n      fragments: {\n        first: () => Relay.QL`fragment on Node{id,firstName}`,\n        last: () => Relay.QL`fragment on Node{id,lastName}`,\n      },\n    });\n\n    makeRoute = function() {\n      class MockRoute extends Relay.Route {}\n      MockRoute.routeName = 'MockRoute';\n      MockRoute.path = '/{id}';\n      MockRoute.paramDefinitions = {\n        id: {\n          type: 'String',\n          id: true,\n        },\n      };\n      MockRoute.queries = {\n        first: Component => Relay.QL`\n          query {\n            node(id:$id) {\n              ${Component.getFragment('first')}\n            }\n          }\n        `,\n        last: Component => Relay.QL`\n          query {\n            node(id:$id) {\n              ${Component.getFragment('last')}\n            }\n          }\n        `,\n      };\n      return MockRoute;\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates a query for a component given a route', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({id: '123'});\n    var queries = getRelayQueries(MockPageContainer, route);\n\n    var expected = {\n      first: getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            ${Relay.QL`fragment on Node{id,firstName}`}\n          }\n        }\n      `),\n      last: getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            ${Relay.QL`fragment on Node{id,lastName}`}\n          }\n        }\n      `),\n    };\n\n    expect(queries.first).toEqualQueryRoot(expected.first);\n    expect(queries.first.getVariables()).toBe(route.params);\n\n    expect(queries.last).toEqualQueryRoot(expected.last);\n    expect(queries.last.getVariables()).toBe(route.params);\n  });\n\n  it('omits queries with undefined root call values', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({id: undefined});\n    var queries = getRelayQueries(MockPageContainer, route);\n\n    expect(queries).toEqual({\n      first: null,\n      last: null,\n    });\n  });\n\n  it('returns null for fragments without a matching route query', () => {\n    class FirstRoute extends Relay.Route {}\n    FirstRoute.routeName = 'BadRoute';\n    FirstRoute.queries = {\n      first: () => Relay.QL`query { node(id:\"123\") }`,\n    };\n    var route = new FirstRoute({});\n    var queries = getRelayQueries(MockPageContainer, route);\n\n    expect(queries.last).toBe(null);\n  });\n\n  it('throws for invalid `Relay.QL` queries', () => {\n    class BadRoute extends Relay.Route {}\n    BadRoute.routeName = 'BadRoute';\n    BadRoute.queries = {\n      first: () => Relay.QL`fragment on Node{id}`,\n    };\n    var badRoute = new BadRoute({});\n\n    expect(() => {\n      getRelayQueries(MockPageContainer, badRoute);\n    }).toFailInvariant(\n      'Relay.QL: query `BadRoute.queries.first` is invalid, a typical ' +\n      'query is defined using: () => Relay.QL`query { ... }`.'\n    );\n  });\n\n  it('warns if a container does not include a required fragment', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({id: '123'});\n\n    var AnotherMockContainer = Relay.createContainer(MockPageComponent, {\n      fragments: {\n        first: () => Relay.QL`fragment on Node{id}`,\n      },\n    });\n\n    var queries = getRelayQueries(AnotherMockContainer, route);\n    expect(queries.last).toBe(undefined);\n\n    expect([\n      'Relay.QL: query `%s.queries.%s` is invalid, expected fragment ' +\n      '`%s.fragments.%s` to be defined.',\n      'MockRoute',\n      'last',\n      'Relay(MockPageComponent)',\n      'last',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('sets root fragment variables to route params', () => {\n    class MockRoute extends Relay.Route {}\n    MockRoute.routeName = 'MockRoute';\n    MockRoute.path = '/';\n    MockRoute.paramDefinitions = {};\n    MockRoute.queries = {\n      first: () => Relay.QL`\n        query {\n          viewer\n        }\n      `,\n    };\n\n    var route = new MockRoute({\n      fragmentParam: 'foo',\n      otherParam: 'bar',\n    });\n\n    var AnotherMockContainer = Relay.createContainer(MockPageComponent, {\n      initialVariables: {\n        fragmentParam: null,\n      },\n      fragments: {\n        first: () => Relay.QL`fragment on Node{id}`,\n      },\n    });\n\n    var queries = getRelayQueries(AnotherMockContainer, route);\n\n    expect(queries.first.getVariables()).toEqual(route.params);\n    // `otherParam` is not passed to the root fragment since the variable\n    // is not defined in the component's `initialVariables`.\n    expect(queries.first.getChildren()[0].getVariables()).toEqual({\n      fragmentParam: 'foo',\n    });\n  });\n});\n","dependencies":["configureForRelayOSS","React","Relay","RelayTestUtils","getRelayQueries"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @emails oncall+relay\n */\n\n'use strict';\n\nrequire('configureForRelayOSS');\n\njest.mock('warning');\n\nconst React = require('React');\nconst Relay = require('Relay');\nconst RelayTestUtils = require('RelayTestUtils');\n\nconst getRelayQueries = require('getRelayQueries');\n\ndescribe('getRelayQueries', () => {\n  var MockPageContainer;\n  var MockPageComponent;\n\n  var makeRoute;\n\n  var {getNode} = RelayTestUtils;\n\n  beforeEach(() => {\n    jest.resetModuleRegistry();\n\n    MockPageComponent = class MockPageComponent extends React.Component {\n      render() {\n        return <div/>;\n      }\n    };\n\n    MockPageContainer = Relay.createContainer(MockPageComponent, {\n      fragments: {\n        first: () => Relay.QL`fragment on Node{id,firstName}`,\n        last: () => Relay.QL`fragment on Node{id,lastName}`,\n      },\n    });\n\n    makeRoute = function() {\n      class MockRoute extends Relay.Route {}\n      MockRoute.routeName = 'MockRoute';\n      MockRoute.path = '/{id}';\n      MockRoute.paramDefinitions = {\n        id: {\n          type: 'String',\n          id: true,\n        },\n      };\n      MockRoute.queries = {\n        first: Component => Relay.QL`\n          query {\n            node(id:$id) {\n              ${Component.getFragment('first')}\n            }\n          }\n        `,\n        last: Component => Relay.QL`\n          query {\n            node(id:$id) {\n              ${Component.getFragment('last')}\n            }\n          }\n        `,\n      };\n      return MockRoute;\n    };\n\n    jasmine.addMatchers(RelayTestUtils.matchers);\n  });\n\n  it('creates a query for a component given a route', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({id: '123'});\n    var queries = getRelayQueries(MockPageContainer, route);\n\n    var expected = {\n      first: getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            ${Relay.QL`fragment on Node{id,firstName}`}\n          }\n        }\n      `),\n      last: getNode(Relay.QL`\n        query {\n          node(id: \"123\") {\n            ${Relay.QL`fragment on Node{id,lastName}`}\n          }\n        }\n      `),\n    };\n\n    expect(queries.first).toEqualQueryRoot(expected.first);\n    expect(queries.first.getVariables()).toBe(route.params);\n\n    expect(queries.last).toEqualQueryRoot(expected.last);\n    expect(queries.last.getVariables()).toBe(route.params);\n  });\n\n  it('omits queries with undefined root call values', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({id: undefined});\n    var queries = getRelayQueries(MockPageContainer, route);\n\n    expect(queries).toEqual({\n      first: null,\n      last: null,\n    });\n  });\n\n  it('returns null for fragments without a matching route query', () => {\n    class FirstRoute extends Relay.Route {}\n    FirstRoute.routeName = 'BadRoute';\n    FirstRoute.queries = {\n      first: () => Relay.QL`query { node(id:\"123\") }`,\n    };\n    var route = new FirstRoute({});\n    var queries = getRelayQueries(MockPageContainer, route);\n\n    expect(queries.last).toBe(null);\n  });\n\n  it('throws for invalid `Relay.QL` queries', () => {\n    class BadRoute extends Relay.Route {}\n    BadRoute.routeName = 'BadRoute';\n    BadRoute.queries = {\n      first: () => Relay.QL`fragment on Node{id}`,\n    };\n    var badRoute = new BadRoute({});\n\n    expect(() => {\n      getRelayQueries(MockPageContainer, badRoute);\n    }).toFailInvariant(\n      'Relay.QL: query `BadRoute.queries.first` is invalid, a typical ' +\n      'query is defined using: () => Relay.QL`query { ... }`.'\n    );\n  });\n\n  it('warns if a container does not include a required fragment', () => {\n    var MockRoute = makeRoute();\n    var route = new MockRoute({id: '123'});\n\n    var AnotherMockContainer = Relay.createContainer(MockPageComponent, {\n      fragments: {\n        first: () => Relay.QL`fragment on Node{id}`,\n      },\n    });\n\n    var queries = getRelayQueries(AnotherMockContainer, route);\n    expect(queries.last).toBe(undefined);\n\n    expect([\n      'Relay.QL: query `%s.queries.%s` is invalid, expected fragment ' +\n      '`%s.fragments.%s` to be defined.',\n      'MockRoute',\n      'last',\n      'Relay(MockPageComponent)',\n      'last',\n    ]).toBeWarnedNTimes(1);\n  });\n\n  it('sets root fragment variables to route params', () => {\n    class MockRoute extends Relay.Route {}\n    MockRoute.routeName = 'MockRoute';\n    MockRoute.path = '/';\n    MockRoute.paramDefinitions = {};\n    MockRoute.queries = {\n      first: () => Relay.QL`\n        query {\n          viewer\n        }\n      `,\n    };\n\n    var route = new MockRoute({\n      fragmentParam: 'foo',\n      otherParam: 'bar',\n    });\n\n    var AnotherMockContainer = Relay.createContainer(MockPageComponent, {\n      initialVariables: {\n        fragmentParam: null,\n      },\n      fragments: {\n        first: () => Relay.QL`fragment on Node{id}`,\n      },\n    });\n\n    var queries = getRelayQueries(AnotherMockContainer, route);\n\n    expect(queries.first.getVariables()).toEqual(route.params);\n    // `otherParam` is not passed to the root fragment since the variable\n    // is not defined in the component's `initialVariables`.\n    expect(queries.first.getChildren()[0].getVariables()).toEqual({\n      fragmentParam: 'foo',\n    });\n  });\n});\n"},"name":"/Users/cpojer/Projects/relay/src/container/__tests__/getRelayQueries-test.js"}},"/Users/cpojer/Projects/relay/src/__forks__/container/RelayContainerProxy.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayContainerProxy","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayContainerProxy\n */\n\n'use strict';\n\nmodule.exports = require('RelayOSSContainerProxy');\n","dependencies":["RelayOSSContainerProxy","RelayContainerProxy"],"id":"RelayContainerProxy","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayContainerProxy\n */\n\n'use strict';\n\nmodule.exports = require('RelayOSSContainerProxy');\n"}}},"/Users/cpojer/Projects/relay/src/__forks__/container/prepareRelayContainerProps.js":{"metadata":{"mtime":1455679338000},"data":{"name":"prepareRelayContainerProps","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule prepareRelayContainerProps\n */\n\n'use strict';\n\nmodule.exports = require('prepareRelayOSSContainerProps');\n","dependencies":["prepareRelayOSSContainerProps","prepareRelayContainerProps"],"id":"prepareRelayContainerProps","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule prepareRelayContainerProps\n */\n\n'use strict';\n\nmodule.exports = require('prepareRelayOSSContainerProps');\n"}}},"/Users/cpojer/Projects/relay/src/__forks__/interface/RelayNodeInterface.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayNodeInterface","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayNodeInterface\n */\n\n'use strict';\n\nmodule.exports = require('RelayOSSNodeInterface');\n","dependencies":["RelayOSSNodeInterface","RelayNodeInterface"],"id":"RelayNodeInterface","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayNodeInterface\n */\n\n'use strict';\n\nmodule.exports = require('RelayOSSNodeInterface');\n"}}},"/Users/cpojer/Projects/relay/src/__forks__/interface/RelayConnectionInterface.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayConnectionInterface","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayConnectionInterface\n */\n\n'use strict';\n\nmodule.exports = require('RelayOSSConnectionInterface');\n","dependencies":["RelayOSSConnectionInterface","RelayConnectionInterface"],"id":"RelayConnectionInterface","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayConnectionInterface\n */\n\n'use strict';\n\nmodule.exports = require('RelayOSSConnectionInterface');\n"}}},"/Users/cpojer/Projects/relay/src/__forks__/traversal/printRelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"name":"printRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule printRelayQuery\n */\n\n'use strict';\n\nmodule.exports = require('printRelayOSSQuery');\n","dependencies":["printRelayOSSQuery","printRelayQuery"],"id":"printRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule printRelayQuery\n */\n\n'use strict';\n\nmodule.exports = require('printRelayOSSQuery');\n"}}},"/Users/cpojer/Projects/relay/src/__forks__/Relay.js":{"metadata":{"mtime":1455679338000},"data":{"name":"Relay","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Relay\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar RelayDefaultNetworkLayer = require('RelayDefaultNetworkLayer');\nvar RelayPublic = require('RelayPublic');\n\n// By default, assume that GraphQL is served at `/graphql` on the same domain.\n// $FlowFixMe(>=0.16.0)\nRelayPublic.injectNetworkLayer(new RelayDefaultNetworkLayer('/graphql'));\n\nmodule.exports = {\n  ...RelayPublic,\n  // Expose the default network layer to allow convenient re-configuration.\n  DefaultNetworkLayer: RelayDefaultNetworkLayer,\n};\n","dependencies":["RelayDefaultNetworkLayer","RelayPublic","Relay"],"id":"Relay","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Relay\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar RelayDefaultNetworkLayer = require('RelayDefaultNetworkLayer');\nvar RelayPublic = require('RelayPublic');\n\n// By default, assume that GraphQL is served at `/graphql` on the same domain.\n// $FlowFixMe(>=0.16.0)\nRelayPublic.injectNetworkLayer(new RelayDefaultNetworkLayer('/graphql'));\n\nmodule.exports = {\n  ...RelayPublic,\n  // Expose the default network layer to allow convenient re-configuration.\n  DefaultNetworkLayer: RelayDefaultNetworkLayer,\n};\n"}}},"/Users/cpojer/Projects/relay/src/__mocks__/RelayPublic.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayPublic');\n","dependencies":["RelayPublic"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require.requireActual('RelayPublic');\n"},"name":"/Users/cpojer/Projects/relay/src/__mocks__/RelayPublic.js"}},"/Users/cpojer/Projects/relay/src/__mocks__/Relay.js":{"metadata":{"mtime":1455679338000},"data":{"isHaste":false,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require('RelayPublic');\n","dependencies":["RelayPublic"],"source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\nmodule.exports = require('RelayPublic');\n"},"name":"/Users/cpojer/Projects/relay/src/__mocks__/Relay.js"}},"/Users/cpojer/Projects/relay/src/container/RelayRootContainer.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayRootContainer","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRootContainer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst React = require('React');\nimport type {RelayQueryConfigSpec} from 'RelayContainer';\nconst RelayPropTypes = require('RelayPropTypes');\nimport type {\n  ComponentFetchState,\n  ReadyState,\n  RelayContainer,\n} from 'RelayTypes';\nconst RelayRenderer = require('RelayRenderer');\n\ntype RootContainerProps = {\n  Component: RelayContainer;\n  forceFetch?: ?boolean;\n  onReadyStateChange?: ?(readyState: ReadyState) => void;\n  renderFailure?: ?(error: Error, retry: ?() => void) => ReactElement;\n  renderFetched?: ?(\n    data: Object,\n    fetchState: ComponentFetchState\n  ) => ReactElement;\n  renderLoading?: ?() => ReactElement;\n  route: RelayQueryConfigSpec;\n};\n\nconst {PropTypes} = React;\n\n/**\n * @public\n *\n * RelayRootContainer sends requests for data required to render the supplied\n * `Component` and `route`. The `Component` must be a container created using\n * `Relay.createContainer`.\n *\n * === Render Callbacks ===\n *\n * Whenever the RelayRootContainer renders, one of three render callback props\n * are invoked depending on whether data is being loaded, can be resolved, or if\n * an error is incurred.\n *\n *  ReactDOM.render(\n *    <RelayRootContainer\n *      Component={FooComponent}\n *      route={fooRoute}\n *      renderLoading={function() {\n *        return <View>Loading...</View>;\n *      }}\n *      renderFetched={function(data) {\n *        // Must spread `data` into <FooComponent>.\n *        return <FooComponent {...data} />;\n *      }}\n *      renderFailure={function(error) {\n *        return <View>Error: {error.message}</View>;\n *      }}\n *    />,\n *    ...\n *  );\n *\n * If a callback is not supplied, it has a default behavior:\n *\n *  - Without `renderFetched`, `Component` will be rendered with fetched data.\n *  - Without `renderFailure`, an error will render to null.\n *  - Without `renderLoading`, the existing view will continue to render. If\n *    this is the initial mount (with no existing view), renders to null.\n *\n * In addition, supplying a `renderLoading` that returns undefined has the same\n * effect as not supplying the callback. (Usually, an undefined return value is\n * an error in React).\n *\n * === Refs ===\n *\n * References to elements rendered by any of these callbacks can be obtained by\n * using the React `ref` prop. For example:\n *\n *   <FooComponent {...data} ref={handleFooRef} />\n *\n *   function handleFooRef(component) {\n *     // Invoked when `<FooComponent>` is mounted or unmounted. When mounted,\n *     // `component` will be the component. When unmounted, `component` will\n *     // be null.\n *   }\n *\n */\nfunction RelayRootContainer({\n  Component,\n  forceFetch,\n  onReadyStateChange,\n  renderFailure,\n  renderFetched,\n  renderLoading,\n  route,\n}: RootContainerProps): ReactElement {\n  return (\n    <RelayRenderer\n      Container={Component}\n      forceFetch={forceFetch}\n      onReadyStateChange={onReadyStateChange}\n      queryConfig={route}\n      render={({done, error, props, retry, stale}) => {\n        if (error) {\n          if (renderFailure) {\n            return renderFailure(error, retry);\n          }\n        } else if (props) {\n          if (renderFetched) {\n            return renderFetched(props, {done, stale});\n          } else {\n            return <Component {...props} />;\n          }\n        } else {\n          if (renderLoading) {\n            return renderLoading();\n          }\n        }\n        return undefined;\n      }}\n    />\n  );\n}\n\nRelayRootContainer.propTypes = {\n  Component: RelayPropTypes.Container,\n  forceFetch: PropTypes.bool,\n  onReadyStateChange: PropTypes.func,\n  renderFailure: PropTypes.func,\n  renderFetched: PropTypes.func,\n  renderLoading: PropTypes.func,\n  route: RelayPropTypes.QueryConfig.isRequired,\n};\n\nRelayRootContainer.childContextTypes = {\n  route: RelayPropTypes.QueryConfig.isRequired,\n};\n\nmodule.exports = RelayRootContainer;\n","dependencies":["RelayContainer","RelayTypes","React","RelayPropTypes","RelayRenderer"],"id":"RelayRootContainer","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRootContainer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst React = require('React');\nimport type {RelayQueryConfigSpec} from 'RelayContainer';\nconst RelayPropTypes = require('RelayPropTypes');\nimport type {\n  ComponentFetchState,\n  ReadyState,\n  RelayContainer,\n} from 'RelayTypes';\nconst RelayRenderer = require('RelayRenderer');\n\ntype RootContainerProps = {\n  Component: RelayContainer;\n  forceFetch?: ?boolean;\n  onReadyStateChange?: ?(readyState: ReadyState) => void;\n  renderFailure?: ?(error: Error, retry: ?() => void) => ReactElement;\n  renderFetched?: ?(\n    data: Object,\n    fetchState: ComponentFetchState\n  ) => ReactElement;\n  renderLoading?: ?() => ReactElement;\n  route: RelayQueryConfigSpec;\n};\n\nconst {PropTypes} = React;\n\n/**\n * @public\n *\n * RelayRootContainer sends requests for data required to render the supplied\n * `Component` and `route`. The `Component` must be a container created using\n * `Relay.createContainer`.\n *\n * === Render Callbacks ===\n *\n * Whenever the RelayRootContainer renders, one of three render callback props\n * are invoked depending on whether data is being loaded, can be resolved, or if\n * an error is incurred.\n *\n *  ReactDOM.render(\n *    <RelayRootContainer\n *      Component={FooComponent}\n *      route={fooRoute}\n *      renderLoading={function() {\n *        return <View>Loading...</View>;\n *      }}\n *      renderFetched={function(data) {\n *        // Must spread `data` into <FooComponent>.\n *        return <FooComponent {...data} />;\n *      }}\n *      renderFailure={function(error) {\n *        return <View>Error: {error.message}</View>;\n *      }}\n *    />,\n *    ...\n *  );\n *\n * If a callback is not supplied, it has a default behavior:\n *\n *  - Without `renderFetched`, `Component` will be rendered with fetched data.\n *  - Without `renderFailure`, an error will render to null.\n *  - Without `renderLoading`, the existing view will continue to render. If\n *    this is the initial mount (with no existing view), renders to null.\n *\n * In addition, supplying a `renderLoading` that returns undefined has the same\n * effect as not supplying the callback. (Usually, an undefined return value is\n * an error in React).\n *\n * === Refs ===\n *\n * References to elements rendered by any of these callbacks can be obtained by\n * using the React `ref` prop. For example:\n *\n *   <FooComponent {...data} ref={handleFooRef} />\n *\n *   function handleFooRef(component) {\n *     // Invoked when `<FooComponent>` is mounted or unmounted. When mounted,\n *     // `component` will be the component. When unmounted, `component` will\n *     // be null.\n *   }\n *\n */\nfunction RelayRootContainer({\n  Component,\n  forceFetch,\n  onReadyStateChange,\n  renderFailure,\n  renderFetched,\n  renderLoading,\n  route,\n}: RootContainerProps): ReactElement {\n  return (\n    <RelayRenderer\n      Container={Component}\n      forceFetch={forceFetch}\n      onReadyStateChange={onReadyStateChange}\n      queryConfig={route}\n      render={({done, error, props, retry, stale}) => {\n        if (error) {\n          if (renderFailure) {\n            return renderFailure(error, retry);\n          }\n        } else if (props) {\n          if (renderFetched) {\n            return renderFetched(props, {done, stale});\n          } else {\n            return <Component {...props} />;\n          }\n        } else {\n          if (renderLoading) {\n            return renderLoading();\n          }\n        }\n        return undefined;\n      }}\n    />\n  );\n}\n\nRelayRootContainer.propTypes = {\n  Component: RelayPropTypes.Container,\n  forceFetch: PropTypes.bool,\n  onReadyStateChange: PropTypes.func,\n  renderFailure: PropTypes.func,\n  renderFetched: PropTypes.func,\n  renderLoading: PropTypes.func,\n  route: RelayPropTypes.QueryConfig.isRequired,\n};\n\nRelayRootContainer.childContextTypes = {\n  route: RelayPropTypes.QueryConfig.isRequired,\n};\n\nmodule.exports = RelayRootContainer;\n"}}},"/Users/cpojer/Projects/relay/src/container/RelayRenderer.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayRenderer","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRenderer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst React = require('React');\nimport type {RelayQueryConfigSpec} from 'RelayContainer';\nimport type {GarbageCollectionHold} from 'RelayGarbageCollector';\nimport type {RelayQuerySet} from 'RelayInternalTypes';\nconst RelayPropTypes = require('RelayPropTypes');\nconst RelayStore = require('RelayStore');\nimport type {\n  Abortable,\n  ComponentReadyState,\n  ReadyState,\n  RelayContainer,\n} from 'RelayTypes';\nconst StaticContainer = require('StaticContainer.react');\n\nconst getRelayQueries = require('getRelayQueries');\nconst invariant = require('invariant');\nconst mapObject = require('mapObject');\n\ntype RelayRendererProps = {\n  Container: RelayContainer;\n  forceFetch?: ?boolean;\n  onForceFetch?: ?(\n    querySet: RelayQuerySet,\n    callback: (readyState: ReadyState) => void\n  ) => Abortable;\n  onPrimeCache?: ?(\n    querySet: RelayQuerySet,\n    callback: (readyState: ReadyState) => void\n  ) => Abortable;\n  onReadyStateChange?: ?(readyState: ReadyState) => void;\n  queryConfig: RelayQueryConfigSpec;\n  render?: ?RelayRendererRenderCallback;\n};\nexport type RelayRendererRenderCallback =\n  (renderArgs: RelayRendererRenderArgs) => ?ReactElement;\ntype RelayRendererRenderArgs = {\n  done: boolean;\n  error: ?Error;\n  props: ?Object;\n  retry: ?Function;\n  stale: boolean;\n};\ntype RelayRendererState = {\n  activeContainer: ?RelayContainer;\n  activeQueryConfig: ?RelayQueryConfigSpec;\n  readyState: ?ComponentReadyState;\n  renderArgs: RelayRendererRenderArgs;\n};\n\nconst {PropTypes} = React;\n\n/**\n * @public\n *\n * RelayRenderer renders a container and query config after fulfilling its data\n * dependencies. Precise rendering behavior is configured via the `render` prop\n * which takes a callback.\n *\n * The container created using `Relay.createContainer` must be supplied via the\n * `Container` prop, and the query configuration that conforms to the shape of a\n * `RelayQueryConfig` must be supplied via the `queryConfig` prop.\n *\n * === Render Callback ===\n *\n * The `render` callback is called with an object with the following properties:\n *\n *   props: ?Object\n *     If present, sufficient data is ready to render the container. This object\n *     must be spread into the container using the spread attribute operator. If\n *     absent, there is insufficient data to render the container.\n *\n *   done: boolean\n *     Whether all data dependencies have been fulfilled. If `props` is present\n *     but `done` is false, then sufficient data is ready to render, but some\n *     data dependencies have not yet been fulfilled.\n *\n *   error: ?Error\n *     If present, an error occurred while fulfilling data dependencies. If\n *     `props` and `error` are both present, then sufficient data is ready to\n *     render, but an error occurred while fulfilling deferred dependencies.\n *\n *   retry: ?Function\n *     A function that can be called to re-attempt to fulfill data dependencies.\n *     This property is only present if an `error` has occurred.\n *\n *   stale: boolean\n *     When `forceFetch` is enabled, a request is always made to fetch updated\n *     data. However, if all data dependencies can be immediately fulfilled, the\n *     `props` property will be present. In this case, `stale` will be true.\n *\n * The `render` callback can return `undefined` to continue rendering the last\n * view rendered (e.g. when transitioning from one `queryConfig` to another).\n *\n * If a `render` callback is not supplied, the default behavior is to render the\n * container if data is available, the existing view if one exists, or nothing.\n *\n * === Refs ===\n *\n * References to elements rendered by the `render` callback can be obtained by\n * using the React `ref` prop. For example:\n *\n *   <FooComponent {...props} ref={handleFooRef} />\n *\n *   function handleFooRef(component) {\n *     // Invoked when `<FooComponent>` is mounted or unmounted. When mounted,\n *     // `component` will be the component. When unmounted, `component` will\n *     // be null.\n *   }\n *\n */\nclass RelayRenderer extends React.Component {\n  gcHold: ?GarbageCollectionHold;\n  mounted: boolean;\n  pendingRequest: ?Abortable;\n  props: RelayRendererProps;\n  state: RelayRendererState;\n\n  constructor(props: RelayRendererProps, context: any) {\n    super(props, context);\n    const garbageCollector =\n      RelayStore.getStoreData().getGarbageCollector();\n    this.gcHold = garbageCollector && garbageCollector.acquireHold();\n    this.mounted = true;\n    this.pendingRequest = null;\n    this.state = this._buildState(null, null, null, null);\n  }\n\n  /**\n   * @private\n   */\n  _buildState(\n    activeContainer: ?RelayContainer,\n    activeQueryConfig: ?RelayQueryConfigSpec,\n    readyState: ?ReadyState,\n    props: ?Object\n  ): RelayRendererState {\n    return {\n      activeContainer,\n      activeQueryConfig,\n      readyState: readyState && {...readyState, mounted: true},\n      renderArgs: {\n        done: !!readyState && readyState.done,\n        error: readyState && readyState.error,\n        props,\n        retry: () => this._retry(),\n        stale: !!readyState && readyState.stale,\n      },\n    };\n  }\n\n  getChildContext(): Object {\n    return {\n      relay: RelayStore,\n      route: this.props.queryConfig,\n    };\n  }\n\n  componentDidMount(): void {\n    this._runQueries(this.props);\n  }\n\n  /**\n   * @private\n   */\n  _runQueries(\n    {\n      Container,\n      forceFetch,\n      onForceFetch,\n      onPrimeCache,\n      queryConfig,\n    }: RelayRendererProps\n  ): void {\n    const querySet = getRelayQueries(Container, queryConfig);\n    const onReadyStateChange = readyState => {\n      if (!this.mounted) {\n        this._handleReadyStateChange({...readyState, mounted: false});\n        return;\n      }\n      if (request !== this.pendingRequest) {\n        // Ignore (abort) ready state if we have a new pending request.\n        return;\n      }\n      if (readyState.aborted || readyState.done || readyState.error) {\n        this.pendingRequest = null;\n      }\n      let {props} = this.state.renderArgs;\n      if (readyState.ready && !props) {\n        props = {\n          ...queryConfig.params,\n          ...mapObject(querySet, createFragmentPointerForRoot),\n        };\n      }\n      this.setState(\n        this._buildState(\n          Container,\n          queryConfig,\n          readyState,\n          props\n        )\n      );\n    };\n\n    if (this.pendingRequest) {\n      this.pendingRequest.abort();\n    }\n\n    const request = this.pendingRequest = forceFetch ?\n      (\n        onForceFetch ?\n          onForceFetch(querySet, onReadyStateChange) :\n          RelayStore.forceFetch(querySet, onReadyStateChange)\n      ) :\n      (\n        onPrimeCache ?\n          onPrimeCache(querySet, onReadyStateChange) :\n          RelayStore.primeCache(querySet, onReadyStateChange)\n      );\n  }\n\n  /**\n   * Returns whether or not the view should be updated during the current render\n   * pass. This is false between invoking `Relay.Store.{primeCache,forceFetch}`\n   * and the first invocation of the `onReadyStateChange` callback if there is\n   * an actively rendered container and query configuration.\n   *\n   * @private\n   */\n  _shouldUpdate(): boolean {\n    const {activeContainer, activeQueryConfig} = this.state;\n    const {Container} = this.props;\n    return (\n      (!activeContainer || Container === activeContainer) &&\n      (!activeQueryConfig || this.props.queryConfig === activeQueryConfig)\n    );\n  }\n\n  /**\n   * @private\n   */\n  _runQueriesAndSetState(props: RelayRendererProps): void {\n    this._runQueries(props);\n    this.setState(\n      this._buildState(\n        this.state.activeContainer,\n        this.state.activeQueryConfig,\n        null,\n        null\n      )\n    );\n  }\n\n  /**\n   * @private\n   */\n  _retry(): void {\n    const {readyState} = this.state;\n    invariant(\n      readyState && readyState.error,\n      'RelayRenderer: You tried to call `retry`, but the last request did ' +\n      'not fail. You can only call this when the last request has failed.'\n    );\n    this._runQueriesAndSetState(this.props);\n  }\n\n  componentWillReceiveProps(nextProps: RelayRendererProps): void {\n    if (nextProps.Container !== this.props.Container ||\n        nextProps.queryConfig !== this.props.queryConfig ||\n        (nextProps.forceFetch && !this.props.forceFetch)) {\n      this._runQueriesAndSetState(nextProps);\n    }\n  }\n\n  componentDidUpdate(\n    prevProps: RelayRendererProps,\n    prevState?: RelayRendererState\n  ): void {\n    // `prevState` should exist; the truthy check is for Flow soundness.\n    const {readyState} = this.state;\n    if (readyState) {\n      if (!prevState || readyState !== prevState.readyState) {\n        this._handleReadyStateChange(readyState);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  _handleReadyStateChange(readyState: ReadyState): void {\n    const {onReadyStateChange} = this.props;\n    if (onReadyStateChange) {\n      onReadyStateChange(readyState);\n    }\n  }\n\n  componentWillUnmount(): void {\n    if (this.pendingRequest) {\n      this.pendingRequest.abort();\n    }\n    if (this.gcHold) {\n      this.gcHold.release();\n    }\n    this.gcHold = null;\n    this.mounted = false;\n  }\n\n  render(): ?ReactElement {\n    let children;\n    let shouldUpdate = this._shouldUpdate();\n    if (shouldUpdate) {\n      const {Container, render} = this.props;\n      const {renderArgs} = this.state;\n      if (render) {\n        children = render(renderArgs);\n      } else if (renderArgs.props) {\n        children = <Container {...renderArgs.props} />;\n      }\n    }\n    if (children === undefined) {\n      children = null;\n      shouldUpdate = false;\n    }\n    return (\n      <StaticContainer shouldUpdate={shouldUpdate}>\n        {children}\n      </StaticContainer>\n    );\n  }\n}\n\nfunction createFragmentPointerForRoot(query) {\n  return query ?\n    RelayFragmentPointer.createForRoot(\n      RelayStore.getStoreData().getQueuedStore(),\n      query\n    ) :\n    null;\n}\n\nRelayRenderer.propTypes = {\n  Container: RelayPropTypes.Container,\n  forceFetch: PropTypes.bool,\n  onReadyStateChange: PropTypes.func,\n  queryConfig: RelayPropTypes.QueryConfig.isRequired,\n  render: PropTypes.func,\n};\n\nRelayRenderer.childContextTypes = {\n  relay: RelayPropTypes.Context,\n  route: RelayPropTypes.QueryConfig.isRequired,\n};\n\nmodule.exports = RelayRenderer;\n","dependencies":["RelayContainer","RelayGarbageCollector","RelayInternalTypes","RelayTypes","RelayFragmentPointer","React","RelayPropTypes","RelayStore","StaticContainer.react","getRelayQueries","invariant","mapObject"],"id":"RelayRenderer","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRenderer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst React = require('React');\nimport type {RelayQueryConfigSpec} from 'RelayContainer';\nimport type {GarbageCollectionHold} from 'RelayGarbageCollector';\nimport type {RelayQuerySet} from 'RelayInternalTypes';\nconst RelayPropTypes = require('RelayPropTypes');\nconst RelayStore = require('RelayStore');\nimport type {\n  Abortable,\n  ComponentReadyState,\n  ReadyState,\n  RelayContainer,\n} from 'RelayTypes';\nconst StaticContainer = require('StaticContainer.react');\n\nconst getRelayQueries = require('getRelayQueries');\nconst invariant = require('invariant');\nconst mapObject = require('mapObject');\n\ntype RelayRendererProps = {\n  Container: RelayContainer;\n  forceFetch?: ?boolean;\n  onForceFetch?: ?(\n    querySet: RelayQuerySet,\n    callback: (readyState: ReadyState) => void\n  ) => Abortable;\n  onPrimeCache?: ?(\n    querySet: RelayQuerySet,\n    callback: (readyState: ReadyState) => void\n  ) => Abortable;\n  onReadyStateChange?: ?(readyState: ReadyState) => void;\n  queryConfig: RelayQueryConfigSpec;\n  render?: ?RelayRendererRenderCallback;\n};\nexport type RelayRendererRenderCallback =\n  (renderArgs: RelayRendererRenderArgs) => ?ReactElement;\ntype RelayRendererRenderArgs = {\n  done: boolean;\n  error: ?Error;\n  props: ?Object;\n  retry: ?Function;\n  stale: boolean;\n};\ntype RelayRendererState = {\n  activeContainer: ?RelayContainer;\n  activeQueryConfig: ?RelayQueryConfigSpec;\n  readyState: ?ComponentReadyState;\n  renderArgs: RelayRendererRenderArgs;\n};\n\nconst {PropTypes} = React;\n\n/**\n * @public\n *\n * RelayRenderer renders a container and query config after fulfilling its data\n * dependencies. Precise rendering behavior is configured via the `render` prop\n * which takes a callback.\n *\n * The container created using `Relay.createContainer` must be supplied via the\n * `Container` prop, and the query configuration that conforms to the shape of a\n * `RelayQueryConfig` must be supplied via the `queryConfig` prop.\n *\n * === Render Callback ===\n *\n * The `render` callback is called with an object with the following properties:\n *\n *   props: ?Object\n *     If present, sufficient data is ready to render the container. This object\n *     must be spread into the container using the spread attribute operator. If\n *     absent, there is insufficient data to render the container.\n *\n *   done: boolean\n *     Whether all data dependencies have been fulfilled. If `props` is present\n *     but `done` is false, then sufficient data is ready to render, but some\n *     data dependencies have not yet been fulfilled.\n *\n *   error: ?Error\n *     If present, an error occurred while fulfilling data dependencies. If\n *     `props` and `error` are both present, then sufficient data is ready to\n *     render, but an error occurred while fulfilling deferred dependencies.\n *\n *   retry: ?Function\n *     A function that can be called to re-attempt to fulfill data dependencies.\n *     This property is only present if an `error` has occurred.\n *\n *   stale: boolean\n *     When `forceFetch` is enabled, a request is always made to fetch updated\n *     data. However, if all data dependencies can be immediately fulfilled, the\n *     `props` property will be present. In this case, `stale` will be true.\n *\n * The `render` callback can return `undefined` to continue rendering the last\n * view rendered (e.g. when transitioning from one `queryConfig` to another).\n *\n * If a `render` callback is not supplied, the default behavior is to render the\n * container if data is available, the existing view if one exists, or nothing.\n *\n * === Refs ===\n *\n * References to elements rendered by the `render` callback can be obtained by\n * using the React `ref` prop. For example:\n *\n *   <FooComponent {...props} ref={handleFooRef} />\n *\n *   function handleFooRef(component) {\n *     // Invoked when `<FooComponent>` is mounted or unmounted. When mounted,\n *     // `component` will be the component. When unmounted, `component` will\n *     // be null.\n *   }\n *\n */\nclass RelayRenderer extends React.Component {\n  gcHold: ?GarbageCollectionHold;\n  mounted: boolean;\n  pendingRequest: ?Abortable;\n  props: RelayRendererProps;\n  state: RelayRendererState;\n\n  constructor(props: RelayRendererProps, context: any) {\n    super(props, context);\n    const garbageCollector =\n      RelayStore.getStoreData().getGarbageCollector();\n    this.gcHold = garbageCollector && garbageCollector.acquireHold();\n    this.mounted = true;\n    this.pendingRequest = null;\n    this.state = this._buildState(null, null, null, null);\n  }\n\n  /**\n   * @private\n   */\n  _buildState(\n    activeContainer: ?RelayContainer,\n    activeQueryConfig: ?RelayQueryConfigSpec,\n    readyState: ?ReadyState,\n    props: ?Object\n  ): RelayRendererState {\n    return {\n      activeContainer,\n      activeQueryConfig,\n      readyState: readyState && {...readyState, mounted: true},\n      renderArgs: {\n        done: !!readyState && readyState.done,\n        error: readyState && readyState.error,\n        props,\n        retry: () => this._retry(),\n        stale: !!readyState && readyState.stale,\n      },\n    };\n  }\n\n  getChildContext(): Object {\n    return {\n      relay: RelayStore,\n      route: this.props.queryConfig,\n    };\n  }\n\n  componentDidMount(): void {\n    this._runQueries(this.props);\n  }\n\n  /**\n   * @private\n   */\n  _runQueries(\n    {\n      Container,\n      forceFetch,\n      onForceFetch,\n      onPrimeCache,\n      queryConfig,\n    }: RelayRendererProps\n  ): void {\n    const querySet = getRelayQueries(Container, queryConfig);\n    const onReadyStateChange = readyState => {\n      if (!this.mounted) {\n        this._handleReadyStateChange({...readyState, mounted: false});\n        return;\n      }\n      if (request !== this.pendingRequest) {\n        // Ignore (abort) ready state if we have a new pending request.\n        return;\n      }\n      if (readyState.aborted || readyState.done || readyState.error) {\n        this.pendingRequest = null;\n      }\n      let {props} = this.state.renderArgs;\n      if (readyState.ready && !props) {\n        props = {\n          ...queryConfig.params,\n          ...mapObject(querySet, createFragmentPointerForRoot),\n        };\n      }\n      this.setState(\n        this._buildState(\n          Container,\n          queryConfig,\n          readyState,\n          props\n        )\n      );\n    };\n\n    if (this.pendingRequest) {\n      this.pendingRequest.abort();\n    }\n\n    const request = this.pendingRequest = forceFetch ?\n      (\n        onForceFetch ?\n          onForceFetch(querySet, onReadyStateChange) :\n          RelayStore.forceFetch(querySet, onReadyStateChange)\n      ) :\n      (\n        onPrimeCache ?\n          onPrimeCache(querySet, onReadyStateChange) :\n          RelayStore.primeCache(querySet, onReadyStateChange)\n      );\n  }\n\n  /**\n   * Returns whether or not the view should be updated during the current render\n   * pass. This is false between invoking `Relay.Store.{primeCache,forceFetch}`\n   * and the first invocation of the `onReadyStateChange` callback if there is\n   * an actively rendered container and query configuration.\n   *\n   * @private\n   */\n  _shouldUpdate(): boolean {\n    const {activeContainer, activeQueryConfig} = this.state;\n    const {Container} = this.props;\n    return (\n      (!activeContainer || Container === activeContainer) &&\n      (!activeQueryConfig || this.props.queryConfig === activeQueryConfig)\n    );\n  }\n\n  /**\n   * @private\n   */\n  _runQueriesAndSetState(props: RelayRendererProps): void {\n    this._runQueries(props);\n    this.setState(\n      this._buildState(\n        this.state.activeContainer,\n        this.state.activeQueryConfig,\n        null,\n        null\n      )\n    );\n  }\n\n  /**\n   * @private\n   */\n  _retry(): void {\n    const {readyState} = this.state;\n    invariant(\n      readyState && readyState.error,\n      'RelayRenderer: You tried to call `retry`, but the last request did ' +\n      'not fail. You can only call this when the last request has failed.'\n    );\n    this._runQueriesAndSetState(this.props);\n  }\n\n  componentWillReceiveProps(nextProps: RelayRendererProps): void {\n    if (nextProps.Container !== this.props.Container ||\n        nextProps.queryConfig !== this.props.queryConfig ||\n        (nextProps.forceFetch && !this.props.forceFetch)) {\n      this._runQueriesAndSetState(nextProps);\n    }\n  }\n\n  componentDidUpdate(\n    prevProps: RelayRendererProps,\n    prevState?: RelayRendererState\n  ): void {\n    // `prevState` should exist; the truthy check is for Flow soundness.\n    const {readyState} = this.state;\n    if (readyState) {\n      if (!prevState || readyState !== prevState.readyState) {\n        this._handleReadyStateChange(readyState);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  _handleReadyStateChange(readyState: ReadyState): void {\n    const {onReadyStateChange} = this.props;\n    if (onReadyStateChange) {\n      onReadyStateChange(readyState);\n    }\n  }\n\n  componentWillUnmount(): void {\n    if (this.pendingRequest) {\n      this.pendingRequest.abort();\n    }\n    if (this.gcHold) {\n      this.gcHold.release();\n    }\n    this.gcHold = null;\n    this.mounted = false;\n  }\n\n  render(): ?ReactElement {\n    let children;\n    let shouldUpdate = this._shouldUpdate();\n    if (shouldUpdate) {\n      const {Container, render} = this.props;\n      const {renderArgs} = this.state;\n      if (render) {\n        children = render(renderArgs);\n      } else if (renderArgs.props) {\n        children = <Container {...renderArgs.props} />;\n      }\n    }\n    if (children === undefined) {\n      children = null;\n      shouldUpdate = false;\n    }\n    return (\n      <StaticContainer shouldUpdate={shouldUpdate}>\n        {children}\n      </StaticContainer>\n    );\n  }\n}\n\nfunction createFragmentPointerForRoot(query) {\n  return query ?\n    RelayFragmentPointer.createForRoot(\n      RelayStore.getStoreData().getQueuedStore(),\n      query\n    ) :\n    null;\n}\n\nRelayRenderer.propTypes = {\n  Container: RelayPropTypes.Container,\n  forceFetch: PropTypes.bool,\n  onReadyStateChange: PropTypes.func,\n  queryConfig: RelayPropTypes.QueryConfig.isRequired,\n  render: PropTypes.func,\n};\n\nRelayRenderer.childContextTypes = {\n  relay: RelayPropTypes.Context,\n  route: RelayPropTypes.QueryConfig.isRequired,\n};\n\nmodule.exports = RelayRenderer;\n"}}},"/Users/cpojer/Projects/relay/src/container/RelayPropTypes.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayPropTypes","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayPropTypes\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst {PropTypes} = require('React');\n\nconst isRelayContainer = require('isRelayContainer');\nconst isRelayContext = require('isRelayContext');\nconst sprintf = require('sprintf');\n\nconst RelayPropTypes = {\n  Container(props: Object, propName: string, componentName: string): ?Error {\n    const component = props[propName];\n    if (component == null) {\n      return new Error(sprintf(\n        'Required prop `%s` was not specified in `%s`.',\n        propName,\n        componentName\n      ));\n    } else if (!isRelayContainer(component)) {\n      return new Error(sprintf(\n        'Invalid prop `%s` supplied to `%s`, expected a RelayContainer.',\n        propName,\n        componentName\n      ));\n    }\n    return null;\n  },\n\n  Context(props: Object, propName: string, componentName: string): ?Error {\n    const context = props[propName];\n    if (!isRelayContext(context)) {\n      return new Error(sprintf(\n        'Invalid prop/context `%s` supplied to `%s`, expected `%s` to be ' +\n        'an object conforming to the `RelayContext` interface.',\n        propName,\n        componentName,\n        context\n      ));\n    }\n    return null;\n  },\n\n  QueryConfig: PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    params: PropTypes.object.isRequired,\n    queries: PropTypes.object.isRequired,\n  }),\n};\n\nmodule.exports = RelayPropTypes;\n","dependencies":["React","isRelayContainer","isRelayContext","sprintf","RelayPropTypes"],"id":"RelayPropTypes","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayPropTypes\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst {PropTypes} = require('React');\n\nconst isRelayContainer = require('isRelayContainer');\nconst isRelayContext = require('isRelayContext');\nconst sprintf = require('sprintf');\n\nconst RelayPropTypes = {\n  Container(props: Object, propName: string, componentName: string): ?Error {\n    const component = props[propName];\n    if (component == null) {\n      return new Error(sprintf(\n        'Required prop `%s` was not specified in `%s`.',\n        propName,\n        componentName\n      ));\n    } else if (!isRelayContainer(component)) {\n      return new Error(sprintf(\n        'Invalid prop `%s` supplied to `%s`, expected a RelayContainer.',\n        propName,\n        componentName\n      ));\n    }\n    return null;\n  },\n\n  Context(props: Object, propName: string, componentName: string): ?Error {\n    const context = props[propName];\n    if (!isRelayContext(context)) {\n      return new Error(sprintf(\n        'Invalid prop/context `%s` supplied to `%s`, expected `%s` to be ' +\n        'an object conforming to the `RelayContext` interface.',\n        propName,\n        componentName,\n        context\n      ));\n    }\n    return null;\n  },\n\n  QueryConfig: PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    params: PropTypes.object.isRequired,\n    queries: PropTypes.object.isRequired,\n  }),\n};\n\nmodule.exports = RelayPropTypes;\n"}}},"/Users/cpojer/Projects/relay/src/container/RelayOSSContainerProxy.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayOSSContainerProxy","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayOSSContainerProxy\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {RelayContainer} from 'RelayTypes';\n\n/**\n * This feature is deprecated and unavailable in open source.\n */\nvar RelayOSSContainerProxy = {\n  proxyMethods(\n    RelayContainer: RelayContainer,\n    Component: ReactClass\n  ): void {},\n};\n\nmodule.exports = RelayOSSContainerProxy;\n","dependencies":["RelayTypes","RelayOSSContainerProxy"],"id":"RelayOSSContainerProxy","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayOSSContainerProxy\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {RelayContainer} from 'RelayTypes';\n\n/**\n * This feature is deprecated and unavailable in open source.\n */\nvar RelayOSSContainerProxy = {\n  proxyMethods(\n    RelayContainer: RelayContainer,\n    Component: ReactClass\n  ): void {},\n};\n\nmodule.exports = RelayOSSContainerProxy;\n"}}},"/Users/cpojer/Projects/relay/src/container/RelayContainerComparators.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayContainerComparators","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayContainerComparators\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Compares `objectA` and `objectB` using the provided `isEqual` function.\n *\n * If a `filter` object is provided, only its keys will be checked during\n * comparison.\n */\nfunction compareObjects(\n  isEqual: (propA: any, propB: any, key: string) => boolean,\n  objectA: Object,\n  objectB: Object,\n  filter?: Object\n): boolean {\n  var key;\n\n  // Test for A's keys different from B.\n  for (key in objectA) {\n    if (filter && !filter.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (objectA.hasOwnProperty(key) && (\n          !objectB.hasOwnProperty(key) ||\n          !isEqual(objectA[key], objectB[key], key))) {\n      return false;\n    }\n  }\n  // Test for B's keys missing from A.\n  for (key in objectB) {\n    if (filter && !filter.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (objectB.hasOwnProperty(key) && !objectA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isScalarAndEqual(valueA, valueB) {\n  return valueA === valueB && (valueA === null || typeof valueA !== 'object');\n}\n\nfunction isQueryDataEqual(\n  fragmentPointers: Object,\n  currProp: mixed,\n  nextProp: mixed,\n  propName: string\n): boolean {\n  return (\n    // resolved data did not change\n    (fragmentPointers[propName] && currProp === nextProp) ||\n    // otherwise compare fake data\n    isScalarAndEqual(currProp, nextProp)\n  );\n}\n\nfunction isNonQueryPropEqual(\n  fragments: Object,\n  currProp: mixed,\n  nextProp: mixed,\n  propName: string\n): boolean {\n  return (\n    // ignore props with fragments (instead resolved values are compared)\n    fragments.hasOwnProperty(propName) ||\n    // otherwise props must be scalar and === in order to skip\n    isScalarAndEqual(currProp, nextProp)\n  );\n}\n\n/**\n * Relay-aware comparators for props and state provide a reasonable default\n * implementation of `shouldComponentUpdate`.\n */\nvar RelayContainerComparators = {\n  areQueryResultsEqual(\n    fragmentPointers: Object,\n    prevQueryData: Object,\n    nextQueryData: Object\n  ): boolean {\n    return compareObjects(\n      isQueryDataEqual.bind(null, fragmentPointers),\n      prevQueryData,\n      nextQueryData\n    );\n  },\n\n  areNonQueryPropsEqual(\n    fragments: Object,\n    props: Object,\n    nextProps: Object\n  ): boolean {\n    return compareObjects(\n      isNonQueryPropEqual.bind(null, fragments),\n      props,\n      nextProps\n    );\n  },\n\n  areQueryVariablesEqual(\n    variables: Object,\n    nextVariables: Object\n  ): boolean {\n    return compareObjects(isScalarAndEqual, variables, nextVariables);\n  },\n};\n\nmodule.exports = RelayContainerComparators;\n","dependencies":[],"id":"RelayContainerComparators","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayContainerComparators\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Compares `objectA` and `objectB` using the provided `isEqual` function.\n *\n * If a `filter` object is provided, only its keys will be checked during\n * comparison.\n */\nfunction compareObjects(\n  isEqual: (propA: any, propB: any, key: string) => boolean,\n  objectA: Object,\n  objectB: Object,\n  filter?: Object\n): boolean {\n  var key;\n\n  // Test for A's keys different from B.\n  for (key in objectA) {\n    if (filter && !filter.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (objectA.hasOwnProperty(key) && (\n          !objectB.hasOwnProperty(key) ||\n          !isEqual(objectA[key], objectB[key], key))) {\n      return false;\n    }\n  }\n  // Test for B's keys missing from A.\n  for (key in objectB) {\n    if (filter && !filter.hasOwnProperty(key)) {\n      continue;\n    }\n\n    if (objectB.hasOwnProperty(key) && !objectA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isScalarAndEqual(valueA, valueB) {\n  return valueA === valueB && (valueA === null || typeof valueA !== 'object');\n}\n\nfunction isQueryDataEqual(\n  fragmentPointers: Object,\n  currProp: mixed,\n  nextProp: mixed,\n  propName: string\n): boolean {\n  return (\n    // resolved data did not change\n    (fragmentPointers[propName] && currProp === nextProp) ||\n    // otherwise compare fake data\n    isScalarAndEqual(currProp, nextProp)\n  );\n}\n\nfunction isNonQueryPropEqual(\n  fragments: Object,\n  currProp: mixed,\n  nextProp: mixed,\n  propName: string\n): boolean {\n  return (\n    // ignore props with fragments (instead resolved values are compared)\n    fragments.hasOwnProperty(propName) ||\n    // otherwise props must be scalar and === in order to skip\n    isScalarAndEqual(currProp, nextProp)\n  );\n}\n\n/**\n * Relay-aware comparators for props and state provide a reasonable default\n * implementation of `shouldComponentUpdate`.\n */\nvar RelayContainerComparators = {\n  areQueryResultsEqual(\n    fragmentPointers: Object,\n    prevQueryData: Object,\n    nextQueryData: Object\n  ): boolean {\n    return compareObjects(\n      isQueryDataEqual.bind(null, fragmentPointers),\n      prevQueryData,\n      nextQueryData\n    );\n  },\n\n  areNonQueryPropsEqual(\n    fragments: Object,\n    props: Object,\n    nextProps: Object\n  ): boolean {\n    return compareObjects(\n      isNonQueryPropEqual.bind(null, fragments),\n      props,\n      nextProps\n    );\n  },\n\n  areQueryVariablesEqual(\n    variables: Object,\n    nextVariables: Object\n  ): boolean {\n    return compareObjects(isScalarAndEqual, variables, nextVariables);\n  },\n};\n\nmodule.exports = RelayContainerComparators;\n"}}},"/Users/cpojer/Projects/relay/src/container/prepareRelayOSSContainerProps.js":{"metadata":{"mtime":1455679338000},"data":{"name":"prepareRelayOSSContainerProps","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule prepareRelayOSSContainerProps\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * Provides an opportunity for Relay to fork how RelayContainer props are spread\n * into the inner component.\n */\nfunction prepareRelayOSSContainerProps(\n  relayProps: {[propName: string]: mixed}\n): {[propName: string]: mixed} {\n  return {relay: relayProps};\n}\n\nmodule.exports = prepareRelayOSSContainerProps;\n","dependencies":["prepareRelayOSSContainerProps"],"id":"prepareRelayOSSContainerProps","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule prepareRelayOSSContainerProps\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * Provides an opportunity for Relay to fork how RelayContainer props are spread\n * into the inner component.\n */\nfunction prepareRelayOSSContainerProps(\n  relayProps: {[propName: string]: mixed}\n): {[propName: string]: mixed} {\n  return {relay: relayProps};\n}\n\nmodule.exports = prepareRelayOSSContainerProps;\n"}}},"/Users/cpojer/Projects/relay/src/container/isRelayContainer.js":{"metadata":{"mtime":1455679338000},"data":{"name":"isRelayContainer","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isRelayContainer\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nfunction isRelayContainer(component: any): boolean {\n  return !!(\n    component &&\n    component.getFragmentNames &&\n    component.getFragment &&\n    component.hasFragment &&\n    component.hasVariable\n  );\n}\n\nmodule.exports = isRelayContainer;\n","dependencies":["isRelayContainer"],"id":"isRelayContainer","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isRelayContainer\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nfunction isRelayContainer(component: any): boolean {\n  return !!(\n    component &&\n    component.getFragmentNames &&\n    component.getFragment &&\n    component.hasFragment &&\n    component.hasVariable\n  );\n}\n\nmodule.exports = isRelayContainer;\n"}}},"/Users/cpojer/Projects/relay/src/container/isReactComponent.js":{"metadata":{"mtime":1455679338000},"data":{"name":"isReactComponent","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isReactComponent\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * Helper for checking if this is a React Component\n * created with React.Component or React.createClass().\n */\nfunction isReactComponent(component: mixed): boolean {\n  return !!(\n    component &&\n    component.prototype &&\n    component.prototype.isReactComponent\n  );\n}\n\nmodule.exports = isReactComponent;\n","dependencies":["isReactComponent"],"id":"isReactComponent","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isReactComponent\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * Helper for checking if this is a React Component\n * created with React.Component or React.createClass().\n */\nfunction isReactComponent(component: mixed): boolean {\n  return !!(\n    component &&\n    component.prototype &&\n    component.prototype.isReactComponent\n  );\n}\n\nmodule.exports = isReactComponent;\n"}}},"/Users/cpojer/Projects/relay/src/container/getRelayQueries.js":{"metadata":{"mtime":1456974578000},"data":{"name":"getRelayQueries","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getRelayQueries\n * @flow\n */\n\n'use strict';\n\nconst Map = require('Map');\nimport type {\n  RelayLazyContainer,\n  RelayQueryConfigSpec,\n} from 'RelayContainer';\nimport type {RelayQuerySet} from 'RelayInternalTypes';\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\n\nconst buildRQL = require('buildRQL');\nconst invariant = require('invariant');\nconst stableStringify = require('stableStringify');\nconst warning = require('warning');\n\nvar queryCache = new Map();\n\n/**\n * @internal\n *\n * `getRelayQueries` retrieves all queries for a component given a route.\n */\nfunction getRelayQueries(\n  Component: RelayLazyContainer,\n  route: RelayQueryConfigSpec\n): RelayQuerySet {\n  if (!queryCache.has(Component)) {\n    queryCache.set(Component, {});\n  }\n  var cacheKey = route.name + ':' + stableStringify(route.params);\n  /* $FlowFixMe(>=0.22.0): Error discovered while adding Flow types\n   * to Map and Set. This is often because .get() can return null.\n   */\n  var cache = queryCache.get(Component);\n  if (cache.hasOwnProperty(cacheKey)) {\n    return cache[cacheKey];\n  }\n  var querySet = {};\n  Component.getFragmentNames().forEach(fragmentName => {\n    querySet[fragmentName] = null;\n  });\n  Object.keys(route.queries).forEach(queryName => {\n    if (!Component.hasFragment(queryName)) {\n      warning(\n        false,\n        'Relay.QL: query `%s.queries.%s` is invalid, expected fragment ' +\n        '`%s.fragments.%s` to be defined.',\n        route.name,\n        queryName,\n        Component.displayName,\n        queryName\n      );\n      return;\n    }\n    var queryBuilder = route.queries[queryName];\n    if (queryBuilder) {\n      var concreteQuery = buildRQL.Query(\n        queryBuilder,\n        Component,\n        queryName,\n        route.params\n      );\n      invariant(\n        concreteQuery !== undefined,\n        'Relay.QL: query `%s.queries.%s` is invalid, a typical query is ' +\n        'defined using: () => Relay.QL`query { ... }`.',\n        route.name,\n        queryName\n      );\n      if (concreteQuery) {\n        var rootQuery = RelayQuery.Root.create(\n          concreteQuery,\n          RelayMetaRoute.get(route.name),\n          route.params\n        );\n        const identifyingArg = rootQuery.getIdentifyingArg();\n        if (!identifyingArg || identifyingArg.value !== undefined) {\n          querySet[queryName] = rootQuery;\n          return;\n        }\n      }\n    }\n    querySet[queryName] = null;\n  });\n  cache[cacheKey] = querySet;\n  return querySet;\n}\n\nmodule.exports = RelayProfiler.instrument('Relay.getQueries', getRelayQueries);\n","dependencies":["RelayContainer","RelayInternalTypes","Map","RelayMetaRoute","RelayProfiler","RelayQuery","buildRQL","invariant","stableStringify","warning","getRelayQueries"],"id":"getRelayQueries","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getRelayQueries\n * @flow\n */\n\n'use strict';\n\nconst Map = require('Map');\nimport type {\n  RelayLazyContainer,\n  RelayQueryConfigSpec,\n} from 'RelayContainer';\nimport type {RelayQuerySet} from 'RelayInternalTypes';\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\n\nconst buildRQL = require('buildRQL');\nconst invariant = require('invariant');\nconst stableStringify = require('stableStringify');\nconst warning = require('warning');\n\nvar queryCache = new Map();\n\n/**\n * @internal\n *\n * `getRelayQueries` retrieves all queries for a component given a route.\n */\nfunction getRelayQueries(\n  Component: RelayLazyContainer,\n  route: RelayQueryConfigSpec\n): RelayQuerySet {\n  if (!queryCache.has(Component)) {\n    queryCache.set(Component, {});\n  }\n  var cacheKey = route.name + ':' + stableStringify(route.params);\n  /* $FlowFixMe(>=0.22.0): Error discovered while adding Flow types\n   * to Map and Set. This is often because .get() can return null.\n   */\n  var cache = queryCache.get(Component);\n  if (cache.hasOwnProperty(cacheKey)) {\n    return cache[cacheKey];\n  }\n  var querySet = {};\n  Component.getFragmentNames().forEach(fragmentName => {\n    querySet[fragmentName] = null;\n  });\n  Object.keys(route.queries).forEach(queryName => {\n    if (!Component.hasFragment(queryName)) {\n      warning(\n        false,\n        'Relay.QL: query `%s.queries.%s` is invalid, expected fragment ' +\n        '`%s.fragments.%s` to be defined.',\n        route.name,\n        queryName,\n        Component.displayName,\n        queryName\n      );\n      return;\n    }\n    var queryBuilder = route.queries[queryName];\n    if (queryBuilder) {\n      var concreteQuery = buildRQL.Query(\n        queryBuilder,\n        Component,\n        queryName,\n        route.params\n      );\n      invariant(\n        concreteQuery !== undefined,\n        'Relay.QL: query `%s.queries.%s` is invalid, a typical query is ' +\n        'defined using: () => Relay.QL`query { ... }`.',\n        route.name,\n        queryName\n      );\n      if (concreteQuery) {\n        var rootQuery = RelayQuery.Root.create(\n          concreteQuery,\n          RelayMetaRoute.get(route.name),\n          route.params\n        );\n        const identifyingArg = rootQuery.getIdentifyingArg();\n        if (!identifyingArg || identifyingArg.value !== undefined) {\n          querySet[queryName] = rootQuery;\n          return;\n        }\n      }\n    }\n    querySet[queryName] = null;\n  });\n  cache[cacheKey] = querySet;\n  return querySet;\n}\n\nmodule.exports = RelayProfiler.instrument('Relay.getQueries', getRelayQueries);\n"}}},"/Users/cpojer/Projects/relay/src/interface/RelayOSSNodeInterface.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayOSSNodeInterface","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayOSSNodeInterface\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nimport type RelayQuery from 'RelayQuery';\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst generateClientID = require('generateClientID');\nconst invariant = require('invariant');\n\ntype PayloadResult = {\n  dataID: DataID;\n  result: mixed;\n  rootCallInfo?: RootCallInfo;\n};\n\ntype RootCallInfo = {\n  storageKey: string;\n  identifyingArgValue: ?string;\n}\n\n/**\n * @internal\n *\n * Defines logic relevant to the informal \"Node\" GraphQL interface.\n */\nvar RelayOSSNodeInterface = {\n  ANY_TYPE: '__any',\n  ID: 'id',\n  ID_TYPE: 'ID!',\n  NODE: 'node',\n  NODE_TYPE: 'Node',\n  NODES: 'nodes',\n  TYPENAME: '__typename',\n\n  isNodeRootCall(fieldName: string): boolean {\n    return (\n      fieldName === RelayOSSNodeInterface.NODE ||\n      fieldName === RelayOSSNodeInterface.NODES\n    );\n  },\n\n  getResultsFromPayload(\n    store: RelayRecordStore,\n    query: RelayQuery.Root,\n    payload: {[key: string]: mixed}\n  ): Array<PayloadResult> {\n    var results = [];\n\n    var rootBatchCall = query.getBatchCall();\n    if (rootBatchCall) {\n      getPayloadRecords(query, payload).forEach(result => {\n        if (typeof result !== 'object' || !result) {\n          return;\n        }\n        var dataID = result[RelayOSSNodeInterface.ID];\n        invariant(\n          dataID != null,\n          'RelayOSSNodeInterface.getResultsFromPayload(): Unable to write ' +\n          'result with no `%s` field for query, `%s`.',\n          RelayOSSNodeInterface.ID,\n          query.getName()\n        );\n        results.push({dataID, result});\n      });\n    } else {\n      var records = getPayloadRecords(query, payload);\n      var ii = 0;\n      const storageKey = query.getStorageKey();\n      forEachRootCallArg(query, identifyingArgValue => {\n        var result = records[ii++];\n        var dataID = store.getDataID(storageKey, identifyingArgValue);\n        if (dataID == null) {\n          var payloadID = typeof result === 'object' && result ?\n            result[RelayOSSNodeInterface.ID] :\n            null;\n          if (payloadID != null) {\n            dataID = payloadID;\n          } else {\n            dataID = generateClientID();\n          }\n        }\n        results.push({\n          dataID,\n          result,\n          rootCallInfo: {storageKey, identifyingArgValue},\n        });\n      });\n    }\n\n    return results;\n  },\n};\n\nfunction getPayloadRecords(\n  query: RelayQuery.Root,\n  payload: {[key: string]: mixed}\n): Array<mixed> {\n  var fieldName = query.getFieldName();\n  const identifyingArg = query.getIdentifyingArg();\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  var records = payload[fieldName];\n  if (!query.getBatchCall()) {\n    if (Array.isArray(identifyingArgValue)) {\n      invariant(\n        Array.isArray(records),\n        'RelayOSSNodeInterface: Expected payload for root field `%s` to be ' +\n        'an array with %s results, instead received a single non-array result.',\n        fieldName,\n        identifyingArgValue.length\n      );\n      invariant(\n        records.length === identifyingArgValue.length,\n        'RelayOSSNodeInterface: Expected payload for root field `%s` to be ' +\n        'an array with %s results, instead received an array with %s results.',\n        fieldName,\n        identifyingArgValue.length,\n        records.length\n      );\n    } else if (Array.isArray(records)) {\n      invariant(\n        false,\n        'RelayOSSNodeInterface: Expected payload for root field `%s` to be ' +\n        'a single non-array result, instead received an array with %s results.',\n        fieldName,\n        records.length\n      );\n    }\n  }\n  return Array.isArray(records) ? records : [records];\n}\n\nmodule.exports = RelayOSSNodeInterface;\n","dependencies":["RelayInternalTypes","RelayQuery","RelayRecordStore","forEachRootCallArg","generateClientID","invariant","RelayOSSNodeInterface"],"id":"RelayOSSNodeInterface","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayOSSNodeInterface\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nimport type RelayQuery from 'RelayQuery';\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst generateClientID = require('generateClientID');\nconst invariant = require('invariant');\n\ntype PayloadResult = {\n  dataID: DataID;\n  result: mixed;\n  rootCallInfo?: RootCallInfo;\n};\n\ntype RootCallInfo = {\n  storageKey: string;\n  identifyingArgValue: ?string;\n}\n\n/**\n * @internal\n *\n * Defines logic relevant to the informal \"Node\" GraphQL interface.\n */\nvar RelayOSSNodeInterface = {\n  ANY_TYPE: '__any',\n  ID: 'id',\n  ID_TYPE: 'ID!',\n  NODE: 'node',\n  NODE_TYPE: 'Node',\n  NODES: 'nodes',\n  TYPENAME: '__typename',\n\n  isNodeRootCall(fieldName: string): boolean {\n    return (\n      fieldName === RelayOSSNodeInterface.NODE ||\n      fieldName === RelayOSSNodeInterface.NODES\n    );\n  },\n\n  getResultsFromPayload(\n    store: RelayRecordStore,\n    query: RelayQuery.Root,\n    payload: {[key: string]: mixed}\n  ): Array<PayloadResult> {\n    var results = [];\n\n    var rootBatchCall = query.getBatchCall();\n    if (rootBatchCall) {\n      getPayloadRecords(query, payload).forEach(result => {\n        if (typeof result !== 'object' || !result) {\n          return;\n        }\n        var dataID = result[RelayOSSNodeInterface.ID];\n        invariant(\n          dataID != null,\n          'RelayOSSNodeInterface.getResultsFromPayload(): Unable to write ' +\n          'result with no `%s` field for query, `%s`.',\n          RelayOSSNodeInterface.ID,\n          query.getName()\n        );\n        results.push({dataID, result});\n      });\n    } else {\n      var records = getPayloadRecords(query, payload);\n      var ii = 0;\n      const storageKey = query.getStorageKey();\n      forEachRootCallArg(query, identifyingArgValue => {\n        var result = records[ii++];\n        var dataID = store.getDataID(storageKey, identifyingArgValue);\n        if (dataID == null) {\n          var payloadID = typeof result === 'object' && result ?\n            result[RelayOSSNodeInterface.ID] :\n            null;\n          if (payloadID != null) {\n            dataID = payloadID;\n          } else {\n            dataID = generateClientID();\n          }\n        }\n        results.push({\n          dataID,\n          result,\n          rootCallInfo: {storageKey, identifyingArgValue},\n        });\n      });\n    }\n\n    return results;\n  },\n};\n\nfunction getPayloadRecords(\n  query: RelayQuery.Root,\n  payload: {[key: string]: mixed}\n): Array<mixed> {\n  var fieldName = query.getFieldName();\n  const identifyingArg = query.getIdentifyingArg();\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  var records = payload[fieldName];\n  if (!query.getBatchCall()) {\n    if (Array.isArray(identifyingArgValue)) {\n      invariant(\n        Array.isArray(records),\n        'RelayOSSNodeInterface: Expected payload for root field `%s` to be ' +\n        'an array with %s results, instead received a single non-array result.',\n        fieldName,\n        identifyingArgValue.length\n      );\n      invariant(\n        records.length === identifyingArgValue.length,\n        'RelayOSSNodeInterface: Expected payload for root field `%s` to be ' +\n        'an array with %s results, instead received an array with %s results.',\n        fieldName,\n        identifyingArgValue.length,\n        records.length\n      );\n    } else if (Array.isArray(records)) {\n      invariant(\n        false,\n        'RelayOSSNodeInterface: Expected payload for root field `%s` to be ' +\n        'a single non-array result, instead received an array with %s results.',\n        fieldName,\n        records.length\n      );\n    }\n  }\n  return Array.isArray(records) ? records : [records];\n}\n\nmodule.exports = RelayOSSNodeInterface;\n"}}},"/Users/cpojer/Projects/relay/src/interface/RelayOSSConnectionInterface.js":{"metadata":{"mtime":1456974578000},"data":{"name":"RelayOSSConnectionInterface","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayOSSConnectionInterface\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {Call} from 'RelayInternalTypes';\n\nexport type PageInfo = {\n  endCursor: ?string;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  startCursor: ?string;\n};\n\nconst CLIENT_MUTATION_ID = 'clientMutationId';\nconst CONNECTION_CALLS = {\n  'after': true,\n  'before': true,\n  'find': true,\n  'first': true,\n  'last': true,\n  'surrounds': true,\n};\nconst CURSOR = 'cursor';\nconst EDGES = 'edges';\nconst END_CURSOR = 'endCursor';\nconst HAS_NEXT_PAGE = 'hasNextPage';\nconst HAS_PREV_PAGE = 'hasPreviousPage';\nconst NODE = 'node';\nconst PAGE_INFO = 'pageInfo';\nconst REQUIRED_RANGE_CALLS = {\n  'find': true,\n  'first': true,\n  'last': true,\n};\nconst START_CURSOR = 'startCursor';\n\n/**\n * @internal\n *\n * Defines logic relevant to the informal \"Connection\" GraphQL interface.\n */\nconst RelayOSSConnectionInterface = {\n  CLIENT_MUTATION_ID,\n  CURSOR,\n  EDGES,\n  END_CURSOR,\n  HAS_NEXT_PAGE,\n  HAS_PREV_PAGE,\n  NODE,\n  PAGE_INFO,\n  START_CURSOR,\n\n  /**\n   * Whether `edges` fields are expected to have `source` fields.\n   */\n  EDGES_HAVE_SOURCE_FIELD: false,\n\n  /**\n   * Checks whether a call exists strictly to encode which parts of a connection\n   * to fetch. Fields that only differ by connection call values should have the\n   * same identity.\n   */\n  isConnectionCall(call: Call): boolean {\n    return CONNECTION_CALLS.hasOwnProperty(call.name);\n  },\n\n  /**\n   * Checks whether a set of calls on a connection supply enough information to\n   * fetch the range fields (i.e. `edges` and `page_info`).\n   */\n  hasRangeCalls(calls: Array<Call>): boolean {\n    return calls.some(call => REQUIRED_RANGE_CALLS.hasOwnProperty(call.name));\n  },\n\n  /**\n   * Gets a default record representing a connection's `PAGE_INFO`.\n   */\n  getDefaultPageInfo(): PageInfo {\n    return {\n      [END_CURSOR]: undefined,\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n      [START_CURSOR]: undefined,\n    };\n  },\n};\n\nmodule.exports = RelayOSSConnectionInterface;\n","dependencies":["RelayInternalTypes","RelayOSSConnectionInterface"],"id":"RelayOSSConnectionInterface","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayOSSConnectionInterface\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {Call} from 'RelayInternalTypes';\n\nexport type PageInfo = {\n  endCursor: ?string;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  startCursor: ?string;\n};\n\nconst CLIENT_MUTATION_ID = 'clientMutationId';\nconst CONNECTION_CALLS = {\n  'after': true,\n  'before': true,\n  'find': true,\n  'first': true,\n  'last': true,\n  'surrounds': true,\n};\nconst CURSOR = 'cursor';\nconst EDGES = 'edges';\nconst END_CURSOR = 'endCursor';\nconst HAS_NEXT_PAGE = 'hasNextPage';\nconst HAS_PREV_PAGE = 'hasPreviousPage';\nconst NODE = 'node';\nconst PAGE_INFO = 'pageInfo';\nconst REQUIRED_RANGE_CALLS = {\n  'find': true,\n  'first': true,\n  'last': true,\n};\nconst START_CURSOR = 'startCursor';\n\n/**\n * @internal\n *\n * Defines logic relevant to the informal \"Connection\" GraphQL interface.\n */\nconst RelayOSSConnectionInterface = {\n  CLIENT_MUTATION_ID,\n  CURSOR,\n  EDGES,\n  END_CURSOR,\n  HAS_NEXT_PAGE,\n  HAS_PREV_PAGE,\n  NODE,\n  PAGE_INFO,\n  START_CURSOR,\n\n  /**\n   * Whether `edges` fields are expected to have `source` fields.\n   */\n  EDGES_HAVE_SOURCE_FIELD: false,\n\n  /**\n   * Checks whether a call exists strictly to encode which parts of a connection\n   * to fetch. Fields that only differ by connection call values should have the\n   * same identity.\n   */\n  isConnectionCall(call: Call): boolean {\n    return CONNECTION_CALLS.hasOwnProperty(call.name);\n  },\n\n  /**\n   * Checks whether a set of calls on a connection supply enough information to\n   * fetch the range fields (i.e. `edges` and `page_info`).\n   */\n  hasRangeCalls(calls: Array<Call>): boolean {\n    return calls.some(call => REQUIRED_RANGE_CALLS.hasOwnProperty(call.name));\n  },\n\n  /**\n   * Gets a default record representing a connection's `PAGE_INFO`.\n   */\n  getDefaultPageInfo(): PageInfo {\n    return {\n      [END_CURSOR]: undefined,\n      [HAS_NEXT_PAGE]: false,\n      [HAS_PREV_PAGE]: false,\n      [START_CURSOR]: undefined,\n    };\n  },\n};\n\nmodule.exports = RelayOSSConnectionInterface;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/validateMutationConfig.js":{"metadata":{"mtime":1455679338000},"data":{"name":"validateMutationConfig","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule validateMutationConfig\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {RelayMutationConfig} from 'RelayTypes';\n\nconst invariant = require('invariant');\nconst sprintf = require('sprintf');\nconst testEditDistance = require('testEditDistance');\n\ntype PropertyDescription = {\n  [name: string]: boolean;\n};\n\nconst FUZZY_THRESHOLD = 3;\nconst OPTIONAL = false;\nconst REQUIRED = true;\n\nfunction validateMutationConfig(\n  config: RelayMutationConfig,\n  name: string,\n): void {\n  function assertValid(properties: PropertyDescription): void {\n    // Check for unexpected properties.\n    Object.keys(config).forEach(property => {\n      if (property === 'type') {\n        return;\n      }\n\n      if (!properties.hasOwnProperty(property)) {\n        const message = sprintf(\n          'validateMutationConfig: Unexpected key `%s` in `%s` config ' +\n          'for `%s`',\n          property,\n          config.type,\n          name\n        );\n        const suggestion = Object.keys(properties).find(\n          candidate => testEditDistance(candidate, property, FUZZY_THRESHOLD)\n        );\n        if (suggestion) {\n          invariant(false, '%s; did you mean `%s`?', message, suggestion);\n        } else {\n          /* eslint-disable fb-www/sprintf-like-args-uniqueness */\n          invariant(false, '%s.', message);\n          /* eslint-enable fb-www/sprintf-like-args-uniqueness */\n        }\n      }\n    });\n\n    // Check for missing properties.\n    Object.keys(properties).forEach(property => {\n      const isRequired = properties[property];\n      if (isRequired && !config[property]) {\n        invariant(\n          false,\n          'validateMutationConfig: `%s` config on `%s` must have property ' +\n          '`%s`.',\n          config.type,\n          name,\n          property\n        );\n      }\n    });\n  }\n\n  switch (config.type) {\n    case 'FIELDS_CHANGE':\n      assertValid({\n        fieldIDs: REQUIRED,\n      });\n      break;\n\n    case 'RANGE_ADD':\n      assertValid({\n        connectionName: REQUIRED,\n        edgeName: REQUIRED,\n        parentID: REQUIRED,\n        parentName: OPTIONAL,\n        rangeBehaviors: REQUIRED,\n      });\n      break;\n\n    case 'NODE_DELETE':\n      assertValid({\n        connectionName: REQUIRED,\n        deletedIDFieldName: REQUIRED,\n        parentID: REQUIRED,\n        parentName: REQUIRED,\n      });\n      break;\n\n    case 'RANGE_DELETE':\n      assertValid({\n        connectionName: REQUIRED,\n        deletedIDFieldName: REQUIRED,\n        parentID: REQUIRED,\n        parentName: REQUIRED,\n        pathToConnection: REQUIRED,\n      });\n      break;\n\n    case 'REQUIRED_CHILDREN':\n      assertValid({\n        children: REQUIRED,\n      });\n      break;\n\n    default:\n      invariant(\n        false,\n        'validateMutationConfig: unknown config type `%s` on `%s`',\n        config.type,\n        name,\n      );\n  }\n}\n\nmodule.exports = validateMutationConfig;\n","dependencies":["RelayTypes","invariant","sprintf","testEditDistance","validateMutationConfig"],"id":"validateMutationConfig","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule validateMutationConfig\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {RelayMutationConfig} from 'RelayTypes';\n\nconst invariant = require('invariant');\nconst sprintf = require('sprintf');\nconst testEditDistance = require('testEditDistance');\n\ntype PropertyDescription = {\n  [name: string]: boolean;\n};\n\nconst FUZZY_THRESHOLD = 3;\nconst OPTIONAL = false;\nconst REQUIRED = true;\n\nfunction validateMutationConfig(\n  config: RelayMutationConfig,\n  name: string,\n): void {\n  function assertValid(properties: PropertyDescription): void {\n    // Check for unexpected properties.\n    Object.keys(config).forEach(property => {\n      if (property === 'type') {\n        return;\n      }\n\n      if (!properties.hasOwnProperty(property)) {\n        const message = sprintf(\n          'validateMutationConfig: Unexpected key `%s` in `%s` config ' +\n          'for `%s`',\n          property,\n          config.type,\n          name\n        );\n        const suggestion = Object.keys(properties).find(\n          candidate => testEditDistance(candidate, property, FUZZY_THRESHOLD)\n        );\n        if (suggestion) {\n          invariant(false, '%s; did you mean `%s`?', message, suggestion);\n        } else {\n          /* eslint-disable fb-www/sprintf-like-args-uniqueness */\n          invariant(false, '%s.', message);\n          /* eslint-enable fb-www/sprintf-like-args-uniqueness */\n        }\n      }\n    });\n\n    // Check for missing properties.\n    Object.keys(properties).forEach(property => {\n      const isRequired = properties[property];\n      if (isRequired && !config[property]) {\n        invariant(\n          false,\n          'validateMutationConfig: `%s` config on `%s` must have property ' +\n          '`%s`.',\n          config.type,\n          name,\n          property\n        );\n      }\n    });\n  }\n\n  switch (config.type) {\n    case 'FIELDS_CHANGE':\n      assertValid({\n        fieldIDs: REQUIRED,\n      });\n      break;\n\n    case 'RANGE_ADD':\n      assertValid({\n        connectionName: REQUIRED,\n        edgeName: REQUIRED,\n        parentID: REQUIRED,\n        parentName: OPTIONAL,\n        rangeBehaviors: REQUIRED,\n      });\n      break;\n\n    case 'NODE_DELETE':\n      assertValid({\n        connectionName: REQUIRED,\n        deletedIDFieldName: REQUIRED,\n        parentID: REQUIRED,\n        parentName: REQUIRED,\n      });\n      break;\n\n    case 'RANGE_DELETE':\n      assertValid({\n        connectionName: REQUIRED,\n        deletedIDFieldName: REQUIRED,\n        parentID: REQUIRED,\n        parentName: REQUIRED,\n        pathToConnection: REQUIRED,\n      });\n      break;\n\n    case 'REQUIRED_CHILDREN':\n      assertValid({\n        children: REQUIRED,\n      });\n      break;\n\n    default:\n      invariant(\n        false,\n        'validateMutationConfig: unknown config type `%s` on `%s`',\n        config.type,\n        name,\n      );\n  }\n}\n\nmodule.exports = validateMutationConfig;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/RelayMutationType.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationType","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationType\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar RelayMutationType = {\n  FIELDS_CHANGE: 'FIELDS_CHANGE',\n  NODE_DELETE: 'NODE_DELETE',\n  RANGE_ADD: 'RANGE_ADD',\n  RANGE_DELETE: 'RANGE_DELETE',\n  REQUIRED_CHILDREN: 'REQUIRED_CHILDREN',\n};\n\nmodule.exports = RelayMutationType;\n","dependencies":["RelayMutationType"],"id":"RelayMutationType","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationType\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar RelayMutationType = {\n  FIELDS_CHANGE: 'FIELDS_CHANGE',\n  NODE_DELETE: 'NODE_DELETE',\n  RANGE_ADD: 'RANGE_ADD',\n  RANGE_DELETE: 'RANGE_DELETE',\n  REQUIRED_CHILDREN: 'REQUIRED_CHILDREN',\n};\n\nmodule.exports = RelayMutationType;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/RelayMutationTransactionStatus.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationTransactionStatus","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationTransactionStatus\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar RelayMutationTransactionStatus = {\n  /**\n   * Transaction hasn't yet been sent to the server. Client has an optimistic\n   * update applied if the mutation defined one. Transaction can be committed or\n   * rolledback.\n   */\n  UNCOMMITTED: 'UNCOMMITTED',\n\n  /**\n   * Transaction was committed but another transaction with the same collision\n   * key is pending, so the transaction has been queued to send to the server.\n   */\n  COMMIT_QUEUED: 'COMMIT_QUEUED',\n\n  /**\n   * Transaction was queued for commit but another transaction with the same\n   * collision queue failed to commit. All transactions in the collision\n   * queue, including this one, have been failed as well. Transaction can be\n   * recommitted or rolledback.\n   */\n  COLLISION_COMMIT_FAILED: 'COLLISION_COMMIT_FAILED',\n\n  /**\n   * Transaction was sent to the server for comitting and a response is awaited.\n   */\n  COMMITTING: 'COMMITTING',\n\n  /**\n   * Transaction was sent to the server for comitting but was failed.\n   */\n  COMMIT_FAILED: 'COMMIT_FAILED',\n};\n\nmodule.exports = RelayMutationTransactionStatus;\n","dependencies":[],"id":"RelayMutationTransactionStatus","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationTransactionStatus\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar RelayMutationTransactionStatus = {\n  /**\n   * Transaction hasn't yet been sent to the server. Client has an optimistic\n   * update applied if the mutation defined one. Transaction can be committed or\n   * rolledback.\n   */\n  UNCOMMITTED: 'UNCOMMITTED',\n\n  /**\n   * Transaction was committed but another transaction with the same collision\n   * key is pending, so the transaction has been queued to send to the server.\n   */\n  COMMIT_QUEUED: 'COMMIT_QUEUED',\n\n  /**\n   * Transaction was queued for commit but another transaction with the same\n   * collision queue failed to commit. All transactions in the collision\n   * queue, including this one, have been failed as well. Transaction can be\n   * recommitted or rolledback.\n   */\n  COLLISION_COMMIT_FAILED: 'COLLISION_COMMIT_FAILED',\n\n  /**\n   * Transaction was sent to the server for comitting and a response is awaited.\n   */\n  COMMITTING: 'COMMITTING',\n\n  /**\n   * Transaction was sent to the server for comitting but was failed.\n   */\n  COMMIT_FAILED: 'COMMIT_FAILED',\n};\n\nmodule.exports = RelayMutationTransactionStatus;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/RelayMutationTransaction.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationTransaction","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationTransaction\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ClientMutationID} from 'RelayInternalTypes';\nimport type RelayMutationQueue from 'RelayMutationQueue';\nconst RelayMutationTransactionStatus = require('RelayMutationTransactionStatus');\n\nconst invariant = require('invariant');\n\n/**\n * @internal\n */\nclass RelayMutationTransaction {\n  _id: ClientMutationID;\n  _mutationQueue: RelayMutationQueue;\n\n  constructor(mutationQueue: RelayMutationQueue, id: ClientMutationID) {\n    this._id = id;\n    this._mutationQueue = mutationQueue;\n  }\n\n  commit(): void {\n    const status = this.getStatus();\n    invariant(\n      status === RelayMutationTransactionStatus.UNCOMMITTED,\n      'RelayMutationTransaction: Only transactions with status `UNCOMMITTED` ' +\n      'can be comitted.'\n    );\n\n    this._mutationQueue.commit(this._id);\n  }\n\n  recommit(): void {\n    const status = this.getStatus();\n    invariant(\n      status === RelayMutationTransactionStatus.COMMIT_FAILED ||\n      status === RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED,\n      'RelayMutationTransaction: Only transaction with status ' +\n      '`COMMIT_FAILED` or `COLLISION_COMMIT_FAILED` can be comitted.'\n    );\n\n    this._mutationQueue.commit(this._id);\n  }\n\n  rollback(): void {\n    const status = this.getStatus();\n    invariant(\n      status === RelayMutationTransactionStatus.UNCOMMITTED ||\n      status === RelayMutationTransactionStatus.COMMIT_FAILED ||\n      status === RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED,\n      'RelayMutationTransaction: Only transactions with status `UNCOMMITTED` ' +\n      '`COMMIT_FAILED` or `COLLISION_COMMIT_FAILED` can be rolledback.'\n    );\n\n    this._mutationQueue.rollback(this._id);\n  }\n\n  getError(): ?Error {\n    return this._mutationQueue.getError(this._id);\n  }\n\n  getStatus(): $Keys<typeof RelayMutationTransactionStatus> {\n    return this._mutationQueue.getStatus(this._id);\n  }\n}\n\nmodule.exports = RelayMutationTransaction;\n","dependencies":["RelayInternalTypes","RelayMutationQueue","RelayMutationTransactionStatus","invariant"],"id":"RelayMutationTransaction","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationTransaction\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ClientMutationID} from 'RelayInternalTypes';\nimport type RelayMutationQueue from 'RelayMutationQueue';\nconst RelayMutationTransactionStatus = require('RelayMutationTransactionStatus');\n\nconst invariant = require('invariant');\n\n/**\n * @internal\n */\nclass RelayMutationTransaction {\n  _id: ClientMutationID;\n  _mutationQueue: RelayMutationQueue;\n\n  constructor(mutationQueue: RelayMutationQueue, id: ClientMutationID) {\n    this._id = id;\n    this._mutationQueue = mutationQueue;\n  }\n\n  commit(): void {\n    const status = this.getStatus();\n    invariant(\n      status === RelayMutationTransactionStatus.UNCOMMITTED,\n      'RelayMutationTransaction: Only transactions with status `UNCOMMITTED` ' +\n      'can be comitted.'\n    );\n\n    this._mutationQueue.commit(this._id);\n  }\n\n  recommit(): void {\n    const status = this.getStatus();\n    invariant(\n      status === RelayMutationTransactionStatus.COMMIT_FAILED ||\n      status === RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED,\n      'RelayMutationTransaction: Only transaction with status ' +\n      '`COMMIT_FAILED` or `COLLISION_COMMIT_FAILED` can be comitted.'\n    );\n\n    this._mutationQueue.commit(this._id);\n  }\n\n  rollback(): void {\n    const status = this.getStatus();\n    invariant(\n      status === RelayMutationTransactionStatus.UNCOMMITTED ||\n      status === RelayMutationTransactionStatus.COMMIT_FAILED ||\n      status === RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED,\n      'RelayMutationTransaction: Only transactions with status `UNCOMMITTED` ' +\n      '`COMMIT_FAILED` or `COLLISION_COMMIT_FAILED` can be rolledback.'\n    );\n\n    this._mutationQueue.rollback(this._id);\n  }\n\n  getError(): ?Error {\n    return this._mutationQueue.getError(this._id);\n  }\n\n  getStatus(): $Keys<typeof RelayMutationTransactionStatus> {\n    return this._mutationQueue.getStatus(this._id);\n  }\n}\n\nmodule.exports = RelayMutationTransaction;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/RelayMutationQueue.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationQueue","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationQueue\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {ConcreteMutation} from 'ConcreteQuery';\nconst ErrorUtils = require('ErrorUtils');\nconst QueryBuilder = require('QueryBuilder');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutationQuery = require('RelayMutationQuery');\nconst RelayMutationRequest = require('RelayMutationRequest');\nconst RelayMutationTransaction = require('RelayMutationTransaction');\nconst RelayMutationTransactionStatus = require('RelayMutationTransactionStatus');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nimport type RelayStoreData from 'RelayStoreData';\nimport type {FileMap} from 'RelayMutation';\nimport type RelayMutation from 'RelayMutation';\nconst RelayQuery = require('RelayQuery');\nimport type {ClientMutationID} from 'RelayInternalTypes';\nimport type {\n  RelayMutationConfig,\n  RelayMutationTransactionCommitCallbacks,\n  RelayMutationTransactionCommitFailureCallback,\n  RelayMutationTransactionCommitSuccessCallback,\n  Variables,\n} from 'RelayTypes';\n\nconst base62 = require('base62');\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst fromGraphQL = require('fromGraphQL');\nconst invariant = require('invariant');\nconst nullthrows = require('nullthrows');\nconst resolveImmediate = require('resolveImmediate');\n\ntype CollisionQueueMap = {[key: string]: Array<PendingTransaction>};\ntype PendingTransactionMap = {\n  [key: ClientMutationID]: PendingTransaction;\n};\ntype TransactionData = {\n  id: ClientMutationID;\n  mutation: RelayMutation;\n  mutationTransaction: RelayMutationTransaction;\n  onFailure: ?RelayMutationTransactionCommitFailureCallback;\n  onSuccess: ?RelayMutationTransactionCommitSuccessCallback;\n};\ntype TransactionQueue = Array<PendingTransaction>;\n\nconst {CLIENT_MUTATION_ID} = RelayConnectionInterface;\n\nlet transactionIDCounter = 0;\n\n/**\n * @internal\n *\n * Coordinates execution of concurrent mutations, including application and\n * rollback of optimistic payloads and enqueueing mutations with the same\n * collision key.\n */\nclass RelayMutationQueue {\n  _collisionQueueMap: CollisionQueueMap;\n  _pendingTransactionMap: PendingTransactionMap;\n  _queue: TransactionQueue;\n  _storeData: RelayStoreData;\n  _willBatchRefreshQueuedData: boolean;\n\n  constructor(storeData: RelayStoreData) {\n    this._collisionQueueMap = {};\n    this._pendingTransactionMap = {};\n    this._queue = [];\n    this._storeData = storeData;\n    this._willBatchRefreshQueuedData = false;\n  }\n\n  createTransaction(\n    mutation: RelayMutation,\n    callbacks: ?RelayMutationTransactionCommitCallbacks\n  ): RelayMutationTransaction {\n    const id = base62(transactionIDCounter++);\n    const mutationTransaction = new RelayMutationTransaction(this, id);\n    const transaction = new PendingTransaction({\n      id,\n      mutation,\n      mutationTransaction,\n      onFailure: callbacks && callbacks.onFailure,\n      onSuccess: callbacks && callbacks.onSuccess,\n    });\n    this._pendingTransactionMap[id] = transaction;\n    this._queue.push(transaction);\n    this._handleOptimisticUpdate(transaction);\n\n    return mutationTransaction;\n  }\n\n  getTransaction(id: ClientMutationID): RelayMutationTransaction {\n    return this._get(id).mutationTransaction;\n  }\n\n  getError(id: ClientMutationID): ?Error {\n    return this._get(id).error;\n  }\n\n  getStatus(\n    id: ClientMutationID\n  ): $Keys<typeof RelayMutationTransactionStatus> {\n    return this._get(id).status;\n  }\n\n  commit(id: ClientMutationID): void {\n    const transaction = this._get(id);\n    const collisionKey = transaction.getCollisionKey();\n    const collisionQueue =\n      collisionKey && this._collisionQueueMap[collisionKey];\n    if (collisionQueue) {\n      collisionQueue.push(transaction);\n      transaction.status = RelayMutationTransactionStatus.COMMIT_QUEUED;\n      transaction.error = null;\n      return;\n    }\n    if (collisionKey) {\n      this._collisionQueueMap[collisionKey] = [transaction];\n    }\n    this._handleCommit(transaction);\n  }\n\n  rollback(id: ClientMutationID): void {\n    const transaction = this._get(id);\n    this._handleRollback(transaction);\n  }\n\n  _get(id: ClientMutationID): PendingTransaction {\n    const transaction = this._pendingTransactionMap[id];\n    invariant(\n      transaction,\n      'RelayMutationQueue: `%s` is not a valid pending transaction ID.',\n      id\n    );\n    return transaction;\n  }\n\n  _handleOptimisticUpdate(transaction: PendingTransaction): void {\n    const optimisticResponse = transaction.getOptimisticResponse();\n    const optimisticQuery = transaction.getOptimisticQuery(this._storeData);\n    if (optimisticResponse && optimisticQuery) {\n      const configs =\n        transaction.getOptimisticConfigs() || transaction.getConfigs();\n      this._storeData.handleUpdatePayload(\n        optimisticQuery,\n        optimisticResponse,\n        {\n          configs,\n          isOptimisticUpdate: true,\n        }\n      );\n    }\n  }\n\n  _handleCommitFailure(\n    transaction: PendingTransaction,\n    error: ?Error\n  ): void {\n    const status = error ?\n      RelayMutationTransactionStatus.COMMIT_FAILED :\n      RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED;\n    transaction.status = status;\n    transaction.error = error;\n\n    let shouldRollback = true;\n    const onFailure = transaction.onFailure;\n    if (onFailure) {\n      var preventAutoRollback = function() { shouldRollback = false; };\n      ErrorUtils.applyWithGuard(\n        onFailure,\n        null,\n        [transaction.mutationTransaction, preventAutoRollback],\n        null,\n        'RelayMutationTransaction:onCommitFailure'\n      );\n    }\n\n    if (error) {\n      this._failCollisionQueue(transaction);\n    }\n\n    // Might have already been rolled back via `onFailure`.\n    if (\n      shouldRollback &&\n      this._pendingTransactionMap.hasOwnProperty(transaction.id)\n    ) {\n      this._handleRollback(transaction);\n    }\n    this._batchRefreshQueuedData();\n  }\n\n  _handleCommitSuccess(\n    transaction: PendingTransaction,\n    response: Object\n  ): void {\n    this._advanceCollisionQueue(transaction);\n    this._clearPendingTransaction(transaction);\n\n    this._refreshQueuedData();\n    this._storeData.handleUpdatePayload(\n      transaction.getQuery(this._storeData),\n      response[transaction.getCallName()],\n      {\n        configs: transaction.getConfigs(),\n        isOptimisticUpdate: false,\n      }\n    );\n\n    const onSuccess = transaction.onSuccess;\n    if (onSuccess) {\n      ErrorUtils.applyWithGuard(\n        onSuccess,\n        null,\n        [response],\n        null,\n        'RelayMutationTransaction:onCommitSuccess'\n      );\n    }\n  }\n\n  _handleCommit(transaction: PendingTransaction): void {\n    transaction.status = RelayMutationTransactionStatus.COMMITTING;\n    transaction.error = null;\n\n    const request = new RelayMutationRequest(\n      transaction.getQuery(this._storeData),\n      transaction.getFiles(),\n    );\n    RelayNetworkLayer.sendMutation(request);\n\n    request.getPromise().done(\n      result => this._handleCommitSuccess(transaction, result.response),\n      error => this._handleCommitFailure(transaction, error)\n    );\n  }\n\n  _handleRollback(transaction: PendingTransaction): void {\n    this._clearPendingTransaction(transaction);\n    this._batchRefreshQueuedData();\n  }\n\n  _clearPendingTransaction(transaction: PendingTransaction): void {\n    delete this._pendingTransactionMap[transaction.id];\n    this._queue = this._queue.filter(tx => tx !== transaction);\n  }\n\n  _advanceCollisionQueue(transaction: PendingTransaction): void {\n    const collisionKey = transaction.getCollisionKey();\n    if (collisionKey) {\n      var collisionQueue = nullthrows(this._collisionQueueMap[collisionKey]);\n      // Remove the transaction that called this function.\n      collisionQueue.shift();\n\n      if (collisionQueue.length) {\n        this._handleCommit(collisionQueue[0]);\n      } else {\n        delete this._collisionQueueMap[collisionKey];\n      }\n    }\n  }\n\n  _failCollisionQueue(transaction: PendingTransaction): void {\n    const collisionKey = transaction.getCollisionKey();\n    if (collisionKey) {\n      const collisionQueue = nullthrows(this._collisionQueueMap[collisionKey]);\n      // Remove the transaction that called this function.\n      collisionQueue.shift();\n      collisionQueue.forEach(\n        transaction => this._handleCommitFailure(transaction, null)\n      );\n      delete this._collisionQueueMap[collisionKey];\n    }\n  }\n\n  _batchRefreshQueuedData(): void {\n    if (!this._willBatchRefreshQueuedData) {\n      this._willBatchRefreshQueuedData = true;\n      resolveImmediate(() => {\n        this._willBatchRefreshQueuedData = false;\n        this._refreshQueuedData();\n      });\n    }\n  }\n\n  _refreshQueuedData(): void {\n    this._storeData.clearQueuedData();\n    this._queue.forEach(\n      transaction => this._handleOptimisticUpdate(transaction)\n    );\n  }\n}\n\n/**\n * @private\n */\nclass PendingTransaction {\n  error: ?Error;\n  id: ClientMutationID;\n  mutation: RelayMutation;\n  mutationTransaction: RelayMutationTransaction;\n  onFailure: ?RelayMutationTransactionCommitFailureCallback;\n  onSuccess: ?RelayMutationTransactionCommitSuccessCallback;\n  status: $Keys<typeof RelayMutationTransactionStatus>;\n\n  // Lazily computed and memoized private properties\n  _callName: string;\n  _collisionKey: ?string;\n  _configs: Array<{[key: string]: mixed}>;\n  _error: ?Error;\n  _fatQuery: RelayQuery.Fragment;\n  _files: ?FileMap;\n  _inputVariable: Variables;\n  _mutationNode: ConcreteMutation;\n  _onCommitFailureCallback: ?RelayMutationTransactionCommitFailureCallback;\n  _onCommitSuccessCallback: ?RelayMutationTransactionCommitSuccessCallback;\n  _optimisticConfigs: ?Array<{[key: string]: mixed}>;\n  _optimisticQuery: ?RelayQuery.Mutation;\n  _optimisticResponse: ?Object;\n  _query: RelayQuery.Mutation;\n\n  constructor(\n    transactionData: TransactionData\n  ) {\n    this.error = null;\n    this.id = transactionData.id;\n    this.mutation = transactionData.mutation;\n    this.mutationTransaction = transactionData.mutationTransaction;\n    this.onFailure = transactionData.onFailure;\n    this.onSuccess = transactionData.onSuccess;\n    this.status = RelayMutationTransactionStatus.UNCOMMITTED;\n  }\n\n  getCallName(): string {\n    if (!this._callName) {\n      this._callName = this.getMutationNode().calls[0].name;\n    }\n    return this._callName;\n  }\n\n  getCollisionKey(): ?string {\n    if (this._collisionKey === undefined) {\n      this._collisionKey = this.mutation.getCollisionKey() || null;\n    }\n    return this._collisionKey;\n  }\n\n  getConfigs(): Array<RelayMutationConfig> {\n    if (!this._configs) {\n      this._configs = this.mutation.getConfigs();\n    }\n    return this._configs;\n  }\n\n  getFatQuery(): RelayQuery.Fragment {\n    if (!this._fatQuery) {\n      const fragment = fromGraphQL.Fragment(this.mutation.getFatQuery());\n      invariant(\n        fragment instanceof RelayQuery.Fragment,\n        'RelayMutationQueue: Expected `getFatQuery` to return a GraphQL ' +\n        'Fragment'\n      );\n      this._fatQuery = nullthrows(flattenRelayQuery(\n        fragment,\n        {\n          preserveEmptyNodes: fragment.isPattern(),\n          shouldRemoveFragments: true,\n        }\n      ));\n    }\n    return this._fatQuery;\n  }\n\n  getFiles(): ?FileMap {\n    if (this._files === undefined) {\n      this._files = this.mutation.getFiles() || null;\n    }\n    return this._files;\n  }\n\n  getInputVariable(): Variables  {\n    if (!this._inputVariable) {\n      var inputVariable = {\n        ...this.mutation.getVariables(),\n        [CLIENT_MUTATION_ID]: this.id,\n      };\n      this._inputVariable = inputVariable;\n    }\n    return this._inputVariable;\n  }\n\n  getMutationNode(): ConcreteMutation {\n    if (!this._mutationNode) {\n      const mutationNode = QueryBuilder.getMutation(this.mutation.getMutation());\n      invariant(\n        mutationNode,\n        'RelayMutation: Expected `getMutation` to return a mutation created ' +\n        'with Relay.QL`mutation { ... }`.'\n      );\n      this._mutationNode = mutationNode;\n    }\n    return this._mutationNode;\n  }\n\n  getOptimisticConfigs(): ?Array<{[key: string]: mixed}> {\n    if (this._optimisticConfigs === undefined) {\n      this._optimisticConfigs = this.mutation.getOptimisticConfigs() || null;\n    }\n    return this._optimisticConfigs;\n  }\n\n  getOptimisticQuery(storeData: RelayStoreData): ?RelayQuery.Mutation {\n    if (this._optimisticQuery === undefined) {\n      var optimisticResponse = this.getOptimisticResponse();\n      if (optimisticResponse) {\n        var optimisticConfigs = this.getOptimisticConfigs();\n        if (optimisticConfigs) {\n          this._optimisticQuery = RelayMutationQuery.buildQuery({\n            configs: optimisticConfigs,\n            fatQuery: this.getFatQuery(),\n            input: this.getInputVariable(),\n            mutationName: this.mutation.constructor.name,\n            mutation: this.getMutationNode(),\n            tracker: storeData.getQueryTracker(),\n          });\n        } else {\n          this._optimisticQuery =\n            RelayMutationQuery.buildQueryForOptimisticUpdate({\n              response: optimisticResponse,\n              fatQuery: this.getFatQuery(),\n              mutation: this.getMutationNode(),\n              tracker: storeData.getQueryTracker(),\n            });\n        }\n      } else {\n        this._optimisticQuery = null;\n      }\n    }\n    return this._optimisticQuery;\n  }\n\n  getOptimisticResponse(): ?Object {\n    if (this._optimisticResponse === undefined) {\n      var optimisticResponse = this.mutation.getOptimisticResponse() || null;\n      if (optimisticResponse) {\n        optimisticResponse[CLIENT_MUTATION_ID] = this.id;\n      }\n      this._optimisticResponse = optimisticResponse;\n    }\n    return this._optimisticResponse;\n  }\n\n  getQuery(storeData: RelayStoreData): RelayQuery.Mutation {\n    if (!this._query) {\n      this._query = RelayMutationQuery.buildQuery({\n        configs: this.getConfigs(),\n        fatQuery: this.getFatQuery(),\n        input: this.getInputVariable(),\n        mutationName: this.getMutationNode().name,\n        mutation: this.getMutationNode(),\n        tracker: storeData.getQueryTracker(),\n      });\n    }\n    return this._query;\n  }\n}\n\nmodule.exports = RelayMutationQueue;\n","dependencies":["ConcreteQuery","RelayStoreData","RelayMutation","RelayInternalTypes","RelayTypes","ErrorUtils","QueryBuilder","RelayConnectionInterface","RelayMutationQuery","RelayMutationRequest","RelayMutationTransaction","RelayMutationTransactionStatus","RelayNetworkLayer","RelayQuery","base62","flattenRelayQuery","fromGraphQL","invariant","nullthrows","resolveImmediate","RelayMutationQueue"],"id":"RelayMutationQueue","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationQueue\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {ConcreteMutation} from 'ConcreteQuery';\nconst ErrorUtils = require('ErrorUtils');\nconst QueryBuilder = require('QueryBuilder');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayMutationQuery = require('RelayMutationQuery');\nconst RelayMutationRequest = require('RelayMutationRequest');\nconst RelayMutationTransaction = require('RelayMutationTransaction');\nconst RelayMutationTransactionStatus = require('RelayMutationTransactionStatus');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nimport type RelayStoreData from 'RelayStoreData';\nimport type {FileMap} from 'RelayMutation';\nimport type RelayMutation from 'RelayMutation';\nconst RelayQuery = require('RelayQuery');\nimport type {ClientMutationID} from 'RelayInternalTypes';\nimport type {\n  RelayMutationConfig,\n  RelayMutationTransactionCommitCallbacks,\n  RelayMutationTransactionCommitFailureCallback,\n  RelayMutationTransactionCommitSuccessCallback,\n  Variables,\n} from 'RelayTypes';\n\nconst base62 = require('base62');\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst fromGraphQL = require('fromGraphQL');\nconst invariant = require('invariant');\nconst nullthrows = require('nullthrows');\nconst resolveImmediate = require('resolveImmediate');\n\ntype CollisionQueueMap = {[key: string]: Array<PendingTransaction>};\ntype PendingTransactionMap = {\n  [key: ClientMutationID]: PendingTransaction;\n};\ntype TransactionData = {\n  id: ClientMutationID;\n  mutation: RelayMutation;\n  mutationTransaction: RelayMutationTransaction;\n  onFailure: ?RelayMutationTransactionCommitFailureCallback;\n  onSuccess: ?RelayMutationTransactionCommitSuccessCallback;\n};\ntype TransactionQueue = Array<PendingTransaction>;\n\nconst {CLIENT_MUTATION_ID} = RelayConnectionInterface;\n\nlet transactionIDCounter = 0;\n\n/**\n * @internal\n *\n * Coordinates execution of concurrent mutations, including application and\n * rollback of optimistic payloads and enqueueing mutations with the same\n * collision key.\n */\nclass RelayMutationQueue {\n  _collisionQueueMap: CollisionQueueMap;\n  _pendingTransactionMap: PendingTransactionMap;\n  _queue: TransactionQueue;\n  _storeData: RelayStoreData;\n  _willBatchRefreshQueuedData: boolean;\n\n  constructor(storeData: RelayStoreData) {\n    this._collisionQueueMap = {};\n    this._pendingTransactionMap = {};\n    this._queue = [];\n    this._storeData = storeData;\n    this._willBatchRefreshQueuedData = false;\n  }\n\n  createTransaction(\n    mutation: RelayMutation,\n    callbacks: ?RelayMutationTransactionCommitCallbacks\n  ): RelayMutationTransaction {\n    const id = base62(transactionIDCounter++);\n    const mutationTransaction = new RelayMutationTransaction(this, id);\n    const transaction = new PendingTransaction({\n      id,\n      mutation,\n      mutationTransaction,\n      onFailure: callbacks && callbacks.onFailure,\n      onSuccess: callbacks && callbacks.onSuccess,\n    });\n    this._pendingTransactionMap[id] = transaction;\n    this._queue.push(transaction);\n    this._handleOptimisticUpdate(transaction);\n\n    return mutationTransaction;\n  }\n\n  getTransaction(id: ClientMutationID): RelayMutationTransaction {\n    return this._get(id).mutationTransaction;\n  }\n\n  getError(id: ClientMutationID): ?Error {\n    return this._get(id).error;\n  }\n\n  getStatus(\n    id: ClientMutationID\n  ): $Keys<typeof RelayMutationTransactionStatus> {\n    return this._get(id).status;\n  }\n\n  commit(id: ClientMutationID): void {\n    const transaction = this._get(id);\n    const collisionKey = transaction.getCollisionKey();\n    const collisionQueue =\n      collisionKey && this._collisionQueueMap[collisionKey];\n    if (collisionQueue) {\n      collisionQueue.push(transaction);\n      transaction.status = RelayMutationTransactionStatus.COMMIT_QUEUED;\n      transaction.error = null;\n      return;\n    }\n    if (collisionKey) {\n      this._collisionQueueMap[collisionKey] = [transaction];\n    }\n    this._handleCommit(transaction);\n  }\n\n  rollback(id: ClientMutationID): void {\n    const transaction = this._get(id);\n    this._handleRollback(transaction);\n  }\n\n  _get(id: ClientMutationID): PendingTransaction {\n    const transaction = this._pendingTransactionMap[id];\n    invariant(\n      transaction,\n      'RelayMutationQueue: `%s` is not a valid pending transaction ID.',\n      id\n    );\n    return transaction;\n  }\n\n  _handleOptimisticUpdate(transaction: PendingTransaction): void {\n    const optimisticResponse = transaction.getOptimisticResponse();\n    const optimisticQuery = transaction.getOptimisticQuery(this._storeData);\n    if (optimisticResponse && optimisticQuery) {\n      const configs =\n        transaction.getOptimisticConfigs() || transaction.getConfigs();\n      this._storeData.handleUpdatePayload(\n        optimisticQuery,\n        optimisticResponse,\n        {\n          configs,\n          isOptimisticUpdate: true,\n        }\n      );\n    }\n  }\n\n  _handleCommitFailure(\n    transaction: PendingTransaction,\n    error: ?Error\n  ): void {\n    const status = error ?\n      RelayMutationTransactionStatus.COMMIT_FAILED :\n      RelayMutationTransactionStatus.COLLISION_COMMIT_FAILED;\n    transaction.status = status;\n    transaction.error = error;\n\n    let shouldRollback = true;\n    const onFailure = transaction.onFailure;\n    if (onFailure) {\n      var preventAutoRollback = function() { shouldRollback = false; };\n      ErrorUtils.applyWithGuard(\n        onFailure,\n        null,\n        [transaction.mutationTransaction, preventAutoRollback],\n        null,\n        'RelayMutationTransaction:onCommitFailure'\n      );\n    }\n\n    if (error) {\n      this._failCollisionQueue(transaction);\n    }\n\n    // Might have already been rolled back via `onFailure`.\n    if (\n      shouldRollback &&\n      this._pendingTransactionMap.hasOwnProperty(transaction.id)\n    ) {\n      this._handleRollback(transaction);\n    }\n    this._batchRefreshQueuedData();\n  }\n\n  _handleCommitSuccess(\n    transaction: PendingTransaction,\n    response: Object\n  ): void {\n    this._advanceCollisionQueue(transaction);\n    this._clearPendingTransaction(transaction);\n\n    this._refreshQueuedData();\n    this._storeData.handleUpdatePayload(\n      transaction.getQuery(this._storeData),\n      response[transaction.getCallName()],\n      {\n        configs: transaction.getConfigs(),\n        isOptimisticUpdate: false,\n      }\n    );\n\n    const onSuccess = transaction.onSuccess;\n    if (onSuccess) {\n      ErrorUtils.applyWithGuard(\n        onSuccess,\n        null,\n        [response],\n        null,\n        'RelayMutationTransaction:onCommitSuccess'\n      );\n    }\n  }\n\n  _handleCommit(transaction: PendingTransaction): void {\n    transaction.status = RelayMutationTransactionStatus.COMMITTING;\n    transaction.error = null;\n\n    const request = new RelayMutationRequest(\n      transaction.getQuery(this._storeData),\n      transaction.getFiles(),\n    );\n    RelayNetworkLayer.sendMutation(request);\n\n    request.getPromise().done(\n      result => this._handleCommitSuccess(transaction, result.response),\n      error => this._handleCommitFailure(transaction, error)\n    );\n  }\n\n  _handleRollback(transaction: PendingTransaction): void {\n    this._clearPendingTransaction(transaction);\n    this._batchRefreshQueuedData();\n  }\n\n  _clearPendingTransaction(transaction: PendingTransaction): void {\n    delete this._pendingTransactionMap[transaction.id];\n    this._queue = this._queue.filter(tx => tx !== transaction);\n  }\n\n  _advanceCollisionQueue(transaction: PendingTransaction): void {\n    const collisionKey = transaction.getCollisionKey();\n    if (collisionKey) {\n      var collisionQueue = nullthrows(this._collisionQueueMap[collisionKey]);\n      // Remove the transaction that called this function.\n      collisionQueue.shift();\n\n      if (collisionQueue.length) {\n        this._handleCommit(collisionQueue[0]);\n      } else {\n        delete this._collisionQueueMap[collisionKey];\n      }\n    }\n  }\n\n  _failCollisionQueue(transaction: PendingTransaction): void {\n    const collisionKey = transaction.getCollisionKey();\n    if (collisionKey) {\n      const collisionQueue = nullthrows(this._collisionQueueMap[collisionKey]);\n      // Remove the transaction that called this function.\n      collisionQueue.shift();\n      collisionQueue.forEach(\n        transaction => this._handleCommitFailure(transaction, null)\n      );\n      delete this._collisionQueueMap[collisionKey];\n    }\n  }\n\n  _batchRefreshQueuedData(): void {\n    if (!this._willBatchRefreshQueuedData) {\n      this._willBatchRefreshQueuedData = true;\n      resolveImmediate(() => {\n        this._willBatchRefreshQueuedData = false;\n        this._refreshQueuedData();\n      });\n    }\n  }\n\n  _refreshQueuedData(): void {\n    this._storeData.clearQueuedData();\n    this._queue.forEach(\n      transaction => this._handleOptimisticUpdate(transaction)\n    );\n  }\n}\n\n/**\n * @private\n */\nclass PendingTransaction {\n  error: ?Error;\n  id: ClientMutationID;\n  mutation: RelayMutation;\n  mutationTransaction: RelayMutationTransaction;\n  onFailure: ?RelayMutationTransactionCommitFailureCallback;\n  onSuccess: ?RelayMutationTransactionCommitSuccessCallback;\n  status: $Keys<typeof RelayMutationTransactionStatus>;\n\n  // Lazily computed and memoized private properties\n  _callName: string;\n  _collisionKey: ?string;\n  _configs: Array<{[key: string]: mixed}>;\n  _error: ?Error;\n  _fatQuery: RelayQuery.Fragment;\n  _files: ?FileMap;\n  _inputVariable: Variables;\n  _mutationNode: ConcreteMutation;\n  _onCommitFailureCallback: ?RelayMutationTransactionCommitFailureCallback;\n  _onCommitSuccessCallback: ?RelayMutationTransactionCommitSuccessCallback;\n  _optimisticConfigs: ?Array<{[key: string]: mixed}>;\n  _optimisticQuery: ?RelayQuery.Mutation;\n  _optimisticResponse: ?Object;\n  _query: RelayQuery.Mutation;\n\n  constructor(\n    transactionData: TransactionData\n  ) {\n    this.error = null;\n    this.id = transactionData.id;\n    this.mutation = transactionData.mutation;\n    this.mutationTransaction = transactionData.mutationTransaction;\n    this.onFailure = transactionData.onFailure;\n    this.onSuccess = transactionData.onSuccess;\n    this.status = RelayMutationTransactionStatus.UNCOMMITTED;\n  }\n\n  getCallName(): string {\n    if (!this._callName) {\n      this._callName = this.getMutationNode().calls[0].name;\n    }\n    return this._callName;\n  }\n\n  getCollisionKey(): ?string {\n    if (this._collisionKey === undefined) {\n      this._collisionKey = this.mutation.getCollisionKey() || null;\n    }\n    return this._collisionKey;\n  }\n\n  getConfigs(): Array<RelayMutationConfig> {\n    if (!this._configs) {\n      this._configs = this.mutation.getConfigs();\n    }\n    return this._configs;\n  }\n\n  getFatQuery(): RelayQuery.Fragment {\n    if (!this._fatQuery) {\n      const fragment = fromGraphQL.Fragment(this.mutation.getFatQuery());\n      invariant(\n        fragment instanceof RelayQuery.Fragment,\n        'RelayMutationQueue: Expected `getFatQuery` to return a GraphQL ' +\n        'Fragment'\n      );\n      this._fatQuery = nullthrows(flattenRelayQuery(\n        fragment,\n        {\n          preserveEmptyNodes: fragment.isPattern(),\n          shouldRemoveFragments: true,\n        }\n      ));\n    }\n    return this._fatQuery;\n  }\n\n  getFiles(): ?FileMap {\n    if (this._files === undefined) {\n      this._files = this.mutation.getFiles() || null;\n    }\n    return this._files;\n  }\n\n  getInputVariable(): Variables  {\n    if (!this._inputVariable) {\n      var inputVariable = {\n        ...this.mutation.getVariables(),\n        [CLIENT_MUTATION_ID]: this.id,\n      };\n      this._inputVariable = inputVariable;\n    }\n    return this._inputVariable;\n  }\n\n  getMutationNode(): ConcreteMutation {\n    if (!this._mutationNode) {\n      const mutationNode = QueryBuilder.getMutation(this.mutation.getMutation());\n      invariant(\n        mutationNode,\n        'RelayMutation: Expected `getMutation` to return a mutation created ' +\n        'with Relay.QL`mutation { ... }`.'\n      );\n      this._mutationNode = mutationNode;\n    }\n    return this._mutationNode;\n  }\n\n  getOptimisticConfigs(): ?Array<{[key: string]: mixed}> {\n    if (this._optimisticConfigs === undefined) {\n      this._optimisticConfigs = this.mutation.getOptimisticConfigs() || null;\n    }\n    return this._optimisticConfigs;\n  }\n\n  getOptimisticQuery(storeData: RelayStoreData): ?RelayQuery.Mutation {\n    if (this._optimisticQuery === undefined) {\n      var optimisticResponse = this.getOptimisticResponse();\n      if (optimisticResponse) {\n        var optimisticConfigs = this.getOptimisticConfigs();\n        if (optimisticConfigs) {\n          this._optimisticQuery = RelayMutationQuery.buildQuery({\n            configs: optimisticConfigs,\n            fatQuery: this.getFatQuery(),\n            input: this.getInputVariable(),\n            mutationName: this.mutation.constructor.name,\n            mutation: this.getMutationNode(),\n            tracker: storeData.getQueryTracker(),\n          });\n        } else {\n          this._optimisticQuery =\n            RelayMutationQuery.buildQueryForOptimisticUpdate({\n              response: optimisticResponse,\n              fatQuery: this.getFatQuery(),\n              mutation: this.getMutationNode(),\n              tracker: storeData.getQueryTracker(),\n            });\n        }\n      } else {\n        this._optimisticQuery = null;\n      }\n    }\n    return this._optimisticQuery;\n  }\n\n  getOptimisticResponse(): ?Object {\n    if (this._optimisticResponse === undefined) {\n      var optimisticResponse = this.mutation.getOptimisticResponse() || null;\n      if (optimisticResponse) {\n        optimisticResponse[CLIENT_MUTATION_ID] = this.id;\n      }\n      this._optimisticResponse = optimisticResponse;\n    }\n    return this._optimisticResponse;\n  }\n\n  getQuery(storeData: RelayStoreData): RelayQuery.Mutation {\n    if (!this._query) {\n      this._query = RelayMutationQuery.buildQuery({\n        configs: this.getConfigs(),\n        fatQuery: this.getFatQuery(),\n        input: this.getInputVariable(),\n        mutationName: this.getMutationNode().name,\n        mutation: this.getMutationNode(),\n        tracker: storeData.getQueryTracker(),\n      });\n    }\n    return this._query;\n  }\n}\n\nmodule.exports = RelayMutationQueue;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/RelayMutationQuery.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ConcreteMutation} from 'ConcreteQuery';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {DataID, RangeBehaviors} from 'RelayInternalTypes';\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nimport type RelayQueryTracker from 'RelayQueryTracker';\nconst RelayRecord = require('RelayRecord');\nimport type {Variables} from 'RelayTypes';\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst forEachObject = require('forEachObject');\nconst nullthrows = require('nullthrows');\nconst inferRelayFieldsFromData = require('inferRelayFieldsFromData');\nconst intersectRelayQuery = require('intersectRelayQuery');\nconst invariant = require('invariant');\n\n// This should probably use disjoint unions.\ntype MutationConfig = {[key: string]: $FlowFixMe};\n\ntype BasicMutationFragmentBuilderConfig = {\n  fatQuery: RelayQuery.Fragment;\n  tracker: RelayQueryTracker;\n};\ntype FieldsMutationFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    fieldIDs: {[fieldName: string]: DataID | Array<DataID>};\n  };\ntype EdgeDeletionMutationFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    connectionName: string;\n    parentID: DataID;\n    parentName: string;\n  };\ntype EdgeInsertionMutationFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    connectionName: string;\n    parentID: DataID;\n    edgeName: string;\n    parentName?: string;\n    rangeBehaviors: RangeBehaviors;\n  };\ntype OptimisticUpdateFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    response: Object;\n  };\ntype OptimisticUpdateQueryBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    mutation: ConcreteMutation;\n    response: Object;\n  };\n\nvar {CLIENT_MUTATION_ID} = RelayConnectionInterface;\nvar {ANY_TYPE, ID, TYPENAME} = RelayNodeInterface;\n\n/**\n * @internal\n *\n * Constructs query fragments that are sent with mutations, which should ensure\n * that any records changed as a result of mutations are brought up-to-date.\n *\n * The fragments are a minimal subset created by intersecting the \"fat query\"\n * (fields that a mutation declares may have changed) with the \"tracked query\"\n * (fields representing data previously queried and written into the store).\n */\nvar RelayMutationQuery = {\n  /**\n   * Accepts a mapping from field names to data IDs. The field names must exist\n   * as top-level fields in the fat query. These top-level fields are used to\n   * re-fetch any data that has changed for records identified by the data IDs.\n   *\n   * The supplied mapping may contain multiple field names. In addition, each\n   * field name may map to an array of data IDs if the field is plural.\n   */\n  buildFragmentForFields(\n    {\n      fatQuery,\n      fieldIDs,\n      tracker,\n    }: FieldsMutationFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    var mutatedFields = [];\n    forEachObject(fieldIDs, (dataIDOrIDs, fieldName) => {\n      var fatField = getFieldFromFatQuery(fatQuery, fieldName);\n      var dataIDs = [].concat(dataIDOrIDs);\n      var trackedChildren = [];\n      dataIDs.forEach(dataID => {\n        trackedChildren.push(...tracker.getTrackedChildrenForID(dataID));\n      });\n      var trackedField = fatField.clone(trackedChildren);\n      if (trackedField) {\n        var mutationField = intersectRelayQuery(trackedField, fatField);\n        if (mutationField) {\n          mutatedFields.push(mutationField);\n        }\n      }\n    });\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a fragment used to update any data as a result of a mutation that\n   * deletes an edge from a connection. The primary difference between this and\n   * `createForFields` is whether or not the connection edges are re-fetched.\n   *\n   * `connectionName`\n   *   Name of the connection field from which the edge is being deleted.\n   *\n   * `parentID`\n   *   ID of the parent record containing the connection which may have metadata\n   *   that needs to be re-fetched.\n   *\n   * `parentName`\n   *   Name of the top-level field in the fat query that corresponds to the\n   *   parent record.\n   */\n  buildFragmentForEdgeDeletion(\n    {\n      fatQuery,\n      connectionName,\n      parentID,\n      parentName,\n      tracker,\n    }: EdgeDeletionMutationFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    var fatParent = getFieldFromFatQuery(fatQuery, parentName);\n    var mutatedFields = [];\n    var trackedParent = fatParent.clone(\n      tracker.getTrackedChildrenForID(parentID)\n    );\n    if (trackedParent) {\n      var filterUnterminatedRange = node => (\n        node.getSchemaName() === connectionName\n      );\n      var mutatedField = intersectRelayQuery(\n        trackedParent,\n        fatParent,\n        filterUnterminatedRange\n      );\n      if (mutatedField) {\n        mutatedFields.push(mutatedField);\n      }\n    }\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a fragment used to fetch data necessary to insert a new edge into\n   * an existing connection.\n   *\n   * `connectionName`\n   *   Name of the connection field into which the edge is being inserted.\n   *\n   * `parentID`\n   *   ID of the parent record containing the connection which may have metadata\n   *   that needs to be re-fetched.\n   *\n   * `edgeName`\n   *   Name of the top-level field in the fat query that corresponds to the\n   *   newly inserted edge.\n   *\n   * `parentName`\n   *   Name of the top-level field in the fat query that corresponds to the\n   *   parent record. If not supplied, metadata on the parent record and any\n   *   connections without entries in `rangeBehaviors` will not be updated.\n   */\n  buildFragmentForEdgeInsertion(\n    {\n      fatQuery,\n      connectionName,\n      parentID,\n      edgeName,\n      parentName,\n      rangeBehaviors,\n      tracker,\n    }: EdgeInsertionMutationFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    var trackedChildren = tracker.getTrackedChildrenForID(parentID);\n\n    var mutatedFields = [];\n    var trackedConnections = [];\n    trackedChildren.forEach(trackedChild => {\n      trackedConnections.push(\n        ...findDescendantFields(trackedChild, connectionName)\n      );\n    });\n\n    if (trackedConnections.length) {\n      var keysWithoutRangeBehavior: {[hash: string]: boolean} = {};\n      var mutatedEdgeFields = [];\n      trackedConnections.forEach(trackedConnection => {\n        var trackedEdges = findDescendantFields(trackedConnection, 'edges');\n        if (!trackedEdges.length) {\n          return;\n        }\n        if (trackedConnection.getRangeBehaviorKey() in rangeBehaviors) {\n          // Include edges from all connections that exist in `rangeBehaviors`.\n          // This may add duplicates, but they will eventually be flattened.\n          trackedEdges.forEach(trackedEdge => {\n            mutatedEdgeFields.push(...trackedEdge.getChildren());\n          });\n        } else {\n          // If the connection is not in `rangeBehaviors`, re-fetch it.\n          keysWithoutRangeBehavior[trackedConnection.getShallowHash()] = true;\n        }\n      });\n      if (mutatedEdgeFields.length) {\n        mutatedFields.push(\n          buildEdgeField(parentID, edgeName, mutatedEdgeFields)\n        );\n      }\n\n      // TODO: Do this even if there are no tracked connections.\n      if (parentName != null) {\n        var fatParent = getFieldFromFatQuery(fatQuery, parentName);\n        var trackedParent = fatParent.clone(trackedChildren);\n        if (trackedParent) {\n          var filterUnterminatedRange = node => (\n            !keysWithoutRangeBehavior.hasOwnProperty(node.getShallowHash())\n          );\n          var mutatedParent = intersectRelayQuery(\n            trackedParent,\n            fatParent,\n            filterUnterminatedRange\n          );\n          if (mutatedParent) {\n            mutatedFields.push(mutatedParent);\n          }\n        }\n      }\n    }\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a fragment used to fetch the given optimistic response.\n   */\n  buildFragmentForOptimisticUpdate(\n    {response, fatQuery}: OptimisticUpdateFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    // Silences RelayQueryNode being incompatible with sub-class RelayQueryField\n    // A detailed error description is available in #7635477\n    var mutatedFields = (inferRelayFieldsFromData(response): $FlowIssue);\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a RelayQuery.Mutation used to fetch the given optimistic response.\n   */\n  buildQueryForOptimisticUpdate(\n    {\n      fatQuery,\n      mutation,\n      response,\n      tracker,\n    }: OptimisticUpdateQueryBuilderConfig\n  ): RelayQuery.Mutation {\n    var children = [\n      nullthrows(RelayMutationQuery.buildFragmentForOptimisticUpdate({\n        response,\n        fatQuery,\n        tracker,\n      })),\n    ];\n    return RelayQuery.Mutation.build(\n      'OptimisticQuery',\n      fatQuery.getType(),\n      mutation.calls[0].name,\n      null,\n      children,\n      mutation.metadata\n    );\n  },\n\n  /**\n   * Creates a RelayQuery.Mutation for the given config. See type\n   * `MutationConfig` and the `buildFragmentForEdgeInsertion`,\n   * `buildFragmentForEdgeDeletion` and `buildFragmentForFields` methods above\n   * for possible configs.\n   */\n  buildQuery(\n    {\n      configs,\n      fatQuery,\n      input,\n      mutationName,\n      mutation,\n      tracker,\n    }: {\n      configs: Array<MutationConfig>;\n      fatQuery: RelayQuery.Fragment;\n      input: Variables,\n      mutationName: string;\n      mutation: ConcreteMutation;\n      tracker: RelayQueryTracker;\n    }\n  ): RelayQuery.Mutation {\n    var children: Array<?RelayQuery.Node> = [\n      RelayQuery.Field.build({\n        fieldName: CLIENT_MUTATION_ID,\n        type: 'String',\n        metadata: {isRequisite:true},\n      }),\n    ];\n\n    configs.forEach(config => {\n      switch (config.type) {\n        case RelayMutationType.REQUIRED_CHILDREN:\n          children = children.concat(config.children.map(child =>\n             RelayQuery.Fragment.create(\n              child,\n              RelayMetaRoute.get('$buildQuery'),\n              {}\n            )\n          ));\n          break;\n\n        case RelayMutationType.RANGE_ADD:\n          children.push(RelayMutationQuery.buildFragmentForEdgeInsertion({\n            connectionName: config.connectionName,\n            edgeName: config.edgeName,\n            fatQuery,\n            parentID: config.parentID,\n            parentName: config.parentName,\n            rangeBehaviors: sanitizeRangeBehaviors(config.rangeBehaviors),\n            tracker,\n          }));\n          break;\n\n        case RelayMutationType.RANGE_DELETE:\n        case RelayMutationType.NODE_DELETE:\n          children.push(RelayMutationQuery.buildFragmentForEdgeDeletion({\n            connectionName: config.connectionName,\n            fatQuery,\n            parentID: config.parentID,\n            parentName: config.parentName,\n            tracker,\n          }));\n          children.push(\n            Array.isArray(config.deletedIDFieldName) ?\n              buildDeletedConnectionNodeIDField(config.deletedIDFieldName) :\n              RelayQuery.Field.build({\n                fieldName: config.deletedIDFieldName,\n                type: 'String',\n              })\n          );\n          break;\n\n        case RelayMutationType.FIELDS_CHANGE:\n          children.push(RelayMutationQuery.buildFragmentForFields({\n            fatQuery,\n            fieldIDs: config.fieldIDs,\n            tracker,\n          }));\n          break;\n\n        default:\n          invariant(\n            false,\n            'RelayMutationQuery: Unrecognized config key `%s` for `%s`.',\n            config.type,\n            mutationName\n          );\n      }\n    });\n\n    return RelayQuery.Mutation.build(\n      mutationName,\n      fatQuery.getType(),\n      mutation.calls[0].name,\n      input,\n      (children.filter(child => child != null): any),\n      mutation.metadata\n    );\n  },\n};\n\nfunction getFieldFromFatQuery(\n  fatQuery: RelayQuery.Node,\n  fieldName: string\n): RelayQuery.Field {\n  var field = fatQuery.getFieldByStorageKey(fieldName);\n  invariant(\n    field,\n    'RelayMutationQuery: Invalid field name on fat query, `%s`.',\n    fieldName\n  );\n  return field;\n}\n\nfunction buildMutationFragment(\n  fatQuery: RelayQuery.Fragment,\n  fields: Array<RelayQuery.Node>\n): ?RelayQuery.Fragment {\n  var fragment = RelayQuery.Fragment.build(\n    'MutationQuery',\n    fatQuery.getType(),\n    fields\n  );\n  if (fragment) {\n    invariant(\n      fragment instanceof RelayQuery.Fragment,\n      'RelayMutationQuery: Expected a fragment.'\n    );\n    return fragment;\n  }\n  return null;\n}\n\nfunction buildDeletedConnectionNodeIDField(\n  fieldNames: Array<string>\n): RelayQuery.Field {\n  let field = RelayQuery.Field.build({\n    fieldName: ID,\n    type: 'String',\n  });\n  for (let ii = fieldNames.length - 1; ii >= 0; ii--) {\n    field = RelayQuery.Field.build({\n      fieldName: fieldNames[ii],\n      type: ANY_TYPE,\n      children: [field],\n      metadata: {\n        canHaveSubselections: true,\n      },\n    });\n  }\n  return field;\n}\n\nfunction buildEdgeField(\n  parentID: DataID,\n  edgeName: string,\n  edgeFields: Array<RelayQuery.Node>\n): RelayQuery.Field {\n  var fields = [\n    RelayQuery.Field.build({\n      fieldName: 'cursor',\n      type: 'String',\n    }),\n    RelayQuery.Field.build({\n      fieldName: TYPENAME,\n      type: 'String',\n    }),\n  ];\n  if (RelayConnectionInterface.EDGES_HAVE_SOURCE_FIELD &&\n      !RelayRecord.isClientID(parentID)) {\n    fields.push(\n      RelayQuery.Field.build({\n        children: [\n          RelayQuery.Field.build({\n            fieldName: ID,\n            type: 'String',\n          }),\n          RelayQuery.Field.build({\n            fieldName: TYPENAME,\n            type: 'String',\n          }),\n        ],\n        fieldName: 'source',\n        metadata: {canHaveSubselections: true},\n        type: ANY_TYPE,\n      })\n    );\n  }\n  fields.push(...edgeFields);\n  var edgeField = flattenRelayQuery(RelayQuery.Field.build({\n    children: fields,\n    fieldName: edgeName,\n    metadata: {canHaveSubselections: true},\n    type: ANY_TYPE,\n  }));\n  invariant(\n    edgeField instanceof RelayQuery.Field,\n    'RelayMutationQuery: Expected a field.'\n  );\n  return edgeField;\n}\n\nfunction sanitizeRangeBehaviors(\n  rangeBehaviors: RangeBehaviors\n): RangeBehaviors {\n  // Prior to 0.4.1 you would have to specify the args in your range behaviors\n  // in the same order they appeared in your query. From 0.4.1 onward, args in a\n  // range behavior key must be in alphabetical order.\n  let unsortedKeys;\n  forEachObject(rangeBehaviors, (value, key) => {\n    if (key !== '') {\n      const keyParts = key\n        // Remove the last parenthesis\n        .slice(0, -1)\n        // Slice on unescaped parentheses followed immediately by a `.`\n        .split(/\\)\\./);\n      const sortedKey = keyParts\n        .sort()\n        .join(').') +\n        (keyParts.length ? ')' : '');\n      if (sortedKey !== key) {\n        unsortedKeys = unsortedKeys || [];\n        unsortedKeys.push(key);\n      }\n    }\n  });\n  if (unsortedKeys) {\n    invariant(\n      false,\n      'RelayMutation: To define a range behavior key without sorting ' +\n      'the arguments alphabetically is disallowed as of Relay 0.5.1. Please ' +\n      'sort the argument names of the range behavior key%s `%s`%s.',\n      unsortedKeys.length === 1 ? '' : 's',\n      unsortedKeys.length === 1 ?\n        unsortedKeys[0] :\n        unsortedKeys.length === 2 ?\n          `${unsortedKeys[0]}\\` and \\`${unsortedKeys[1]}` :\n          unsortedKeys.slice(0, -1).join('`, `'),\n      unsortedKeys.length > 2 ? `, and \\`${unsortedKeys.slice(-1)}\\`` : ''\n    );\n  }\n  return rangeBehaviors;\n}\n\n/**\n * Finds all direct and indirect child fields of `node` with the given\n * field name.\n */\nfunction findDescendantFields(\n  rootNode: RelayQuery.Node,\n  fieldName: string\n): Array<RelayQuery.Field> {\n  var fields = [];\n  function traverse(node) {\n    if (node instanceof RelayQuery.Field) {\n      if (node.getSchemaName() === fieldName) {\n        fields.push(node);\n        return;\n      }\n    }\n    if (\n      node === rootNode ||\n      node instanceof RelayQuery.Fragment\n    ) {\n      // Search fragments and the root node for matching fields, but skip\n      // descendant non-matching fields.\n      node.getChildren().forEach(child => traverse(child));\n    }\n  }\n  traverse(rootNode);\n  return fields;\n}\n\nmodule.exports = RelayMutationQuery;\n","dependencies":["ConcreteQuery","RelayInternalTypes","RelayQueryTracker","RelayTypes","RelayConnectionInterface","RelayMetaRoute","RelayMutationType","RelayNodeInterface","RelayQuery","RelayRecord","flattenRelayQuery","forEachObject","nullthrows","inferRelayFieldsFromData","intersectRelayQuery","invariant"],"id":"RelayMutationQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ConcreteMutation} from 'ConcreteQuery';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {DataID, RangeBehaviors} from 'RelayInternalTypes';\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nimport type RelayQueryTracker from 'RelayQueryTracker';\nconst RelayRecord = require('RelayRecord');\nimport type {Variables} from 'RelayTypes';\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst forEachObject = require('forEachObject');\nconst nullthrows = require('nullthrows');\nconst inferRelayFieldsFromData = require('inferRelayFieldsFromData');\nconst intersectRelayQuery = require('intersectRelayQuery');\nconst invariant = require('invariant');\n\n// This should probably use disjoint unions.\ntype MutationConfig = {[key: string]: $FlowFixMe};\n\ntype BasicMutationFragmentBuilderConfig = {\n  fatQuery: RelayQuery.Fragment;\n  tracker: RelayQueryTracker;\n};\ntype FieldsMutationFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    fieldIDs: {[fieldName: string]: DataID | Array<DataID>};\n  };\ntype EdgeDeletionMutationFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    connectionName: string;\n    parentID: DataID;\n    parentName: string;\n  };\ntype EdgeInsertionMutationFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    connectionName: string;\n    parentID: DataID;\n    edgeName: string;\n    parentName?: string;\n    rangeBehaviors: RangeBehaviors;\n  };\ntype OptimisticUpdateFragmentBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    response: Object;\n  };\ntype OptimisticUpdateQueryBuilderConfig =\n  BasicMutationFragmentBuilderConfig & {\n    mutation: ConcreteMutation;\n    response: Object;\n  };\n\nvar {CLIENT_MUTATION_ID} = RelayConnectionInterface;\nvar {ANY_TYPE, ID, TYPENAME} = RelayNodeInterface;\n\n/**\n * @internal\n *\n * Constructs query fragments that are sent with mutations, which should ensure\n * that any records changed as a result of mutations are brought up-to-date.\n *\n * The fragments are a minimal subset created by intersecting the \"fat query\"\n * (fields that a mutation declares may have changed) with the \"tracked query\"\n * (fields representing data previously queried and written into the store).\n */\nvar RelayMutationQuery = {\n  /**\n   * Accepts a mapping from field names to data IDs. The field names must exist\n   * as top-level fields in the fat query. These top-level fields are used to\n   * re-fetch any data that has changed for records identified by the data IDs.\n   *\n   * The supplied mapping may contain multiple field names. In addition, each\n   * field name may map to an array of data IDs if the field is plural.\n   */\n  buildFragmentForFields(\n    {\n      fatQuery,\n      fieldIDs,\n      tracker,\n    }: FieldsMutationFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    var mutatedFields = [];\n    forEachObject(fieldIDs, (dataIDOrIDs, fieldName) => {\n      var fatField = getFieldFromFatQuery(fatQuery, fieldName);\n      var dataIDs = [].concat(dataIDOrIDs);\n      var trackedChildren = [];\n      dataIDs.forEach(dataID => {\n        trackedChildren.push(...tracker.getTrackedChildrenForID(dataID));\n      });\n      var trackedField = fatField.clone(trackedChildren);\n      if (trackedField) {\n        var mutationField = intersectRelayQuery(trackedField, fatField);\n        if (mutationField) {\n          mutatedFields.push(mutationField);\n        }\n      }\n    });\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a fragment used to update any data as a result of a mutation that\n   * deletes an edge from a connection. The primary difference between this and\n   * `createForFields` is whether or not the connection edges are re-fetched.\n   *\n   * `connectionName`\n   *   Name of the connection field from which the edge is being deleted.\n   *\n   * `parentID`\n   *   ID of the parent record containing the connection which may have metadata\n   *   that needs to be re-fetched.\n   *\n   * `parentName`\n   *   Name of the top-level field in the fat query that corresponds to the\n   *   parent record.\n   */\n  buildFragmentForEdgeDeletion(\n    {\n      fatQuery,\n      connectionName,\n      parentID,\n      parentName,\n      tracker,\n    }: EdgeDeletionMutationFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    var fatParent = getFieldFromFatQuery(fatQuery, parentName);\n    var mutatedFields = [];\n    var trackedParent = fatParent.clone(\n      tracker.getTrackedChildrenForID(parentID)\n    );\n    if (trackedParent) {\n      var filterUnterminatedRange = node => (\n        node.getSchemaName() === connectionName\n      );\n      var mutatedField = intersectRelayQuery(\n        trackedParent,\n        fatParent,\n        filterUnterminatedRange\n      );\n      if (mutatedField) {\n        mutatedFields.push(mutatedField);\n      }\n    }\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a fragment used to fetch data necessary to insert a new edge into\n   * an existing connection.\n   *\n   * `connectionName`\n   *   Name of the connection field into which the edge is being inserted.\n   *\n   * `parentID`\n   *   ID of the parent record containing the connection which may have metadata\n   *   that needs to be re-fetched.\n   *\n   * `edgeName`\n   *   Name of the top-level field in the fat query that corresponds to the\n   *   newly inserted edge.\n   *\n   * `parentName`\n   *   Name of the top-level field in the fat query that corresponds to the\n   *   parent record. If not supplied, metadata on the parent record and any\n   *   connections without entries in `rangeBehaviors` will not be updated.\n   */\n  buildFragmentForEdgeInsertion(\n    {\n      fatQuery,\n      connectionName,\n      parentID,\n      edgeName,\n      parentName,\n      rangeBehaviors,\n      tracker,\n    }: EdgeInsertionMutationFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    var trackedChildren = tracker.getTrackedChildrenForID(parentID);\n\n    var mutatedFields = [];\n    var trackedConnections = [];\n    trackedChildren.forEach(trackedChild => {\n      trackedConnections.push(\n        ...findDescendantFields(trackedChild, connectionName)\n      );\n    });\n\n    if (trackedConnections.length) {\n      var keysWithoutRangeBehavior: {[hash: string]: boolean} = {};\n      var mutatedEdgeFields = [];\n      trackedConnections.forEach(trackedConnection => {\n        var trackedEdges = findDescendantFields(trackedConnection, 'edges');\n        if (!trackedEdges.length) {\n          return;\n        }\n        if (trackedConnection.getRangeBehaviorKey() in rangeBehaviors) {\n          // Include edges from all connections that exist in `rangeBehaviors`.\n          // This may add duplicates, but they will eventually be flattened.\n          trackedEdges.forEach(trackedEdge => {\n            mutatedEdgeFields.push(...trackedEdge.getChildren());\n          });\n        } else {\n          // If the connection is not in `rangeBehaviors`, re-fetch it.\n          keysWithoutRangeBehavior[trackedConnection.getShallowHash()] = true;\n        }\n      });\n      if (mutatedEdgeFields.length) {\n        mutatedFields.push(\n          buildEdgeField(parentID, edgeName, mutatedEdgeFields)\n        );\n      }\n\n      // TODO: Do this even if there are no tracked connections.\n      if (parentName != null) {\n        var fatParent = getFieldFromFatQuery(fatQuery, parentName);\n        var trackedParent = fatParent.clone(trackedChildren);\n        if (trackedParent) {\n          var filterUnterminatedRange = node => (\n            !keysWithoutRangeBehavior.hasOwnProperty(node.getShallowHash())\n          );\n          var mutatedParent = intersectRelayQuery(\n            trackedParent,\n            fatParent,\n            filterUnterminatedRange\n          );\n          if (mutatedParent) {\n            mutatedFields.push(mutatedParent);\n          }\n        }\n      }\n    }\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a fragment used to fetch the given optimistic response.\n   */\n  buildFragmentForOptimisticUpdate(\n    {response, fatQuery}: OptimisticUpdateFragmentBuilderConfig\n  ): ?RelayQuery.Node {\n    // Silences RelayQueryNode being incompatible with sub-class RelayQueryField\n    // A detailed error description is available in #7635477\n    var mutatedFields = (inferRelayFieldsFromData(response): $FlowIssue);\n    return buildMutationFragment(fatQuery, mutatedFields);\n  },\n\n  /**\n   * Creates a RelayQuery.Mutation used to fetch the given optimistic response.\n   */\n  buildQueryForOptimisticUpdate(\n    {\n      fatQuery,\n      mutation,\n      response,\n      tracker,\n    }: OptimisticUpdateQueryBuilderConfig\n  ): RelayQuery.Mutation {\n    var children = [\n      nullthrows(RelayMutationQuery.buildFragmentForOptimisticUpdate({\n        response,\n        fatQuery,\n        tracker,\n      })),\n    ];\n    return RelayQuery.Mutation.build(\n      'OptimisticQuery',\n      fatQuery.getType(),\n      mutation.calls[0].name,\n      null,\n      children,\n      mutation.metadata\n    );\n  },\n\n  /**\n   * Creates a RelayQuery.Mutation for the given config. See type\n   * `MutationConfig` and the `buildFragmentForEdgeInsertion`,\n   * `buildFragmentForEdgeDeletion` and `buildFragmentForFields` methods above\n   * for possible configs.\n   */\n  buildQuery(\n    {\n      configs,\n      fatQuery,\n      input,\n      mutationName,\n      mutation,\n      tracker,\n    }: {\n      configs: Array<MutationConfig>;\n      fatQuery: RelayQuery.Fragment;\n      input: Variables,\n      mutationName: string;\n      mutation: ConcreteMutation;\n      tracker: RelayQueryTracker;\n    }\n  ): RelayQuery.Mutation {\n    var children: Array<?RelayQuery.Node> = [\n      RelayQuery.Field.build({\n        fieldName: CLIENT_MUTATION_ID,\n        type: 'String',\n        metadata: {isRequisite:true},\n      }),\n    ];\n\n    configs.forEach(config => {\n      switch (config.type) {\n        case RelayMutationType.REQUIRED_CHILDREN:\n          children = children.concat(config.children.map(child =>\n             RelayQuery.Fragment.create(\n              child,\n              RelayMetaRoute.get('$buildQuery'),\n              {}\n            )\n          ));\n          break;\n\n        case RelayMutationType.RANGE_ADD:\n          children.push(RelayMutationQuery.buildFragmentForEdgeInsertion({\n            connectionName: config.connectionName,\n            edgeName: config.edgeName,\n            fatQuery,\n            parentID: config.parentID,\n            parentName: config.parentName,\n            rangeBehaviors: sanitizeRangeBehaviors(config.rangeBehaviors),\n            tracker,\n          }));\n          break;\n\n        case RelayMutationType.RANGE_DELETE:\n        case RelayMutationType.NODE_DELETE:\n          children.push(RelayMutationQuery.buildFragmentForEdgeDeletion({\n            connectionName: config.connectionName,\n            fatQuery,\n            parentID: config.parentID,\n            parentName: config.parentName,\n            tracker,\n          }));\n          children.push(\n            Array.isArray(config.deletedIDFieldName) ?\n              buildDeletedConnectionNodeIDField(config.deletedIDFieldName) :\n              RelayQuery.Field.build({\n                fieldName: config.deletedIDFieldName,\n                type: 'String',\n              })\n          );\n          break;\n\n        case RelayMutationType.FIELDS_CHANGE:\n          children.push(RelayMutationQuery.buildFragmentForFields({\n            fatQuery,\n            fieldIDs: config.fieldIDs,\n            tracker,\n          }));\n          break;\n\n        default:\n          invariant(\n            false,\n            'RelayMutationQuery: Unrecognized config key `%s` for `%s`.',\n            config.type,\n            mutationName\n          );\n      }\n    });\n\n    return RelayQuery.Mutation.build(\n      mutationName,\n      fatQuery.getType(),\n      mutation.calls[0].name,\n      input,\n      (children.filter(child => child != null): any),\n      mutation.metadata\n    );\n  },\n};\n\nfunction getFieldFromFatQuery(\n  fatQuery: RelayQuery.Node,\n  fieldName: string\n): RelayQuery.Field {\n  var field = fatQuery.getFieldByStorageKey(fieldName);\n  invariant(\n    field,\n    'RelayMutationQuery: Invalid field name on fat query, `%s`.',\n    fieldName\n  );\n  return field;\n}\n\nfunction buildMutationFragment(\n  fatQuery: RelayQuery.Fragment,\n  fields: Array<RelayQuery.Node>\n): ?RelayQuery.Fragment {\n  var fragment = RelayQuery.Fragment.build(\n    'MutationQuery',\n    fatQuery.getType(),\n    fields\n  );\n  if (fragment) {\n    invariant(\n      fragment instanceof RelayQuery.Fragment,\n      'RelayMutationQuery: Expected a fragment.'\n    );\n    return fragment;\n  }\n  return null;\n}\n\nfunction buildDeletedConnectionNodeIDField(\n  fieldNames: Array<string>\n): RelayQuery.Field {\n  let field = RelayQuery.Field.build({\n    fieldName: ID,\n    type: 'String',\n  });\n  for (let ii = fieldNames.length - 1; ii >= 0; ii--) {\n    field = RelayQuery.Field.build({\n      fieldName: fieldNames[ii],\n      type: ANY_TYPE,\n      children: [field],\n      metadata: {\n        canHaveSubselections: true,\n      },\n    });\n  }\n  return field;\n}\n\nfunction buildEdgeField(\n  parentID: DataID,\n  edgeName: string,\n  edgeFields: Array<RelayQuery.Node>\n): RelayQuery.Field {\n  var fields = [\n    RelayQuery.Field.build({\n      fieldName: 'cursor',\n      type: 'String',\n    }),\n    RelayQuery.Field.build({\n      fieldName: TYPENAME,\n      type: 'String',\n    }),\n  ];\n  if (RelayConnectionInterface.EDGES_HAVE_SOURCE_FIELD &&\n      !RelayRecord.isClientID(parentID)) {\n    fields.push(\n      RelayQuery.Field.build({\n        children: [\n          RelayQuery.Field.build({\n            fieldName: ID,\n            type: 'String',\n          }),\n          RelayQuery.Field.build({\n            fieldName: TYPENAME,\n            type: 'String',\n          }),\n        ],\n        fieldName: 'source',\n        metadata: {canHaveSubselections: true},\n        type: ANY_TYPE,\n      })\n    );\n  }\n  fields.push(...edgeFields);\n  var edgeField = flattenRelayQuery(RelayQuery.Field.build({\n    children: fields,\n    fieldName: edgeName,\n    metadata: {canHaveSubselections: true},\n    type: ANY_TYPE,\n  }));\n  invariant(\n    edgeField instanceof RelayQuery.Field,\n    'RelayMutationQuery: Expected a field.'\n  );\n  return edgeField;\n}\n\nfunction sanitizeRangeBehaviors(\n  rangeBehaviors: RangeBehaviors\n): RangeBehaviors {\n  // Prior to 0.4.1 you would have to specify the args in your range behaviors\n  // in the same order they appeared in your query. From 0.4.1 onward, args in a\n  // range behavior key must be in alphabetical order.\n  let unsortedKeys;\n  forEachObject(rangeBehaviors, (value, key) => {\n    if (key !== '') {\n      const keyParts = key\n        // Remove the last parenthesis\n        .slice(0, -1)\n        // Slice on unescaped parentheses followed immediately by a `.`\n        .split(/\\)\\./);\n      const sortedKey = keyParts\n        .sort()\n        .join(').') +\n        (keyParts.length ? ')' : '');\n      if (sortedKey !== key) {\n        unsortedKeys = unsortedKeys || [];\n        unsortedKeys.push(key);\n      }\n    }\n  });\n  if (unsortedKeys) {\n    invariant(\n      false,\n      'RelayMutation: To define a range behavior key without sorting ' +\n      'the arguments alphabetically is disallowed as of Relay 0.5.1. Please ' +\n      'sort the argument names of the range behavior key%s `%s`%s.',\n      unsortedKeys.length === 1 ? '' : 's',\n      unsortedKeys.length === 1 ?\n        unsortedKeys[0] :\n        unsortedKeys.length === 2 ?\n          `${unsortedKeys[0]}\\` and \\`${unsortedKeys[1]}` :\n          unsortedKeys.slice(0, -1).join('`, `'),\n      unsortedKeys.length > 2 ? `, and \\`${unsortedKeys.slice(-1)}\\`` : ''\n    );\n  }\n  return rangeBehaviors;\n}\n\n/**\n * Finds all direct and indirect child fields of `node` with the given\n * field name.\n */\nfunction findDescendantFields(\n  rootNode: RelayQuery.Node,\n  fieldName: string\n): Array<RelayQuery.Field> {\n  var fields = [];\n  function traverse(node) {\n    if (node instanceof RelayQuery.Field) {\n      if (node.getSchemaName() === fieldName) {\n        fields.push(node);\n        return;\n      }\n    }\n    if (\n      node === rootNode ||\n      node instanceof RelayQuery.Fragment\n    ) {\n      // Search fragments and the root node for matching fields, but skip\n      // descendant non-matching fields.\n      node.getChildren().forEach(child => traverse(child));\n    }\n  }\n  traverse(rootNode);\n  return fields;\n}\n\nmodule.exports = RelayMutationQuery;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/RelayMutation.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayMutation","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutation\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ConcreteFragment} from 'ConcreteQuery';\nimport type {RelayConcreteNode} from 'RelayQL';\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayStore = require('RelayStore');\nimport type {\n  RelayMutationConfig,\n  Variables,\n} from 'RelayTypes';\n\nconst buildRQL = require('buildRQL');\nimport type {RelayQLFragmentBuilder} from 'buildRQL';\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nexport type FileMap = {[key: string]: File};\nexport type RelayMutationFragments<Tk> = {\n  [key: Tk]: RelayQLFragmentBuilder;\n};\n\n/**\n * @public\n *\n * RelayMutation is the base class for modeling mutations of data.\n */\nclass RelayMutation<Tp: Object> {\n  static name: $FlowIssue;\n  /* $FlowIssue(>=0.20.0) #9410317 */\n  static fragments: RelayMutationFragments<$Keys<Tp>>;\n  static initialVariables: Variables;\n  static prepareVariables: ?(\n    prevVariables: Variables,\n    route: RelayMetaRoute\n  ) => Variables;\n\n  props: Tp;\n  _didShowFakeDataWarning: boolean;\n\n  constructor(props: Tp) {\n    this._didShowFakeDataWarning = false;\n    this._resolveProps(props);\n  }\n\n  /**\n   * Each mutation corresponds to a field on the server which is used by clients\n   * to communicate the type of mutation to be executed.\n   */\n  getMutation(): RelayConcreteNode {\n    invariant(\n      false,\n      '%s: Expected abstract method `getMutation` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * \"Fat queries\" represent a predetermined set of fields that may change as a\n   * result of a mutation, and which should therefore be queried in order to get\n   * a consistent view of the data after performing a mutation. In practice, we\n   * query for a subset of those fields because we intersect the fat query with\n   * the tracked query we have for a given node (ie. the pieces of data we've\n   * previously queried for and have therefore written to the store).\n   *\n   * Fat queries can be written like normal GraphQL queries with one main\n   * exception: fat queries use childless non-scalar fields to indicate that\n   * anything under that field may change. For example, the fat query for\n   * feedback_like contains the field `like_sentence` with no child fields.\n   * This means that any field below `like_sentence` may change as a result of\n   * feedback_like.\n   *\n   * When adding a fat query, consider *all* of the data that might change as a\n   * result of the mutation - not just data that we currently use in Relay. We\n   * don't need to worry about overfetching here (this query is never executed\n   * on its own; the infrastructure always intersects it with what is actually\n   * needed), and if we omit fields here we might get odd consistency behavior\n   * in the future when we add new views or modify existing ones.\n   */\n  getFatQuery(): RelayConcreteNode {\n    invariant(\n      false,\n      '%s: Expected abstract method `getFatQuery` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * These configurations are used to generate the query for the mutation to be\n   * sent to the server and to correctly write the server's response into the\n   * client store.\n   *\n   * Possible configuration types:\n   *\n   * -  FIELDS_CHANGE provides configuration for mutation fields.\n   *    {\n   *      type: RelayMutationType.FIELDS_CHANGE;\n   *      fieldIDs: {[fieldName: string]: DataID | Array<DataID>};\n   *    }\n   *    where fieldIDs map `fieldName`s from the fatQuery to a DataID or\n   *    array of DataIDs to be updated in the store.\n   *\n   * -  RANGE_ADD provides configuration for adding a new edge to a range.\n   *    {\n   *      type: RelayMutationType.RANGE_ADD;\n   *      parentName: string;\n   *      parentID: string;\n   *      connectionName: string;\n   *      edgeName: string;\n   *      rangeBehaviors:\n   *        {[call: string]: GraphQLMutatorConstants.RANGE_OPERATIONS};\n   *    }\n   *    where `parentName` is the field in the fatQuery that contains the range,\n   *    `parentID` is the DataID of `parentName` in the store, `connectionName`\n   *    is the name of the range, `edgeName` is the name of the key in server\n   *    response that contains the newly created edge, `rangeBehaviors` maps\n   *    stringified representation of calls on the connection to\n   *    GraphQLMutatorConstants.RANGE_OPERATIONS.\n   *\n   * -  NODE_DELETE provides configuration for deleting a node and the\n   *    corresponding edge from a range.\n   *    {\n   *      type: RelayMutationType.NODE_DELETE;\n   *      parentName: string;\n   *      parentID: string;\n   *      connectionName: string;\n   *      deletedIDFieldName: string;\n   *    }\n   *    where `parentName`, `parentID` and `connectionName` refer to the same\n   *    things as in RANGE_ADD, `deletedIDFieldName` is the name of the key in\n   *    the server response that contains the DataID of the deleted node.\n   *\n   * -  RANGE_DELETE provides configuration for deleting an edge from a range\n   *    but doesn't delete the node.\n   *    {\n   *      type: RelayMutationType.RANGE_DELETE;\n   *      parentName: string;\n   *      parentID: string;\n   *      connectionName: string;\n   *      deletedIDFieldName: string | Array<string>;\n   *      pathToConnection: Array<string>;\n   *    }\n   *    where `parentName`, `parentID`, `connectionName` and\n   *    `deletedIDFieldName` refer to the same things as in NODE_DELETE.\n   *    `deletedIDFieldName` can also be a path from the response root to the\n   *    deleted node. `pathToConnection` is a path from `parentName` to\n   *    `connectionName`.\n   *\n   * -  REQUIRED_CHILDREN is used to append additional children (fragments or\n   *    fields) to the mutation query. Any data fetched for these children is\n   *    not written to the client store, but you can add code to process it\n   *    in the `onSuccess` callback passed to the `RelayContext` `applyUpdate`\n   *    method. You may need to use this, for example, to fetch fields on a new\n   *    object created by the mutation (and which Relay would normally not\n   *    attempt to fetch because it has not previously fetched anything for that\n   *    object).\n   *    {\n   *      type: RelayMutationType.REQUIRED_CHILDREN;\n   *      children: Array<RelayQuery.Node>;\n   *    }\n   */\n  getConfigs(): Array<RelayMutationConfig> {\n    invariant(\n      false,\n      '%s: Expected abstract method `getConfigs` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * These variables form the \"input\" to the mutation query sent to the server.\n   */\n  getVariables(): {[name: string]: mixed} {\n    invariant(\n      false,\n      '%s: Expected abstract method `getVariables` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * These will be sent along with the mutation query to the server.\n   */\n  getFiles(): ?FileMap {\n    return null;\n  }\n\n  /**\n   * When a request is sent to the server, mutations can optionally construct an\n   * optimistic response that has the same shape as the server response payload.\n   * This optimistic response is used to pre-emptively update the client cache\n   * to simulate an instantaneous response.\n   *\n   * The optimistic response may be a subset or superset of the actual response\n   * payload. It can be a subset if certain fields are impossible to create on\n   * the client (and if views are expected to handle the data inconsistency). It\n   * can be a superset of the actual response payload if certain fields that are\n   * affected have not been queried by the client, yet.\n   */\n  getOptimisticResponse(): ?{[key: string]: mixed} {\n    return null;\n  }\n\n  /**\n   * Optional. Similar to `getConfig`, this is used to create the query\n   * corresponding to the `optimisticResponse`. If not provided, the query\n   * will be inferred from the optimistic response. Most subclasses shouldn't\n   * need to extend this method.\n   */\n  getOptimisticConfigs(): ?Array<{[key: string]: mixed}> {\n    return null;\n  }\n\n  /**\n   * An optional collision key allows a mutation to identify itself with other\n   * mutations that affect the same fields. Mutations with the same collision\n   * are sent to the server serially and in-order to avoid unpredictable and\n   * potentially incorrect behavior.\n   */\n  getCollisionKey(): ?string {\n    return null;\n  }\n\n  _resolveProps(props: Tp): void {\n    const fragments = this.constructor.fragments;\n    const initialVariables = this.constructor.initialVariables || {};\n\n    const resolvedProps = {...props};\n    forEachObject(fragments, (fragmentBuilder, fragmentName) => {\n      var propValue = props[fragmentName];\n      warning(\n        propValue !== undefined,\n        'RelayMutation: Expected data for fragment `%s` to be supplied to ' +\n        '`%s` as a prop. Pass an explicit `null` if this is intentional.',\n        fragmentName,\n        this.constructor.name\n      );\n\n      if (propValue == null) {\n        return;\n      }\n      if (typeof propValue !== 'object') {\n        warning(\n          false,\n          'RelayMutation: Expected data for fragment `%s` supplied to `%s` ' +\n          'to be an object.',\n          fragmentName,\n          this.constructor.name\n        );\n        return;\n      }\n\n      const fragment = RelayQuery.Fragment.create(\n        buildMutationFragment(\n          this.constructor.name,\n          fragmentName,\n          fragmentBuilder,\n          initialVariables\n        ),\n        RelayMetaRoute.get(`$RelayMutation_${this.constructor.name}`),\n        initialVariables\n      );\n\n      if (fragment.isPlural()) {\n        invariant(\n          Array.isArray(propValue),\n          'RelayMutation: Invalid prop `%s` supplied to `%s`, expected an ' +\n          'array of records because the corresponding fragment is plural.',\n          fragmentName,\n          this.constructor.name\n        );\n        var dataIDs = propValue.map((item, ii) => {\n          invariant(\n            typeof item === 'object' && item != null,\n            'RelayMutation: Invalid prop `%s` supplied to `%s`, ' +\n            'expected element at index %s to have query data.',\n            fragmentName,\n            this.constructor.name,\n            ii\n          );\n          const dataID = RelayFragmentPointer.getDataID(item, fragment);\n          invariant(\n            dataID,\n            'RelayMutation: Invalid prop `%s` supplied to `%s`, ' +\n            'expected element at index %s to have query data.',\n            fragmentName,\n            this.constructor.name,\n            ii\n          );\n          return dataID;\n        });\n\n        resolvedProps[fragmentName] = RelayStore.readAll(fragment, dataIDs);\n      } else {\n        invariant(\n          !Array.isArray(propValue),\n          'RelayMutation: Invalid prop `%s` supplied to `%s`, expected a ' +\n          'single record because the corresponding fragment is not plural.',\n          fragmentName,\n          this.constructor.name\n        );\n        var dataID = RelayFragmentPointer.getDataID(propValue, fragment);\n        if (dataID) {\n          resolvedProps[fragmentName] = RelayStore.read(fragment, dataID);\n        } else {\n          if (__DEV__) {\n            if (!this._didShowFakeDataWarning) {\n              this._didShowFakeDataWarning = true;\n              warning(\n                false,\n                'RelayMutation: Expected prop `%s` supplied to `%s` to ' +\n                'be data fetched by Relay. This is likely an error unless ' +\n                'you are purposely passing in mock data that conforms to ' +\n                'the shape of this mutation\\'s fragment.',\n                fragmentName,\n                this.constructor.name\n              );\n            }\n          }\n        }\n      }\n    });\n    this.props = resolvedProps;\n  }\n\n  static getFragment(\n    fragmentName: $Keys<Tp>,\n    variableMapping?: Variables\n  ): RelayFragmentReference {\n    // TODO: Unify fragment API for containers and mutations, #7860172.\n    var fragments = this.fragments;\n    var fragmentBuilder = fragments[fragmentName];\n    if (!fragmentBuilder) {\n      invariant(\n        false,\n        '%s.getFragment(): `%s` is not a valid fragment name. Available ' +\n        'fragments names: %s',\n        this.name,\n        fragmentName,\n        Object.keys(fragments).map(name => '`' + name + '`').join(', ')\n      );\n    }\n\n    const initialVariables = this.initialVariables || {};\n    var prepareVariables = this.prepareVariables;\n\n    return RelayFragmentReference.createForContainer(\n      () => buildMutationFragment(\n        this.name,\n        fragmentName,\n        fragmentBuilder,\n        initialVariables\n      ),\n      initialVariables,\n      variableMapping,\n      prepareVariables\n    );\n  }\n}\n\n/**\n * Wrapper around `buildRQL.Fragment` with contextual error messages.\n */\nfunction buildMutationFragment(\n  mutationName: string,\n  fragmentName: string,\n  fragmentBuilder: RelayQLFragmentBuilder,\n  variables: Variables\n): ConcreteFragment {\n  var fragment = buildRQL.Fragment(\n    fragmentBuilder,\n    variables\n  );\n  invariant(\n    fragment,\n    'Relay.QL defined on mutation `%s` named `%s` is not a valid fragment. ' +\n    'A typical fragment is defined using: Relay.QL`fragment on Type {...}`',\n    mutationName,\n    fragmentName\n  );\n  return fragment;\n}\n\nmodule.exports = RelayMutation;\n","dependencies":["ConcreteQuery","RelayQL","RelayTypes","buildRQL","RelayFragmentPointer","RelayFragmentReference","RelayMetaRoute","RelayQuery","RelayStore","forEachObject","invariant","warning"],"id":"RelayMutation","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutation\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ConcreteFragment} from 'ConcreteQuery';\nimport type {RelayConcreteNode} from 'RelayQL';\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\nconst RelayStore = require('RelayStore');\nimport type {\n  RelayMutationConfig,\n  Variables,\n} from 'RelayTypes';\n\nconst buildRQL = require('buildRQL');\nimport type {RelayQLFragmentBuilder} from 'buildRQL';\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nexport type FileMap = {[key: string]: File};\nexport type RelayMutationFragments<Tk> = {\n  [key: Tk]: RelayQLFragmentBuilder;\n};\n\n/**\n * @public\n *\n * RelayMutation is the base class for modeling mutations of data.\n */\nclass RelayMutation<Tp: Object> {\n  static name: $FlowIssue;\n  /* $FlowIssue(>=0.20.0) #9410317 */\n  static fragments: RelayMutationFragments<$Keys<Tp>>;\n  static initialVariables: Variables;\n  static prepareVariables: ?(\n    prevVariables: Variables,\n    route: RelayMetaRoute\n  ) => Variables;\n\n  props: Tp;\n  _didShowFakeDataWarning: boolean;\n\n  constructor(props: Tp) {\n    this._didShowFakeDataWarning = false;\n    this._resolveProps(props);\n  }\n\n  /**\n   * Each mutation corresponds to a field on the server which is used by clients\n   * to communicate the type of mutation to be executed.\n   */\n  getMutation(): RelayConcreteNode {\n    invariant(\n      false,\n      '%s: Expected abstract method `getMutation` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * \"Fat queries\" represent a predetermined set of fields that may change as a\n   * result of a mutation, and which should therefore be queried in order to get\n   * a consistent view of the data after performing a mutation. In practice, we\n   * query for a subset of those fields because we intersect the fat query with\n   * the tracked query we have for a given node (ie. the pieces of data we've\n   * previously queried for and have therefore written to the store).\n   *\n   * Fat queries can be written like normal GraphQL queries with one main\n   * exception: fat queries use childless non-scalar fields to indicate that\n   * anything under that field may change. For example, the fat query for\n   * feedback_like contains the field `like_sentence` with no child fields.\n   * This means that any field below `like_sentence` may change as a result of\n   * feedback_like.\n   *\n   * When adding a fat query, consider *all* of the data that might change as a\n   * result of the mutation - not just data that we currently use in Relay. We\n   * don't need to worry about overfetching here (this query is never executed\n   * on its own; the infrastructure always intersects it with what is actually\n   * needed), and if we omit fields here we might get odd consistency behavior\n   * in the future when we add new views or modify existing ones.\n   */\n  getFatQuery(): RelayConcreteNode {\n    invariant(\n      false,\n      '%s: Expected abstract method `getFatQuery` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * These configurations are used to generate the query for the mutation to be\n   * sent to the server and to correctly write the server's response into the\n   * client store.\n   *\n   * Possible configuration types:\n   *\n   * -  FIELDS_CHANGE provides configuration for mutation fields.\n   *    {\n   *      type: RelayMutationType.FIELDS_CHANGE;\n   *      fieldIDs: {[fieldName: string]: DataID | Array<DataID>};\n   *    }\n   *    where fieldIDs map `fieldName`s from the fatQuery to a DataID or\n   *    array of DataIDs to be updated in the store.\n   *\n   * -  RANGE_ADD provides configuration for adding a new edge to a range.\n   *    {\n   *      type: RelayMutationType.RANGE_ADD;\n   *      parentName: string;\n   *      parentID: string;\n   *      connectionName: string;\n   *      edgeName: string;\n   *      rangeBehaviors:\n   *        {[call: string]: GraphQLMutatorConstants.RANGE_OPERATIONS};\n   *    }\n   *    where `parentName` is the field in the fatQuery that contains the range,\n   *    `parentID` is the DataID of `parentName` in the store, `connectionName`\n   *    is the name of the range, `edgeName` is the name of the key in server\n   *    response that contains the newly created edge, `rangeBehaviors` maps\n   *    stringified representation of calls on the connection to\n   *    GraphQLMutatorConstants.RANGE_OPERATIONS.\n   *\n   * -  NODE_DELETE provides configuration for deleting a node and the\n   *    corresponding edge from a range.\n   *    {\n   *      type: RelayMutationType.NODE_DELETE;\n   *      parentName: string;\n   *      parentID: string;\n   *      connectionName: string;\n   *      deletedIDFieldName: string;\n   *    }\n   *    where `parentName`, `parentID` and `connectionName` refer to the same\n   *    things as in RANGE_ADD, `deletedIDFieldName` is the name of the key in\n   *    the server response that contains the DataID of the deleted node.\n   *\n   * -  RANGE_DELETE provides configuration for deleting an edge from a range\n   *    but doesn't delete the node.\n   *    {\n   *      type: RelayMutationType.RANGE_DELETE;\n   *      parentName: string;\n   *      parentID: string;\n   *      connectionName: string;\n   *      deletedIDFieldName: string | Array<string>;\n   *      pathToConnection: Array<string>;\n   *    }\n   *    where `parentName`, `parentID`, `connectionName` and\n   *    `deletedIDFieldName` refer to the same things as in NODE_DELETE.\n   *    `deletedIDFieldName` can also be a path from the response root to the\n   *    deleted node. `pathToConnection` is a path from `parentName` to\n   *    `connectionName`.\n   *\n   * -  REQUIRED_CHILDREN is used to append additional children (fragments or\n   *    fields) to the mutation query. Any data fetched for these children is\n   *    not written to the client store, but you can add code to process it\n   *    in the `onSuccess` callback passed to the `RelayContext` `applyUpdate`\n   *    method. You may need to use this, for example, to fetch fields on a new\n   *    object created by the mutation (and which Relay would normally not\n   *    attempt to fetch because it has not previously fetched anything for that\n   *    object).\n   *    {\n   *      type: RelayMutationType.REQUIRED_CHILDREN;\n   *      children: Array<RelayQuery.Node>;\n   *    }\n   */\n  getConfigs(): Array<RelayMutationConfig> {\n    invariant(\n      false,\n      '%s: Expected abstract method `getConfigs` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * These variables form the \"input\" to the mutation query sent to the server.\n   */\n  getVariables(): {[name: string]: mixed} {\n    invariant(\n      false,\n      '%s: Expected abstract method `getVariables` to be implemented.',\n      this.constructor.name\n    );\n  }\n\n  /**\n   * These will be sent along with the mutation query to the server.\n   */\n  getFiles(): ?FileMap {\n    return null;\n  }\n\n  /**\n   * When a request is sent to the server, mutations can optionally construct an\n   * optimistic response that has the same shape as the server response payload.\n   * This optimistic response is used to pre-emptively update the client cache\n   * to simulate an instantaneous response.\n   *\n   * The optimistic response may be a subset or superset of the actual response\n   * payload. It can be a subset if certain fields are impossible to create on\n   * the client (and if views are expected to handle the data inconsistency). It\n   * can be a superset of the actual response payload if certain fields that are\n   * affected have not been queried by the client, yet.\n   */\n  getOptimisticResponse(): ?{[key: string]: mixed} {\n    return null;\n  }\n\n  /**\n   * Optional. Similar to `getConfig`, this is used to create the query\n   * corresponding to the `optimisticResponse`. If not provided, the query\n   * will be inferred from the optimistic response. Most subclasses shouldn't\n   * need to extend this method.\n   */\n  getOptimisticConfigs(): ?Array<{[key: string]: mixed}> {\n    return null;\n  }\n\n  /**\n   * An optional collision key allows a mutation to identify itself with other\n   * mutations that affect the same fields. Mutations with the same collision\n   * are sent to the server serially and in-order to avoid unpredictable and\n   * potentially incorrect behavior.\n   */\n  getCollisionKey(): ?string {\n    return null;\n  }\n\n  _resolveProps(props: Tp): void {\n    const fragments = this.constructor.fragments;\n    const initialVariables = this.constructor.initialVariables || {};\n\n    const resolvedProps = {...props};\n    forEachObject(fragments, (fragmentBuilder, fragmentName) => {\n      var propValue = props[fragmentName];\n      warning(\n        propValue !== undefined,\n        'RelayMutation: Expected data for fragment `%s` to be supplied to ' +\n        '`%s` as a prop. Pass an explicit `null` if this is intentional.',\n        fragmentName,\n        this.constructor.name\n      );\n\n      if (propValue == null) {\n        return;\n      }\n      if (typeof propValue !== 'object') {\n        warning(\n          false,\n          'RelayMutation: Expected data for fragment `%s` supplied to `%s` ' +\n          'to be an object.',\n          fragmentName,\n          this.constructor.name\n        );\n        return;\n      }\n\n      const fragment = RelayQuery.Fragment.create(\n        buildMutationFragment(\n          this.constructor.name,\n          fragmentName,\n          fragmentBuilder,\n          initialVariables\n        ),\n        RelayMetaRoute.get(`$RelayMutation_${this.constructor.name}`),\n        initialVariables\n      );\n\n      if (fragment.isPlural()) {\n        invariant(\n          Array.isArray(propValue),\n          'RelayMutation: Invalid prop `%s` supplied to `%s`, expected an ' +\n          'array of records because the corresponding fragment is plural.',\n          fragmentName,\n          this.constructor.name\n        );\n        var dataIDs = propValue.map((item, ii) => {\n          invariant(\n            typeof item === 'object' && item != null,\n            'RelayMutation: Invalid prop `%s` supplied to `%s`, ' +\n            'expected element at index %s to have query data.',\n            fragmentName,\n            this.constructor.name,\n            ii\n          );\n          const dataID = RelayFragmentPointer.getDataID(item, fragment);\n          invariant(\n            dataID,\n            'RelayMutation: Invalid prop `%s` supplied to `%s`, ' +\n            'expected element at index %s to have query data.',\n            fragmentName,\n            this.constructor.name,\n            ii\n          );\n          return dataID;\n        });\n\n        resolvedProps[fragmentName] = RelayStore.readAll(fragment, dataIDs);\n      } else {\n        invariant(\n          !Array.isArray(propValue),\n          'RelayMutation: Invalid prop `%s` supplied to `%s`, expected a ' +\n          'single record because the corresponding fragment is not plural.',\n          fragmentName,\n          this.constructor.name\n        );\n        var dataID = RelayFragmentPointer.getDataID(propValue, fragment);\n        if (dataID) {\n          resolvedProps[fragmentName] = RelayStore.read(fragment, dataID);\n        } else {\n          if (__DEV__) {\n            if (!this._didShowFakeDataWarning) {\n              this._didShowFakeDataWarning = true;\n              warning(\n                false,\n                'RelayMutation: Expected prop `%s` supplied to `%s` to ' +\n                'be data fetched by Relay. This is likely an error unless ' +\n                'you are purposely passing in mock data that conforms to ' +\n                'the shape of this mutation\\'s fragment.',\n                fragmentName,\n                this.constructor.name\n              );\n            }\n          }\n        }\n      }\n    });\n    this.props = resolvedProps;\n  }\n\n  static getFragment(\n    fragmentName: $Keys<Tp>,\n    variableMapping?: Variables\n  ): RelayFragmentReference {\n    // TODO: Unify fragment API for containers and mutations, #7860172.\n    var fragments = this.fragments;\n    var fragmentBuilder = fragments[fragmentName];\n    if (!fragmentBuilder) {\n      invariant(\n        false,\n        '%s.getFragment(): `%s` is not a valid fragment name. Available ' +\n        'fragments names: %s',\n        this.name,\n        fragmentName,\n        Object.keys(fragments).map(name => '`' + name + '`').join(', ')\n      );\n    }\n\n    const initialVariables = this.initialVariables || {};\n    var prepareVariables = this.prepareVariables;\n\n    return RelayFragmentReference.createForContainer(\n      () => buildMutationFragment(\n        this.name,\n        fragmentName,\n        fragmentBuilder,\n        initialVariables\n      ),\n      initialVariables,\n      variableMapping,\n      prepareVariables\n    );\n  }\n}\n\n/**\n * Wrapper around `buildRQL.Fragment` with contextual error messages.\n */\nfunction buildMutationFragment(\n  mutationName: string,\n  fragmentName: string,\n  fragmentBuilder: RelayQLFragmentBuilder,\n  variables: Variables\n): ConcreteFragment {\n  var fragment = buildRQL.Fragment(\n    fragmentBuilder,\n    variables\n  );\n  invariant(\n    fragment,\n    'Relay.QL defined on mutation `%s` named `%s` is not a valid fragment. ' +\n    'A typical fragment is defined using: Relay.QL`fragment on Type {...}`',\n    mutationName,\n    fragmentName\n  );\n  return fragment;\n}\n\nmodule.exports = RelayMutation;\n"}}},"/Users/cpojer/Projects/relay/src/mutation/rangeOperationToMetadataKey.js":{"metadata":{"mtime":1455679338000},"data":{"name":"rangeOperationToMetadataKey","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule rangeOperationToMetadataKey\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst mapObject = require('mapObject');\n\nconst RANGE_OPERATION_METADATA_PREFIX = '__rangeOperation';\nconst RANGE_OPERATION_METADATA_SUFFIX = '__';\n\n/**\n * A map from developer-friendly operation names (\"append\", \"prepend\", \"remove\")\n * to internal book-keeping keys used to store metadata on records\n * (\"__rangeOperationAppend__\" etc).\n */\nconst rangeOperationToMetadataKey = mapObject(\n  GraphQLMutatorConstants.RANGE_OPERATIONS,\n  (value, key, object) => {\n    const capitalizedKey = key[0].toUpperCase() + key.slice(1);\n    return (\n      RANGE_OPERATION_METADATA_PREFIX +\n      capitalizedKey +\n      RANGE_OPERATION_METADATA_SUFFIX\n    );\n  }\n);\n\nmodule.exports = Object.freeze(rangeOperationToMetadataKey);\n","dependencies":["GraphQLMutatorConstants","mapObject","rangeOperationToMetadataKey"],"id":"rangeOperationToMetadataKey","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule rangeOperationToMetadataKey\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst mapObject = require('mapObject');\n\nconst RANGE_OPERATION_METADATA_PREFIX = '__rangeOperation';\nconst RANGE_OPERATION_METADATA_SUFFIX = '__';\n\n/**\n * A map from developer-friendly operation names (\"append\", \"prepend\", \"remove\")\n * to internal book-keeping keys used to store metadata on records\n * (\"__rangeOperationAppend__\" etc).\n */\nconst rangeOperationToMetadataKey = mapObject(\n  GraphQLMutatorConstants.RANGE_OPERATIONS,\n  (value, key, object) => {\n    const capitalizedKey = key[0].toUpperCase() + key.slice(1);\n    return (\n      RANGE_OPERATION_METADATA_PREFIX +\n      capitalizedKey +\n      RANGE_OPERATION_METADATA_SUFFIX\n    );\n  }\n);\n\nmodule.exports = Object.freeze(rangeOperationToMetadataKey);\n"}}},"/Users/cpojer/Projects/relay/src/network/RelayQueryRequest.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayQueryRequest","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryRequest\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Deferred = require('Deferred');\nimport type {PrintedQuery} from 'RelayInternalTypes';\nimport type RelayQuery from 'RelayQuery';\nimport type {QueryResult, Variables} from 'RelayTypes';\n\nconst printRelayQuery = require('printRelayQuery');\n\n/**\n * @internal\n *\n * Instances of these are made available via `RelayNetworkLayer.sendQueries`.\n */\nclass RelayQueryRequest extends Deferred<QueryResult, Error> {\n  _printedQuery: ?PrintedQuery;\n  _query: RelayQuery.Root;\n\n  constructor(query: RelayQuery.Root) {\n    super();\n    this._printedQuery = null;\n    this._query = query;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string name used to refer to this request for printing debug output.\n   */\n  getDebugName(): string {\n    return this._query.getName();\n  }\n\n  /**\n   * @public\n   *\n   * Gets a unique identifier for this query. These identifiers are useful for\n   * assigning response payloads to their corresponding queries when sent in a\n   * single GraphQL request.\n   */\n  getID(): string {\n    return this._query.getID();\n  }\n\n  /**\n   * @public\n   *\n   * Gets the variables used by the query. These variables should be serialized\n   * and sent in the GraphQL request.\n   */\n  getVariables(): Variables {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._query);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.variables;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string representation of the GraphQL query.\n   */\n  getQueryString(): string {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._query);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.text;\n  }\n\n  /**\n   * @public\n   * @unstable\n   */\n  getQuery(): RelayQuery.Root {\n    return this._query;\n  }\n}\n\nmodule.exports = RelayQueryRequest;\n","dependencies":["RelayInternalTypes","RelayQuery","RelayTypes","Deferred","printRelayQuery","RelayQueryRequest"],"id":"RelayQueryRequest","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryRequest\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Deferred = require('Deferred');\nimport type {PrintedQuery} from 'RelayInternalTypes';\nimport type RelayQuery from 'RelayQuery';\nimport type {QueryResult, Variables} from 'RelayTypes';\n\nconst printRelayQuery = require('printRelayQuery');\n\n/**\n * @internal\n *\n * Instances of these are made available via `RelayNetworkLayer.sendQueries`.\n */\nclass RelayQueryRequest extends Deferred<QueryResult, Error> {\n  _printedQuery: ?PrintedQuery;\n  _query: RelayQuery.Root;\n\n  constructor(query: RelayQuery.Root) {\n    super();\n    this._printedQuery = null;\n    this._query = query;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string name used to refer to this request for printing debug output.\n   */\n  getDebugName(): string {\n    return this._query.getName();\n  }\n\n  /**\n   * @public\n   *\n   * Gets a unique identifier for this query. These identifiers are useful for\n   * assigning response payloads to their corresponding queries when sent in a\n   * single GraphQL request.\n   */\n  getID(): string {\n    return this._query.getID();\n  }\n\n  /**\n   * @public\n   *\n   * Gets the variables used by the query. These variables should be serialized\n   * and sent in the GraphQL request.\n   */\n  getVariables(): Variables {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._query);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.variables;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string representation of the GraphQL query.\n   */\n  getQueryString(): string {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._query);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.text;\n  }\n\n  /**\n   * @public\n   * @unstable\n   */\n  getQuery(): RelayQuery.Root {\n    return this._query;\n  }\n}\n\nmodule.exports = RelayQueryRequest;\n"}}},"/Users/cpojer/Projects/relay/src/network/RelayNetworkLayer.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayNetworkLayer","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayNetworkLayer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayMutationRequest from 'RelayMutationRequest';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQueryRequest from 'RelayQueryRequest';\n\nconst invariant = require('invariant');\n\ntype NetworkLayer = {\n  sendMutation: (mutationRequest: RelayMutationRequest) => ?Promise;\n  sendQueries: (queryRequests: Array<RelayQueryRequest>) => ?Promise;\n  supports: (...options: Array<string>) => boolean;\n};\n\nvar injectedNetworkLayer;\n\n/**\n * @internal\n *\n * `RelayNetworkLayer` provides a method to inject custom network behavior.\n */\nvar RelayNetworkLayer = {\n  injectNetworkLayer(networkLayer: ?NetworkLayer): void {\n    injectedNetworkLayer = networkLayer;\n  },\n\n  sendMutation(mutationRequest: RelayMutationRequest): void {\n    var networkLayer = getCurrentNetworkLayer();\n    var promise = networkLayer.sendMutation(mutationRequest);\n    if (promise) {\n      Promise.resolve(promise).done();\n    }\n  },\n\n  sendQueries(queryRequests: Array<RelayQueryRequest>): void {\n    var networkLayer = getCurrentNetworkLayer();\n    var promise = networkLayer.sendQueries(queryRequests);\n    if (promise) {\n      Promise.resolve(promise).done();\n    }\n  },\n\n  supports(...options: Array<string>): boolean {\n    var networkLayer = getCurrentNetworkLayer();\n    return networkLayer.supports(...options);\n  },\n};\n\nfunction getCurrentNetworkLayer(): $FlowIssue {\n  invariant(\n    injectedNetworkLayer,\n    'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network layer.'\n  );\n  return injectedNetworkLayer;\n}\n\nRelayProfiler.instrumentMethods(RelayNetworkLayer, {\n  sendMutation: 'RelayNetworkLayer.sendMutation',\n  sendQueries: 'RelayNetworkLayer.sendQueries',\n});\n\nmodule.exports = RelayNetworkLayer;\n","dependencies":["RelayMutationRequest","RelayQueryRequest","RelayProfiler","invariant","RelayNetworkLayer"],"id":"RelayNetworkLayer","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayNetworkLayer\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayMutationRequest from 'RelayMutationRequest';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQueryRequest from 'RelayQueryRequest';\n\nconst invariant = require('invariant');\n\ntype NetworkLayer = {\n  sendMutation: (mutationRequest: RelayMutationRequest) => ?Promise;\n  sendQueries: (queryRequests: Array<RelayQueryRequest>) => ?Promise;\n  supports: (...options: Array<string>) => boolean;\n};\n\nvar injectedNetworkLayer;\n\n/**\n * @internal\n *\n * `RelayNetworkLayer` provides a method to inject custom network behavior.\n */\nvar RelayNetworkLayer = {\n  injectNetworkLayer(networkLayer: ?NetworkLayer): void {\n    injectedNetworkLayer = networkLayer;\n  },\n\n  sendMutation(mutationRequest: RelayMutationRequest): void {\n    var networkLayer = getCurrentNetworkLayer();\n    var promise = networkLayer.sendMutation(mutationRequest);\n    if (promise) {\n      Promise.resolve(promise).done();\n    }\n  },\n\n  sendQueries(queryRequests: Array<RelayQueryRequest>): void {\n    var networkLayer = getCurrentNetworkLayer();\n    var promise = networkLayer.sendQueries(queryRequests);\n    if (promise) {\n      Promise.resolve(promise).done();\n    }\n  },\n\n  supports(...options: Array<string>): boolean {\n    var networkLayer = getCurrentNetworkLayer();\n    return networkLayer.supports(...options);\n  },\n};\n\nfunction getCurrentNetworkLayer(): $FlowIssue {\n  invariant(\n    injectedNetworkLayer,\n    'RelayNetworkLayer: Use `injectNetworkLayer` to configure a network layer.'\n  );\n  return injectedNetworkLayer;\n}\n\nRelayProfiler.instrumentMethods(RelayNetworkLayer, {\n  sendMutation: 'RelayNetworkLayer.sendMutation',\n  sendQueries: 'RelayNetworkLayer.sendQueries',\n});\n\nmodule.exports = RelayNetworkLayer;\n"}}},"/Users/cpojer/Projects/relay/src/network/RelayMutationRequest.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationRequest","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationRequest\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Deferred = require('Deferred');\nimport type {PrintedQuery} from 'RelayInternalTypes';\nimport type {FileMap} from 'RelayMutation';\nimport type RelayQuery from 'RelayQuery';\nimport type {MutationResult, Variables} from 'RelayTypes';\n\nconst printRelayQuery = require('printRelayQuery');\n\n/**\n * @internal\n *\n * Instances of these are made available via `RelayNetworkLayer.sendMutation`.\n */\nclass RelayMutationRequest extends Deferred<MutationResult, Error> {\n  _mutation: RelayQuery.Mutation;\n  _printedQuery: ?PrintedQuery;\n  _files: ?FileMap;\n\n  constructor(\n    mutation: RelayQuery.Mutation,\n    files: ?FileMap\n  ) {\n    super();\n    this._mutation = mutation;\n    this._printedQuery = null;\n    this._files = files;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string name used to refer to this request for printing debug output.\n   */\n  getDebugName(): string {\n    return this._mutation.getName();\n  }\n\n  /**\n   * @public\n   *\n   * Gets an optional map from name to File objects.\n   */\n  getFiles(): ?FileMap {\n    return this._files;\n  }\n\n  /**\n   * @public\n   *\n   * Gets the variables used by the mutation. These variables should be\n   * serialized and sent in the GraphQL request.\n   */\n  getVariables(): Variables {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._mutation);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.variables;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string representation of the GraphQL mutation.\n   */\n  getQueryString(): string {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._mutation);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.text;\n  }\n\n  /**\n   * @public\n   * @unstable\n   */\n  getMutation(): RelayQuery.Mutation {\n    return this._mutation;\n  }\n}\n\nmodule.exports = RelayMutationRequest;\n","dependencies":["RelayInternalTypes","RelayMutation","RelayQuery","RelayTypes","Deferred","printRelayQuery","RelayMutationRequest"],"id":"RelayMutationRequest","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationRequest\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Deferred = require('Deferred');\nimport type {PrintedQuery} from 'RelayInternalTypes';\nimport type {FileMap} from 'RelayMutation';\nimport type RelayQuery from 'RelayQuery';\nimport type {MutationResult, Variables} from 'RelayTypes';\n\nconst printRelayQuery = require('printRelayQuery');\n\n/**\n * @internal\n *\n * Instances of these are made available via `RelayNetworkLayer.sendMutation`.\n */\nclass RelayMutationRequest extends Deferred<MutationResult, Error> {\n  _mutation: RelayQuery.Mutation;\n  _printedQuery: ?PrintedQuery;\n  _files: ?FileMap;\n\n  constructor(\n    mutation: RelayQuery.Mutation,\n    files: ?FileMap\n  ) {\n    super();\n    this._mutation = mutation;\n    this._printedQuery = null;\n    this._files = files;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string name used to refer to this request for printing debug output.\n   */\n  getDebugName(): string {\n    return this._mutation.getName();\n  }\n\n  /**\n   * @public\n   *\n   * Gets an optional map from name to File objects.\n   */\n  getFiles(): ?FileMap {\n    return this._files;\n  }\n\n  /**\n   * @public\n   *\n   * Gets the variables used by the mutation. These variables should be\n   * serialized and sent in the GraphQL request.\n   */\n  getVariables(): Variables {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._mutation);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.variables;\n  }\n\n  /**\n   * @public\n   *\n   * Gets a string representation of the GraphQL mutation.\n   */\n  getQueryString(): string {\n    var printedQuery = this._printedQuery;\n    if (!printedQuery) {\n      printedQuery = printRelayQuery(this._mutation);\n      this._printedQuery = printedQuery;\n    }\n    return printedQuery.text;\n  }\n\n  /**\n   * @public\n   * @unstable\n   */\n  getMutation(): RelayQuery.Mutation {\n    return this._mutation;\n  }\n}\n\nmodule.exports = RelayMutationRequest;\n"}}},"/Users/cpojer/Projects/relay/src/network/fetchRelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"name":"fetchRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule fetchRelayQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQueryRequest = require('RelayQueryRequest');\nimport type RelayQuery from 'RelayQuery';\n\nconst resolveImmediate = require('resolveImmediate');\n\nlet queue: ?Array<RelayQueryRequest> = null;\n\n/**\n * @internal\n *\n * Schedules the supplied `query` to be sent to the server.\n *\n * This is a low-level transport API; application code should use higher-level\n * interfaces exposed by RelayContainer for retrieving data transparently via\n * queries defined on components.\n */\nfunction fetchRelayQuery(query: RelayQuery.Root): Promise {\n  if (!queue) {\n    queue = [];\n    const currentQueue = queue;\n    resolveImmediate(() => {\n      queue = null;\n      profileQueue(currentQueue);\n      processQueue(currentQueue);\n    });\n  }\n  const request = new RelayQueryRequest(query);\n  queue.push(request);\n  return request.getPromise();\n}\n\nfunction processQueue(currentQueue: Array<RelayQueryRequest>): void {\n  RelayNetworkLayer.sendQueries(currentQueue);\n}\n\n/**\n * Profiles time from request to receiving the first server response.\n */\nfunction profileQueue(currentQueue: Array<RelayQueryRequest>): void {\n  // TODO #8783781: remove aggregate `fetchRelayQuery` profiler\n  let firstResultProfiler = RelayProfiler.profile('fetchRelayQuery');\n  currentQueue.forEach(query => {\n    const profiler = RelayProfiler.profile('fetchRelayQuery.query');\n    const onSettle = () => {\n      profiler.stop();\n      if (firstResultProfiler) {\n        firstResultProfiler.stop();\n        firstResultProfiler = null;\n      }\n    };\n    query.getPromise().done(onSettle, onSettle);\n  });\n}\n\nmodule.exports = fetchRelayQuery;\n","dependencies":["RelayQuery","RelayNetworkLayer","RelayProfiler","RelayQueryRequest","resolveImmediate","fetchRelayQuery"],"id":"fetchRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule fetchRelayQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQueryRequest = require('RelayQueryRequest');\nimport type RelayQuery from 'RelayQuery';\n\nconst resolveImmediate = require('resolveImmediate');\n\nlet queue: ?Array<RelayQueryRequest> = null;\n\n/**\n * @internal\n *\n * Schedules the supplied `query` to be sent to the server.\n *\n * This is a low-level transport API; application code should use higher-level\n * interfaces exposed by RelayContainer for retrieving data transparently via\n * queries defined on components.\n */\nfunction fetchRelayQuery(query: RelayQuery.Root): Promise {\n  if (!queue) {\n    queue = [];\n    const currentQueue = queue;\n    resolveImmediate(() => {\n      queue = null;\n      profileQueue(currentQueue);\n      processQueue(currentQueue);\n    });\n  }\n  const request = new RelayQueryRequest(query);\n  queue.push(request);\n  return request.getPromise();\n}\n\nfunction processQueue(currentQueue: Array<RelayQueryRequest>): void {\n  RelayNetworkLayer.sendQueries(currentQueue);\n}\n\n/**\n * Profiles time from request to receiving the first server response.\n */\nfunction profileQueue(currentQueue: Array<RelayQueryRequest>): void {\n  // TODO #8783781: remove aggregate `fetchRelayQuery` profiler\n  let firstResultProfiler = RelayProfiler.profile('fetchRelayQuery');\n  currentQueue.forEach(query => {\n    const profiler = RelayProfiler.profile('fetchRelayQuery.query');\n    const onSettle = () => {\n      profiler.stop();\n      if (firstResultProfiler) {\n        firstResultProfiler.stop();\n        firstResultProfiler = null;\n      }\n    };\n    query.getPromise().done(onSettle, onSettle);\n  });\n}\n\nmodule.exports = fetchRelayQuery;\n"}}},"/Users/cpojer/Projects/relay/src/query/toGraphQL.js":{"metadata":{"mtime":1456103379000},"data":{"name":"toGraphQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule toGraphQL\n * @flow\n */\n\n'use strict';\n\nimport type {\n  ConcreteField,\n  ConcreteFragment,\n  ConcreteQuery,\n  ConcreteSelection,\n} from 'ConcreteQuery';\nconst QueryBuilder = require('QueryBuilder');\nconst RelayQuery = require('RelayQuery');\n\nconst callsToGraphQL = require('callsToGraphQL');\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst invariant = require('invariant');\n\n/**\n * @internal\n *\n * Converts a RelayQuery.Node into a plain object representation. This is\n * equivalent to the AST produced by `babel-relay-plugin` and is intended for\n * use in serializing RelayQuery nodes.\n *\n * NOTE: This is used by external open source projects.\n */\nconst toGraphQL = {\n  Query(node: RelayQuery.Root): ConcreteQuery {\n    const batchCall = node.getBatchCall();\n    let identifyingArgValue;\n    if (batchCall) {\n      identifyingArgValue = QueryBuilder.createBatchCallVariable(\n        batchCall.sourceQueryID,\n        batchCall.sourceQueryPath\n      );\n    } else {\n      const identifyingArg = node.getIdentifyingArg();\n      if (identifyingArg) {\n        if (Array.isArray(identifyingArg.value)) {\n          identifyingArgValue = identifyingArg.value.map(\n            QueryBuilder.createCallValue\n          );\n        } else {\n          identifyingArgValue = QueryBuilder.createCallValue(\n            identifyingArg.value\n          );\n        }\n      }\n    }\n\n    const children = node.getChildren().map(toGraphQLSelection);\n    // Use `QueryBuilder` to generate the correct calls from the\n    // identifying argument & metadata.\n    return QueryBuilder.createQuery({\n      children,\n      fieldName: node.getFieldName(),\n      identifyingArgValue,\n      isDeferred: node.isDeferred(),\n      metadata: node.getConcreteQueryNode().metadata,\n      name: node.getName(),\n      type: node.getType(),\n    });\n  },\n  Fragment(node: RelayQuery.Fragment): ConcreteFragment {\n    const children = node.getChildren().map(toGraphQLSelection);\n    const fragment: ConcreteFragment = {\n      children,\n      id: generateConcreteFragmentID(),\n      kind: 'Fragment',\n      metadata: {\n        isAbstract: node.isAbstract(),\n        plural: node.isPlural(),\n      },\n      name: node.getDebugName(),\n      type: node.getType(),\n    };\n    return fragment;\n  },\n  Field(node: RelayQuery.Field): ConcreteField {\n    const calls = callsToGraphQL(node.getCallsWithValues());\n    const children = node.getChildren().map(toGraphQLSelection);\n    const field: ConcreteField = {\n      alias: node.getConcreteQueryNode().alias,\n      calls,\n      children,\n      fieldName: node.getSchemaName(),\n      kind: 'Field',\n      metadata: node.getConcreteQueryNode().metadata,\n      type: node.getType(),\n    };\n    return field;\n  },\n};\n\nfunction toGraphQLSelection(\n  node: RelayQuery.Node\n): ConcreteSelection  {\n  if (node instanceof RelayQuery.Fragment) {\n    return toGraphQL.Fragment(node);\n  } else {\n    invariant(node instanceof RelayQuery.Field, 'toGraphQL: Invalid node.');\n    return toGraphQL.Field(node);\n  }\n}\n\nmodule.exports = toGraphQL;\n","dependencies":["ConcreteQuery","QueryBuilder","RelayQuery","callsToGraphQL","generateConcreteFragmentID","invariant","toGraphQL"],"id":"toGraphQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule toGraphQL\n * @flow\n */\n\n'use strict';\n\nimport type {\n  ConcreteField,\n  ConcreteFragment,\n  ConcreteQuery,\n  ConcreteSelection,\n} from 'ConcreteQuery';\nconst QueryBuilder = require('QueryBuilder');\nconst RelayQuery = require('RelayQuery');\n\nconst callsToGraphQL = require('callsToGraphQL');\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst invariant = require('invariant');\n\n/**\n * @internal\n *\n * Converts a RelayQuery.Node into a plain object representation. This is\n * equivalent to the AST produced by `babel-relay-plugin` and is intended for\n * use in serializing RelayQuery nodes.\n *\n * NOTE: This is used by external open source projects.\n */\nconst toGraphQL = {\n  Query(node: RelayQuery.Root): ConcreteQuery {\n    const batchCall = node.getBatchCall();\n    let identifyingArgValue;\n    if (batchCall) {\n      identifyingArgValue = QueryBuilder.createBatchCallVariable(\n        batchCall.sourceQueryID,\n        batchCall.sourceQueryPath\n      );\n    } else {\n      const identifyingArg = node.getIdentifyingArg();\n      if (identifyingArg) {\n        if (Array.isArray(identifyingArg.value)) {\n          identifyingArgValue = identifyingArg.value.map(\n            QueryBuilder.createCallValue\n          );\n        } else {\n          identifyingArgValue = QueryBuilder.createCallValue(\n            identifyingArg.value\n          );\n        }\n      }\n    }\n\n    const children = node.getChildren().map(toGraphQLSelection);\n    // Use `QueryBuilder` to generate the correct calls from the\n    // identifying argument & metadata.\n    return QueryBuilder.createQuery({\n      children,\n      fieldName: node.getFieldName(),\n      identifyingArgValue,\n      isDeferred: node.isDeferred(),\n      metadata: node.getConcreteQueryNode().metadata,\n      name: node.getName(),\n      type: node.getType(),\n    });\n  },\n  Fragment(node: RelayQuery.Fragment): ConcreteFragment {\n    const children = node.getChildren().map(toGraphQLSelection);\n    const fragment: ConcreteFragment = {\n      children,\n      id: generateConcreteFragmentID(),\n      kind: 'Fragment',\n      metadata: {\n        isAbstract: node.isAbstract(),\n        plural: node.isPlural(),\n      },\n      name: node.getDebugName(),\n      type: node.getType(),\n    };\n    return fragment;\n  },\n  Field(node: RelayQuery.Field): ConcreteField {\n    const calls = callsToGraphQL(node.getCallsWithValues());\n    const children = node.getChildren().map(toGraphQLSelection);\n    const field: ConcreteField = {\n      alias: node.getConcreteQueryNode().alias,\n      calls,\n      children,\n      fieldName: node.getSchemaName(),\n      kind: 'Field',\n      metadata: node.getConcreteQueryNode().metadata,\n      type: node.getType(),\n    };\n    return field;\n  },\n};\n\nfunction toGraphQLSelection(\n  node: RelayQuery.Node\n): ConcreteSelection  {\n  if (node instanceof RelayQuery.Fragment) {\n    return toGraphQL.Fragment(node);\n  } else {\n    invariant(node instanceof RelayQuery.Field, 'toGraphQL: Invalid node.');\n    return toGraphQL.Field(node);\n  }\n}\n\nmodule.exports = toGraphQL;\n"}}},"/Users/cpojer/Projects/relay/src/query/stableStringify.js":{"metadata":{"mtime":1455679338000},"data":{"name":"stableStringify","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule stableStringify\n * @flow\n */\n\n'use strict';\n\nfunction isObject(value: mixed) {\n  return (\n    value !== null &&\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\n/**\n * Simple recursive stringifier that handles basic objects (does not handle\n * corner cases such as circular references) and produces a JSON-like\n * serialization suitable for use as a cache key or other similar internal\n * book-keeping detail.\n *\n * Sample input:\n *\n *     var object = {\n *       top2: {\n *         middle: {\n *           inner: [1, 'foo', ['bar', 2]],\n *           other: false,\n *         },\n *       },\n *       top1: [\n *         {first: true},\n *         {first: false},\n *         'random',\n *       ],\n *       misc: true,\n *       extra: null,\n *     };\n *\n * Sample output (some whitespace added for clarity):\n *\n *    {\n *      extra:null,\n *      misc:true,\n *      top1:[0:{first:true},1:{first:false},2:\"random\"],\n *      top2:{middle:{inner:[0:1,1:\"foo\",2:[0:\"bar\",1:2]],other:false}}\n *    }\n */\nfunction stableStringify(input: any): string {\n  const inputIsArray = Array.isArray(input);\n  const inputIsObject = isObject(input);\n  if (inputIsArray || inputIsObject) {\n    var keys = Object.keys(input);\n    if (keys.length) {\n      var result = [];\n      keys.sort();\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = input[key];\n        if (isObject(value) || Array.isArray(value)) {\n          value = stableStringify(value);\n        } else {\n          value = JSON.stringify(value);\n        }\n        result.push(key + ':' + value);\n      }\n\n      if (inputIsArray) {\n        return '[' + result.join(',') + ']';\n      } else {\n        return '{' + result.join(',') + '}';\n      }\n    }\n  }\n  return JSON.stringify(input);\n}\n\nmodule.exports = stableStringify;\n","dependencies":["stableStringify"],"id":"stableStringify","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule stableStringify\n * @flow\n */\n\n'use strict';\n\nfunction isObject(value: mixed) {\n  return (\n    value !== null &&\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\n/**\n * Simple recursive stringifier that handles basic objects (does not handle\n * corner cases such as circular references) and produces a JSON-like\n * serialization suitable for use as a cache key or other similar internal\n * book-keeping detail.\n *\n * Sample input:\n *\n *     var object = {\n *       top2: {\n *         middle: {\n *           inner: [1, 'foo', ['bar', 2]],\n *           other: false,\n *         },\n *       },\n *       top1: [\n *         {first: true},\n *         {first: false},\n *         'random',\n *       ],\n *       misc: true,\n *       extra: null,\n *     };\n *\n * Sample output (some whitespace added for clarity):\n *\n *    {\n *      extra:null,\n *      misc:true,\n *      top1:[0:{first:true},1:{first:false},2:\"random\"],\n *      top2:{middle:{inner:[0:1,1:\"foo\",2:[0:\"bar\",1:2]],other:false}}\n *    }\n */\nfunction stableStringify(input: any): string {\n  const inputIsArray = Array.isArray(input);\n  const inputIsObject = isObject(input);\n  if (inputIsArray || inputIsObject) {\n    var keys = Object.keys(input);\n    if (keys.length) {\n      var result = [];\n      keys.sort();\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = input[key];\n        if (isObject(value) || Array.isArray(value)) {\n          value = stableStringify(value);\n        } else {\n          value = JSON.stringify(value);\n        }\n        result.push(key + ':' + value);\n      }\n\n      if (inputIsArray) {\n        return '[' + result.join(',') + ']';\n      } else {\n        return '{' + result.join(',') + '}';\n      }\n    }\n  }\n  return JSON.stringify(input);\n}\n\nmodule.exports = stableStringify;\n"}}},"/Users/cpojer/Projects/relay/src/query/serializeRelayQueryCall.js":{"metadata":{"mtime":1455679338000},"data":{"name":"serializeRelayQueryCall","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule serializeRelayQueryCall\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {\n  Call,\n  CallValue,\n} from 'RelayInternalTypes';\n\nconst flattenArray = require('flattenArray');\n\n/**\n * @internal\n *\n * Serializes a query \"call\" (a legacy combination of field and argument value).\n */\nfunction serializeRelayQueryCall(call: Call): string {\n  var {value} = call;\n  var valueString;\n  if (Array.isArray(value)) {\n    valueString = flattenArray(value).map(serializeCallValue).join(',');\n  } else {\n    valueString = serializeCallValue(value);\n  }\n  return '.' + call.name + '(' + valueString +')';\n}\n\nfunction serializeCallValue(value: ?CallValue): string {\n  if (value == null) {\n    return '';\n  } else if (typeof value !== 'string') {\n    return JSON.stringify(value);\n  } else {\n    return value;\n  }\n}\n\nmodule.exports = serializeRelayQueryCall;\n","dependencies":["RelayInternalTypes","flattenArray","serializeRelayQueryCall"],"id":"serializeRelayQueryCall","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule serializeRelayQueryCall\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {\n  Call,\n  CallValue,\n} from 'RelayInternalTypes';\n\nconst flattenArray = require('flattenArray');\n\n/**\n * @internal\n *\n * Serializes a query \"call\" (a legacy combination of field and argument value).\n */\nfunction serializeRelayQueryCall(call: Call): string {\n  var {value} = call;\n  var valueString;\n  if (Array.isArray(value)) {\n    valueString = flattenArray(value).map(serializeCallValue).join(',');\n  } else {\n    valueString = serializeCallValue(value);\n  }\n  return '.' + call.name + '(' + valueString +')';\n}\n\nfunction serializeCallValue(value: ?CallValue): string {\n  if (value == null) {\n    return '';\n  } else if (typeof value !== 'string') {\n    return JSON.stringify(value);\n  } else {\n    return value;\n  }\n}\n\nmodule.exports = serializeRelayQueryCall;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayRouteFragment.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayRouteFragment","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRouteFragment\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayMetaRoute from 'RelayMetaRoute';\nimport type {RelayConcreteNode} from 'RelayQL';\n\ntype FragmentBuilder = (route: RelayMetaRoute) => ?RelayConcreteNode;\n\n/**\n * Represents a query fragment that is conditional upon the active route as a\n * function that returns either a literal fragment or a fragment reference.\n *\n * Example GraphQL:\n *\n * ```\n * Node {\n *   ${(route) => matchRoute(route, ...)}\n * }\n * ```\n */\nclass RelayRouteFragment {\n  _builder: FragmentBuilder;\n\n  constructor(builder: FragmentBuilder) {\n    this._builder = builder;\n  }\n\n  /**\n   * Returns the query fragment that matches the given route, if any.\n   */\n  getFragmentForRoute(\n    route: RelayMetaRoute\n  ): ?RelayConcreteNode {\n    return this._builder(route);\n  }\n}\n\nmodule.exports = RelayRouteFragment;\n","dependencies":["RelayMetaRoute","RelayQL","RelayRouteFragment"],"id":"RelayRouteFragment","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRouteFragment\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayMetaRoute from 'RelayMetaRoute';\nimport type {RelayConcreteNode} from 'RelayQL';\n\ntype FragmentBuilder = (route: RelayMetaRoute) => ?RelayConcreteNode;\n\n/**\n * Represents a query fragment that is conditional upon the active route as a\n * function that returns either a literal fragment or a fragment reference.\n *\n * Example GraphQL:\n *\n * ```\n * Node {\n *   ${(route) => matchRoute(route, ...)}\n * }\n * ```\n */\nclass RelayRouteFragment {\n  _builder: FragmentBuilder;\n\n  constructor(builder: FragmentBuilder) {\n    this._builder = builder;\n  }\n\n  /**\n   * Returns the query fragment that matches the given route, if any.\n   */\n  getFragmentForRoute(\n    route: RelayMetaRoute\n  ): ?RelayConcreteNode {\n    return this._builder(route);\n  }\n}\n\nmodule.exports = RelayRouteFragment;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayRefQueryDescriptor.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayRefQueryDescriptor","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRefQueryDescriptor\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\nexport type NodePath = Array<RelayQuery.Node>;\n\n/**\n * @internal\n *\n * Represents a node that will eventually become a \"ref query\".\n *\n * Includes the `nodePath` (ancestor nodes) that can be used to construct an\n * appropriate the JSONPath for the query.\n *\n * @see splitDeferredRelayQueries\n */\nclass RelayRefQueryDescriptor {\n  node: RelayQuery.Node;\n  nodePath: NodePath;\n\n  constructor(node: RelayQuery.Node, nodePath: NodePath) {\n    this.node = node;\n    this.nodePath = nodePath;\n  }\n}\n\nmodule.exports = RelayRefQueryDescriptor;\n","dependencies":["RelayQuery","RelayRefQueryDescriptor"],"id":"RelayRefQueryDescriptor","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRefQueryDescriptor\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\nexport type NodePath = Array<RelayQuery.Node>;\n\n/**\n * @internal\n *\n * Represents a node that will eventually become a \"ref query\".\n *\n * Includes the `nodePath` (ancestor nodes) that can be used to construct an\n * appropriate the JSONPath for the query.\n *\n * @see splitDeferredRelayQueries\n */\nclass RelayRefQueryDescriptor {\n  node: RelayQuery.Node;\n  nodePath: NodePath;\n\n  constructor(node: RelayQuery.Node, nodePath: NodePath) {\n    this.node = node;\n    this.nodePath = nodePath;\n  }\n}\n\nmodule.exports = RelayRefQueryDescriptor;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayQueryVisitor.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayQueryVisitor","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryVisitor\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\n\n/**\n * @internal\n *\n * Base class for traversing a Relay Query.\n *\n * Subclasses can optionally implement methods to customize the traversal:\n *\n * - `visitField(field, state)`: Called for each field.\n * - `visitFragment(fragment, state)`: Called for each fragment.\n * - `visitQuery(fragment, state)`: Called for the top level query.\n *\n * A `state` variable is passed along to all callbacks and can be used to\n * accumulate data while traversing (effectively passing data back up the tree),\n * or modify the behavior of later callbacks (effectively passing data down the\n * tree).\n *\n * There are two additional methods for controlling the traversal:\n *\n * - `traverse(parent, state)`: Visits all children of `parent`. Subclasses\n *   may override in order to short-circuit traversal. Note that\n *   `visit{Field,Fragment,Query}` are //not// called on `parent`, as it will\n *   already have been visited by the time this method is called.\n * - `visit(child, state)`: Processes the `child` node, calling the appropriate\n *   `visit{Field,Fragment,Query}` method based on the node type.\n *\n * By convention, each of the callback methods returns the visited node. This is\n * used by the `RelayQueryTransform` subclass to implement mapping and filtering\n * behavior, but purely-visitor subclases do not need to follow this convention.\n *\n * @see RelayQueryTransform\n */\nclass RelayQueryVisitor<Ts> {\n  visit(\n    node: RelayQuery.Node,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    if (node instanceof RelayQuery.Field) {\n      return this.visitField(node, nextState);\n    } else if (node instanceof RelayQuery.Fragment) {\n      return this.visitFragment(node, nextState);\n    } else if (node instanceof RelayQuery.Root) {\n      return this.visitRoot(node, nextState);\n    }\n  }\n\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    nextState: Ts\n  ): ?Tn {\n    if (node.canHaveSubselections()) {\n      this.traverseChildren(node, nextState, function(child) {\n        this.visit(child, nextState);\n      }, this);\n    }\n    return node;\n  }\n\n  traverseChildren(\n    node: RelayQuery.Node,\n    nextState: Ts,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ): void {\n    const children = node.getChildren();\n    for (let index = 0; index < children.length; index++) {\n      callback.call(context, children[index], index, children);\n    }\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    return this.traverse(node, nextState);\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    return this.traverse(node, nextState);\n  }\n\n  visitRoot(\n    node: RelayQuery.Root,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    return this.traverse(node, nextState);\n  }\n}\n\nmodule.exports = RelayQueryVisitor;\n","dependencies":["RelayQuery","RelayQueryVisitor"],"id":"RelayQueryVisitor","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryVisitor\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\n\n/**\n * @internal\n *\n * Base class for traversing a Relay Query.\n *\n * Subclasses can optionally implement methods to customize the traversal:\n *\n * - `visitField(field, state)`: Called for each field.\n * - `visitFragment(fragment, state)`: Called for each fragment.\n * - `visitQuery(fragment, state)`: Called for the top level query.\n *\n * A `state` variable is passed along to all callbacks and can be used to\n * accumulate data while traversing (effectively passing data back up the tree),\n * or modify the behavior of later callbacks (effectively passing data down the\n * tree).\n *\n * There are two additional methods for controlling the traversal:\n *\n * - `traverse(parent, state)`: Visits all children of `parent`. Subclasses\n *   may override in order to short-circuit traversal. Note that\n *   `visit{Field,Fragment,Query}` are //not// called on `parent`, as it will\n *   already have been visited by the time this method is called.\n * - `visit(child, state)`: Processes the `child` node, calling the appropriate\n *   `visit{Field,Fragment,Query}` method based on the node type.\n *\n * By convention, each of the callback methods returns the visited node. This is\n * used by the `RelayQueryTransform` subclass to implement mapping and filtering\n * behavior, but purely-visitor subclases do not need to follow this convention.\n *\n * @see RelayQueryTransform\n */\nclass RelayQueryVisitor<Ts> {\n  visit(\n    node: RelayQuery.Node,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    if (node instanceof RelayQuery.Field) {\n      return this.visitField(node, nextState);\n    } else if (node instanceof RelayQuery.Fragment) {\n      return this.visitFragment(node, nextState);\n    } else if (node instanceof RelayQuery.Root) {\n      return this.visitRoot(node, nextState);\n    }\n  }\n\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    nextState: Ts\n  ): ?Tn {\n    if (node.canHaveSubselections()) {\n      this.traverseChildren(node, nextState, function(child) {\n        this.visit(child, nextState);\n      }, this);\n    }\n    return node;\n  }\n\n  traverseChildren(\n    node: RelayQuery.Node,\n    nextState: Ts,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ): void {\n    const children = node.getChildren();\n    for (let index = 0; index < children.length; index++) {\n      callback.call(context, children[index], index, children);\n    }\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    return this.traverse(node, nextState);\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    return this.traverse(node, nextState);\n  }\n\n  visitRoot(\n    node: RelayQuery.Root,\n    nextState: Ts\n  ): ?RelayQuery.Node {\n    return this.traverse(node, nextState);\n  }\n}\n\nmodule.exports = RelayQueryVisitor;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayQueryTransform.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayQueryTransform","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryTransform\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\n\n/**\n * @internal\n *\n * `RelayQueryTransform` is a `RelayQueryVisitor` subclass that simplifies the\n * process of traversing, filtering, or transforming a Relay Query.\n *\n * The traversal is a map operation from `RelayQuery` nodes to nodes. The\n * default implementation traverses all nodes and maps each one to its\n * original value (ie. a no-op).\n *\n * Just like `RelayQueryVisitor`, subclasses of `RelayQueryTransform` can\n * optionally implement methods to customize the traversal and mapping of\n * different RelayQuery node types:\n *\n * - `visitField(field, state)`: Returns the new value for the visited field, or\n *   `null` to remove it from the output.\n * - `visitFragment(fragment, state)`: Returns the new value for the visited\n *   fragment, or `null` to remove it from the output.\n * - `visitQuery(fragment, state)`: Returns the new value for the top-level\n *   query, or `null` to transform the entire query out of existence.\n *\n * There are two additional methods for controlling the traversal:\n *\n * - `traverse(parent, state)`: Returns a cloned copy of the parent node after\n *   processing all of its children. Does not clone if nothing changed.\n * - `visit(child, state)`: Processes the child node, calling the appropriate\n *   `visit{Field,Fragment,Root` method based on the node type.\n *\n * All of these methods may return the original node in order to leave it\n * intact.\n *\n * @see RelayQueryVisitor\n */\nclass RelayQueryTransform<Ts> extends RelayQueryVisitor<Ts> {\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    nextState: Ts\n  ): ?Tn {\n    if (!node.canHaveSubselections()) {\n      return node;\n    }\n    let nextChildren;\n    this.traverseChildren(node, nextState, function(child, index, children) {\n      const prevChild = children[index];\n      const nextChild = this.visit(prevChild, nextState);\n      if (nextChild !== prevChild) {\n        nextChildren = nextChildren || children.slice(0, index);\n      }\n      if (nextChildren && nextChild) {\n        nextChildren.push(nextChild);\n      }\n    }, this);\n    if (nextChildren) {\n      if (!nextChildren.length) {\n        return null;\n      }\n      return node.clone(nextChildren);\n    }\n    return node;\n  }\n}\n\nmodule.exports = RelayQueryTransform;\n","dependencies":["RelayQuery","RelayQueryVisitor","RelayQueryTransform"],"id":"RelayQueryTransform","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryTransform\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\n\n/**\n * @internal\n *\n * `RelayQueryTransform` is a `RelayQueryVisitor` subclass that simplifies the\n * process of traversing, filtering, or transforming a Relay Query.\n *\n * The traversal is a map operation from `RelayQuery` nodes to nodes. The\n * default implementation traverses all nodes and maps each one to its\n * original value (ie. a no-op).\n *\n * Just like `RelayQueryVisitor`, subclasses of `RelayQueryTransform` can\n * optionally implement methods to customize the traversal and mapping of\n * different RelayQuery node types:\n *\n * - `visitField(field, state)`: Returns the new value for the visited field, or\n *   `null` to remove it from the output.\n * - `visitFragment(fragment, state)`: Returns the new value for the visited\n *   fragment, or `null` to remove it from the output.\n * - `visitQuery(fragment, state)`: Returns the new value for the top-level\n *   query, or `null` to transform the entire query out of existence.\n *\n * There are two additional methods for controlling the traversal:\n *\n * - `traverse(parent, state)`: Returns a cloned copy of the parent node after\n *   processing all of its children. Does not clone if nothing changed.\n * - `visit(child, state)`: Processes the child node, calling the appropriate\n *   `visit{Field,Fragment,Root` method based on the node type.\n *\n * All of these methods may return the original node in order to leave it\n * intact.\n *\n * @see RelayQueryVisitor\n */\nclass RelayQueryTransform<Ts> extends RelayQueryVisitor<Ts> {\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    nextState: Ts\n  ): ?Tn {\n    if (!node.canHaveSubselections()) {\n      return node;\n    }\n    let nextChildren;\n    this.traverseChildren(node, nextState, function(child, index, children) {\n      const prevChild = children[index];\n      const nextChild = this.visit(prevChild, nextState);\n      if (nextChild !== prevChild) {\n        nextChildren = nextChildren || children.slice(0, index);\n      }\n      if (nextChildren && nextChild) {\n        nextChildren.push(nextChild);\n      }\n    }, this);\n    if (nextChildren) {\n      if (!nextChildren.length) {\n        return null;\n      }\n      return node.clone(nextChildren);\n    }\n    return node;\n  }\n}\n\nmodule.exports = RelayQueryTransform;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayQueryPath.js":{"metadata":{"mtime":1456974578000},"data":{"name":"RelayQueryPath","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryPath\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayRecord = require('RelayRecord');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nconst {ID, NODE_TYPE, TYPENAME} = RelayNodeInterface;\n\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  type: 'String',\n});\nconst typeField = RelayQuery.Field.build({\n  fieldName: TYPENAME,\n  type: 'String',\n});\n\n/**\n * @internal\n *\n * Represents the path (root plus fields) within a query that fetched a\n * particular node. Each step of the path may represent a root query (for\n * refetchable nodes) or the field path from the nearest refetchable node.\n */\nclass RelayQueryPath {\n  _name: string;\n  _node: RelayQuery.Root | RelayQuery.Field | RelayQuery.Fragment;\n  _parent: ?RelayQueryPath;\n\n  constructor(\n    node: RelayQuery.Root | RelayQuery.Field | RelayQuery.Fragment,\n    parent?: RelayQueryPath\n  ) {\n    if (node instanceof RelayQuery.Root) {\n      invariant(\n        !parent,\n        'RelayQueryPath: Root paths may not have a parent.'\n      );\n      this._name = node.getName();\n    } else {\n      invariant(\n        parent,\n        'RelayQueryPath: A parent is required for field paths.'\n      );\n      this._name = parent.getName();\n    }\n    this._node = node;\n    this._parent = parent;\n  }\n\n  /**\n   * Returns true if this is a root path (the node is a root node with an ID),\n   * false otherwise.\n   */\n  isRootPath(): boolean {\n    return !this._parent;\n  }\n\n  /**\n   * Gets the parent path, throwing if it does not exist. Use `!isRootPath()`\n   * to check if there is a parent.\n   */\n  getParent(): RelayQueryPath {\n    var parent = this._parent;\n    invariant(\n      parent,\n      'RelayQueryPath.getParent(): Cannot get the parent of a root path.'\n    );\n    return parent;\n  }\n\n  /**\n   * Helper to get the name of the root query node.\n   */\n  getName(): string {\n    return this._name;\n  }\n\n  /**\n   * Gets a new path that describes how to access the given `node` via the\n   * current path. Returns a new, root path if `dataID` is provided and\n   * refetchable, otherwise returns an extension of the current path.\n   */\n  getPath(\n    node: RelayQuery.Field | RelayQuery.Fragment,\n    dataID: DataID\n  ): RelayQueryPath {\n    if (RelayRecord.isClientID(dataID)) {\n      return new RelayQueryPath(node, this);\n    } else {\n      const root = RelayQuery.Root.build(\n        this.getName(),\n        RelayNodeInterface.NODE,\n        dataID,\n        [idField, typeField],\n        {\n          identifyingArgName: RelayNodeInterface.ID,\n          identifyingArgType: RelayNodeInterface.ID_TYPE,\n          isAbstract: true,\n          isDeferred: false,\n          isPlural: false,\n        },\n        NODE_TYPE\n      );\n      return new RelayQueryPath(root);\n    }\n  }\n\n  /**\n   * Returns a new root query that follows only the fields in this path and then\n   * appends the specified field/fragment at the node reached by the path.\n   *\n   * The query also includes any ID fields along the way.\n   */\n  getQuery(\n    store: RelayRecordStore,\n    appendNode: RelayQuery.Fragment | RelayQuery.Field\n  ): RelayQuery.Root {\n    let node = this._node;\n    let path = this;\n    let child = appendNode;\n    while (\n      node instanceof RelayQuery.Field ||\n      node instanceof RelayQuery.Fragment\n    ) {\n      const idFieldName = node instanceof RelayQuery.Field ?\n        node.getInferredPrimaryKey() :\n        ID;\n      if (idFieldName) {\n        child = node.clone([\n          child,\n          node.getFieldByStorageKey(idFieldName),\n          node.getFieldByStorageKey(TYPENAME),\n        ]);\n      } else {\n        child = node.clone([child]);\n      }\n      path = path._parent;\n      invariant(\n        path,\n        'RelayQueryPath.getQuery(): Expected a parent path.'\n      );\n      node = path._node;\n    }\n    invariant(child, 'RelayQueryPath: Expected a leaf node.');\n    invariant(\n      node instanceof RelayQuery.Root,\n      'RelayQueryPath: Expected a root node.'\n    );\n    let children = [\n      child,\n      (node: $FlowIssue).getFieldByStorageKey(ID),\n      (node: $FlowIssue).getFieldByStorageKey(TYPENAME),\n    ];\n    const metadata = {...node.getConcreteQueryNode().metadata};\n    const identifyingArg = node.getIdentifyingArg();\n    if (identifyingArg && identifyingArg.name != null) {\n      metadata.identifyingArgName = identifyingArg.name;\n    }\n    // At this point `children` will be a partial query such as:\n    //   id\n    //   __typename\n    //   fieldOnFoo { ${appendNode} }\n    //\n    // In which `fieldOnFoo` is a field of type `Foo`, and cannot be queried on\n    // `Node`. To make the query valid it must be wrapped in a conditioning\n    // fragment based on the concrete type of the root id:\n    //   node(id: $rootID) {\n    //     ... on TypeOFRootID {\n    //        # above Fragment\n    //     }\n    //   }\n    if (identifyingArg && identifyingArg.value != null) {\n      const identifyingArgValue = identifyingArg.value;\n      if (\n        typeof identifyingArgValue !== 'string' &&\n        typeof identifyingArgValue !== 'number'\n      ) {\n        // TODO #8054994: Supporting aribtrary identifying value types\n        invariant(\n          false,\n          'Relay: Expected argument to root field `%s` to be a string or ' +\n          'number, got `%s`.',\n          node.getFieldName(),\n          JSON.stringify(identifyingArgValue)\n        );\n      }\n      const rootID = store.getDataID(\n        node.getFieldName(),\n        '' + identifyingArgValue\n      );\n      const rootType = rootID && store.getType(rootID);\n      if (rootType != null) {\n        children = [RelayQuery.Fragment.build(\n          this.getName(),\n          rootType,\n          children\n        )];\n      } else {\n        const recordState = rootID != null ?\n          store.getRecordState(rootID) :\n          RelayRecordState.UNKNOWN;\n        warning(\n          false,\n          'RelayQueryPath: No typename found for %s record `%s`. ' +\n          'Generating a possibly invalid query.',\n          recordState.toLowerCase(),\n          identifyingArgValue\n        );\n      }\n    }\n    return RelayQuery.Root.build(\n      this.getName(),\n      node.getFieldName(),\n      (identifyingArg && identifyingArg.value) || null,\n      children,\n      metadata,\n      node.getType()\n    );\n  }\n}\n\nmodule.exports = RelayQueryPath;\n","dependencies":["RelayInternalTypes","RelayRecordStore","RelayNodeInterface","RelayQuery","RelayRecord","RelayRecordState","invariant","warning","RelayQueryPath"],"id":"RelayQueryPath","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryPath\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayRecord = require('RelayRecord');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nconst {ID, NODE_TYPE, TYPENAME} = RelayNodeInterface;\n\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  type: 'String',\n});\nconst typeField = RelayQuery.Field.build({\n  fieldName: TYPENAME,\n  type: 'String',\n});\n\n/**\n * @internal\n *\n * Represents the path (root plus fields) within a query that fetched a\n * particular node. Each step of the path may represent a root query (for\n * refetchable nodes) or the field path from the nearest refetchable node.\n */\nclass RelayQueryPath {\n  _name: string;\n  _node: RelayQuery.Root | RelayQuery.Field | RelayQuery.Fragment;\n  _parent: ?RelayQueryPath;\n\n  constructor(\n    node: RelayQuery.Root | RelayQuery.Field | RelayQuery.Fragment,\n    parent?: RelayQueryPath\n  ) {\n    if (node instanceof RelayQuery.Root) {\n      invariant(\n        !parent,\n        'RelayQueryPath: Root paths may not have a parent.'\n      );\n      this._name = node.getName();\n    } else {\n      invariant(\n        parent,\n        'RelayQueryPath: A parent is required for field paths.'\n      );\n      this._name = parent.getName();\n    }\n    this._node = node;\n    this._parent = parent;\n  }\n\n  /**\n   * Returns true if this is a root path (the node is a root node with an ID),\n   * false otherwise.\n   */\n  isRootPath(): boolean {\n    return !this._parent;\n  }\n\n  /**\n   * Gets the parent path, throwing if it does not exist. Use `!isRootPath()`\n   * to check if there is a parent.\n   */\n  getParent(): RelayQueryPath {\n    var parent = this._parent;\n    invariant(\n      parent,\n      'RelayQueryPath.getParent(): Cannot get the parent of a root path.'\n    );\n    return parent;\n  }\n\n  /**\n   * Helper to get the name of the root query node.\n   */\n  getName(): string {\n    return this._name;\n  }\n\n  /**\n   * Gets a new path that describes how to access the given `node` via the\n   * current path. Returns a new, root path if `dataID` is provided and\n   * refetchable, otherwise returns an extension of the current path.\n   */\n  getPath(\n    node: RelayQuery.Field | RelayQuery.Fragment,\n    dataID: DataID\n  ): RelayQueryPath {\n    if (RelayRecord.isClientID(dataID)) {\n      return new RelayQueryPath(node, this);\n    } else {\n      const root = RelayQuery.Root.build(\n        this.getName(),\n        RelayNodeInterface.NODE,\n        dataID,\n        [idField, typeField],\n        {\n          identifyingArgName: RelayNodeInterface.ID,\n          identifyingArgType: RelayNodeInterface.ID_TYPE,\n          isAbstract: true,\n          isDeferred: false,\n          isPlural: false,\n        },\n        NODE_TYPE\n      );\n      return new RelayQueryPath(root);\n    }\n  }\n\n  /**\n   * Returns a new root query that follows only the fields in this path and then\n   * appends the specified field/fragment at the node reached by the path.\n   *\n   * The query also includes any ID fields along the way.\n   */\n  getQuery(\n    store: RelayRecordStore,\n    appendNode: RelayQuery.Fragment | RelayQuery.Field\n  ): RelayQuery.Root {\n    let node = this._node;\n    let path = this;\n    let child = appendNode;\n    while (\n      node instanceof RelayQuery.Field ||\n      node instanceof RelayQuery.Fragment\n    ) {\n      const idFieldName = node instanceof RelayQuery.Field ?\n        node.getInferredPrimaryKey() :\n        ID;\n      if (idFieldName) {\n        child = node.clone([\n          child,\n          node.getFieldByStorageKey(idFieldName),\n          node.getFieldByStorageKey(TYPENAME),\n        ]);\n      } else {\n        child = node.clone([child]);\n      }\n      path = path._parent;\n      invariant(\n        path,\n        'RelayQueryPath.getQuery(): Expected a parent path.'\n      );\n      node = path._node;\n    }\n    invariant(child, 'RelayQueryPath: Expected a leaf node.');\n    invariant(\n      node instanceof RelayQuery.Root,\n      'RelayQueryPath: Expected a root node.'\n    );\n    let children = [\n      child,\n      (node: $FlowIssue).getFieldByStorageKey(ID),\n      (node: $FlowIssue).getFieldByStorageKey(TYPENAME),\n    ];\n    const metadata = {...node.getConcreteQueryNode().metadata};\n    const identifyingArg = node.getIdentifyingArg();\n    if (identifyingArg && identifyingArg.name != null) {\n      metadata.identifyingArgName = identifyingArg.name;\n    }\n    // At this point `children` will be a partial query such as:\n    //   id\n    //   __typename\n    //   fieldOnFoo { ${appendNode} }\n    //\n    // In which `fieldOnFoo` is a field of type `Foo`, and cannot be queried on\n    // `Node`. To make the query valid it must be wrapped in a conditioning\n    // fragment based on the concrete type of the root id:\n    //   node(id: $rootID) {\n    //     ... on TypeOFRootID {\n    //        # above Fragment\n    //     }\n    //   }\n    if (identifyingArg && identifyingArg.value != null) {\n      const identifyingArgValue = identifyingArg.value;\n      if (\n        typeof identifyingArgValue !== 'string' &&\n        typeof identifyingArgValue !== 'number'\n      ) {\n        // TODO #8054994: Supporting aribtrary identifying value types\n        invariant(\n          false,\n          'Relay: Expected argument to root field `%s` to be a string or ' +\n          'number, got `%s`.',\n          node.getFieldName(),\n          JSON.stringify(identifyingArgValue)\n        );\n      }\n      const rootID = store.getDataID(\n        node.getFieldName(),\n        '' + identifyingArgValue\n      );\n      const rootType = rootID && store.getType(rootID);\n      if (rootType != null) {\n        children = [RelayQuery.Fragment.build(\n          this.getName(),\n          rootType,\n          children\n        )];\n      } else {\n        const recordState = rootID != null ?\n          store.getRecordState(rootID) :\n          RelayRecordState.UNKNOWN;\n        warning(\n          false,\n          'RelayQueryPath: No typename found for %s record `%s`. ' +\n          'Generating a possibly invalid query.',\n          recordState.toLowerCase(),\n          identifyingArgValue\n        );\n      }\n    }\n    return RelayQuery.Root.build(\n      this.getName(),\n      node.getFieldName(),\n      (identifyingArg && identifyingArg.value) || null,\n      children,\n      metadata,\n      node.getType()\n    );\n  }\n}\n\nmodule.exports = RelayQueryPath;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayQuery.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteField,\n  ConcreteFieldMetadata,\n  ConcreteFragment,\n  ConcreteMutation,\n  ConcreteNode,\n  ConcreteOperationMetadata,\n  ConcreteQuery,\n  ConcreteQueryMetadata,\n} from 'ConcreteQuery';\nconst QueryBuilder = require('QueryBuilder');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayFragmentReference = require('RelayFragmentReference');\nimport type {Call, Directive}  from 'RelayInternalTypes';\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayRouteFragment = require('RelayRouteFragment');\nimport type {Variables} from 'RelayTypes';\n\nconst areEqual = require('areEqual');\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst callsToGraphQL = require('callsToGraphQL');\nconst directivesToGraphQL = require('directivesToGraphQL');\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst invariant = require('invariant');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\nconst shallowEqual = require('shallowEqual');\nconst stableStringify = require('stableStringify');\n\ntype BatchCall = {\n  refParamName: string;\n  sourceQueryID: string;\n  sourceQueryPath: string;\n};\ntype FragmentMetadata = {\n  isDeferred: boolean;\n  isContainerFragment: boolean;\n};\n// TODO: replace once #6525923 is resolved\ntype NextChildren = Array<any>;\n\n// conditional field calls/values\nconst IF = 'if';\nconst UNLESS = 'unless';\nconst TRUE = 'true';\nconst FALSE = 'false';\nconst SKIP = 'skip';\nconst INCLUDE = 'include';\n\nlet _nextQueryID = 0;\n\nconst DEFAULT_FRAGMENT_METADATA = {\n  isDeferred: false,\n  isContainerFragment: false,\n};\nconst EMPTY_DIRECTIVES = [];\nconst EMPTY_CALLS = [];\n\nif (__DEV__) {\n  Object.freeze(EMPTY_CALLS);\n  Object.freeze(EMPTY_DIRECTIVES);\n}\n\n/**\n * @internal\n *\n * Queries in Relay are represented as trees. Possible nodes include the root,\n * fields, and fragments. Fields can have children, or they can be leaf nodes.\n * Root and fragment nodes must always have children.\n *\n * `RelayQueryNode` provides access to information such as the field name,\n * generated alias, sub-fields, and call values.\n *\n * Nodes are immutable; query modification is supported via `clone`:\n *\n * ```\n * var next = prev.clone(prev.getChildren().filter(f => ...));\n * ```\n *\n * Note: Mediating access to actual query nodes is necessary so that we can\n * replace the current mutable GraphQL nodes with an immutable query\n * representation. This class *must not* mutate the underlying `concreteNode`.\n * Instead, use an instance variable (see `clone()`).\n *\n * TODO (#6937314): RelayQueryNode support for toJSON/fromJSON\n */\nclass RelayQueryNode {\n  constructor: Function; // for flow\n  __calls__: ?Array<Call>;\n  __children__: ?Array<RelayQueryNode>;\n  __concreteNode__: any;\n  __fieldMap__: ?{[key: string]: RelayQueryField};\n  __hasDeferredDescendant__: ?boolean;\n  __hasValidatedConnectionCalls__: ?boolean;\n  __route__: RelayMetaRoute;\n  __serializationKey__: ?string;\n  __storageKey__: ?string;\n  __variables__: Variables;\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQueryNode {\n    var node = createNode(concreteNode, route, variables);\n    invariant(\n      node instanceof RelayQueryNode,\n      'RelayQueryNode.create(): ' +\n      'Expected a GraphQL fragment, mutation, or query.'\n    );\n    return node;\n  }\n\n  /**\n   * @private\n   *\n   * Base class for all node types, must not be directly instantiated.\n   */\n  constructor(\n    concreteNode: any,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    invariant(\n      this.constructor.name !== 'RelayQueryNode',\n      'RelayQueryNode: Abstract class cannot be instantiated.'\n    );\n    this.__concreteNode__ = concreteNode;\n    this.__route__ = route;\n    this.__variables__ = variables;\n\n    // lazily computed properties\n    this.__calls__ = null;\n    this.__children__ = null;\n    this.__fieldMap__ = null;\n    this.__hasDeferredDescendant__ = null;\n    this.__hasValidatedConnectionCalls__ = null;\n    this.__serializationKey__ = null;\n    this.__storageKey__ = null;\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  isGenerated(): boolean {\n    return false;\n  }\n\n  isRefQueryDependency(): boolean {\n    return false;\n  }\n\n  clone(children: NextChildren): ?RelayQueryNode {\n    if (!this.canHaveSubselections()) {\n      // Compact new children *after* this check, for consistency.\n      invariant(\n        children.length === 0,\n        'RelayQueryNode: Cannot add children to field `%s` because it does ' +\n        'not support sub-selections (sub-fields).',\n        this instanceof RelayQueryField ? this.getSchemaName() : null\n      );\n      return this;\n    }\n\n    var prevChildren = this.getChildren();\n    var nextChildren = cloneChildren(prevChildren, children);\n\n    if (!nextChildren.length) {\n      return null;\n    } else if (nextChildren === prevChildren) {\n      return this;\n    }\n\n    var clone = RelayQueryNode.create(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__\n    );\n    clone.__children__ = nextChildren;\n    clone.__calls__ = this.__calls__;\n    clone.__serializationKey__ = this.__serializationKey__;\n    clone.__storageKey__ = this.__storageKey__;\n\n    return clone;\n  }\n\n  getChildren(): Array<RelayQueryNode> {\n    let children = this.__children__;\n    if (!children) {\n      const nextChildren = [];\n      const concreteChildren = (this.__concreteNode__: ConcreteNode).children;\n      if (concreteChildren) {\n        concreteChildren.forEach(concreteChild => {\n          if (concreteChild == null) {\n            return;\n          }\n          var node = createNode(\n            concreteChild,\n            this.__route__,\n            this.__variables__\n          );\n          if (node && node.isIncluded()) {\n            nextChildren.push(node);\n          }\n        });\n      }\n      this.__children__ = nextChildren;\n      children = nextChildren;\n    }\n    return children;\n  }\n\n  isIncluded(): boolean {\n    // Bail out early since most nodes won't have directives\n    if (!(this.__concreteNode__.directives: ConcreteNode)) {\n      return true;\n    }\n    return this.getDirectives().every(directive => {\n      if (directive.name === SKIP) {\n        return !directive.args.some(arg => arg.name === IF && !!arg.value);\n      } else if (directive.name === INCLUDE) {\n        return !directive.args.some(arg => arg.name === IF && !arg.value);\n      }\n      return true;\n    });\n  }\n\n  getDirectives(): Array<Directive> {\n    const concreteDirectives = (this.__concreteNode__: ConcreteNode).directives;\n    if (concreteDirectives) {\n      return this.__concreteNode__.directives.map(directive => {\n        return {\n          args: callsFromGraphQL(directive.args, this.__variables__),\n          name: directive.name,\n        };\n      });\n    }\n    return EMPTY_DIRECTIVES;\n  }\n\n  getField(field: RelayQueryField): ?RelayQueryField {\n    return this.getFieldByStorageKey(field.getStorageKey());\n  }\n\n  getFieldByStorageKey(storageKey: string): ?RelayQueryField {\n    var fieldMap = this.__fieldMap__;\n    if (!fieldMap) {\n      fieldMap = {};\n      var child;\n      var children = this.getChildren();\n      for (var ii = 0; ii < children.length; ii++) {\n        child = children[ii];\n        if (child instanceof RelayQueryField) {\n          fieldMap[child.getStorageKey()] = child;\n        }\n      }\n      this.__fieldMap__ = fieldMap;\n    }\n    return fieldMap[storageKey];\n  }\n\n  getType(): string {\n    return this.__concreteNode__.type;\n  }\n\n  getRoute(): RelayMetaRoute {\n    return this.__route__;\n  }\n\n  getVariables(): Variables {\n    return this.__variables__;\n  }\n\n  hasDeferredDescendant(): boolean {\n    var hasDeferredDescendant = this.__hasDeferredDescendant__;\n    if (hasDeferredDescendant == null) {\n      hasDeferredDescendant =\n        this.canHaveSubselections() &&\n        this.getChildren().some(child => child.hasDeferredDescendant());\n      this.__hasDeferredDescendant__ = hasDeferredDescendant;\n    }\n    return hasDeferredDescendant;\n  }\n\n  isAbstract(): boolean {\n    throw new Error('RelayQueryNode: Abstract function cannot be called.');\n  }\n\n  isRequisite(): boolean {\n    return false;\n  }\n\n  /**\n   * Determine if `this` and `that` are deeply equal.\n   */\n  equals(that: RelayQueryNode): boolean {\n    var thisChildren = this.getChildren();\n    var thatChildren = that.getChildren();\n\n    return thisChildren === thatChildren || (\n      thisChildren.length === thatChildren.length &&\n      thisChildren.every((c, ii) => c.equals(thatChildren[ii]))\n    );\n  }\n\n  /**\n   * Performs a fast comparison of whether `this` and `that` represent identical\n   * query nodes. Returns true only if the concrete nodes, routes, and variables\n   * are all the same.\n   *\n   * Note that it is possible that this method can return false in cases where\n   * `equals` would return true. This can happen when the concrete nodes are\n   * different but structurally identical, or when the route/variables are\n   * different but do not have an effect on the structure of the query.\n   */\n  isEquivalent(that: RelayQueryNode): boolean {\n    return (\n      this.__concreteNode__ === that.__concreteNode__ &&\n      this.__route__ === that.__route__ &&\n      shallowEqual(this.__variables__, that.__variables__)\n    );\n  }\n\n  createNode(concreteNode: any): RelayQueryNode {\n    return RelayQueryNode.create(\n      concreteNode,\n      this.__route__,\n      this.__variables__\n    );\n  }\n\n  getConcreteQueryNode(): any {\n    return this.__concreteNode__;\n  }\n}\n\n/**\n * @internal\n *\n * Wraps access to query root nodes.\n */\nclass RelayQueryRoot extends RelayQueryNode {\n  __batchCall__: ?BatchCall;\n  __id__: ?string;\n  __identifyingArg__: ?Call;\n  __storageKey__: ?string;\n\n  /**\n   * Helper to construct a new root query with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build(\n    name: string,\n    fieldName: string,\n    value: mixed,\n    children: ?Array<RelayQueryNode>,\n    metadata: ConcreteQueryMetadata,\n    type: string\n  ): RelayQueryRoot {\n    const nextChildren = children ? children.filter(child => !!child) : [];\n    const batchCallVariable = QueryBuilder.getBatchCallVariable(value);\n    let identifyingArgValue;\n    if (batchCallVariable) {\n      identifyingArgValue = batchCallVariable;\n    } else if (Array.isArray(value)) {\n      identifyingArgValue = value.map(QueryBuilder.createCallValue);\n    } else if (value) {\n      identifyingArgValue = QueryBuilder.createCallValue(value);\n    }\n    const concreteRoot = QueryBuilder.createQuery({\n      fieldName,\n      identifyingArgValue,\n      metadata,\n      name,\n      type,\n    });\n    var root = new RelayQueryRoot(\n      concreteRoot,\n      RelayMetaRoute.get('$RelayQuery'),\n      {}\n    );\n    root.__children__ = nextChildren;\n    return root;\n  }\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQueryRoot {\n    const query = QueryBuilder.getQuery(concreteNode);\n    invariant(\n      query,\n      'RelayQueryRoot.create(): Expected a GraphQL `query { ... }`, got: %s',\n      concreteNode\n    );\n    return new RelayQueryRoot(\n      query,\n      route,\n      variables\n    );\n  }\n\n  constructor(\n    concreteNode: ConcreteQuery,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    super(concreteNode, route, variables);\n    this.__batchCall__ = undefined;\n    this.__id__ = undefined;\n    this.__identifyingArg__ = undefined;\n    this.__storageKey__ = undefined;\n\n    // Ensure IDs are generated in the order that queries are created\n    this.getID();\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  getName(): string {\n    let name = (this.__concreteNode__: ConcreteQuery).name;\n    if (!name) {\n      name = this.getID();\n      (this.__concreteNode__: ConcreteQuery).name = name;\n    }\n    return name;\n  }\n\n  getID(): string {\n    var id = this.__id__;\n    if (id == null) {\n      id = 'q' + _nextQueryID++;\n      this.__id__ = id;\n    }\n    return id;\n  }\n\n  getBatchCall(): ?BatchCall {\n    let batchCall = this.__batchCall__;\n    if (batchCall === undefined) {\n      const concreteCalls = (this.__concreteNode__: ConcreteQuery).calls;\n      if (concreteCalls) {\n        var callArg = concreteCalls[0] && concreteCalls[0].value;\n        if (\n          callArg != null &&\n          !Array.isArray(callArg) &&\n          callArg.kind === 'BatchCallVariable'\n        ) {\n          batchCall = {\n            refParamName: 'ref_' + callArg.sourceQueryID,\n            sourceQueryID: callArg.sourceQueryID,\n            sourceQueryPath: callArg.jsonPath,\n          };\n        }\n      }\n      batchCall = batchCall || null;\n      this.__batchCall__ = batchCall;\n    }\n    return batchCall;\n  }\n\n  getCallsWithValues(): Array<Call> {\n    let calls = this.__calls__;\n    if (!calls) {\n      const concreteCalls = (this.__concreteNode__: ConcreteQuery).calls;\n      if (concreteCalls) {\n        calls = callsFromGraphQL(concreteCalls, this.__variables__);\n      } else {\n        calls = EMPTY_CALLS;\n      }\n      this.__calls__ = calls;\n    }\n    return calls;\n  }\n\n  getFieldName(): string {\n    return (this.__concreteNode__: ConcreteQuery).fieldName;\n  }\n\n  getIdentifyingArg(): ?Call {\n    let identifyingArg = this.__identifyingArg__;\n    if (!identifyingArg) {\n      const metadata = (this.__concreteNode__: ConcreteQuery).metadata;\n      const identifyingArgName = metadata.identifyingArgName;\n      if (identifyingArgName != null) {\n        identifyingArg =\n          this.getCallsWithValues().find(c => c.name === identifyingArgName);\n        if (identifyingArg && metadata.identifyingArgType != null) {\n          identifyingArg.type = metadata.identifyingArgType;\n        }\n        this.__identifyingArg__ = identifyingArg;\n      }\n    }\n    return identifyingArg;\n  }\n\n  getStorageKey(): string {\n    let storageKey = this.__storageKey__;\n    if (!storageKey) {\n      let args = this.getCallsWithValues();\n      const identifyingArg = this.getIdentifyingArg();\n      if (identifyingArg) {\n        args = args.filter(arg => arg !== identifyingArg);\n      }\n      const field = RelayQueryField.build({\n        fieldName: this.getFieldName(),\n        calls: args,\n        type: this.getType(),\n      });\n      storageKey = field.getStorageKey();\n      this.__storageKey__ = storageKey;\n    }\n    return storageKey;\n  }\n\n  hasDeferredDescendant(): boolean {\n    return this.isDeferred() || super.hasDeferredDescendant();\n  }\n\n  isAbstract(): boolean {\n    return !!(this.__concreteNode__: ConcreteQuery).metadata.isAbstract;\n  }\n\n  isDeferred(): boolean {\n    return !!(this.__concreteNode__: ConcreteQuery).isDeferred;\n  }\n\n  isPlural(): boolean {\n    return !!(this.__concreteNode__: ConcreteQuery).metadata.isPlural;\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryRoot)) {\n      return false;\n    }\n    if (!areEqual(this.getBatchCall(), that.getBatchCall())) {\n      return false;\n    }\n    if (\n      this.getFieldName() !== that.getFieldName() ||\n      !areEqual(this.getCallsWithValues(), that.getCallsWithValues())\n    ) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Abstract base class for mutations and subscriptions.\n */\nclass RelayQueryOperation extends RelayQueryNode {\n  __callVariableName__: string;\n\n  constructor(\n    concreteNode: any,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    super(concreteNode, route, variables);\n    invariant(\n      this.constructor.name !== 'RelayQueryOperation',\n      'RelayQueryOperation: Abstract class cannot be instantiated.'\n    );\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  getName(): string {\n    return (this.__concreteNode__: ConcreteMutation).name;\n  }\n\n  getResponseType(): string {\n    return (this.__concreteNode__: ConcreteMutation).responseType;\n  }\n\n  getType(): string {\n    return this.getResponseType();\n  }\n\n  getInputType(): string {\n    const inputType =\n      (this.__concreteNode__: ConcreteMutation).metadata.inputType;\n    invariant(\n      inputType,\n      'RelayQuery: Expected operation `%s` to be annotated with the type of ' +\n      'its argument. Either the babel transform was configured incorrectly, ' +\n      'or the schema failed to define an argument for this mutation.',\n      this.getCall().name\n    );\n    return inputType;\n  }\n\n  getCall(): Call {\n    let calls = this.__calls__;\n    if (!calls) {\n      const concreteCalls = (this.__concreteNode__: ConcreteMutation).calls;\n      if (concreteCalls) {\n        calls = callsFromGraphQL(concreteCalls, this.__variables__);\n      } else {\n        calls = EMPTY_CALLS;\n      }\n      this.__calls__ = calls;\n    }\n    return calls[0];\n  }\n\n  getCallVariableName(): string {\n    if (!this.__callVariableName__) {\n      const concreteCalls = (this.__concreteNode__: ConcreteMutation).calls;\n      const callVariable =\n        concreteCalls && QueryBuilder.getCallVariable(concreteCalls[0].value);\n      invariant(\n        callVariable,\n        'RelayQuery: Expected mutation to have a single argument.'\n      );\n      this.__callVariableName__ = callVariable.callVariableName;\n    }\n    return this.__callVariableName__;\n  }\n\n  /**\n   * Mutations and subscriptions must have a concrete type due to the need for\n   * requisite top-level fields.\n   */\n  isAbstract(): boolean {\n    return false;\n  }\n}\n\n/**\n * @internal\n *\n * Represents a GraphQL mutation.\n */\nclass RelayQueryMutation extends RelayQueryOperation {\n  /**\n   * Helper to construct a new mutation with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build(\n    name: string,\n    responseType: string,\n    callName: string,\n    callValue?: ?mixed,\n    children?: ?Array<RelayQueryNode>,\n    metadata?: ?ConcreteOperationMetadata\n  ): RelayQueryMutation {\n    var nextChildren = children ? children.filter(child => !!child) : [];\n    var concreteMutation = QueryBuilder.createMutation({\n      calls: [QueryBuilder.createCall(\n        callName,\n        QueryBuilder.createCallVariable('input')\n      )],\n      metadata,\n      name,\n      responseType,\n    });\n    var mutation = new RelayQueryMutation(\n      concreteMutation,\n      RelayMetaRoute.get('$RelayQuery'),\n      {input: callValue || ''}\n    );\n    mutation.__children__ = nextChildren;\n    return mutation;\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryMutation)) {\n      return false;\n    }\n    if (!areEqual(this.getResponseType(), that.getResponseType())) {\n      return false;\n    }\n    if (!areEqual(this.getCall(), that.getCall())) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a GraphQL subscription.\n */\nclass RelayQuerySubscription extends RelayQueryOperation {\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQuerySubscription {\n    const subscription = QueryBuilder.getSubscription(concreteNode);\n    invariant(\n      subscription,\n      'RelayQuerySubscription.create(): ' +\n      'Expected a GraphQL `subscription { ... }`, got: %s',\n      concreteNode\n    );\n    return new RelayQuerySubscription(\n      concreteNode,\n      route,\n      variables\n    );\n  }\n\n  getPublishedPayloadType(): string {\n    return this.getResponseType();\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQuerySubscription)) {\n      return false;\n    }\n    if (\n      !areEqual(this.getPublishedPayloadType(), that.getPublishedPayloadType())\n    ) {\n      return false;\n    }\n    if (!areEqual(this.getCall(), that.getCall())) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Wraps access to query fragments.\n */\nclass RelayQueryFragment extends RelayQueryNode {\n  __compositeHash__: ?string;\n  __metadata__: FragmentMetadata;\n\n  /**\n   * Helper to construct a new fragment with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build(\n    name: string,\n    type: string,\n    children?: ?Array<RelayQueryNode>,\n    metadata?: ?{[key: string]: mixed}\n  ): RelayQueryFragment {\n    var nextChildren = children ? children.filter(child => !!child) : [];\n    var concreteFragment = QueryBuilder.createFragment({\n      name,\n      type,\n      metadata,\n    });\n    var fragment = new RelayQueryFragment(\n      concreteFragment,\n      RelayMetaRoute.get('$RelayQuery'),\n      {},\n      {\n        isDeferred: !!(metadata && metadata.isDeferred),\n        isContainerFragment: !!(metadata && metadata.isContainerFragment),\n      }\n    );\n    fragment.__children__ = nextChildren;\n    return fragment;\n  }\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables,\n    metadata?: ?FragmentMetadata\n  ): RelayQueryFragment {\n    const fragment = QueryBuilder.getFragment(concreteNode);\n    invariant(\n      fragment,\n      'RelayQueryFragment.create(): ' +\n      'Expected a GraphQL `fragment { ... }`, got: %s',\n      concreteNode\n    );\n    return createMemoizedFragment(\n      fragment,\n      route,\n      variables,\n      metadata || DEFAULT_FRAGMENT_METADATA\n    );\n  }\n\n  constructor(\n    concreteNode: ConcreteFragment,\n    route: RelayMetaRoute,\n    variables: Variables,\n    metadata?: FragmentMetadata\n  ) {\n    super(concreteNode, route, variables);\n    this.__compositeHash__ = null;\n    this.__metadata__ = metadata || DEFAULT_FRAGMENT_METADATA;\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  getDebugName(): string {\n    return (this.__concreteNode__: ConcreteFragment).name;\n  }\n\n  /**\n   * The \"concrete fragment id\" uniquely identifies a Relay.QL`fragment ...`\n   * within the source code of an application and will remain the same across\n   * runs of a particular version of an application.\n   */\n  getConcreteFragmentID(): string {\n    return (this.__concreteNode__: ConcreteFragment).id;\n  }\n\n  /**\n   * The \"composite hash\" is similar to the concrete instance hash, but it also\n   * differentiates between varying variable values or route names.\n   *\n   * The composite hash is used to:\n   * - Avoid printing the same fragment twice, in order to reduce upload size.\n   * - Remember which deferred fragment/data pairs have been fetched.\n   */\n  getCompositeHash(): string {\n    let compositeHash = this.__compositeHash__;\n    if (!compositeHash) {\n      // TODO: Simplify this hash function, #9599170.\n      compositeHash = generateRQLFieldAlias(\n        this.getConcreteFragmentID() +\n        '.' + this.__route__.name +\n        '.' + stableStringify(this.__variables__)\n      );\n      this.__compositeHash__ = compositeHash;\n    }\n    return compositeHash;\n  }\n\n  isAbstract(): boolean {\n    return !!(this.__concreteNode__: ConcreteFragment).metadata.isAbstract;\n  }\n\n  isDeferred(): boolean {\n    return this.__metadata__.isDeferred;\n  }\n\n  isPattern(): boolean {\n    return !!(this.__concreteNode__: ConcreteFragment).metadata.pattern;\n  }\n\n  isPlural(): boolean {\n    const metadata = (this.__concreteNode__: ConcreteFragment).metadata;\n    return !!(\n      metadata.isPlural ||  // FB Printer\n      metadata.plural       // OSS Printer from `@relay`\n    );\n  }\n\n  cloneAsPlainFragment(): RelayQueryFragment {\n    return createMemoizedFragment(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__,\n      DEFAULT_FRAGMENT_METADATA\n    );\n  }\n\n  isContainerFragment(): boolean {\n    return this.__metadata__.isContainerFragment;\n  }\n\n  hasDeferredDescendant(): boolean {\n    return this.isDeferred() || super.hasDeferredDescendant();\n  }\n\n  clone(children: NextChildren): ?RelayQueryNode {\n    var clone = super.clone(children);\n    if (clone !== this &&\n        clone instanceof RelayQueryFragment) {\n      clone.__concreteNode__ = {\n        ...clone.__concreteNode__,\n        id: generateConcreteFragmentID(),\n      };\n      clone.__metadata__ = {\n        ...this.__metadata__,\n      };\n    }\n    return clone;\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryFragment)) {\n      return false;\n    }\n    if (this.getType() !== that.getType()) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Wraps access to query fields.\n */\nclass RelayQueryField extends RelayQueryNode {\n  __debugName__: ?string;\n  __isRefQueryDependency__: boolean;\n  __rangeBehaviorKey__: ?string;\n  __shallowHash__: ?string;\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQueryField {\n    const field = QueryBuilder.getField(concreteNode);\n    invariant(\n      field,\n      'RelayQueryField.create(): Expected a GraphQL field, got: %s',\n      concreteNode\n    );\n    return new RelayQueryField(\n      field,\n      route,\n      variables\n    );\n  }\n\n  /**\n   * Helper to construct a new field with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build({\n    alias,\n    directives,\n    calls,\n    children,\n    fieldName,\n    metadata,\n    type,\n  }: {\n    alias?: ?string;\n    directives?: ?Array<Directive>;\n    calls?: ?Array<Call>;\n    children?: ?NextChildren;\n    fieldName: string;\n    metadata?: ?ConcreteFieldMetadata;\n    type: string;\n  }): RelayQueryField {\n    var nextChildren = children ? children.filter(child => !!child) : [];\n    var concreteField = QueryBuilder.createField({\n      alias,\n      calls: calls ? callsToGraphQL(calls) : null,\n      directives: directives ? directivesToGraphQL(directives) : null,\n      fieldName,\n      metadata,\n      type,\n    });\n    var field = new RelayQueryField(\n      concreteField,\n      RelayMetaRoute.get('$RelayQuery'),\n      {}\n    );\n    field.__children__ = nextChildren;\n    return field;\n  }\n\n  constructor(\n    concreteNode: ConcreteField,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    super(concreteNode, route, variables);\n    this.__debugName__ = undefined;\n    this.__isRefQueryDependency__ = false;\n    this.__rangeBehaviorKey__ = undefined;\n    this.__shallowHash__ = undefined;\n  }\n\n  canHaveSubselections(): boolean {\n    return !!(\n      (this.__concreteNode__: ConcreteField).metadata.canHaveSubselections\n    );\n  }\n\n  isAbstract(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isAbstract;\n  }\n\n  isFindable(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isFindable;\n  }\n\n  isGenerated(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isGenerated;\n  }\n\n  isConnection(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isConnection;\n  }\n\n  isConnectionWithoutNodeID(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata\n      .isConnectionWithoutNodeID;\n  }\n\n  isPlural(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isPlural;\n  }\n\n  isRefQueryDependency(): boolean {\n    return this.__isRefQueryDependency__;\n  }\n\n  isRequisite(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isRequisite;\n  }\n\n  getDebugName(): string {\n    let debugName = this.__debugName__;\n    if (!debugName) {\n      debugName = this.getSchemaName();\n      let printedCoreArgs;\n      this.getCallsWithValues().forEach(arg => {\n        if (this._isCoreArg(arg)) {\n          printedCoreArgs = printedCoreArgs || [];\n          printedCoreArgs.push(serializeRelayQueryCall(arg));\n        }\n      });\n      if (printedCoreArgs) {\n        debugName += printedCoreArgs.sort().join('');\n      }\n      this.__debugName__ = debugName;\n    }\n    return debugName;\n  }\n\n  /**\n   * The canonical name for the referenced field in the schema.\n   */\n  getSchemaName(): string {\n    return (this.__concreteNode__: ConcreteField).fieldName;\n  }\n\n  /**\n   * A string representing the range behavior eligible arguments associated with\n   * this field. Arguments will be sorted.\n   *\n   * Non-core arguments (like connection and identifying arguments) are dropped.\n   *   `field(first: 10, foo: \"bar\", baz: \"bat\")` => `'baz(bat).foo(bar)'`\n   *   `username(name: \"steve\")`                  => `''`\n   */\n  getRangeBehaviorKey(): string {\n    invariant(\n      this.isConnection(),\n      'RelayQueryField: Range behavior keys are associated exclusively with ' +\n      'connection fields. `getRangeBehaviorKey()` was called on the ' +\n      'non-connection field `%s`.',\n      this.getSchemaName()\n    );\n    let rangeBehaviorKey = this.__rangeBehaviorKey__;\n    if (rangeBehaviorKey == null) {\n      const printedCoreArgs = [];\n      this.getCallsWithValues().forEach(arg => {\n        if (this._isCoreArg(arg)) {\n          printedCoreArgs.push(serializeRelayQueryCall(arg));\n        }\n      });\n      rangeBehaviorKey = printedCoreArgs.sort().join('').slice(1);\n      this.__rangeBehaviorKey__ = rangeBehaviorKey;\n    }\n    return rangeBehaviorKey;\n  }\n\n  /**\n   * The name for the field when serializing the query or interpreting query\n   * responses from the server. The serialization key is derived from\n   * all calls/values and hashed for compactness.\n   *\n   * Given the GraphQL\n   *   `field(first: 10, foo: \"bar\", baz: \"bat\")`, or\n   *   `field(baz: \"bat\", foo: \"bar\", first: 10)`\n   *\n   * ...the following serialization key will be produced:\n   *   `generateRQLFieldAlias('field.bar(bat).first(10).foo(bar)')`\n   */\n  getSerializationKey(): string {\n    let serializationKey = this.__serializationKey__;\n    if (!serializationKey) {\n      serializationKey = generateRQLFieldAlias(\n        this.getSchemaName() +\n        this.getCallsWithValues()\n          .map(serializeRelayQueryCall)\n          .sort()\n          .join('')\n      );\n      this.__serializationKey__ = serializationKey;\n    }\n    return serializationKey;\n  }\n\n  /**\n   * Returns a hash of the field name and all argument values.\n   */\n  getShallowHash(): string {\n    let shallowHash = this.__shallowHash__;\n    if (!shallowHash) {\n      this.__shallowHash__ = shallowHash =\n        this.getSchemaName() +\n        serializeCalls(this.getCallsWithValues());\n    }\n    return shallowHash;\n  }\n\n  /**\n   * The name which Relay internals can use to reference this field, without\n   * collisions.\n   *\n   * Given the GraphQL\n   *   `field(first: 10, foo: \"bar\", baz: \"bat\")`, or\n   *   `field(baz: \"bat\", foo: \"bar\", first: 10)`\n   *\n   * ...the following storage key will be produced:\n   *   `'field{bar:\"bat\",foo:\"bar\"}'`\n   */\n  getStorageKey(): string {\n    let storageKey = this.__storageKey__;\n    if (!storageKey) {\n      this.__storageKey__ = storageKey =\n        this.getSchemaName() +\n        serializeCalls(\n          this.getCallsWithValues().filter(call => this._isCoreArg(call))\n        );\n    }\n    return storageKey;\n  }\n\n  /**\n   * The name by which this field's results should be made available to the\n   * application.\n   */\n  getApplicationName(): string {\n    const concreteNode = (this.__concreteNode__: ConcreteField);\n    return concreteNode.alias || concreteNode.fieldName;\n  }\n\n  getInferredRootCallName(): ?string {\n    return (this.__concreteNode__: ConcreteField).metadata.inferredRootCallName;\n  }\n\n  getInferredPrimaryKey(): ?string {\n    return (this.__concreteNode__: ConcreteField).metadata.inferredPrimaryKey;\n  }\n\n  getCallsWithValues(): Array<Call> {\n    let calls = this.__calls__;\n    if (!calls) {\n      const concreteCalls = (this.__concreteNode__: ConcreteField).calls;\n      if (concreteCalls) {\n        calls = callsFromGraphQL(concreteCalls, this.__variables__);\n      } else {\n        calls = EMPTY_CALLS;\n      }\n      this.__calls__ = calls;\n    }\n    return calls;\n  }\n\n  getCallType(callName: string): ?string {\n    const concreteCalls = (this.__concreteNode__: ConcreteField).calls;\n    const concreteCall = concreteCalls && concreteCalls.filter(\n      call => call.name === callName\n    )[0];\n    if (concreteCall) {\n      return concreteCall.metadata.type;\n    }\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryField)) {\n      return false;\n    }\n    if (\n      this.getSchemaName() !== that.getSchemaName() ||\n      this.getApplicationName() !== that.getApplicationName() ||\n      !areEqual(this.getCallsWithValues(), that.getCallsWithValues())\n    ) {\n      return false;\n    }\n    return super.equals(that);\n  }\n\n  cloneAsRefQueryDependency(): RelayQueryField {\n    var field = new RelayQueryField(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__\n    );\n    field.__children__ = [];\n    field.__isRefQueryDependency__ = true;\n    return field;\n  }\n\n  cloneFieldWithCalls(\n    children: NextChildren,\n    calls: Array<Call>\n  ): ?RelayQueryField {\n    if (!this.canHaveSubselections()) {\n      // Compact new children *after* this check, for consistency.\n      invariant(\n        children.length === 0,\n        'RelayQueryNode: Cannot add children to field `%s` because it does ' +\n        'not support sub-selections (sub-fields).',\n        this.getSchemaName()\n      );\n    }\n\n    // use `clone()` if call values do not change\n    if (areEqual(this.getCallsWithValues(), calls)) {\n      var clone: RelayQueryField = (this.clone(children): any);\n      return clone;\n    }\n\n    var nextChildren = cloneChildren(this.getChildren(), children);\n    if (!nextChildren.length) {\n      return null;\n    }\n\n    var field = new RelayQueryField(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__\n    );\n    field.__children__ = nextChildren;\n    field.__calls__ = calls;\n\n    return field;\n  }\n\n  /**\n   * The following types of arguments are non-core:\n   * - Range calls such as `first` or `find` on connections.\n   * - Conditionals when the field is present.\n   */\n  _isCoreArg(arg: Call): boolean {\n    return (\n      // `name(if:true)`, `name(unless:false)`, and `name` are equivalent.\n      !(arg.name === IF && (String(arg.value) === TRUE)) &&\n      !(arg.name === UNLESS && (String(arg.value) === FALSE)) &&\n      // Connection arguments can be stripped out.\n      !(this.isConnection() && RelayConnectionInterface.isConnectionCall(arg))\n    );\n  }\n}\n\nfunction createNode(\n  concreteNode: mixed,\n  route: RelayMetaRoute,\n  variables: Variables\n): ?RelayQueryNode {\n  invariant(\n    typeof concreteNode === 'object' &&\n    concreteNode !== null,\n    'RelayQueryNode: Expected a GraphQL object created with `Relay.QL`, got' +\n    '`%s`.',\n    concreteNode\n  );\n  const kind = concreteNode.kind;\n  let type = RelayQueryNode;\n  if (kind === 'Field') {\n    type = RelayQueryField;\n  } else if (kind === 'Fragment') {\n    type = RelayQueryFragment;\n  } else if (kind === 'FragmentReference') {\n    type = RelayQueryFragment;\n    const fragment = QueryBuilder.getFragment(concreteNode.fragment);\n    // TODO #9171213: Reference directives should override fragment directives\n    if (fragment) {\n      return createMemoizedFragment(\n        fragment,\n        route,\n        {},\n        {\n          isDeferred: false,\n          isContainerFragment: true,\n        }\n      );\n    }\n  } else if (kind === 'Query') {\n    type = RelayQueryRoot;\n  } else if (kind === 'Mutation') {\n    type = RelayQueryMutation;\n  } else if (kind === 'Subscription') {\n    type = RelayQuerySubscription;\n  } else if (concreteNode instanceof RelayRouteFragment) {\n    const fragment = concreteNode.getFragmentForRoute(route);\n    if (fragment) {\n      // may be null if no value was defined for this route.\n      return createNode(\n        fragment,\n        route,\n        variables\n      );\n    }\n    return null;\n  } else if (concreteNode instanceof RelayFragmentReference) {\n    const fragment = concreteNode.getFragment(variables);\n    const fragmentVariables = concreteNode.getVariables(route, variables);\n    if (fragment) {\n      // the fragment may be null when `if` or `unless` conditions are not met.\n      return createMemoizedFragment(\n        fragment,\n        route,\n        fragmentVariables,\n        {\n          isDeferred: concreteNode.isDeferred(),\n          isContainerFragment: concreteNode.isContainerFragment(),\n        }\n      );\n    }\n    return null;\n  } else {\n  }\n  return new type(\n    (concreteNode: any),\n    route,\n    variables\n  );\n}\n\n/**\n * Memoizes the `RelayQueryFragment` equivalent of a given GraphQL fragment\n * for the given route, variables, and deferred status.\n */\nfunction createMemoizedFragment(\n  concreteFragment: ConcreteFragment,\n  route: RelayMetaRoute,\n  variables: Variables,\n  metadata: FragmentMetadata\n): RelayQueryFragment {\n  var cacheKey = route.name + ':' + stableStringify(variables) + ':' +\n    stableStringify(metadata);\n  var fragment = (concreteFragment: any).__cachedFragment__;\n  var fragmentCacheKey = (concreteFragment: any).__cacheKey__;\n  if (!fragment || fragmentCacheKey !== cacheKey) {\n    fragment = new RelayQueryFragment(\n      concreteFragment,\n      route,\n      variables,\n      metadata\n    );\n    (concreteFragment: any).__cachedFragment__ = fragment;\n    (concreteFragment: any).__cacheKey__ = cacheKey;\n  }\n  return fragment;\n}\n\n/**\n * Compacts new children and compares them to the previous children.\n * - If all items are equal, returns previous array\n * - If any items differ, returns new array\n */\nfunction cloneChildren(\n  prevChildren: Array<RelayQueryNode>,\n  nextChildren: NextChildren\n): Array<RelayQueryNode> {\n  var children = [];\n  var isSameChildren = true;\n\n  var prevIndex = 0;\n  for (var ii = 0; ii < nextChildren.length; ii++) {\n    var child = nextChildren[ii];\n    if (child) {\n      children.push(child);\n      isSameChildren = isSameChildren && child === prevChildren[prevIndex++];\n    }\n  }\n\n  if (isSameChildren && children.length === prevChildren.length) {\n    return prevChildren;\n  } else {\n    return children;\n  }\n}\n\n/**\n * Creates an opaque serialization of calls.\n */\nfunction serializeCalls(calls: Array<Call>): string {\n  if (calls.length) {\n    const callMap = {};\n    calls.forEach(call => {\n      callMap[call.name] = call.value;\n    });\n    return stableStringify(callMap);\n  } else {\n    return '';\n  }\n}\n\nRelayProfiler.instrumentMethods(RelayQueryNode.prototype, {\n  clone: '@RelayQueryNode.prototype.clone',\n  equals: '@RelayQueryNode.prototype.equals',\n  getChildren: '@RelayQueryNode.prototype.getChildren',\n  getDirectives: '@RelayQueryNode.prototype.getDirectives',\n  hasDeferredDescendant: '@RelayQueryNode.prototype.hasDeferredDescendant',\n  getFieldByStorageKey: '@RelayQueryNode.prototype.getFieldByStorageKey',\n});\n\nRelayProfiler.instrumentMethods(RelayQueryField.prototype, {\n  getStorageKey: '@RelayQueryField.prototype.getStorageKey',\n  getSerializationKey: '@RelayQueryField.prototype.getSerializationKey',\n});\n\nmodule.exports = {\n  Field: RelayQueryField,\n  Fragment: RelayQueryFragment,\n  Mutation: RelayQueryMutation,\n  Node: RelayQueryNode,\n  Operation: RelayQueryOperation,\n  Root: RelayQueryRoot,\n  Subscription: RelayQuerySubscription,\n};\n","dependencies":["ConcreteQuery","RelayInternalTypes","RelayTypes","QueryBuilder","RelayConnectionInterface","RelayFragmentReference","RelayMetaRoute","RelayProfiler","RelayRouteFragment","areEqual","callsFromGraphQL","callsToGraphQL","directivesToGraphQL","generateConcreteFragmentID","generateRQLFieldAlias","invariant","serializeRelayQueryCall","shallowEqual","stableStringify","RelayQuery"],"id":"RelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteField,\n  ConcreteFieldMetadata,\n  ConcreteFragment,\n  ConcreteMutation,\n  ConcreteNode,\n  ConcreteOperationMetadata,\n  ConcreteQuery,\n  ConcreteQueryMetadata,\n} from 'ConcreteQuery';\nconst QueryBuilder = require('QueryBuilder');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayFragmentReference = require('RelayFragmentReference');\nimport type {Call, Directive}  from 'RelayInternalTypes';\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayRouteFragment = require('RelayRouteFragment');\nimport type {Variables} from 'RelayTypes';\n\nconst areEqual = require('areEqual');\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst callsToGraphQL = require('callsToGraphQL');\nconst directivesToGraphQL = require('directivesToGraphQL');\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst generateRQLFieldAlias = require('generateRQLFieldAlias');\nconst invariant = require('invariant');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\nconst shallowEqual = require('shallowEqual');\nconst stableStringify = require('stableStringify');\n\ntype BatchCall = {\n  refParamName: string;\n  sourceQueryID: string;\n  sourceQueryPath: string;\n};\ntype FragmentMetadata = {\n  isDeferred: boolean;\n  isContainerFragment: boolean;\n};\n// TODO: replace once #6525923 is resolved\ntype NextChildren = Array<any>;\n\n// conditional field calls/values\nconst IF = 'if';\nconst UNLESS = 'unless';\nconst TRUE = 'true';\nconst FALSE = 'false';\nconst SKIP = 'skip';\nconst INCLUDE = 'include';\n\nlet _nextQueryID = 0;\n\nconst DEFAULT_FRAGMENT_METADATA = {\n  isDeferred: false,\n  isContainerFragment: false,\n};\nconst EMPTY_DIRECTIVES = [];\nconst EMPTY_CALLS = [];\n\nif (__DEV__) {\n  Object.freeze(EMPTY_CALLS);\n  Object.freeze(EMPTY_DIRECTIVES);\n}\n\n/**\n * @internal\n *\n * Queries in Relay are represented as trees. Possible nodes include the root,\n * fields, and fragments. Fields can have children, or they can be leaf nodes.\n * Root and fragment nodes must always have children.\n *\n * `RelayQueryNode` provides access to information such as the field name,\n * generated alias, sub-fields, and call values.\n *\n * Nodes are immutable; query modification is supported via `clone`:\n *\n * ```\n * var next = prev.clone(prev.getChildren().filter(f => ...));\n * ```\n *\n * Note: Mediating access to actual query nodes is necessary so that we can\n * replace the current mutable GraphQL nodes with an immutable query\n * representation. This class *must not* mutate the underlying `concreteNode`.\n * Instead, use an instance variable (see `clone()`).\n *\n * TODO (#6937314): RelayQueryNode support for toJSON/fromJSON\n */\nclass RelayQueryNode {\n  constructor: Function; // for flow\n  __calls__: ?Array<Call>;\n  __children__: ?Array<RelayQueryNode>;\n  __concreteNode__: any;\n  __fieldMap__: ?{[key: string]: RelayQueryField};\n  __hasDeferredDescendant__: ?boolean;\n  __hasValidatedConnectionCalls__: ?boolean;\n  __route__: RelayMetaRoute;\n  __serializationKey__: ?string;\n  __storageKey__: ?string;\n  __variables__: Variables;\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQueryNode {\n    var node = createNode(concreteNode, route, variables);\n    invariant(\n      node instanceof RelayQueryNode,\n      'RelayQueryNode.create(): ' +\n      'Expected a GraphQL fragment, mutation, or query.'\n    );\n    return node;\n  }\n\n  /**\n   * @private\n   *\n   * Base class for all node types, must not be directly instantiated.\n   */\n  constructor(\n    concreteNode: any,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    invariant(\n      this.constructor.name !== 'RelayQueryNode',\n      'RelayQueryNode: Abstract class cannot be instantiated.'\n    );\n    this.__concreteNode__ = concreteNode;\n    this.__route__ = route;\n    this.__variables__ = variables;\n\n    // lazily computed properties\n    this.__calls__ = null;\n    this.__children__ = null;\n    this.__fieldMap__ = null;\n    this.__hasDeferredDescendant__ = null;\n    this.__hasValidatedConnectionCalls__ = null;\n    this.__serializationKey__ = null;\n    this.__storageKey__ = null;\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  isGenerated(): boolean {\n    return false;\n  }\n\n  isRefQueryDependency(): boolean {\n    return false;\n  }\n\n  clone(children: NextChildren): ?RelayQueryNode {\n    if (!this.canHaveSubselections()) {\n      // Compact new children *after* this check, for consistency.\n      invariant(\n        children.length === 0,\n        'RelayQueryNode: Cannot add children to field `%s` because it does ' +\n        'not support sub-selections (sub-fields).',\n        this instanceof RelayQueryField ? this.getSchemaName() : null\n      );\n      return this;\n    }\n\n    var prevChildren = this.getChildren();\n    var nextChildren = cloneChildren(prevChildren, children);\n\n    if (!nextChildren.length) {\n      return null;\n    } else if (nextChildren === prevChildren) {\n      return this;\n    }\n\n    var clone = RelayQueryNode.create(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__\n    );\n    clone.__children__ = nextChildren;\n    clone.__calls__ = this.__calls__;\n    clone.__serializationKey__ = this.__serializationKey__;\n    clone.__storageKey__ = this.__storageKey__;\n\n    return clone;\n  }\n\n  getChildren(): Array<RelayQueryNode> {\n    let children = this.__children__;\n    if (!children) {\n      const nextChildren = [];\n      const concreteChildren = (this.__concreteNode__: ConcreteNode).children;\n      if (concreteChildren) {\n        concreteChildren.forEach(concreteChild => {\n          if (concreteChild == null) {\n            return;\n          }\n          var node = createNode(\n            concreteChild,\n            this.__route__,\n            this.__variables__\n          );\n          if (node && node.isIncluded()) {\n            nextChildren.push(node);\n          }\n        });\n      }\n      this.__children__ = nextChildren;\n      children = nextChildren;\n    }\n    return children;\n  }\n\n  isIncluded(): boolean {\n    // Bail out early since most nodes won't have directives\n    if (!(this.__concreteNode__.directives: ConcreteNode)) {\n      return true;\n    }\n    return this.getDirectives().every(directive => {\n      if (directive.name === SKIP) {\n        return !directive.args.some(arg => arg.name === IF && !!arg.value);\n      } else if (directive.name === INCLUDE) {\n        return !directive.args.some(arg => arg.name === IF && !arg.value);\n      }\n      return true;\n    });\n  }\n\n  getDirectives(): Array<Directive> {\n    const concreteDirectives = (this.__concreteNode__: ConcreteNode).directives;\n    if (concreteDirectives) {\n      return this.__concreteNode__.directives.map(directive => {\n        return {\n          args: callsFromGraphQL(directive.args, this.__variables__),\n          name: directive.name,\n        };\n      });\n    }\n    return EMPTY_DIRECTIVES;\n  }\n\n  getField(field: RelayQueryField): ?RelayQueryField {\n    return this.getFieldByStorageKey(field.getStorageKey());\n  }\n\n  getFieldByStorageKey(storageKey: string): ?RelayQueryField {\n    var fieldMap = this.__fieldMap__;\n    if (!fieldMap) {\n      fieldMap = {};\n      var child;\n      var children = this.getChildren();\n      for (var ii = 0; ii < children.length; ii++) {\n        child = children[ii];\n        if (child instanceof RelayQueryField) {\n          fieldMap[child.getStorageKey()] = child;\n        }\n      }\n      this.__fieldMap__ = fieldMap;\n    }\n    return fieldMap[storageKey];\n  }\n\n  getType(): string {\n    return this.__concreteNode__.type;\n  }\n\n  getRoute(): RelayMetaRoute {\n    return this.__route__;\n  }\n\n  getVariables(): Variables {\n    return this.__variables__;\n  }\n\n  hasDeferredDescendant(): boolean {\n    var hasDeferredDescendant = this.__hasDeferredDescendant__;\n    if (hasDeferredDescendant == null) {\n      hasDeferredDescendant =\n        this.canHaveSubselections() &&\n        this.getChildren().some(child => child.hasDeferredDescendant());\n      this.__hasDeferredDescendant__ = hasDeferredDescendant;\n    }\n    return hasDeferredDescendant;\n  }\n\n  isAbstract(): boolean {\n    throw new Error('RelayQueryNode: Abstract function cannot be called.');\n  }\n\n  isRequisite(): boolean {\n    return false;\n  }\n\n  /**\n   * Determine if `this` and `that` are deeply equal.\n   */\n  equals(that: RelayQueryNode): boolean {\n    var thisChildren = this.getChildren();\n    var thatChildren = that.getChildren();\n\n    return thisChildren === thatChildren || (\n      thisChildren.length === thatChildren.length &&\n      thisChildren.every((c, ii) => c.equals(thatChildren[ii]))\n    );\n  }\n\n  /**\n   * Performs a fast comparison of whether `this` and `that` represent identical\n   * query nodes. Returns true only if the concrete nodes, routes, and variables\n   * are all the same.\n   *\n   * Note that it is possible that this method can return false in cases where\n   * `equals` would return true. This can happen when the concrete nodes are\n   * different but structurally identical, or when the route/variables are\n   * different but do not have an effect on the structure of the query.\n   */\n  isEquivalent(that: RelayQueryNode): boolean {\n    return (\n      this.__concreteNode__ === that.__concreteNode__ &&\n      this.__route__ === that.__route__ &&\n      shallowEqual(this.__variables__, that.__variables__)\n    );\n  }\n\n  createNode(concreteNode: any): RelayQueryNode {\n    return RelayQueryNode.create(\n      concreteNode,\n      this.__route__,\n      this.__variables__\n    );\n  }\n\n  getConcreteQueryNode(): any {\n    return this.__concreteNode__;\n  }\n}\n\n/**\n * @internal\n *\n * Wraps access to query root nodes.\n */\nclass RelayQueryRoot extends RelayQueryNode {\n  __batchCall__: ?BatchCall;\n  __id__: ?string;\n  __identifyingArg__: ?Call;\n  __storageKey__: ?string;\n\n  /**\n   * Helper to construct a new root query with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build(\n    name: string,\n    fieldName: string,\n    value: mixed,\n    children: ?Array<RelayQueryNode>,\n    metadata: ConcreteQueryMetadata,\n    type: string\n  ): RelayQueryRoot {\n    const nextChildren = children ? children.filter(child => !!child) : [];\n    const batchCallVariable = QueryBuilder.getBatchCallVariable(value);\n    let identifyingArgValue;\n    if (batchCallVariable) {\n      identifyingArgValue = batchCallVariable;\n    } else if (Array.isArray(value)) {\n      identifyingArgValue = value.map(QueryBuilder.createCallValue);\n    } else if (value) {\n      identifyingArgValue = QueryBuilder.createCallValue(value);\n    }\n    const concreteRoot = QueryBuilder.createQuery({\n      fieldName,\n      identifyingArgValue,\n      metadata,\n      name,\n      type,\n    });\n    var root = new RelayQueryRoot(\n      concreteRoot,\n      RelayMetaRoute.get('$RelayQuery'),\n      {}\n    );\n    root.__children__ = nextChildren;\n    return root;\n  }\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQueryRoot {\n    const query = QueryBuilder.getQuery(concreteNode);\n    invariant(\n      query,\n      'RelayQueryRoot.create(): Expected a GraphQL `query { ... }`, got: %s',\n      concreteNode\n    );\n    return new RelayQueryRoot(\n      query,\n      route,\n      variables\n    );\n  }\n\n  constructor(\n    concreteNode: ConcreteQuery,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    super(concreteNode, route, variables);\n    this.__batchCall__ = undefined;\n    this.__id__ = undefined;\n    this.__identifyingArg__ = undefined;\n    this.__storageKey__ = undefined;\n\n    // Ensure IDs are generated in the order that queries are created\n    this.getID();\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  getName(): string {\n    let name = (this.__concreteNode__: ConcreteQuery).name;\n    if (!name) {\n      name = this.getID();\n      (this.__concreteNode__: ConcreteQuery).name = name;\n    }\n    return name;\n  }\n\n  getID(): string {\n    var id = this.__id__;\n    if (id == null) {\n      id = 'q' + _nextQueryID++;\n      this.__id__ = id;\n    }\n    return id;\n  }\n\n  getBatchCall(): ?BatchCall {\n    let batchCall = this.__batchCall__;\n    if (batchCall === undefined) {\n      const concreteCalls = (this.__concreteNode__: ConcreteQuery).calls;\n      if (concreteCalls) {\n        var callArg = concreteCalls[0] && concreteCalls[0].value;\n        if (\n          callArg != null &&\n          !Array.isArray(callArg) &&\n          callArg.kind === 'BatchCallVariable'\n        ) {\n          batchCall = {\n            refParamName: 'ref_' + callArg.sourceQueryID,\n            sourceQueryID: callArg.sourceQueryID,\n            sourceQueryPath: callArg.jsonPath,\n          };\n        }\n      }\n      batchCall = batchCall || null;\n      this.__batchCall__ = batchCall;\n    }\n    return batchCall;\n  }\n\n  getCallsWithValues(): Array<Call> {\n    let calls = this.__calls__;\n    if (!calls) {\n      const concreteCalls = (this.__concreteNode__: ConcreteQuery).calls;\n      if (concreteCalls) {\n        calls = callsFromGraphQL(concreteCalls, this.__variables__);\n      } else {\n        calls = EMPTY_CALLS;\n      }\n      this.__calls__ = calls;\n    }\n    return calls;\n  }\n\n  getFieldName(): string {\n    return (this.__concreteNode__: ConcreteQuery).fieldName;\n  }\n\n  getIdentifyingArg(): ?Call {\n    let identifyingArg = this.__identifyingArg__;\n    if (!identifyingArg) {\n      const metadata = (this.__concreteNode__: ConcreteQuery).metadata;\n      const identifyingArgName = metadata.identifyingArgName;\n      if (identifyingArgName != null) {\n        identifyingArg =\n          this.getCallsWithValues().find(c => c.name === identifyingArgName);\n        if (identifyingArg && metadata.identifyingArgType != null) {\n          identifyingArg.type = metadata.identifyingArgType;\n        }\n        this.__identifyingArg__ = identifyingArg;\n      }\n    }\n    return identifyingArg;\n  }\n\n  getStorageKey(): string {\n    let storageKey = this.__storageKey__;\n    if (!storageKey) {\n      let args = this.getCallsWithValues();\n      const identifyingArg = this.getIdentifyingArg();\n      if (identifyingArg) {\n        args = args.filter(arg => arg !== identifyingArg);\n      }\n      const field = RelayQueryField.build({\n        fieldName: this.getFieldName(),\n        calls: args,\n        type: this.getType(),\n      });\n      storageKey = field.getStorageKey();\n      this.__storageKey__ = storageKey;\n    }\n    return storageKey;\n  }\n\n  hasDeferredDescendant(): boolean {\n    return this.isDeferred() || super.hasDeferredDescendant();\n  }\n\n  isAbstract(): boolean {\n    return !!(this.__concreteNode__: ConcreteQuery).metadata.isAbstract;\n  }\n\n  isDeferred(): boolean {\n    return !!(this.__concreteNode__: ConcreteQuery).isDeferred;\n  }\n\n  isPlural(): boolean {\n    return !!(this.__concreteNode__: ConcreteQuery).metadata.isPlural;\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryRoot)) {\n      return false;\n    }\n    if (!areEqual(this.getBatchCall(), that.getBatchCall())) {\n      return false;\n    }\n    if (\n      this.getFieldName() !== that.getFieldName() ||\n      !areEqual(this.getCallsWithValues(), that.getCallsWithValues())\n    ) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Abstract base class for mutations and subscriptions.\n */\nclass RelayQueryOperation extends RelayQueryNode {\n  __callVariableName__: string;\n\n  constructor(\n    concreteNode: any,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    super(concreteNode, route, variables);\n    invariant(\n      this.constructor.name !== 'RelayQueryOperation',\n      'RelayQueryOperation: Abstract class cannot be instantiated.'\n    );\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  getName(): string {\n    return (this.__concreteNode__: ConcreteMutation).name;\n  }\n\n  getResponseType(): string {\n    return (this.__concreteNode__: ConcreteMutation).responseType;\n  }\n\n  getType(): string {\n    return this.getResponseType();\n  }\n\n  getInputType(): string {\n    const inputType =\n      (this.__concreteNode__: ConcreteMutation).metadata.inputType;\n    invariant(\n      inputType,\n      'RelayQuery: Expected operation `%s` to be annotated with the type of ' +\n      'its argument. Either the babel transform was configured incorrectly, ' +\n      'or the schema failed to define an argument for this mutation.',\n      this.getCall().name\n    );\n    return inputType;\n  }\n\n  getCall(): Call {\n    let calls = this.__calls__;\n    if (!calls) {\n      const concreteCalls = (this.__concreteNode__: ConcreteMutation).calls;\n      if (concreteCalls) {\n        calls = callsFromGraphQL(concreteCalls, this.__variables__);\n      } else {\n        calls = EMPTY_CALLS;\n      }\n      this.__calls__ = calls;\n    }\n    return calls[0];\n  }\n\n  getCallVariableName(): string {\n    if (!this.__callVariableName__) {\n      const concreteCalls = (this.__concreteNode__: ConcreteMutation).calls;\n      const callVariable =\n        concreteCalls && QueryBuilder.getCallVariable(concreteCalls[0].value);\n      invariant(\n        callVariable,\n        'RelayQuery: Expected mutation to have a single argument.'\n      );\n      this.__callVariableName__ = callVariable.callVariableName;\n    }\n    return this.__callVariableName__;\n  }\n\n  /**\n   * Mutations and subscriptions must have a concrete type due to the need for\n   * requisite top-level fields.\n   */\n  isAbstract(): boolean {\n    return false;\n  }\n}\n\n/**\n * @internal\n *\n * Represents a GraphQL mutation.\n */\nclass RelayQueryMutation extends RelayQueryOperation {\n  /**\n   * Helper to construct a new mutation with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build(\n    name: string,\n    responseType: string,\n    callName: string,\n    callValue?: ?mixed,\n    children?: ?Array<RelayQueryNode>,\n    metadata?: ?ConcreteOperationMetadata\n  ): RelayQueryMutation {\n    var nextChildren = children ? children.filter(child => !!child) : [];\n    var concreteMutation = QueryBuilder.createMutation({\n      calls: [QueryBuilder.createCall(\n        callName,\n        QueryBuilder.createCallVariable('input')\n      )],\n      metadata,\n      name,\n      responseType,\n    });\n    var mutation = new RelayQueryMutation(\n      concreteMutation,\n      RelayMetaRoute.get('$RelayQuery'),\n      {input: callValue || ''}\n    );\n    mutation.__children__ = nextChildren;\n    return mutation;\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryMutation)) {\n      return false;\n    }\n    if (!areEqual(this.getResponseType(), that.getResponseType())) {\n      return false;\n    }\n    if (!areEqual(this.getCall(), that.getCall())) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a GraphQL subscription.\n */\nclass RelayQuerySubscription extends RelayQueryOperation {\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQuerySubscription {\n    const subscription = QueryBuilder.getSubscription(concreteNode);\n    invariant(\n      subscription,\n      'RelayQuerySubscription.create(): ' +\n      'Expected a GraphQL `subscription { ... }`, got: %s',\n      concreteNode\n    );\n    return new RelayQuerySubscription(\n      concreteNode,\n      route,\n      variables\n    );\n  }\n\n  getPublishedPayloadType(): string {\n    return this.getResponseType();\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQuerySubscription)) {\n      return false;\n    }\n    if (\n      !areEqual(this.getPublishedPayloadType(), that.getPublishedPayloadType())\n    ) {\n      return false;\n    }\n    if (!areEqual(this.getCall(), that.getCall())) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Wraps access to query fragments.\n */\nclass RelayQueryFragment extends RelayQueryNode {\n  __compositeHash__: ?string;\n  __metadata__: FragmentMetadata;\n\n  /**\n   * Helper to construct a new fragment with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build(\n    name: string,\n    type: string,\n    children?: ?Array<RelayQueryNode>,\n    metadata?: ?{[key: string]: mixed}\n  ): RelayQueryFragment {\n    var nextChildren = children ? children.filter(child => !!child) : [];\n    var concreteFragment = QueryBuilder.createFragment({\n      name,\n      type,\n      metadata,\n    });\n    var fragment = new RelayQueryFragment(\n      concreteFragment,\n      RelayMetaRoute.get('$RelayQuery'),\n      {},\n      {\n        isDeferred: !!(metadata && metadata.isDeferred),\n        isContainerFragment: !!(metadata && metadata.isContainerFragment),\n      }\n    );\n    fragment.__children__ = nextChildren;\n    return fragment;\n  }\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables,\n    metadata?: ?FragmentMetadata\n  ): RelayQueryFragment {\n    const fragment = QueryBuilder.getFragment(concreteNode);\n    invariant(\n      fragment,\n      'RelayQueryFragment.create(): ' +\n      'Expected a GraphQL `fragment { ... }`, got: %s',\n      concreteNode\n    );\n    return createMemoizedFragment(\n      fragment,\n      route,\n      variables,\n      metadata || DEFAULT_FRAGMENT_METADATA\n    );\n  }\n\n  constructor(\n    concreteNode: ConcreteFragment,\n    route: RelayMetaRoute,\n    variables: Variables,\n    metadata?: FragmentMetadata\n  ) {\n    super(concreteNode, route, variables);\n    this.__compositeHash__ = null;\n    this.__metadata__ = metadata || DEFAULT_FRAGMENT_METADATA;\n  }\n\n  canHaveSubselections(): boolean {\n    return true;\n  }\n\n  getDebugName(): string {\n    return (this.__concreteNode__: ConcreteFragment).name;\n  }\n\n  /**\n   * The \"concrete fragment id\" uniquely identifies a Relay.QL`fragment ...`\n   * within the source code of an application and will remain the same across\n   * runs of a particular version of an application.\n   */\n  getConcreteFragmentID(): string {\n    return (this.__concreteNode__: ConcreteFragment).id;\n  }\n\n  /**\n   * The \"composite hash\" is similar to the concrete instance hash, but it also\n   * differentiates between varying variable values or route names.\n   *\n   * The composite hash is used to:\n   * - Avoid printing the same fragment twice, in order to reduce upload size.\n   * - Remember which deferred fragment/data pairs have been fetched.\n   */\n  getCompositeHash(): string {\n    let compositeHash = this.__compositeHash__;\n    if (!compositeHash) {\n      // TODO: Simplify this hash function, #9599170.\n      compositeHash = generateRQLFieldAlias(\n        this.getConcreteFragmentID() +\n        '.' + this.__route__.name +\n        '.' + stableStringify(this.__variables__)\n      );\n      this.__compositeHash__ = compositeHash;\n    }\n    return compositeHash;\n  }\n\n  isAbstract(): boolean {\n    return !!(this.__concreteNode__: ConcreteFragment).metadata.isAbstract;\n  }\n\n  isDeferred(): boolean {\n    return this.__metadata__.isDeferred;\n  }\n\n  isPattern(): boolean {\n    return !!(this.__concreteNode__: ConcreteFragment).metadata.pattern;\n  }\n\n  isPlural(): boolean {\n    const metadata = (this.__concreteNode__: ConcreteFragment).metadata;\n    return !!(\n      metadata.isPlural ||  // FB Printer\n      metadata.plural       // OSS Printer from `@relay`\n    );\n  }\n\n  cloneAsPlainFragment(): RelayQueryFragment {\n    return createMemoizedFragment(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__,\n      DEFAULT_FRAGMENT_METADATA\n    );\n  }\n\n  isContainerFragment(): boolean {\n    return this.__metadata__.isContainerFragment;\n  }\n\n  hasDeferredDescendant(): boolean {\n    return this.isDeferred() || super.hasDeferredDescendant();\n  }\n\n  clone(children: NextChildren): ?RelayQueryNode {\n    var clone = super.clone(children);\n    if (clone !== this &&\n        clone instanceof RelayQueryFragment) {\n      clone.__concreteNode__ = {\n        ...clone.__concreteNode__,\n        id: generateConcreteFragmentID(),\n      };\n      clone.__metadata__ = {\n        ...this.__metadata__,\n      };\n    }\n    return clone;\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryFragment)) {\n      return false;\n    }\n    if (this.getType() !== that.getType()) {\n      return false;\n    }\n    return super.equals(that);\n  }\n}\n\n/**\n * @internal\n *\n * Wraps access to query fields.\n */\nclass RelayQueryField extends RelayQueryNode {\n  __debugName__: ?string;\n  __isRefQueryDependency__: boolean;\n  __rangeBehaviorKey__: ?string;\n  __shallowHash__: ?string;\n\n  static create(\n    concreteNode: mixed,\n    route: RelayMetaRoute,\n    variables: Variables\n  ): RelayQueryField {\n    const field = QueryBuilder.getField(concreteNode);\n    invariant(\n      field,\n      'RelayQueryField.create(): Expected a GraphQL field, got: %s',\n      concreteNode\n    );\n    return new RelayQueryField(\n      field,\n      route,\n      variables\n    );\n  }\n\n  /**\n   * Helper to construct a new field with the given attributes and 'empty'\n   * route/variables.\n   */\n  static build({\n    alias,\n    directives,\n    calls,\n    children,\n    fieldName,\n    metadata,\n    type,\n  }: {\n    alias?: ?string;\n    directives?: ?Array<Directive>;\n    calls?: ?Array<Call>;\n    children?: ?NextChildren;\n    fieldName: string;\n    metadata?: ?ConcreteFieldMetadata;\n    type: string;\n  }): RelayQueryField {\n    var nextChildren = children ? children.filter(child => !!child) : [];\n    var concreteField = QueryBuilder.createField({\n      alias,\n      calls: calls ? callsToGraphQL(calls) : null,\n      directives: directives ? directivesToGraphQL(directives) : null,\n      fieldName,\n      metadata,\n      type,\n    });\n    var field = new RelayQueryField(\n      concreteField,\n      RelayMetaRoute.get('$RelayQuery'),\n      {}\n    );\n    field.__children__ = nextChildren;\n    return field;\n  }\n\n  constructor(\n    concreteNode: ConcreteField,\n    route: RelayMetaRoute,\n    variables: Variables\n  ) {\n    super(concreteNode, route, variables);\n    this.__debugName__ = undefined;\n    this.__isRefQueryDependency__ = false;\n    this.__rangeBehaviorKey__ = undefined;\n    this.__shallowHash__ = undefined;\n  }\n\n  canHaveSubselections(): boolean {\n    return !!(\n      (this.__concreteNode__: ConcreteField).metadata.canHaveSubselections\n    );\n  }\n\n  isAbstract(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isAbstract;\n  }\n\n  isFindable(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isFindable;\n  }\n\n  isGenerated(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isGenerated;\n  }\n\n  isConnection(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isConnection;\n  }\n\n  isConnectionWithoutNodeID(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata\n      .isConnectionWithoutNodeID;\n  }\n\n  isPlural(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isPlural;\n  }\n\n  isRefQueryDependency(): boolean {\n    return this.__isRefQueryDependency__;\n  }\n\n  isRequisite(): boolean {\n    return !!(this.__concreteNode__: ConcreteField).metadata.isRequisite;\n  }\n\n  getDebugName(): string {\n    let debugName = this.__debugName__;\n    if (!debugName) {\n      debugName = this.getSchemaName();\n      let printedCoreArgs;\n      this.getCallsWithValues().forEach(arg => {\n        if (this._isCoreArg(arg)) {\n          printedCoreArgs = printedCoreArgs || [];\n          printedCoreArgs.push(serializeRelayQueryCall(arg));\n        }\n      });\n      if (printedCoreArgs) {\n        debugName += printedCoreArgs.sort().join('');\n      }\n      this.__debugName__ = debugName;\n    }\n    return debugName;\n  }\n\n  /**\n   * The canonical name for the referenced field in the schema.\n   */\n  getSchemaName(): string {\n    return (this.__concreteNode__: ConcreteField).fieldName;\n  }\n\n  /**\n   * A string representing the range behavior eligible arguments associated with\n   * this field. Arguments will be sorted.\n   *\n   * Non-core arguments (like connection and identifying arguments) are dropped.\n   *   `field(first: 10, foo: \"bar\", baz: \"bat\")` => `'baz(bat).foo(bar)'`\n   *   `username(name: \"steve\")`                  => `''`\n   */\n  getRangeBehaviorKey(): string {\n    invariant(\n      this.isConnection(),\n      'RelayQueryField: Range behavior keys are associated exclusively with ' +\n      'connection fields. `getRangeBehaviorKey()` was called on the ' +\n      'non-connection field `%s`.',\n      this.getSchemaName()\n    );\n    let rangeBehaviorKey = this.__rangeBehaviorKey__;\n    if (rangeBehaviorKey == null) {\n      const printedCoreArgs = [];\n      this.getCallsWithValues().forEach(arg => {\n        if (this._isCoreArg(arg)) {\n          printedCoreArgs.push(serializeRelayQueryCall(arg));\n        }\n      });\n      rangeBehaviorKey = printedCoreArgs.sort().join('').slice(1);\n      this.__rangeBehaviorKey__ = rangeBehaviorKey;\n    }\n    return rangeBehaviorKey;\n  }\n\n  /**\n   * The name for the field when serializing the query or interpreting query\n   * responses from the server. The serialization key is derived from\n   * all calls/values and hashed for compactness.\n   *\n   * Given the GraphQL\n   *   `field(first: 10, foo: \"bar\", baz: \"bat\")`, or\n   *   `field(baz: \"bat\", foo: \"bar\", first: 10)`\n   *\n   * ...the following serialization key will be produced:\n   *   `generateRQLFieldAlias('field.bar(bat).first(10).foo(bar)')`\n   */\n  getSerializationKey(): string {\n    let serializationKey = this.__serializationKey__;\n    if (!serializationKey) {\n      serializationKey = generateRQLFieldAlias(\n        this.getSchemaName() +\n        this.getCallsWithValues()\n          .map(serializeRelayQueryCall)\n          .sort()\n          .join('')\n      );\n      this.__serializationKey__ = serializationKey;\n    }\n    return serializationKey;\n  }\n\n  /**\n   * Returns a hash of the field name and all argument values.\n   */\n  getShallowHash(): string {\n    let shallowHash = this.__shallowHash__;\n    if (!shallowHash) {\n      this.__shallowHash__ = shallowHash =\n        this.getSchemaName() +\n        serializeCalls(this.getCallsWithValues());\n    }\n    return shallowHash;\n  }\n\n  /**\n   * The name which Relay internals can use to reference this field, without\n   * collisions.\n   *\n   * Given the GraphQL\n   *   `field(first: 10, foo: \"bar\", baz: \"bat\")`, or\n   *   `field(baz: \"bat\", foo: \"bar\", first: 10)`\n   *\n   * ...the following storage key will be produced:\n   *   `'field{bar:\"bat\",foo:\"bar\"}'`\n   */\n  getStorageKey(): string {\n    let storageKey = this.__storageKey__;\n    if (!storageKey) {\n      this.__storageKey__ = storageKey =\n        this.getSchemaName() +\n        serializeCalls(\n          this.getCallsWithValues().filter(call => this._isCoreArg(call))\n        );\n    }\n    return storageKey;\n  }\n\n  /**\n   * The name by which this field's results should be made available to the\n   * application.\n   */\n  getApplicationName(): string {\n    const concreteNode = (this.__concreteNode__: ConcreteField);\n    return concreteNode.alias || concreteNode.fieldName;\n  }\n\n  getInferredRootCallName(): ?string {\n    return (this.__concreteNode__: ConcreteField).metadata.inferredRootCallName;\n  }\n\n  getInferredPrimaryKey(): ?string {\n    return (this.__concreteNode__: ConcreteField).metadata.inferredPrimaryKey;\n  }\n\n  getCallsWithValues(): Array<Call> {\n    let calls = this.__calls__;\n    if (!calls) {\n      const concreteCalls = (this.__concreteNode__: ConcreteField).calls;\n      if (concreteCalls) {\n        calls = callsFromGraphQL(concreteCalls, this.__variables__);\n      } else {\n        calls = EMPTY_CALLS;\n      }\n      this.__calls__ = calls;\n    }\n    return calls;\n  }\n\n  getCallType(callName: string): ?string {\n    const concreteCalls = (this.__concreteNode__: ConcreteField).calls;\n    const concreteCall = concreteCalls && concreteCalls.filter(\n      call => call.name === callName\n    )[0];\n    if (concreteCall) {\n      return concreteCall.metadata.type;\n    }\n  }\n\n  equals(that: RelayQueryNode): boolean {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof RelayQueryField)) {\n      return false;\n    }\n    if (\n      this.getSchemaName() !== that.getSchemaName() ||\n      this.getApplicationName() !== that.getApplicationName() ||\n      !areEqual(this.getCallsWithValues(), that.getCallsWithValues())\n    ) {\n      return false;\n    }\n    return super.equals(that);\n  }\n\n  cloneAsRefQueryDependency(): RelayQueryField {\n    var field = new RelayQueryField(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__\n    );\n    field.__children__ = [];\n    field.__isRefQueryDependency__ = true;\n    return field;\n  }\n\n  cloneFieldWithCalls(\n    children: NextChildren,\n    calls: Array<Call>\n  ): ?RelayQueryField {\n    if (!this.canHaveSubselections()) {\n      // Compact new children *after* this check, for consistency.\n      invariant(\n        children.length === 0,\n        'RelayQueryNode: Cannot add children to field `%s` because it does ' +\n        'not support sub-selections (sub-fields).',\n        this.getSchemaName()\n      );\n    }\n\n    // use `clone()` if call values do not change\n    if (areEqual(this.getCallsWithValues(), calls)) {\n      var clone: RelayQueryField = (this.clone(children): any);\n      return clone;\n    }\n\n    var nextChildren = cloneChildren(this.getChildren(), children);\n    if (!nextChildren.length) {\n      return null;\n    }\n\n    var field = new RelayQueryField(\n      this.__concreteNode__,\n      this.__route__,\n      this.__variables__\n    );\n    field.__children__ = nextChildren;\n    field.__calls__ = calls;\n\n    return field;\n  }\n\n  /**\n   * The following types of arguments are non-core:\n   * - Range calls such as `first` or `find` on connections.\n   * - Conditionals when the field is present.\n   */\n  _isCoreArg(arg: Call): boolean {\n    return (\n      // `name(if:true)`, `name(unless:false)`, and `name` are equivalent.\n      !(arg.name === IF && (String(arg.value) === TRUE)) &&\n      !(arg.name === UNLESS && (String(arg.value) === FALSE)) &&\n      // Connection arguments can be stripped out.\n      !(this.isConnection() && RelayConnectionInterface.isConnectionCall(arg))\n    );\n  }\n}\n\nfunction createNode(\n  concreteNode: mixed,\n  route: RelayMetaRoute,\n  variables: Variables\n): ?RelayQueryNode {\n  invariant(\n    typeof concreteNode === 'object' &&\n    concreteNode !== null,\n    'RelayQueryNode: Expected a GraphQL object created with `Relay.QL`, got' +\n    '`%s`.',\n    concreteNode\n  );\n  const kind = concreteNode.kind;\n  let type = RelayQueryNode;\n  if (kind === 'Field') {\n    type = RelayQueryField;\n  } else if (kind === 'Fragment') {\n    type = RelayQueryFragment;\n  } else if (kind === 'FragmentReference') {\n    type = RelayQueryFragment;\n    const fragment = QueryBuilder.getFragment(concreteNode.fragment);\n    // TODO #9171213: Reference directives should override fragment directives\n    if (fragment) {\n      return createMemoizedFragment(\n        fragment,\n        route,\n        {},\n        {\n          isDeferred: false,\n          isContainerFragment: true,\n        }\n      );\n    }\n  } else if (kind === 'Query') {\n    type = RelayQueryRoot;\n  } else if (kind === 'Mutation') {\n    type = RelayQueryMutation;\n  } else if (kind === 'Subscription') {\n    type = RelayQuerySubscription;\n  } else if (concreteNode instanceof RelayRouteFragment) {\n    const fragment = concreteNode.getFragmentForRoute(route);\n    if (fragment) {\n      // may be null if no value was defined for this route.\n      return createNode(\n        fragment,\n        route,\n        variables\n      );\n    }\n    return null;\n  } else if (concreteNode instanceof RelayFragmentReference) {\n    const fragment = concreteNode.getFragment(variables);\n    const fragmentVariables = concreteNode.getVariables(route, variables);\n    if (fragment) {\n      // the fragment may be null when `if` or `unless` conditions are not met.\n      return createMemoizedFragment(\n        fragment,\n        route,\n        fragmentVariables,\n        {\n          isDeferred: concreteNode.isDeferred(),\n          isContainerFragment: concreteNode.isContainerFragment(),\n        }\n      );\n    }\n    return null;\n  } else {\n  }\n  return new type(\n    (concreteNode: any),\n    route,\n    variables\n  );\n}\n\n/**\n * Memoizes the `RelayQueryFragment` equivalent of a given GraphQL fragment\n * for the given route, variables, and deferred status.\n */\nfunction createMemoizedFragment(\n  concreteFragment: ConcreteFragment,\n  route: RelayMetaRoute,\n  variables: Variables,\n  metadata: FragmentMetadata\n): RelayQueryFragment {\n  var cacheKey = route.name + ':' + stableStringify(variables) + ':' +\n    stableStringify(metadata);\n  var fragment = (concreteFragment: any).__cachedFragment__;\n  var fragmentCacheKey = (concreteFragment: any).__cacheKey__;\n  if (!fragment || fragmentCacheKey !== cacheKey) {\n    fragment = new RelayQueryFragment(\n      concreteFragment,\n      route,\n      variables,\n      metadata\n    );\n    (concreteFragment: any).__cachedFragment__ = fragment;\n    (concreteFragment: any).__cacheKey__ = cacheKey;\n  }\n  return fragment;\n}\n\n/**\n * Compacts new children and compares them to the previous children.\n * - If all items are equal, returns previous array\n * - If any items differ, returns new array\n */\nfunction cloneChildren(\n  prevChildren: Array<RelayQueryNode>,\n  nextChildren: NextChildren\n): Array<RelayQueryNode> {\n  var children = [];\n  var isSameChildren = true;\n\n  var prevIndex = 0;\n  for (var ii = 0; ii < nextChildren.length; ii++) {\n    var child = nextChildren[ii];\n    if (child) {\n      children.push(child);\n      isSameChildren = isSameChildren && child === prevChildren[prevIndex++];\n    }\n  }\n\n  if (isSameChildren && children.length === prevChildren.length) {\n    return prevChildren;\n  } else {\n    return children;\n  }\n}\n\n/**\n * Creates an opaque serialization of calls.\n */\nfunction serializeCalls(calls: Array<Call>): string {\n  if (calls.length) {\n    const callMap = {};\n    calls.forEach(call => {\n      callMap[call.name] = call.value;\n    });\n    return stableStringify(callMap);\n  } else {\n    return '';\n  }\n}\n\nRelayProfiler.instrumentMethods(RelayQueryNode.prototype, {\n  clone: '@RelayQueryNode.prototype.clone',\n  equals: '@RelayQueryNode.prototype.equals',\n  getChildren: '@RelayQueryNode.prototype.getChildren',\n  getDirectives: '@RelayQueryNode.prototype.getDirectives',\n  hasDeferredDescendant: '@RelayQueryNode.prototype.hasDeferredDescendant',\n  getFieldByStorageKey: '@RelayQueryNode.prototype.getFieldByStorageKey',\n});\n\nRelayProfiler.instrumentMethods(RelayQueryField.prototype, {\n  getStorageKey: '@RelayQueryField.prototype.getStorageKey',\n  getSerializationKey: '@RelayQueryField.prototype.getSerializationKey',\n});\n\nmodule.exports = {\n  Field: RelayQueryField,\n  Fragment: RelayQueryFragment,\n  Mutation: RelayQueryMutation,\n  Node: RelayQueryNode,\n  Operation: RelayQueryOperation,\n  Root: RelayQueryRoot,\n  Subscription: RelayQuerySubscription,\n};\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayQL.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQL\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst QueryBuilder = require('QueryBuilder');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayRouteFragment = require('RelayRouteFragment');\n\nconst invariant = require('invariant');\n\nexport type RelayConcreteNode = mixed;\n\n/**\n * @public\n *\n * This is a tag function used with template strings to provide the facade of a\n * runtime GraphQL parser. Example usage:\n *\n *   Relay.QL`fragment on User { name }`\n *\n * In actuality, a Babel transform parses these tag templates and replaces it\n * with an internal representation of the query structure.\n */\nfunction RelayQL(\n  strings: Array<string>,\n  ...substitutions: Array<any>\n): RelayConcreteNode {\n  invariant(\n    false,\n    'RelayQL: Unexpected invocation at runtime. Either the Babel transform ' +\n    'was not set up, or it failed to identify this call site. Make sure it ' +\n    'is being used verbatim as `Relay.QL`.'\n  );\n}\n\nfunction assertValidFragment(substitution: any): void {\n  invariant(\n    substitution instanceof RelayFragmentReference ||\n    QueryBuilder.getFragment(substitution) ||\n    QueryBuilder.getFragmentReference(substitution),\n    'RelayQL: Invalid fragment composition, use ' +\n    '`${Child.getFragment(\\'name\\')}`.'\n  );\n}\n\n/**\n * Private helper methods used by the transformed code.\n */\nObject.assign(RelayQL, {\n  __frag(substitution: any): any {\n    if (typeof substitution === 'function') {\n      // Route conditional fragment, e.g. `${route => matchRoute(route, ...)}`.\n      return new RelayRouteFragment(substitution);\n    }\n    if (substitution != null) {\n      if (Array.isArray(substitution)) {\n        substitution.forEach(assertValidFragment);\n      } else {\n        assertValidFragment(substitution);\n      }\n    }\n    return substitution;\n  },\n  __var(expression: mixed): mixed {\n    const variable = QueryBuilder.getCallVariable(expression);\n    if (variable) {\n      invariant(\n        false,\n        'RelayQL: Invalid argument `%s` supplied via template substitution. ' +\n        'Instead, use an inline variable (e.g. `comments(count: $count)`).',\n        variable.callVariableName\n      );\n    }\n    return QueryBuilder.createCallValue(expression);\n  },\n});\n\nmodule.exports = RelayQL;\n","dependencies":["QueryBuilder","RelayFragmentReference","RelayRouteFragment","invariant","RelayQL"],"id":"RelayQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQL\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst QueryBuilder = require('QueryBuilder');\nconst RelayFragmentReference = require('RelayFragmentReference');\nconst RelayRouteFragment = require('RelayRouteFragment');\n\nconst invariant = require('invariant');\n\nexport type RelayConcreteNode = mixed;\n\n/**\n * @public\n *\n * This is a tag function used with template strings to provide the facade of a\n * runtime GraphQL parser. Example usage:\n *\n *   Relay.QL`fragment on User { name }`\n *\n * In actuality, a Babel transform parses these tag templates and replaces it\n * with an internal representation of the query structure.\n */\nfunction RelayQL(\n  strings: Array<string>,\n  ...substitutions: Array<any>\n): RelayConcreteNode {\n  invariant(\n    false,\n    'RelayQL: Unexpected invocation at runtime. Either the Babel transform ' +\n    'was not set up, or it failed to identify this call site. Make sure it ' +\n    'is being used verbatim as `Relay.QL`.'\n  );\n}\n\nfunction assertValidFragment(substitution: any): void {\n  invariant(\n    substitution instanceof RelayFragmentReference ||\n    QueryBuilder.getFragment(substitution) ||\n    QueryBuilder.getFragmentReference(substitution),\n    'RelayQL: Invalid fragment composition, use ' +\n    '`${Child.getFragment(\\'name\\')}`.'\n  );\n}\n\n/**\n * Private helper methods used by the transformed code.\n */\nObject.assign(RelayQL, {\n  __frag(substitution: any): any {\n    if (typeof substitution === 'function') {\n      // Route conditional fragment, e.g. `${route => matchRoute(route, ...)}`.\n      return new RelayRouteFragment(substitution);\n    }\n    if (substitution != null) {\n      if (Array.isArray(substitution)) {\n        substitution.forEach(assertValidFragment);\n      } else {\n        assertValidFragment(substitution);\n      }\n    }\n    return substitution;\n  },\n  __var(expression: mixed): mixed {\n    const variable = QueryBuilder.getCallVariable(expression);\n    if (variable) {\n      invariant(\n        false,\n        'RelayQL: Invalid argument `%s` supplied via template substitution. ' +\n        'Instead, use an inline variable (e.g. `comments(count: $count)`).',\n        variable.callVariableName\n      );\n    }\n    return QueryBuilder.createCallValue(expression);\n  },\n});\n\nmodule.exports = RelayQL;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayFragmentReference.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayFragmentReference","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayFragmentReference\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ConcreteFragment} from 'ConcreteQuery';\nconst QueryBuilder = require('QueryBuilder');\nimport type RelayMetaRoute from 'RelayMetaRoute';\nimport type {Variables} from 'RelayTypes';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\ntype Condition = (variables: Variables) => boolean;\ntype FragmentGetter = () => ConcreteFragment;\ntype PrepareVariablesCallback = (\n  prevVariables: Variables,\n  route: RelayMetaRoute\n) => Variables;\ntype VariableMapping = {[key: string]: mixed};\n\n/**\n * @internal\n *\n * RelayFragmentReference is the return type of fragment composition:\n *\n *   fragment on Foo {\n *     ${Child.getFragment('bar', {baz: variables.qux})}\n *   }\n *\n * Whereas a fragment defines a sub-query's structure, a fragment reference is\n * a particular instantiation of the fragment as it is composed within a query\n * or another fragment. It encodes the source fragment, initial variables, and\n * a mapping from variables in the composing query's (or fragment's) scope to\n * variables in the fragment's scope.\n *\n * The variable mapping is represented by `variableMapping`, a dictionary that\n * maps from names of variables in the parent scope to variables that exist in\n * the fragment. Example:\n *\n * ```\n * // Fragment:\n * var Container = Relay.createContainer(..., {\n *   initialVariables: {\n *     private: 'foo',\n *     public: 'bar',\n *     variable: null,\n *   },\n *   fragments: {\n *     foo: ...\n *   }\n * });\n *\n * // Reference:\n * ${Container.getQuery(\n *   'foo',\n *   // Variable Mapping:\n *   {\n *     public: 'BAR',\n *     variable: variables.source,\n *   }\n * )}\n * ```\n *\n * When evaluating the referenced fragment, `$public` will be overridden with\n * `'Bar'`. The value of `$variable` will become the value of `$source` in the\n * outer scope. This is analagous to:\n *\n * ```\n * function inner(private = 'foo', public = 'bar', variable) {}\n * function outer(source) {\n *   inner(public = 'BAR', variable = source);\n * }\n * ```\n *\n * Where the value of the inner `variable` depends on how `outer` is called.\n *\n * The `prepareVariables` function allows for variables to be modified based on\n * the runtime environment or route name.\n */\nclass RelayFragmentReference {\n  _conditions: ?Array<Condition>;\n  _initialVariables: Variables;\n  _fragment: ?ConcreteFragment;\n  _fragmentGetter: FragmentGetter;\n  _isContainerFragment: boolean;\n  _isDeferred: boolean;\n  _variableMapping: ?VariableMapping;\n  _prepareVariables: ?PrepareVariablesCallback;\n\n  static createForContainer(\n    fragmentGetter: FragmentGetter,\n    initialVariables?: ?Variables,\n    variableMapping?: ?VariableMapping,\n    prepareVariables?: ?PrepareVariablesCallback\n  ): RelayFragmentReference {\n    var reference = new RelayFragmentReference(\n      fragmentGetter,\n      initialVariables,\n      variableMapping,\n      prepareVariables\n    );\n    reference._isContainerFragment = true;\n    return reference;\n  }\n\n  constructor(\n    fragmentGetter: FragmentGetter,\n    initialVariables?: ?Variables,\n    variableMapping?: ?VariableMapping,\n    prepareVariables?: ?PrepareVariablesCallback\n  ) {\n    this._initialVariables = initialVariables || {};\n    this._fragment = undefined;\n    this._fragmentGetter = fragmentGetter;\n    this._isContainerFragment = false;\n    this._isDeferred = false;\n    this._variableMapping = variableMapping;\n    this._prepareVariables = prepareVariables;\n  }\n\n  /**\n   * Mark this usage of the fragment as deferred.\n   */\n  defer(): RelayFragmentReference {\n    this._isDeferred = true;\n    return this;\n  }\n\n  /**\n   * Mark this fragment for inclusion only if the given variable is truthy.\n   */\n  if(value: any): RelayFragmentReference {\n    const callVariable = QueryBuilder.getCallVariable(value);\n    invariant(\n      callVariable,\n      'RelayFragmentReference: Invalid value `%s` supplied to `if()`. ' +\n      'Expected a variable.',\n      callVariable\n    );\n    this._addCondition(\n      variables => !!variables[callVariable.callVariableName]\n    );\n    return this;\n  }\n\n  /**\n   * Mark this fragment for inclusion only if the given variable is falsy.\n   */\n  unless(value: any): RelayFragmentReference {\n    const callVariable = QueryBuilder.getCallVariable(value);\n    invariant(\n      callVariable,\n      'RelayFragmentReference: Invalid value `%s` supplied to `unless()`. ' +\n      'Expected a variable.',\n      callVariable\n    );\n    this._addCondition(\n      variables => !variables[callVariable.callVariableName]\n    );\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _getFragment(): ConcreteFragment {\n    let fragment = this._fragment;\n    if (fragment == null) {\n      fragment = this._fragmentGetter();\n      this._fragment = fragment;\n    }\n    return fragment;\n  }\n\n  /**\n   * Get the referenced fragment if all conditions are met.\n   */\n  getFragment(variables: Variables): ?ConcreteFragment {\n    // determine if the variables match the supplied if/unless conditions\n    const conditions = this._conditions;\n    if (conditions && !conditions.every(cb => cb(variables))) {\n      return null;\n    }\n    return this._getFragment();\n  }\n\n  /**\n   * Get the variables to pass to the referenced fragment, accounting for\n   * initial values, overrides, and route-specific variables.\n   */\n  getVariables(route: RelayMetaRoute, variables: Variables): Variables {\n    let innerVariables = {...this._initialVariables};\n\n    // map variables from outer -> inner scope\n    const variableMapping = this._variableMapping;\n    if (variableMapping) {\n      forEachObject(variableMapping, (value, name) => {\n        const callVariable = QueryBuilder.getCallVariable(value);\n        if (callVariable) {\n          value = variables[callVariable.callVariableName];\n        }\n        if (value === undefined) {\n          warning(\n            false,\n            'RelayFragmentReference: Variable `%s` is undefined in fragment ' +\n            '`%s`.',\n            name,\n            this._getFragment().name\n          );\n        } else {\n          innerVariables[name] = value;\n        }\n      });\n    }\n\n    const prepareVariables = this._prepareVariables;\n    if (prepareVariables) {\n      innerVariables = prepareVariables(innerVariables, route);\n    }\n\n    return innerVariables;\n  }\n\n  isContainerFragment(): boolean {\n    return this._isContainerFragment;\n  }\n\n  isDeferred(): boolean {\n    return this._isDeferred;\n  }\n\n  _addCondition(condition: Condition): void {\n    let conditions = this._conditions;\n    if (!conditions) {\n      conditions = [];\n      this._conditions = conditions;\n    }\n    conditions.push(condition);\n  }\n}\n\nmodule.exports = RelayFragmentReference;\n","dependencies":["ConcreteQuery","RelayMetaRoute","RelayTypes","QueryBuilder","forEachObject","invariant","warning","RelayFragmentReference"],"id":"RelayFragmentReference","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayFragmentReference\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {ConcreteFragment} from 'ConcreteQuery';\nconst QueryBuilder = require('QueryBuilder');\nimport type RelayMetaRoute from 'RelayMetaRoute';\nimport type {Variables} from 'RelayTypes';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\ntype Condition = (variables: Variables) => boolean;\ntype FragmentGetter = () => ConcreteFragment;\ntype PrepareVariablesCallback = (\n  prevVariables: Variables,\n  route: RelayMetaRoute\n) => Variables;\ntype VariableMapping = {[key: string]: mixed};\n\n/**\n * @internal\n *\n * RelayFragmentReference is the return type of fragment composition:\n *\n *   fragment on Foo {\n *     ${Child.getFragment('bar', {baz: variables.qux})}\n *   }\n *\n * Whereas a fragment defines a sub-query's structure, a fragment reference is\n * a particular instantiation of the fragment as it is composed within a query\n * or another fragment. It encodes the source fragment, initial variables, and\n * a mapping from variables in the composing query's (or fragment's) scope to\n * variables in the fragment's scope.\n *\n * The variable mapping is represented by `variableMapping`, a dictionary that\n * maps from names of variables in the parent scope to variables that exist in\n * the fragment. Example:\n *\n * ```\n * // Fragment:\n * var Container = Relay.createContainer(..., {\n *   initialVariables: {\n *     private: 'foo',\n *     public: 'bar',\n *     variable: null,\n *   },\n *   fragments: {\n *     foo: ...\n *   }\n * });\n *\n * // Reference:\n * ${Container.getQuery(\n *   'foo',\n *   // Variable Mapping:\n *   {\n *     public: 'BAR',\n *     variable: variables.source,\n *   }\n * )}\n * ```\n *\n * When evaluating the referenced fragment, `$public` will be overridden with\n * `'Bar'`. The value of `$variable` will become the value of `$source` in the\n * outer scope. This is analagous to:\n *\n * ```\n * function inner(private = 'foo', public = 'bar', variable) {}\n * function outer(source) {\n *   inner(public = 'BAR', variable = source);\n * }\n * ```\n *\n * Where the value of the inner `variable` depends on how `outer` is called.\n *\n * The `prepareVariables` function allows for variables to be modified based on\n * the runtime environment or route name.\n */\nclass RelayFragmentReference {\n  _conditions: ?Array<Condition>;\n  _initialVariables: Variables;\n  _fragment: ?ConcreteFragment;\n  _fragmentGetter: FragmentGetter;\n  _isContainerFragment: boolean;\n  _isDeferred: boolean;\n  _variableMapping: ?VariableMapping;\n  _prepareVariables: ?PrepareVariablesCallback;\n\n  static createForContainer(\n    fragmentGetter: FragmentGetter,\n    initialVariables?: ?Variables,\n    variableMapping?: ?VariableMapping,\n    prepareVariables?: ?PrepareVariablesCallback\n  ): RelayFragmentReference {\n    var reference = new RelayFragmentReference(\n      fragmentGetter,\n      initialVariables,\n      variableMapping,\n      prepareVariables\n    );\n    reference._isContainerFragment = true;\n    return reference;\n  }\n\n  constructor(\n    fragmentGetter: FragmentGetter,\n    initialVariables?: ?Variables,\n    variableMapping?: ?VariableMapping,\n    prepareVariables?: ?PrepareVariablesCallback\n  ) {\n    this._initialVariables = initialVariables || {};\n    this._fragment = undefined;\n    this._fragmentGetter = fragmentGetter;\n    this._isContainerFragment = false;\n    this._isDeferred = false;\n    this._variableMapping = variableMapping;\n    this._prepareVariables = prepareVariables;\n  }\n\n  /**\n   * Mark this usage of the fragment as deferred.\n   */\n  defer(): RelayFragmentReference {\n    this._isDeferred = true;\n    return this;\n  }\n\n  /**\n   * Mark this fragment for inclusion only if the given variable is truthy.\n   */\n  if(value: any): RelayFragmentReference {\n    const callVariable = QueryBuilder.getCallVariable(value);\n    invariant(\n      callVariable,\n      'RelayFragmentReference: Invalid value `%s` supplied to `if()`. ' +\n      'Expected a variable.',\n      callVariable\n    );\n    this._addCondition(\n      variables => !!variables[callVariable.callVariableName]\n    );\n    return this;\n  }\n\n  /**\n   * Mark this fragment for inclusion only if the given variable is falsy.\n   */\n  unless(value: any): RelayFragmentReference {\n    const callVariable = QueryBuilder.getCallVariable(value);\n    invariant(\n      callVariable,\n      'RelayFragmentReference: Invalid value `%s` supplied to `unless()`. ' +\n      'Expected a variable.',\n      callVariable\n    );\n    this._addCondition(\n      variables => !variables[callVariable.callVariableName]\n    );\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _getFragment(): ConcreteFragment {\n    let fragment = this._fragment;\n    if (fragment == null) {\n      fragment = this._fragmentGetter();\n      this._fragment = fragment;\n    }\n    return fragment;\n  }\n\n  /**\n   * Get the referenced fragment if all conditions are met.\n   */\n  getFragment(variables: Variables): ?ConcreteFragment {\n    // determine if the variables match the supplied if/unless conditions\n    const conditions = this._conditions;\n    if (conditions && !conditions.every(cb => cb(variables))) {\n      return null;\n    }\n    return this._getFragment();\n  }\n\n  /**\n   * Get the variables to pass to the referenced fragment, accounting for\n   * initial values, overrides, and route-specific variables.\n   */\n  getVariables(route: RelayMetaRoute, variables: Variables): Variables {\n    let innerVariables = {...this._initialVariables};\n\n    // map variables from outer -> inner scope\n    const variableMapping = this._variableMapping;\n    if (variableMapping) {\n      forEachObject(variableMapping, (value, name) => {\n        const callVariable = QueryBuilder.getCallVariable(value);\n        if (callVariable) {\n          value = variables[callVariable.callVariableName];\n        }\n        if (value === undefined) {\n          warning(\n            false,\n            'RelayFragmentReference: Variable `%s` is undefined in fragment ' +\n            '`%s`.',\n            name,\n            this._getFragment().name\n          );\n        } else {\n          innerVariables[name] = value;\n        }\n      });\n    }\n\n    const prepareVariables = this._prepareVariables;\n    if (prepareVariables) {\n      innerVariables = prepareVariables(innerVariables, route);\n    }\n\n    return innerVariables;\n  }\n\n  isContainerFragment(): boolean {\n    return this._isContainerFragment;\n  }\n\n  isDeferred(): boolean {\n    return this._isDeferred;\n  }\n\n  _addCondition(condition: Condition): void {\n    let conditions = this._conditions;\n    if (!conditions) {\n      conditions = [];\n      this._conditions = conditions;\n    }\n    conditions.push(condition);\n  }\n}\n\nmodule.exports = RelayFragmentReference;\n"}}},"/Users/cpojer/Projects/relay/src/query/RelayFragmentPointer.js":{"metadata":{"mtime":1456974578000},"data":{"name":"RelayFragmentPointer","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayFragmentPointer\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nconst RelayRecord = require('RelayRecord');\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst invariant = require('invariant');\n\nimport type {DataID} from 'RelayInternalTypes';\nimport type {Record} from 'RelayRecord';\n\ntype FragmentDataIDMap = {\n  [fragmentID: string]: DataID;\n};\ntype FragmentProp = {\n  __dataID__: DataID,\n  __fragments__: FragmentDataIDMap;\n};\n\n/**\n * Fragment pointers encapsulate the fetched data for a fragment reference. They\n * are opaque tokens that are used by Relay containers to read data that is then\n * passed to the underlying React component.\n *\n * @internal\n */\nconst RelayFragmentPointer = {\n  addFragment(\n    record: Record,\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): void {\n    let fragmentMap = record.__fragments__;\n    if (fragmentMap == null) {\n      fragmentMap = record.__fragments__ = {};\n    }\n    invariant(\n      typeof fragmentMap === 'object' && fragmentMap != null,\n      'RelayFragmentPointer: Expected record to contain a fragment map, got ' +\n      '`%s` for record `%s`.',\n      fragmentMap,\n      record.__dataID__\n    );\n    fragmentMap[fragment.getConcreteFragmentID()] = dataID;\n  },\n\n  getDataID(\n    record: Record,\n    fragment: RelayQuery.Fragment\n  ): ?DataID {\n    let fragmentMap = record.__fragments__;\n    if (typeof fragmentMap === 'object' && fragmentMap != null) {\n      return fragmentMap[fragment.getConcreteFragmentID()];\n    }\n    return null;\n  },\n\n  create(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment\n  ): FragmentProp {\n    const record = RelayRecord.create(dataID);\n    RelayFragmentPointer.addFragment(record, fragment, dataID);\n    return record;\n  },\n\n  createForRoot(\n    store: RelayRecordStore,\n    query: RelayQuery.Root\n  ): ?FragmentProp | ?Array<?FragmentProp> {\n    const fragment = getRootFragment(query);\n    if (!fragment) {\n      return null;\n    }\n    const storageKey = query.getStorageKey();\n    const identifyingArg = query.getIdentifyingArg();\n    const identifyingArgValue =\n      (identifyingArg && identifyingArg.value) || null;\n    if (Array.isArray(identifyingArgValue)) {\n      return identifyingArgValue.map(singleIdentifyingArgValue => {\n        const dataID = store.getDataID(storageKey, singleIdentifyingArgValue);\n        if (!dataID) {\n          return null;\n        }\n        return RelayFragmentPointer.create(dataID, fragment);\n      });\n    }\n    invariant(\n      typeof identifyingArgValue === 'string' || identifyingArgValue == null,\n      'RelayFragmentPointer: Value for the argument to `%s` on query `%s` ' +\n      'should be a string, but it was set to `%s`. Check that the value is a ' +\n      'string.',\n      query.getFieldName(),\n      query.getName(),\n      identifyingArgValue\n    );\n    const dataID = store.getDataID(storageKey, identifyingArgValue);\n    if (!dataID) {\n      // TODO(t7765591): Throw if `fragment` is not optional.\n      return null;\n    }\n    return RelayFragmentPointer.create(dataID, fragment);\n  },\n};\n\nfunction getRootFragment(query: RelayQuery.Root): ?RelayQuery.Fragment {\n  const batchCall = query.getBatchCall();\n  if (batchCall) {\n    invariant(\n      false,\n      'Queries supplied at the root cannot have batch call variables. Query ' +\n      '`%s` has a batch call variable, `%s`.',\n      query.getName(),\n      batchCall.refParamName\n    );\n  }\n  let fragment;\n  query.getChildren().forEach(child => {\n    if (child instanceof RelayQuery.Fragment) {\n      invariant(\n        !fragment,\n        'Queries supplied at the root should contain exactly one fragment ' +\n        '(e.g. `${Component.getFragment(\\'...\\')}`). Query `%s` contains ' +\n        'more than one fragment.',\n        query.getName()\n      );\n      fragment = child;\n    } else if (child instanceof RelayQuery.Field) {\n      invariant(\n        child.isGenerated(),\n        'Queries supplied at the root should contain exactly one fragment ' +\n        'and no fields. Query `%s` contains a field, `%s`. If you need to ' +\n        'fetch fields, declare them in a Relay container.',\n        query.getName(),\n        child.getSchemaName()\n      );\n    }\n  });\n  return fragment;\n}\n\nmodule.exports = RelayFragmentPointer;\n","dependencies":["RelayRecordStore","RelayInternalTypes","RelayRecord","RelayQuery","invariant","RelayFragmentPointer"],"id":"RelayFragmentPointer","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayFragmentPointer\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nconst RelayRecord = require('RelayRecord');\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst invariant = require('invariant');\n\nimport type {DataID} from 'RelayInternalTypes';\nimport type {Record} from 'RelayRecord';\n\ntype FragmentDataIDMap = {\n  [fragmentID: string]: DataID;\n};\ntype FragmentProp = {\n  __dataID__: DataID,\n  __fragments__: FragmentDataIDMap;\n};\n\n/**\n * Fragment pointers encapsulate the fetched data for a fragment reference. They\n * are opaque tokens that are used by Relay containers to read data that is then\n * passed to the underlying React component.\n *\n * @internal\n */\nconst RelayFragmentPointer = {\n  addFragment(\n    record: Record,\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): void {\n    let fragmentMap = record.__fragments__;\n    if (fragmentMap == null) {\n      fragmentMap = record.__fragments__ = {};\n    }\n    invariant(\n      typeof fragmentMap === 'object' && fragmentMap != null,\n      'RelayFragmentPointer: Expected record to contain a fragment map, got ' +\n      '`%s` for record `%s`.',\n      fragmentMap,\n      record.__dataID__\n    );\n    fragmentMap[fragment.getConcreteFragmentID()] = dataID;\n  },\n\n  getDataID(\n    record: Record,\n    fragment: RelayQuery.Fragment\n  ): ?DataID {\n    let fragmentMap = record.__fragments__;\n    if (typeof fragmentMap === 'object' && fragmentMap != null) {\n      return fragmentMap[fragment.getConcreteFragmentID()];\n    }\n    return null;\n  },\n\n  create(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment\n  ): FragmentProp {\n    const record = RelayRecord.create(dataID);\n    RelayFragmentPointer.addFragment(record, fragment, dataID);\n    return record;\n  },\n\n  createForRoot(\n    store: RelayRecordStore,\n    query: RelayQuery.Root\n  ): ?FragmentProp | ?Array<?FragmentProp> {\n    const fragment = getRootFragment(query);\n    if (!fragment) {\n      return null;\n    }\n    const storageKey = query.getStorageKey();\n    const identifyingArg = query.getIdentifyingArg();\n    const identifyingArgValue =\n      (identifyingArg && identifyingArg.value) || null;\n    if (Array.isArray(identifyingArgValue)) {\n      return identifyingArgValue.map(singleIdentifyingArgValue => {\n        const dataID = store.getDataID(storageKey, singleIdentifyingArgValue);\n        if (!dataID) {\n          return null;\n        }\n        return RelayFragmentPointer.create(dataID, fragment);\n      });\n    }\n    invariant(\n      typeof identifyingArgValue === 'string' || identifyingArgValue == null,\n      'RelayFragmentPointer: Value for the argument to `%s` on query `%s` ' +\n      'should be a string, but it was set to `%s`. Check that the value is a ' +\n      'string.',\n      query.getFieldName(),\n      query.getName(),\n      identifyingArgValue\n    );\n    const dataID = store.getDataID(storageKey, identifyingArgValue);\n    if (!dataID) {\n      // TODO(t7765591): Throw if `fragment` is not optional.\n      return null;\n    }\n    return RelayFragmentPointer.create(dataID, fragment);\n  },\n};\n\nfunction getRootFragment(query: RelayQuery.Root): ?RelayQuery.Fragment {\n  const batchCall = query.getBatchCall();\n  if (batchCall) {\n    invariant(\n      false,\n      'Queries supplied at the root cannot have batch call variables. Query ' +\n      '`%s` has a batch call variable, `%s`.',\n      query.getName(),\n      batchCall.refParamName\n    );\n  }\n  let fragment;\n  query.getChildren().forEach(child => {\n    if (child instanceof RelayQuery.Fragment) {\n      invariant(\n        !fragment,\n        'Queries supplied at the root should contain exactly one fragment ' +\n        '(e.g. `${Component.getFragment(\\'...\\')}`). Query `%s` contains ' +\n        'more than one fragment.',\n        query.getName()\n      );\n      fragment = child;\n    } else if (child instanceof RelayQuery.Field) {\n      invariant(\n        child.isGenerated(),\n        'Queries supplied at the root should contain exactly one fragment ' +\n        'and no fields. Query `%s` contains a field, `%s`. If you need to ' +\n        'fetch fields, declare them in a Relay container.',\n        query.getName(),\n        child.getSchemaName()\n      );\n    }\n  });\n  return fragment;\n}\n\nmodule.exports = RelayFragmentPointer;\n"}}},"/Users/cpojer/Projects/relay/src/query/QueryBuilder.js":{"metadata":{"mtime":1456103379000},"data":{"name":"QueryBuilder","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule QueryBuilder\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteBatchCallVariable,\n  ConcreteCall,\n  ConcreteCallValue,\n  ConcreteCallVariable,\n  ConcreteDirective,\n  ConcreteDirectiveArgument,\n  ConcreteDirectiveValue,\n  ConcreteField,\n  ConcreteFieldMetadata,\n  ConcreteFragment,\n  ConcreteFragmentMetadata,\n  ConcreteFragmentReference,\n  ConcreteMutation,\n  ConcreteOperationMetadata,\n  ConcreteQuery,\n  ConcreteQueryMetadata,\n  ConcreteSelection,\n  ConcreteSubscription,\n  ConcreteValue,\n} from 'ConcreteQuery';\nconst RelayNodeInterface = require('RelayNodeInterface');\n\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst invariant = require('invariant');\n\nconst EMPTY_CALLS: Array<ConcreteCall> = [];\nconst EMPTY_CHILDREN: Array<?ConcreteSelection> = [];\nconst EMPTY_DIRECTIVES: Array<ConcreteDirective> = [];\nconst EMPTY_METADATA = {};\n\nif (__DEV__) {\n  Object.freeze(EMPTY_CALLS);\n  Object.freeze(EMPTY_CHILDREN);\n  Object.freeze(EMPTY_DIRECTIVES);\n  Object.freeze(EMPTY_METADATA);\n}\n\n/**\n * @internal\n *\n * Helper methods for constructing concrete query objects.\n */\nconst QueryBuilder = {\n  createBatchCallVariable(\n    sourceQueryID: string,\n    jsonPath: string\n  ): ConcreteBatchCallVariable {\n    return {\n      kind: 'BatchCallVariable',\n      sourceQueryID,\n      jsonPath,\n    };\n  },\n\n  createCall(\n    name: string,\n    value: ?ConcreteValue,\n    type?: string\n  ): ConcreteCall {\n    return {\n      kind: 'Call',\n      name,\n      metadata: {\n        type: type || null,\n      },\n      value,\n    };\n  },\n\n  createCallValue(\n    callValue: mixed\n  ): ConcreteCallValue {\n    return {\n      kind: 'CallValue',\n      callValue,\n    };\n  },\n\n  createCallVariable(\n    callVariableName: string\n  ): ConcreteCallVariable {\n    return {\n      kind: 'CallVariable',\n      callVariableName,\n    };\n  },\n\n  createDirective(\n    name: string,\n    args: Array<ConcreteDirectiveArgument>\n  ): ConcreteDirective {\n    return {\n      args,\n      kind: 'Directive',\n      name,\n    };\n  },\n\n  createDirectiveArgument(\n    name: string,\n    value: ?ConcreteDirectiveValue\n  ): ConcreteDirectiveArgument {\n    return {\n      name,\n      value,\n    };\n  },\n\n  createField(partialField: {\n    alias?: ?string;\n    calls?: ?Array<ConcreteCall>;\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    fieldName: string;\n    metadata?: ?ConcreteFieldMetadata;\n    type: string;\n  }): ConcreteField {\n    const partialMetadata = partialField.metadata || EMPTY_METADATA;\n    return {\n      alias: partialField.alias,\n      calls: partialField.calls || EMPTY_CALLS,\n      children: partialField.children || EMPTY_CHILDREN,\n      directives: partialField.directives || EMPTY_DIRECTIVES,\n      fieldName: partialField.fieldName,\n      kind: 'Field',\n      metadata: {\n        canHaveSubselections: !!partialMetadata.canHaveSubselections,\n        inferredRootCallName: partialMetadata.inferredRootCallName,\n        inferredPrimaryKey: partialMetadata.inferredPrimaryKey,\n        isConnection: !!partialMetadata.isConnection,\n        isFindable: !!partialMetadata.isFindable,\n        isGenerated: !!partialMetadata.isGenerated,\n        isPlural: !!partialMetadata.isPlural,\n        isRequisite: !!partialMetadata.isRequisite,\n        isAbstract: !!partialMetadata.isAbstract,\n      },\n      type: partialField.type,\n    };\n  },\n\n  createFragment(partialFragment: {\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    isPlural?: boolean;\n    metadata?: ?ConcreteFragmentMetadata;\n    name: string;\n    type: string;\n  }): ConcreteFragment {\n    const metadata = partialFragment.metadata || EMPTY_METADATA;\n    return {\n      children: partialFragment.children || EMPTY_CHILDREN,\n      directives: partialFragment.directives || EMPTY_DIRECTIVES,\n      id: generateConcreteFragmentID(),\n      kind: 'Fragment',\n      metadata: {\n        isAbstract: !!metadata.isAbstract,\n        pattern: !!metadata.pattern,\n        plural: !!metadata.plural, // match the `@relay` argument name\n      },\n      name: partialFragment.name,\n      type: partialFragment.type,\n    };\n  },\n\n  createFragmentReference(\n    fragment: ConcreteFragment\n  ): ConcreteFragmentReference {\n    return {\n      kind: 'FragmentReference',\n      fragment,\n    };\n  },\n\n  createMutation(partialMutation: {\n    calls?: ?Array<ConcreteCall>;\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    metadata?: ?ConcreteOperationMetadata;\n    name: string;\n    responseType: string;\n  }): ConcreteMutation {\n    const metadata = partialMutation.metadata || EMPTY_METADATA;\n    return {\n      calls: partialMutation.calls || EMPTY_CALLS,\n      children: partialMutation.children || EMPTY_CHILDREN,\n      directives: partialMutation.directives || EMPTY_DIRECTIVES,\n      kind: 'Mutation',\n      metadata: {\n        inputType: metadata.inputType,\n      },\n      name: partialMutation.name,\n      responseType: partialMutation.responseType,\n    };\n  },\n\n  createQuery(partialQuery: {\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    fieldName: string;\n    identifyingArgValue: ?ConcreteValue;\n    isDeferred?: boolean;\n    metadata?: ?ConcreteQueryMetadata;\n    name: string;\n    type: string;\n  }): ConcreteQuery {\n    const metadata = partialQuery.metadata || EMPTY_METADATA;\n    let calls = [];\n    let identifyingArgName = metadata.identifyingArgName;\n    if (\n      identifyingArgName == null &&\n      RelayNodeInterface.isNodeRootCall(partialQuery.fieldName)\n    ) {\n      identifyingArgName = RelayNodeInterface.ID;\n    }\n    if (identifyingArgName != null) {\n      invariant(\n        partialQuery.identifyingArgValue != null,\n        'QueryBuilder.createQuery(): An argument value is required for ' +\n        'query `%s(%s: ???)`.',\n        partialQuery.fieldName,\n        identifyingArgName\n      );\n      calls = [QueryBuilder.createCall(\n        identifyingArgName,\n        partialQuery.identifyingArgValue\n      )];\n    }\n    return {\n      calls,\n      children: partialQuery.children || EMPTY_CHILDREN,\n      directives: partialQuery.directives || EMPTY_DIRECTIVES,\n      fieldName: partialQuery.fieldName,\n      isDeferred: !!(partialQuery.isDeferred || metadata.isDeferred),\n      kind: 'Query',\n      metadata: {\n        identifyingArgName,\n        identifyingArgType: metadata.identifyingArgType,\n        isAbstract: !!metadata.isAbstract,\n        isPlural: !!metadata.isPlural,\n      },\n      name: partialQuery.name,\n      type: partialQuery.type,\n    };\n  },\n\n  createSubscription(partialSubscription: {\n    calls?: ?Array<ConcreteCall>;\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    metadata?: ?ConcreteOperationMetadata;\n    name: string;\n    responseType: string;\n  }): ConcreteSubscription {\n    const metadata = partialSubscription.metadata || EMPTY_METADATA;\n    return {\n      calls: partialSubscription.calls || EMPTY_CALLS,\n      children: partialSubscription.children || EMPTY_CHILDREN,\n      directives: partialSubscription.directives || EMPTY_DIRECTIVES,\n      kind: 'Subscription',\n      metadata: {\n        inputType: metadata.inputType,\n      },\n      name: partialSubscription.name,\n      responseType: partialSubscription.responseType,\n    };\n  },\n\n  getBatchCallVariable(node: mixed): ?ConcreteBatchCallVariable {\n    if (isConcreteKind(node, 'BatchCallVariable')) {\n      return (node: any);\n    }\n  },\n\n  getCallVariable(node: mixed): ?ConcreteCallVariable {\n    if (isConcreteKind(node, 'CallVariable')) {\n      return (node: any);\n    }\n  },\n\n  getField(node: mixed): ?ConcreteField {\n    if (isConcreteKind(node, 'Field')) {\n      return (node: any);\n    }\n  },\n\n  getFragment(node: mixed): ?ConcreteFragment {\n    if (isConcreteKind(node, 'Fragment')) {\n      return (node: any);\n    }\n  },\n\n  getFragmentReference(node: mixed): ?ConcreteFragmentReference {\n    if (isConcreteKind(node, 'FragmentReference')) {\n      return (node: any);\n    }\n  },\n\n  getMutation(node: mixed): ?ConcreteMutation {\n    if (isConcreteKind(node, 'Mutation')) {\n      return (node: any);\n    }\n  },\n\n  getQuery(node: mixed): ?ConcreteQuery {\n    if (isConcreteKind(node, 'Query')) {\n      return (node: any);\n    }\n  },\n\n  getSubscription(node: mixed): ?ConcreteSubscription {\n    if (isConcreteKind(node, 'Subscription')) {\n      return (node: any);\n    }\n  },\n};\n\nfunction isConcreteKind(node: mixed, kind: string): boolean {\n  return (\n    typeof node === 'object' &&\n    node !== null &&\n    node.kind === kind\n  );\n}\n\nmodule.exports = QueryBuilder;\n","dependencies":["ConcreteQuery","RelayNodeInterface","generateConcreteFragmentID","invariant","QueryBuilder"],"id":"QueryBuilder","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule QueryBuilder\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteBatchCallVariable,\n  ConcreteCall,\n  ConcreteCallValue,\n  ConcreteCallVariable,\n  ConcreteDirective,\n  ConcreteDirectiveArgument,\n  ConcreteDirectiveValue,\n  ConcreteField,\n  ConcreteFieldMetadata,\n  ConcreteFragment,\n  ConcreteFragmentMetadata,\n  ConcreteFragmentReference,\n  ConcreteMutation,\n  ConcreteOperationMetadata,\n  ConcreteQuery,\n  ConcreteQueryMetadata,\n  ConcreteSelection,\n  ConcreteSubscription,\n  ConcreteValue,\n} from 'ConcreteQuery';\nconst RelayNodeInterface = require('RelayNodeInterface');\n\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst invariant = require('invariant');\n\nconst EMPTY_CALLS: Array<ConcreteCall> = [];\nconst EMPTY_CHILDREN: Array<?ConcreteSelection> = [];\nconst EMPTY_DIRECTIVES: Array<ConcreteDirective> = [];\nconst EMPTY_METADATA = {};\n\nif (__DEV__) {\n  Object.freeze(EMPTY_CALLS);\n  Object.freeze(EMPTY_CHILDREN);\n  Object.freeze(EMPTY_DIRECTIVES);\n  Object.freeze(EMPTY_METADATA);\n}\n\n/**\n * @internal\n *\n * Helper methods for constructing concrete query objects.\n */\nconst QueryBuilder = {\n  createBatchCallVariable(\n    sourceQueryID: string,\n    jsonPath: string\n  ): ConcreteBatchCallVariable {\n    return {\n      kind: 'BatchCallVariable',\n      sourceQueryID,\n      jsonPath,\n    };\n  },\n\n  createCall(\n    name: string,\n    value: ?ConcreteValue,\n    type?: string\n  ): ConcreteCall {\n    return {\n      kind: 'Call',\n      name,\n      metadata: {\n        type: type || null,\n      },\n      value,\n    };\n  },\n\n  createCallValue(\n    callValue: mixed\n  ): ConcreteCallValue {\n    return {\n      kind: 'CallValue',\n      callValue,\n    };\n  },\n\n  createCallVariable(\n    callVariableName: string\n  ): ConcreteCallVariable {\n    return {\n      kind: 'CallVariable',\n      callVariableName,\n    };\n  },\n\n  createDirective(\n    name: string,\n    args: Array<ConcreteDirectiveArgument>\n  ): ConcreteDirective {\n    return {\n      args,\n      kind: 'Directive',\n      name,\n    };\n  },\n\n  createDirectiveArgument(\n    name: string,\n    value: ?ConcreteDirectiveValue\n  ): ConcreteDirectiveArgument {\n    return {\n      name,\n      value,\n    };\n  },\n\n  createField(partialField: {\n    alias?: ?string;\n    calls?: ?Array<ConcreteCall>;\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    fieldName: string;\n    metadata?: ?ConcreteFieldMetadata;\n    type: string;\n  }): ConcreteField {\n    const partialMetadata = partialField.metadata || EMPTY_METADATA;\n    return {\n      alias: partialField.alias,\n      calls: partialField.calls || EMPTY_CALLS,\n      children: partialField.children || EMPTY_CHILDREN,\n      directives: partialField.directives || EMPTY_DIRECTIVES,\n      fieldName: partialField.fieldName,\n      kind: 'Field',\n      metadata: {\n        canHaveSubselections: !!partialMetadata.canHaveSubselections,\n        inferredRootCallName: partialMetadata.inferredRootCallName,\n        inferredPrimaryKey: partialMetadata.inferredPrimaryKey,\n        isConnection: !!partialMetadata.isConnection,\n        isFindable: !!partialMetadata.isFindable,\n        isGenerated: !!partialMetadata.isGenerated,\n        isPlural: !!partialMetadata.isPlural,\n        isRequisite: !!partialMetadata.isRequisite,\n        isAbstract: !!partialMetadata.isAbstract,\n      },\n      type: partialField.type,\n    };\n  },\n\n  createFragment(partialFragment: {\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    isPlural?: boolean;\n    metadata?: ?ConcreteFragmentMetadata;\n    name: string;\n    type: string;\n  }): ConcreteFragment {\n    const metadata = partialFragment.metadata || EMPTY_METADATA;\n    return {\n      children: partialFragment.children || EMPTY_CHILDREN,\n      directives: partialFragment.directives || EMPTY_DIRECTIVES,\n      id: generateConcreteFragmentID(),\n      kind: 'Fragment',\n      metadata: {\n        isAbstract: !!metadata.isAbstract,\n        pattern: !!metadata.pattern,\n        plural: !!metadata.plural, // match the `@relay` argument name\n      },\n      name: partialFragment.name,\n      type: partialFragment.type,\n    };\n  },\n\n  createFragmentReference(\n    fragment: ConcreteFragment\n  ): ConcreteFragmentReference {\n    return {\n      kind: 'FragmentReference',\n      fragment,\n    };\n  },\n\n  createMutation(partialMutation: {\n    calls?: ?Array<ConcreteCall>;\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    metadata?: ?ConcreteOperationMetadata;\n    name: string;\n    responseType: string;\n  }): ConcreteMutation {\n    const metadata = partialMutation.metadata || EMPTY_METADATA;\n    return {\n      calls: partialMutation.calls || EMPTY_CALLS,\n      children: partialMutation.children || EMPTY_CHILDREN,\n      directives: partialMutation.directives || EMPTY_DIRECTIVES,\n      kind: 'Mutation',\n      metadata: {\n        inputType: metadata.inputType,\n      },\n      name: partialMutation.name,\n      responseType: partialMutation.responseType,\n    };\n  },\n\n  createQuery(partialQuery: {\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    fieldName: string;\n    identifyingArgValue: ?ConcreteValue;\n    isDeferred?: boolean;\n    metadata?: ?ConcreteQueryMetadata;\n    name: string;\n    type: string;\n  }): ConcreteQuery {\n    const metadata = partialQuery.metadata || EMPTY_METADATA;\n    let calls = [];\n    let identifyingArgName = metadata.identifyingArgName;\n    if (\n      identifyingArgName == null &&\n      RelayNodeInterface.isNodeRootCall(partialQuery.fieldName)\n    ) {\n      identifyingArgName = RelayNodeInterface.ID;\n    }\n    if (identifyingArgName != null) {\n      invariant(\n        partialQuery.identifyingArgValue != null,\n        'QueryBuilder.createQuery(): An argument value is required for ' +\n        'query `%s(%s: ???)`.',\n        partialQuery.fieldName,\n        identifyingArgName\n      );\n      calls = [QueryBuilder.createCall(\n        identifyingArgName,\n        partialQuery.identifyingArgValue\n      )];\n    }\n    return {\n      calls,\n      children: partialQuery.children || EMPTY_CHILDREN,\n      directives: partialQuery.directives || EMPTY_DIRECTIVES,\n      fieldName: partialQuery.fieldName,\n      isDeferred: !!(partialQuery.isDeferred || metadata.isDeferred),\n      kind: 'Query',\n      metadata: {\n        identifyingArgName,\n        identifyingArgType: metadata.identifyingArgType,\n        isAbstract: !!metadata.isAbstract,\n        isPlural: !!metadata.isPlural,\n      },\n      name: partialQuery.name,\n      type: partialQuery.type,\n    };\n  },\n\n  createSubscription(partialSubscription: {\n    calls?: ?Array<ConcreteCall>;\n    children?: ?Array<?ConcreteSelection>;\n    directives?: ?Array<ConcreteDirective>;\n    metadata?: ?ConcreteOperationMetadata;\n    name: string;\n    responseType: string;\n  }): ConcreteSubscription {\n    const metadata = partialSubscription.metadata || EMPTY_METADATA;\n    return {\n      calls: partialSubscription.calls || EMPTY_CALLS,\n      children: partialSubscription.children || EMPTY_CHILDREN,\n      directives: partialSubscription.directives || EMPTY_DIRECTIVES,\n      kind: 'Subscription',\n      metadata: {\n        inputType: metadata.inputType,\n      },\n      name: partialSubscription.name,\n      responseType: partialSubscription.responseType,\n    };\n  },\n\n  getBatchCallVariable(node: mixed): ?ConcreteBatchCallVariable {\n    if (isConcreteKind(node, 'BatchCallVariable')) {\n      return (node: any);\n    }\n  },\n\n  getCallVariable(node: mixed): ?ConcreteCallVariable {\n    if (isConcreteKind(node, 'CallVariable')) {\n      return (node: any);\n    }\n  },\n\n  getField(node: mixed): ?ConcreteField {\n    if (isConcreteKind(node, 'Field')) {\n      return (node: any);\n    }\n  },\n\n  getFragment(node: mixed): ?ConcreteFragment {\n    if (isConcreteKind(node, 'Fragment')) {\n      return (node: any);\n    }\n  },\n\n  getFragmentReference(node: mixed): ?ConcreteFragmentReference {\n    if (isConcreteKind(node, 'FragmentReference')) {\n      return (node: any);\n    }\n  },\n\n  getMutation(node: mixed): ?ConcreteMutation {\n    if (isConcreteKind(node, 'Mutation')) {\n      return (node: any);\n    }\n  },\n\n  getQuery(node: mixed): ?ConcreteQuery {\n    if (isConcreteKind(node, 'Query')) {\n      return (node: any);\n    }\n  },\n\n  getSubscription(node: mixed): ?ConcreteSubscription {\n    if (isConcreteKind(node, 'Subscription')) {\n      return (node: any);\n    }\n  },\n};\n\nfunction isConcreteKind(node: mixed, kind: string): boolean {\n  return (\n    typeof node === 'object' &&\n    node !== null &&\n    node.kind === kind\n  );\n}\n\nmodule.exports = QueryBuilder;\n"}}},"/Users/cpojer/Projects/relay/src/query/generateRQLFieldAlias.js":{"metadata":{"mtime":1455679338000},"data":{"name":"generateRQLFieldAlias","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateRQLFieldAlias\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/* eslint-disable no-bitwise */\n\nconst base62 = require('base62');\nconst crc32 = require('crc32');\n\nvar PREFIX = '_';\n\n/**\n * @internal\n *\n * Sanitizes a stringified GraphQL field (including any calls and their values)\n * to produce a valid alias.\n *\n * This is used to auto-alias fields in generated queries, so that developers\n * composing multiple components together don't have to worry about collisions\n * between components requesting the same fields. (Explicit aliases are only\n * needed within a single component when it uses the same field multiple times,\n * in order to differentiate these fields in the props).\n */\nfunction generateRQLFieldAlias(input: string): string {\n  // Field names with no calls can be used as aliases without encoding\n  var index = input.indexOf('.');\n  if (index === -1) {\n    return input;\n  }\n  // Unsign crc32 hash so we do not base62 encode a negative number.\n  return PREFIX + input.substr(0, index) + base62(crc32(input) >>> 0);\n}\n\nmodule.exports = generateRQLFieldAlias;\n","dependencies":["base62","crc32","generateRQLFieldAlias"],"id":"generateRQLFieldAlias","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateRQLFieldAlias\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/* eslint-disable no-bitwise */\n\nconst base62 = require('base62');\nconst crc32 = require('crc32');\n\nvar PREFIX = '_';\n\n/**\n * @internal\n *\n * Sanitizes a stringified GraphQL field (including any calls and their values)\n * to produce a valid alias.\n *\n * This is used to auto-alias fields in generated queries, so that developers\n * composing multiple components together don't have to worry about collisions\n * between components requesting the same fields. (Explicit aliases are only\n * needed within a single component when it uses the same field multiple times,\n * in order to differentiate these fields in the props).\n */\nfunction generateRQLFieldAlias(input: string): string {\n  // Field names with no calls can be used as aliases without encoding\n  var index = input.indexOf('.');\n  if (index === -1) {\n    return input;\n  }\n  // Unsign crc32 hash so we do not base62 encode a negative number.\n  return PREFIX + input.substr(0, index) + base62(crc32(input) >>> 0);\n}\n\nmodule.exports = generateRQLFieldAlias;\n"}}},"/Users/cpojer/Projects/relay/src/query/generateConcreteFragmentID.js":{"metadata":{"mtime":1456103379000},"data":{"name":"generateConcreteFragmentID","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateConcreteFragmentID\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst base62 = require('base62');\n\n// Static ids always end with `:<HASH>` where HASH is an alphanumeric transform\n// of an auto-incrementing index. A double-colon is used to distinguish between\n// client ids and static ids that happen to hash to `:client`.\nconst SUFFIX = '::client';\n\nlet _nextFragmentID = 0;\n\n/**\n * The \"concrete fragment id\" uniquely identifies a Relay.QL`fragment ...`\n * within the source code of an application and will remain the same across\n * runs of a particular version of an application.\n *\n * This function can be used to generate a unique id for fragments constructed\n * at runtime and is guaranteed not to conflict with statically created ids.\n */\nfunction generateConcreteFragmentID(): string {\n  return base62(_nextFragmentID++) + SUFFIX;\n}\n\nmodule.exports = generateConcreteFragmentID;\n","dependencies":["base62","generateConcreteFragmentID"],"id":"generateConcreteFragmentID","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule generateConcreteFragmentID\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst base62 = require('base62');\n\n// Static ids always end with `:<HASH>` where HASH is an alphanumeric transform\n// of an auto-incrementing index. A double-colon is used to distinguish between\n// client ids and static ids that happen to hash to `:client`.\nconst SUFFIX = '::client';\n\nlet _nextFragmentID = 0;\n\n/**\n * The \"concrete fragment id\" uniquely identifies a Relay.QL`fragment ...`\n * within the source code of an application and will remain the same across\n * runs of a particular version of an application.\n *\n * This function can be used to generate a unique id for fragments constructed\n * at runtime and is guaranteed not to conflict with statically created ids.\n */\nfunction generateConcreteFragmentID(): string {\n  return base62(_nextFragmentID++) + SUFFIX;\n}\n\nmodule.exports = generateConcreteFragmentID;\n"}}},"/Users/cpojer/Projects/relay/src/query/fromGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"name":"fromGraphQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule fromGraphQL\n * @flow\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nconst RelayMetaRoute = require('RelayMetaRoute');\n\nconst invariant = require('invariant');\n\ntype ConcreteQueryObject = mixed;\ntype QueryClass = (\n  typeof RelayQuery.Field |\n  typeof RelayQuery.Fragment |\n  typeof RelayQuery.Operation |\n  typeof RelayQuery.Root\n);\n\n/**\n * @internal\n *\n * Converts GraphQL nodes to RelayQuery nodes.\n */\nvar fromGraphQL = {\n  Field(query: ConcreteQueryObject): RelayQuery.Field {\n    var node = createNode(query, RelayQuery.Field);\n    invariant(\n      node instanceof RelayQuery.Field,\n      'fromGraphQL.Field(): Expected a GraphQL field node.'\n    );\n    return node;\n  },\n  Fragment(query: ConcreteQueryObject): RelayQuery.Fragment {\n    var node = createNode(query, RelayQuery.Fragment);\n    invariant(\n      node instanceof RelayQuery.Fragment,\n      'fromGraphQL.Fragment(): Expected a GraphQL fragment node.'\n    );\n    return node;\n  },\n  Query(query: ConcreteQueryObject): RelayQuery.Root {\n    var node = createNode(query, RelayQuery.Root);\n    invariant(\n      node instanceof RelayQuery.Root,\n      'fromGraphQL.Query(): Expected a root node.'\n    );\n    return node;\n  },\n  Operation(query: ConcreteQueryObject): RelayQuery.Operation {\n    var node = createNode(query, RelayQuery.Operation);\n    invariant(\n      node instanceof RelayQuery.Operation,\n      'fromGraphQL.Operation(): Expected a mutation/subscription node.'\n    );\n    return node;\n  },\n};\n\nfunction createNode(\n  query: ConcreteQueryObject,\n  desiredType: QueryClass\n): RelayQuery.Node {\n  var variables = {};\n  var route = RelayMetaRoute.get('$fromGraphQL');\n  return desiredType.create(query, route, variables);\n}\n\nmodule.exports = fromGraphQL;\n","dependencies":["RelayQuery","RelayMetaRoute","invariant","fromGraphQL"],"id":"fromGraphQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule fromGraphQL\n * @flow\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nconst RelayMetaRoute = require('RelayMetaRoute');\n\nconst invariant = require('invariant');\n\ntype ConcreteQueryObject = mixed;\ntype QueryClass = (\n  typeof RelayQuery.Field |\n  typeof RelayQuery.Fragment |\n  typeof RelayQuery.Operation |\n  typeof RelayQuery.Root\n);\n\n/**\n * @internal\n *\n * Converts GraphQL nodes to RelayQuery nodes.\n */\nvar fromGraphQL = {\n  Field(query: ConcreteQueryObject): RelayQuery.Field {\n    var node = createNode(query, RelayQuery.Field);\n    invariant(\n      node instanceof RelayQuery.Field,\n      'fromGraphQL.Field(): Expected a GraphQL field node.'\n    );\n    return node;\n  },\n  Fragment(query: ConcreteQueryObject): RelayQuery.Fragment {\n    var node = createNode(query, RelayQuery.Fragment);\n    invariant(\n      node instanceof RelayQuery.Fragment,\n      'fromGraphQL.Fragment(): Expected a GraphQL fragment node.'\n    );\n    return node;\n  },\n  Query(query: ConcreteQueryObject): RelayQuery.Root {\n    var node = createNode(query, RelayQuery.Root);\n    invariant(\n      node instanceof RelayQuery.Root,\n      'fromGraphQL.Query(): Expected a root node.'\n    );\n    return node;\n  },\n  Operation(query: ConcreteQueryObject): RelayQuery.Operation {\n    var node = createNode(query, RelayQuery.Operation);\n    invariant(\n      node instanceof RelayQuery.Operation,\n      'fromGraphQL.Operation(): Expected a mutation/subscription node.'\n    );\n    return node;\n  },\n};\n\nfunction createNode(\n  query: ConcreteQueryObject,\n  desiredType: QueryClass\n): RelayQuery.Node {\n  var variables = {};\n  var route = RelayMetaRoute.get('$fromGraphQL');\n  return desiredType.create(query, route, variables);\n}\n\nmodule.exports = fromGraphQL;\n"}}},"/Users/cpojer/Projects/relay/src/query/forEachRootCallArg.js":{"metadata":{"mtime":1455679338000},"data":{"name":"forEachRootCallArg","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule forEachRootCallArg\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\nconst invariant = require('invariant');\n\n/**\n * @internal\n *\n * Iterates over the identifying arguments in the supplied root call.\n * If the identifying value is null or undefined, the supplied callback will be\n * invoked once.\n */\nfunction forEachRootCallArg(\n  query: RelayQuery.Root,\n  callback: (identifyingArgValue: ?string) => void\n): void {\n  invariant(\n    !query.getBatchCall(),\n    'forEachRootCallArg(): Cannot iterate over batch call variables.'\n  );\n  function each(identifyingArgValue, fn) {\n    if (Array.isArray(identifyingArgValue)) {\n      identifyingArgValue.forEach(value => each(value, fn));\n    } else if (identifyingArgValue == null) {\n      fn(identifyingArgValue);\n    } else {\n      invariant(\n        typeof identifyingArgValue === 'string' ||\n        typeof identifyingArgValue === 'number',\n        'Relay: Expected arguments to root field `%s` to each be strings/' +\n        'numbers, got `%s`.',\n        query.getFieldName(),\n        JSON.stringify(identifyingArgValue)\n      );\n      fn('' + identifyingArgValue);\n    }\n  }\n  const identifyingArg = query.getIdentifyingArg();\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  each(identifyingArgValue, callback);\n}\n\nmodule.exports = forEachRootCallArg;\n","dependencies":["RelayQuery","invariant","forEachRootCallArg"],"id":"forEachRootCallArg","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule forEachRootCallArg\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\nconst invariant = require('invariant');\n\n/**\n * @internal\n *\n * Iterates over the identifying arguments in the supplied root call.\n * If the identifying value is null or undefined, the supplied callback will be\n * invoked once.\n */\nfunction forEachRootCallArg(\n  query: RelayQuery.Root,\n  callback: (identifyingArgValue: ?string) => void\n): void {\n  invariant(\n    !query.getBatchCall(),\n    'forEachRootCallArg(): Cannot iterate over batch call variables.'\n  );\n  function each(identifyingArgValue, fn) {\n    if (Array.isArray(identifyingArgValue)) {\n      identifyingArgValue.forEach(value => each(value, fn));\n    } else if (identifyingArgValue == null) {\n      fn(identifyingArgValue);\n    } else {\n      invariant(\n        typeof identifyingArgValue === 'string' ||\n        typeof identifyingArgValue === 'number',\n        'Relay: Expected arguments to root field `%s` to each be strings/' +\n        'numbers, got `%s`.',\n        query.getFieldName(),\n        JSON.stringify(identifyingArgValue)\n      );\n      fn('' + identifyingArgValue);\n    }\n  }\n  const identifyingArg = query.getIdentifyingArg();\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  each(identifyingArgValue, callback);\n}\n\nmodule.exports = forEachRootCallArg;\n"}}},"/Users/cpojer/Projects/relay/src/query/directivesToGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"name":"directivesToGraphQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule directivesToGraphQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {ConcreteDirective} from 'ConcreteQuery';\nimport type {Directive} from 'RelayInternalTypes';\nconst QueryBuilder = require('QueryBuilder');\n\n/**\n * @internal\n *\n * Convert plain object `{name, arguments}` directives to GraphQL directive\n * nodes.\n */\nfunction directivesToGraphQL(\n  directives: Array<Directive>\n): Array<ConcreteDirective> {\n  return directives.map(({name, args}) => {\n    const concreteArguments = args.map(({name, value}) => {\n      let concreteArgument = null;\n      if (Array.isArray(value)) {\n        concreteArgument = value.map(QueryBuilder.createCallValue);\n      } else if (value != null)  {\n        concreteArgument = QueryBuilder.createCallValue(value);\n      }\n      return QueryBuilder.createDirectiveArgument(name, concreteArgument);\n    });\n    return QueryBuilder.createDirective(name, concreteArguments);\n  });\n}\n\nmodule.exports = directivesToGraphQL;\n","dependencies":["ConcreteQuery","RelayInternalTypes","QueryBuilder","directivesToGraphQL"],"id":"directivesToGraphQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule directivesToGraphQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {ConcreteDirective} from 'ConcreteQuery';\nimport type {Directive} from 'RelayInternalTypes';\nconst QueryBuilder = require('QueryBuilder');\n\n/**\n * @internal\n *\n * Convert plain object `{name, arguments}` directives to GraphQL directive\n * nodes.\n */\nfunction directivesToGraphQL(\n  directives: Array<Directive>\n): Array<ConcreteDirective> {\n  return directives.map(({name, args}) => {\n    const concreteArguments = args.map(({name, value}) => {\n      let concreteArgument = null;\n      if (Array.isArray(value)) {\n        concreteArgument = value.map(QueryBuilder.createCallValue);\n      } else if (value != null)  {\n        concreteArgument = QueryBuilder.createCallValue(value);\n      }\n      return QueryBuilder.createDirectiveArgument(name, concreteArgument);\n    });\n    return QueryBuilder.createDirective(name, concreteArguments);\n  });\n}\n\nmodule.exports = directivesToGraphQL;\n"}}},"/Users/cpojer/Projects/relay/src/query/createRelayQuery.js":{"metadata":{"mtime":1455679338000},"data":{"name":"createRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createRelayQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\n\nconst invariant = require('invariant');\n\nfunction createRelayQuery(\n  node: Object,\n  variables: {[key: string]: mixed}\n): RelayQuery.Root {\n  invariant(\n    typeof variables === 'object' &&\n    variables != null &&\n    !Array.isArray(variables),\n    'Relay.Query: Expected `variables` to be an object.'\n  );\n  return RelayQuery.Root.create(\n    node,\n    RelayMetaRoute.get('$createRelayQuery'),\n    variables\n  );\n}\n\nmodule.exports = createRelayQuery;\n","dependencies":["RelayMetaRoute","RelayQuery","invariant","createRelayQuery"],"id":"createRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createRelayQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayMetaRoute = require('RelayMetaRoute');\nconst RelayQuery = require('RelayQuery');\n\nconst invariant = require('invariant');\n\nfunction createRelayQuery(\n  node: Object,\n  variables: {[key: string]: mixed}\n): RelayQuery.Root {\n  invariant(\n    typeof variables === 'object' &&\n    variables != null &&\n    !Array.isArray(variables),\n    'Relay.Query: Expected `variables` to be an object.'\n  );\n  return RelayQuery.Root.create(\n    node,\n    RelayMetaRoute.get('$createRelayQuery'),\n    variables\n  );\n}\n\nmodule.exports = createRelayQuery;\n"}}},"/Users/cpojer/Projects/relay/src/query/ConcreteQuery.js":{"metadata":{"mtime":1456103379000},"data":{"name":"ConcreteQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ConcreteQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * Types representing the transformed output of Relay.QL queries.\n */\n\n/**\n * Ideally this would be a union of Field/Fragment/Mutation/Query/Subscription,\n * but that causes lots of Flow errors.\n */\nexport type ConcreteNode = {\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n};\n\nexport type ConcreteSelection =\n  ConcreteField |\n  ConcreteFragment |\n  ConcreteFragmentReference;\n\nexport type ConcreteValue =\n  ConcreteBatchCallVariable |\n  ConcreteCallValue |\n  ConcreteCallVariable |\n  Array<ConcreteCallValue | ConcreteCallVariable>;\n\nexport type ConcreteDirectiveValue =\n  ConcreteCallValue |\n  ConcreteCallVariable |\n  Array<ConcreteCallValue | ConcreteCallVariable>;\n\nexport type ConcreteBatchCallVariable = {\n  jsonPath: string;\n  kind: 'BatchCallVariable';\n  sourceQueryID: string;\n};\n\nexport type ConcreteCall = {\n  kind: 'Call';\n  metadata: {\n    type?: ?string;\n  };\n  name: string;\n  value: ?ConcreteValue;\n};\n\nexport type ConcreteCallValue = {\n  callValue: mixed;\n  kind: 'CallValue';\n}\n\nexport type ConcreteCallVariable = {\n  callVariableName: string;\n  kind: 'CallVariable';\n};\n\nexport type ConcreteDirective = {\n  args: Array<ConcreteDirectiveArgument>;\n  kind: 'Directive';\n  name: string;\n};\n\nexport type ConcreteDirectiveArgument = {\n  name: string;\n  value: ?ConcreteDirectiveValue;\n};\n\nexport type ConcreteFieldMetadata = {\n  canHaveSubselections?: ?boolean;\n  inferredPrimaryKey?: ?string;\n  inferredRootCallName?: ?string;\n  isAbstract?: boolean;\n  isConnection?: boolean;\n  isConnectionWithoutNodeID?: boolean;\n  isFindable?: boolean;\n  isGenerated?: boolean;\n  isPlural?: boolean;\n  isRequisite?: boolean;\n};\n\nexport type ConcreteField = {\n  alias?: ?string;\n  calls?: ?Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  fieldName: string;\n  kind: 'Field';\n  metadata: ConcreteFieldMetadata;\n  type: string;\n};\n\nexport type ConcreteFragmentMetadata = {\n  isAbstract?: boolean;\n  pattern?: boolean;\n  plural?: boolean;\n};\n\nexport type ConcreteFragment = {\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  id: string;\n  kind: 'Fragment';\n  metadata: {\n    isAbstract?: boolean;\n    isPlural?: boolean; // FB Printer\n    pattern?: boolean;  // from @relay directive\n    plural?: boolean;   // OSS Printer from `@relay`\n  };\n  name: string;\n  type: string;\n};\n\nexport type ConcreteFragmentReference = {\n  kind: 'FragmentReference';\n  fragment: ConcreteFragment;\n};\n\nexport type ConcreteMutation = {\n  calls: Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  kind: 'Mutation';\n  metadata: {\n    inputType?: ?string;\n  };\n  name: string;\n  responseType: string;\n};\n\nexport type ConcreteOperationMetadata = {\n  inputType?: ?string;\n};\n\nexport type ConcreteQueryMetadata = {\n  identifyingArgName: ?string;\n  identifyingArgType: ?string;\n  isAbstract: ?boolean;\n  isDeferred: ?boolean;\n  isPlural: ?boolean;\n};\n\nexport type ConcreteQuery = {\n  calls?: ?Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  fieldName: string;\n  isDeferred?: boolean;\n  kind: 'Query';\n  metadata: {\n    identifyingArgName?: ?string;\n    identifyingArgType?: ?string;\n    isAbstract?: ?boolean;\n    isPlural?: ?boolean;\n  };\n  name: string;\n  type: string;\n};\n\nexport type ConcreteSubscription = {\n  calls: Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  kind: 'Subscription';\n  name: string;\n  responseType: string;\n  metadata: {\n    inputType?: ?string;\n  };\n};\n","dependencies":[],"id":"ConcreteQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ConcreteQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * Types representing the transformed output of Relay.QL queries.\n */\n\n/**\n * Ideally this would be a union of Field/Fragment/Mutation/Query/Subscription,\n * but that causes lots of Flow errors.\n */\nexport type ConcreteNode = {\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n};\n\nexport type ConcreteSelection =\n  ConcreteField |\n  ConcreteFragment |\n  ConcreteFragmentReference;\n\nexport type ConcreteValue =\n  ConcreteBatchCallVariable |\n  ConcreteCallValue |\n  ConcreteCallVariable |\n  Array<ConcreteCallValue | ConcreteCallVariable>;\n\nexport type ConcreteDirectiveValue =\n  ConcreteCallValue |\n  ConcreteCallVariable |\n  Array<ConcreteCallValue | ConcreteCallVariable>;\n\nexport type ConcreteBatchCallVariable = {\n  jsonPath: string;\n  kind: 'BatchCallVariable';\n  sourceQueryID: string;\n};\n\nexport type ConcreteCall = {\n  kind: 'Call';\n  metadata: {\n    type?: ?string;\n  };\n  name: string;\n  value: ?ConcreteValue;\n};\n\nexport type ConcreteCallValue = {\n  callValue: mixed;\n  kind: 'CallValue';\n}\n\nexport type ConcreteCallVariable = {\n  callVariableName: string;\n  kind: 'CallVariable';\n};\n\nexport type ConcreteDirective = {\n  args: Array<ConcreteDirectiveArgument>;\n  kind: 'Directive';\n  name: string;\n};\n\nexport type ConcreteDirectiveArgument = {\n  name: string;\n  value: ?ConcreteDirectiveValue;\n};\n\nexport type ConcreteFieldMetadata = {\n  canHaveSubselections?: ?boolean;\n  inferredPrimaryKey?: ?string;\n  inferredRootCallName?: ?string;\n  isAbstract?: boolean;\n  isConnection?: boolean;\n  isConnectionWithoutNodeID?: boolean;\n  isFindable?: boolean;\n  isGenerated?: boolean;\n  isPlural?: boolean;\n  isRequisite?: boolean;\n};\n\nexport type ConcreteField = {\n  alias?: ?string;\n  calls?: ?Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  fieldName: string;\n  kind: 'Field';\n  metadata: ConcreteFieldMetadata;\n  type: string;\n};\n\nexport type ConcreteFragmentMetadata = {\n  isAbstract?: boolean;\n  pattern?: boolean;\n  plural?: boolean;\n};\n\nexport type ConcreteFragment = {\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  id: string;\n  kind: 'Fragment';\n  metadata: {\n    isAbstract?: boolean;\n    isPlural?: boolean; // FB Printer\n    pattern?: boolean;  // from @relay directive\n    plural?: boolean;   // OSS Printer from `@relay`\n  };\n  name: string;\n  type: string;\n};\n\nexport type ConcreteFragmentReference = {\n  kind: 'FragmentReference';\n  fragment: ConcreteFragment;\n};\n\nexport type ConcreteMutation = {\n  calls: Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  kind: 'Mutation';\n  metadata: {\n    inputType?: ?string;\n  };\n  name: string;\n  responseType: string;\n};\n\nexport type ConcreteOperationMetadata = {\n  inputType?: ?string;\n};\n\nexport type ConcreteQueryMetadata = {\n  identifyingArgName: ?string;\n  identifyingArgType: ?string;\n  isAbstract: ?boolean;\n  isDeferred: ?boolean;\n  isPlural: ?boolean;\n};\n\nexport type ConcreteQuery = {\n  calls?: ?Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  fieldName: string;\n  isDeferred?: boolean;\n  kind: 'Query';\n  metadata: {\n    identifyingArgName?: ?string;\n    identifyingArgType?: ?string;\n    isAbstract?: ?boolean;\n    isPlural?: ?boolean;\n  };\n  name: string;\n  type: string;\n};\n\nexport type ConcreteSubscription = {\n  calls: Array<ConcreteCall>;\n  children?: ?Array<?ConcreteSelection>;\n  directives?: ?Array<ConcreteDirective>;\n  kind: 'Subscription';\n  name: string;\n  responseType: string;\n  metadata: {\n    inputType?: ?string;\n  };\n};\n"}}},"/Users/cpojer/Projects/relay/src/query/callsToGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"name":"callsToGraphQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule callsToGraphQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {ConcreteCall} from 'ConcreteQuery';\nimport type {Call} from 'RelayInternalTypes';\nconst QueryBuilder = require('QueryBuilder');\n\n/**\n * @internal\n *\n * Convert from plain object `{name, value}` calls to GraphQL call nodes.\n */\nfunction callsToGraphQL(calls: Array<Call>): Array<ConcreteCall> {\n  return calls.map(({name, value}) => {\n    let concreteValue = null;\n    if (Array.isArray(value)) {\n      concreteValue = value.map(QueryBuilder.createCallValue);\n    } else if (value != null)  {\n      concreteValue = QueryBuilder.createCallValue(value);\n    }\n    return QueryBuilder.createCall(name, concreteValue);\n  });\n}\n\nmodule.exports = callsToGraphQL;\n","dependencies":["ConcreteQuery","RelayInternalTypes","QueryBuilder","callsToGraphQL"],"id":"callsToGraphQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule callsToGraphQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {ConcreteCall} from 'ConcreteQuery';\nimport type {Call} from 'RelayInternalTypes';\nconst QueryBuilder = require('QueryBuilder');\n\n/**\n * @internal\n *\n * Convert from plain object `{name, value}` calls to GraphQL call nodes.\n */\nfunction callsToGraphQL(calls: Array<Call>): Array<ConcreteCall> {\n  return calls.map(({name, value}) => {\n    let concreteValue = null;\n    if (Array.isArray(value)) {\n      concreteValue = value.map(QueryBuilder.createCallValue);\n    } else if (value != null)  {\n      concreteValue = QueryBuilder.createCallValue(value);\n    }\n    return QueryBuilder.createCall(name, concreteValue);\n  });\n}\n\nmodule.exports = callsToGraphQL;\n"}}},"/Users/cpojer/Projects/relay/src/query/callsFromGraphQL.js":{"metadata":{"mtime":1455679338000},"data":{"name":"callsFromGraphQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule callsFromGraphQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteCall,\n  ConcreteValue,\n  ConcreteCallValue,\n  ConcreteCallVariable,\n} from 'ConcreteQuery';\nimport type {Call, CallValue} from 'RelayInternalTypes';\nimport type {Variables} from 'RelayTypes';\n\nconst invariant = require('invariant');\n\ntype CallOrDirective = {\n  name: string;\n  value: ?ConcreteValue;\n};\n\n/**\n * @internal\n *\n * Convert from GraphQL call nodes to plain object `{name,value}` calls.\n */\nfunction callsFromGraphQL(\n  concreteCalls: Array<ConcreteCall>,\n  variables: Variables\n): Array<Call> {\n  // $FlowIssue: ConcreteCall should flow into CallOrDirective\n  var callsOrDirectives: Array<CallOrDirective> = (concreteCalls: $FlowIssue);\n  var orderedCalls = [];\n  for (var ii = 0; ii < callsOrDirectives.length; ii++) {\n    var {name, value} = callsOrDirectives[ii];\n    if (value != null) {\n      if (Array.isArray(value)) {\n        value = value.map(arg => getCallValue(arg, variables));\n      } else if (value.kind === 'BatchCallVariable') {\n        // Batch calls are handled separately\n        value = null;\n      } else {\n        value = getCallValue(value, variables);\n      }\n    }\n    orderedCalls.push({name, value});\n  }\n  return orderedCalls;\n}\n\nfunction getCallValue(\n  value: ConcreteCallValue | ConcreteCallVariable,\n  variables: Variables\n): ?CallValue {\n  if (value.kind === 'CallValue') {\n    return value.callValue;\n  } else {\n    var variableName = value.callVariableName;\n    invariant(\n      variables.hasOwnProperty(variableName),\n      'callsFromGraphQL(): Expected a declared value for variable, `$%s`.',\n      variableName\n    );\n    return variables[variableName];\n  }\n}\n\nmodule.exports = callsFromGraphQL;\n","dependencies":["ConcreteQuery","RelayInternalTypes","RelayTypes","invariant","callsFromGraphQL"],"id":"callsFromGraphQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule callsFromGraphQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteCall,\n  ConcreteValue,\n  ConcreteCallValue,\n  ConcreteCallVariable,\n} from 'ConcreteQuery';\nimport type {Call, CallValue} from 'RelayInternalTypes';\nimport type {Variables} from 'RelayTypes';\n\nconst invariant = require('invariant');\n\ntype CallOrDirective = {\n  name: string;\n  value: ?ConcreteValue;\n};\n\n/**\n * @internal\n *\n * Convert from GraphQL call nodes to plain object `{name,value}` calls.\n */\nfunction callsFromGraphQL(\n  concreteCalls: Array<ConcreteCall>,\n  variables: Variables\n): Array<Call> {\n  // $FlowIssue: ConcreteCall should flow into CallOrDirective\n  var callsOrDirectives: Array<CallOrDirective> = (concreteCalls: $FlowIssue);\n  var orderedCalls = [];\n  for (var ii = 0; ii < callsOrDirectives.length; ii++) {\n    var {name, value} = callsOrDirectives[ii];\n    if (value != null) {\n      if (Array.isArray(value)) {\n        value = value.map(arg => getCallValue(arg, variables));\n      } else if (value.kind === 'BatchCallVariable') {\n        // Batch calls are handled separately\n        value = null;\n      } else {\n        value = getCallValue(value, variables);\n      }\n    }\n    orderedCalls.push({name, value});\n  }\n  return orderedCalls;\n}\n\nfunction getCallValue(\n  value: ConcreteCallValue | ConcreteCallVariable,\n  variables: Variables\n): ?CallValue {\n  if (value.kind === 'CallValue') {\n    return value.callValue;\n  } else {\n    var variableName = value.callVariableName;\n    invariant(\n      variables.hasOwnProperty(variableName),\n      'callsFromGraphQL(): Expected a declared value for variable, `$%s`.',\n      variableName\n    );\n    return variables[variableName];\n  }\n}\n\nmodule.exports = callsFromGraphQL;\n"}}},"/Users/cpojer/Projects/relay/src/query/buildRQL.js":{"metadata":{"mtime":1456974578000},"data":{"name":"buildRQL","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule buildRQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteFragment,\n  ConcreteQuery,\n} from 'ConcreteQuery';\nconst Map = require('Map');\nconst QueryBuilder = require('QueryBuilder');\nimport type {RelayConcreteNode} from 'RelayQL';\nconst RelayProfiler = require('RelayProfiler');\nimport type {RelayContainer, Variables} from 'RelayTypes';\nconst Set = require('Set');\n\nconst filterObject = require('filterObject');\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst invariant = require('invariant');\nconst mapObject = require('mapObject');\n\nexport type RelayQLFragmentBuilder =\n  (variables: Variables) => RelayConcreteNode;\nexport type RelayQLQueryBuilder =\n  (Component: RelayContainer, params: Variables) => RelayConcreteNode;\n\n// Cache results of executing fragment query builders.\nconst fragmentCache = new Map();\nconst concreteFragmentIDSet = new Set();\n\n// Cache results of executing component-specific route query builders.\nconst queryCache = new Map();\n\nfunction isDeprecatedCallWithArgCountGreaterThan(\n  nodeBuilder: Function,\n  count: number\n): boolean {\n  var argLength = nodeBuilder.length;\n  if (__DEV__) {\n    var mockImpl = nodeBuilder;\n    while (mockImpl && mockImpl._getMockImplementation) {\n      mockImpl = mockImpl._getMockImplementation();\n    }\n    if (mockImpl) {\n      argLength = mockImpl.length;\n    }\n  }\n  return argLength > count;\n}\n\n/**\n * @internal\n *\n * Builds a static node representation using a supplied query or fragment\n * builder. This is used for routes, containers, and mutations.\n *\n * If the supplied fragment builder produces an invalid node (e.g. the wrong\n * node type), these will return `undefined`. This is not to be confused with\n * a return value of `null`, which may result from the lack of a node.\n */\nvar buildRQL = {\n  Fragment(\n    fragmentBuilder: RelayQLFragmentBuilder,\n    values: Variables\n  ): ?ConcreteFragment {\n    let node = fragmentCache.get(fragmentBuilder);\n    if (node) {\n      return QueryBuilder.getFragment(node);\n    }\n    const variables = toVariables(values);\n    invariant(\n      !isDeprecatedCallWithArgCountGreaterThan(fragmentBuilder, 1),\n      'Relay.QL: Deprecated usage detected. If you are trying to define a ' +\n      'fragment, use `variables => Relay.QL`.'\n    );\n    node = fragmentBuilder(variables);\n    let fragment = node != null ?\n      QueryBuilder.getFragment(node) :\n      null;\n    if (!fragment) {\n      return fragment;\n    }\n    if (concreteFragmentIDSet.has(fragment.id)) {\n      fragment = {\n        ...fragment,\n        id: generateConcreteFragmentID(),\n      };\n    }\n    concreteFragmentIDSet.add(fragment.id);\n    fragmentCache.set(fragmentBuilder, fragment);\n    return fragment;\n  },\n\n  Query(\n    queryBuilder: RelayQLQueryBuilder,\n    Component: any,\n    queryName: string,\n    values: Variables\n  ): ?ConcreteQuery {\n    let componentCache = queryCache.get(queryBuilder);\n    let node;\n    if (!componentCache) {\n      componentCache = new Map();\n      queryCache.set(queryBuilder, componentCache);\n    } else {\n      node = componentCache.get(Component);\n    }\n    if (!node) {\n      const variables = toVariables(values);\n      invariant(\n        !isDeprecatedCallWithArgCountGreaterThan(queryBuilder, 2),\n        'Relay.QL: Deprecated usage detected. If you are trying to define a ' +\n        'query, use `(Component, variables) => Relay.QL`.'\n      );\n      if (isDeprecatedCallWithArgCountGreaterThan(queryBuilder, 0)) {\n        node = queryBuilder(Component, variables);\n      } else {\n        node = queryBuilder(Component, variables);\n        const query = QueryBuilder.getQuery(node);\n        if (query) {\n          let hasFragment = false;\n          let hasScalarFieldsOnly = true;\n          if (query.children) {\n            query.children.forEach(child => {\n              if (child) {\n                hasFragment = hasFragment || child.kind === 'Fragment';\n                hasScalarFieldsOnly = hasScalarFieldsOnly && (\n                  child.kind === 'Field' &&\n                  (!child.children || child.children.length === 0)\n                );\n              }\n            });\n          }\n          if (!hasFragment) {\n            const children = query.children ? [...query.children] : [];\n            invariant(\n              hasScalarFieldsOnly,\n              'Relay.QL: Expected query `%s` to be empty. For example, use ' +\n              '`node(id: $id)`, not `node(id: $id) { ... }`.',\n              query.fieldName\n            );\n            const fragmentVariables = filterObject(variables, (_, name) =>\n              Component.hasVariable(name)\n            );\n            children.push(Component.getFragment(queryName, fragmentVariables));\n            node = {\n              ...query,\n              children,\n            };\n          }\n        }\n      }\n      componentCache.set(Component, node);\n    }\n    if (node) {\n      return QueryBuilder.getQuery(node) || undefined;\n    }\n    return null;\n  },\n};\n\nfunction toVariables(variables: Variables): {\n  [key: string]: $FlowIssue; // ConcreteCallVariable should flow into mixed\n} {\n  return mapObject(\n    variables,\n    (_, name) => QueryBuilder.createCallVariable(name)\n  );\n}\n\nRelayProfiler.instrumentMethods(buildRQL, {\n  Fragment: 'buildRQL.Fragment',\n  Query: 'buildRQL.Query',\n});\n\nmodule.exports = buildRQL;\n","dependencies":["ConcreteQuery","RelayQL","RelayTypes","Map","QueryBuilder","RelayProfiler","Set","filterObject","generateConcreteFragmentID","invariant","mapObject","buildRQL"],"id":"buildRQL","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule buildRQL\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {\n  ConcreteFragment,\n  ConcreteQuery,\n} from 'ConcreteQuery';\nconst Map = require('Map');\nconst QueryBuilder = require('QueryBuilder');\nimport type {RelayConcreteNode} from 'RelayQL';\nconst RelayProfiler = require('RelayProfiler');\nimport type {RelayContainer, Variables} from 'RelayTypes';\nconst Set = require('Set');\n\nconst filterObject = require('filterObject');\nconst generateConcreteFragmentID = require('generateConcreteFragmentID');\nconst invariant = require('invariant');\nconst mapObject = require('mapObject');\n\nexport type RelayQLFragmentBuilder =\n  (variables: Variables) => RelayConcreteNode;\nexport type RelayQLQueryBuilder =\n  (Component: RelayContainer, params: Variables) => RelayConcreteNode;\n\n// Cache results of executing fragment query builders.\nconst fragmentCache = new Map();\nconst concreteFragmentIDSet = new Set();\n\n// Cache results of executing component-specific route query builders.\nconst queryCache = new Map();\n\nfunction isDeprecatedCallWithArgCountGreaterThan(\n  nodeBuilder: Function,\n  count: number\n): boolean {\n  var argLength = nodeBuilder.length;\n  if (__DEV__) {\n    var mockImpl = nodeBuilder;\n    while (mockImpl && mockImpl._getMockImplementation) {\n      mockImpl = mockImpl._getMockImplementation();\n    }\n    if (mockImpl) {\n      argLength = mockImpl.length;\n    }\n  }\n  return argLength > count;\n}\n\n/**\n * @internal\n *\n * Builds a static node representation using a supplied query or fragment\n * builder. This is used for routes, containers, and mutations.\n *\n * If the supplied fragment builder produces an invalid node (e.g. the wrong\n * node type), these will return `undefined`. This is not to be confused with\n * a return value of `null`, which may result from the lack of a node.\n */\nvar buildRQL = {\n  Fragment(\n    fragmentBuilder: RelayQLFragmentBuilder,\n    values: Variables\n  ): ?ConcreteFragment {\n    let node = fragmentCache.get(fragmentBuilder);\n    if (node) {\n      return QueryBuilder.getFragment(node);\n    }\n    const variables = toVariables(values);\n    invariant(\n      !isDeprecatedCallWithArgCountGreaterThan(fragmentBuilder, 1),\n      'Relay.QL: Deprecated usage detected. If you are trying to define a ' +\n      'fragment, use `variables => Relay.QL`.'\n    );\n    node = fragmentBuilder(variables);\n    let fragment = node != null ?\n      QueryBuilder.getFragment(node) :\n      null;\n    if (!fragment) {\n      return fragment;\n    }\n    if (concreteFragmentIDSet.has(fragment.id)) {\n      fragment = {\n        ...fragment,\n        id: generateConcreteFragmentID(),\n      };\n    }\n    concreteFragmentIDSet.add(fragment.id);\n    fragmentCache.set(fragmentBuilder, fragment);\n    return fragment;\n  },\n\n  Query(\n    queryBuilder: RelayQLQueryBuilder,\n    Component: any,\n    queryName: string,\n    values: Variables\n  ): ?ConcreteQuery {\n    let componentCache = queryCache.get(queryBuilder);\n    let node;\n    if (!componentCache) {\n      componentCache = new Map();\n      queryCache.set(queryBuilder, componentCache);\n    } else {\n      node = componentCache.get(Component);\n    }\n    if (!node) {\n      const variables = toVariables(values);\n      invariant(\n        !isDeprecatedCallWithArgCountGreaterThan(queryBuilder, 2),\n        'Relay.QL: Deprecated usage detected. If you are trying to define a ' +\n        'query, use `(Component, variables) => Relay.QL`.'\n      );\n      if (isDeprecatedCallWithArgCountGreaterThan(queryBuilder, 0)) {\n        node = queryBuilder(Component, variables);\n      } else {\n        node = queryBuilder(Component, variables);\n        const query = QueryBuilder.getQuery(node);\n        if (query) {\n          let hasFragment = false;\n          let hasScalarFieldsOnly = true;\n          if (query.children) {\n            query.children.forEach(child => {\n              if (child) {\n                hasFragment = hasFragment || child.kind === 'Fragment';\n                hasScalarFieldsOnly = hasScalarFieldsOnly && (\n                  child.kind === 'Field' &&\n                  (!child.children || child.children.length === 0)\n                );\n              }\n            });\n          }\n          if (!hasFragment) {\n            const children = query.children ? [...query.children] : [];\n            invariant(\n              hasScalarFieldsOnly,\n              'Relay.QL: Expected query `%s` to be empty. For example, use ' +\n              '`node(id: $id)`, not `node(id: $id) { ... }`.',\n              query.fieldName\n            );\n            const fragmentVariables = filterObject(variables, (_, name) =>\n              Component.hasVariable(name)\n            );\n            children.push(Component.getFragment(queryName, fragmentVariables));\n            node = {\n              ...query,\n              children,\n            };\n          }\n        }\n      }\n      componentCache.set(Component, node);\n    }\n    if (node) {\n      return QueryBuilder.getQuery(node) || undefined;\n    }\n    return null;\n  },\n};\n\nfunction toVariables(variables: Variables): {\n  [key: string]: $FlowIssue; // ConcreteCallVariable should flow into mixed\n} {\n  return mapObject(\n    variables,\n    (_, name) => QueryBuilder.createCallVariable(name)\n  );\n}\n\nRelayProfiler.instrumentMethods(buildRQL, {\n  Fragment: 'buildRQL.Fragment',\n  Query: 'buildRQL.Query',\n});\n\nmodule.exports = buildRQL;\n"}}},"/Users/cpojer/Projects/relay/src/query-config/RelayQueryConfig.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayQueryConfig","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryConfig\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {RootQueries} from 'RelayContainer';\n\nimport type {RelayQLQueryBuilder} from 'buildRQL';\nconst invariant = require('invariant');\n\nexport type ConfigQueries = {[queryName: string]: RelayQLQueryBuilder};\n\n/**\n * Configures the root queries and initial variables that define the context in\n * which the top-level component's fragments are requested. This is meant to be\n * subclassed, of which instances are supplied to `RelayRootContainer`.\n */\nclass RelayQueryConfig<Tv: Object> {\n  name: string;\n  queries: RootQueries;\n  params: Object;\n\n  // TODO: Deprecate `routeName`, #8478719.\n  static routeName: string;\n  static queries: ?ConfigQueries;\n\n  constructor(initialVariables?: ?Tv) {\n    invariant(\n      this.constructor !== RelayQueryConfig,\n      'RelayQueryConfig: Abstract class cannot be instantiated.'\n    );\n\n    Object.defineProperty(this, 'name', {\n      enumerable: true,\n      value: this.constructor.routeName,\n    });\n    Object.defineProperty(this, 'params', {\n      enumerable: true,\n      value: this.prepareVariables({...initialVariables}) || {},\n    });\n    Object.defineProperty(this, 'queries', {\n      enumerable: true,\n      value: {...this.constructor.queries},\n    });\n\n    if (__DEV__) {\n      Object.freeze(this.params);\n      Object.freeze(this.queries);\n    }\n  }\n\n  /**\n   * Provides an opportunity to perform additional logic on the variables.\n   * Child class should override this function to perform custom logic.\n   */\n  prepareVariables(prevVariables: ?Tv): ?Tv {\n    return prevVariables;\n  }\n}\n\nmodule.exports = RelayQueryConfig;\n","dependencies":["RelayContainer","buildRQL","invariant","RelayQueryConfig"],"id":"RelayQueryConfig","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryConfig\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {RootQueries} from 'RelayContainer';\n\nimport type {RelayQLQueryBuilder} from 'buildRQL';\nconst invariant = require('invariant');\n\nexport type ConfigQueries = {[queryName: string]: RelayQLQueryBuilder};\n\n/**\n * Configures the root queries and initial variables that define the context in\n * which the top-level component's fragments are requested. This is meant to be\n * subclassed, of which instances are supplied to `RelayRootContainer`.\n */\nclass RelayQueryConfig<Tv: Object> {\n  name: string;\n  queries: RootQueries;\n  params: Object;\n\n  // TODO: Deprecate `routeName`, #8478719.\n  static routeName: string;\n  static queries: ?ConfigQueries;\n\n  constructor(initialVariables?: ?Tv) {\n    invariant(\n      this.constructor !== RelayQueryConfig,\n      'RelayQueryConfig: Abstract class cannot be instantiated.'\n    );\n\n    Object.defineProperty(this, 'name', {\n      enumerable: true,\n      value: this.constructor.routeName,\n    });\n    Object.defineProperty(this, 'params', {\n      enumerable: true,\n      value: this.prepareVariables({...initialVariables}) || {},\n    });\n    Object.defineProperty(this, 'queries', {\n      enumerable: true,\n      value: {...this.constructor.queries},\n    });\n\n    if (__DEV__) {\n      Object.freeze(this.params);\n      Object.freeze(this.queries);\n    }\n  }\n\n  /**\n   * Provides an opportunity to perform additional logic on the variables.\n   * Child class should override this function to perform custom logic.\n   */\n  prepareVariables(prevVariables: ?Tv): ?Tv {\n    return prevVariables;\n  }\n}\n\nmodule.exports = RelayQueryConfig;\n"}}},"/Users/cpojer/Projects/relay/src/route/RelayRoute.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayRoute","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRoute\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type URI from 'URI';\nimport type {ConfigQueries} from 'RelayQueryConfig';\nconst RelayQueryConfig = require('RelayQueryConfig');\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\n\ntype ParamDefinition = {\n  type: string;\n  required: boolean;\n};\nexport type ParamDefinitions = {[param: string]: ParamDefinition};\ntype StringOrURI = string | URI;\ntype URICreator = (routeConstructor: any, params: Object) => ?StringOrURI;\n\nlet createURI: $FlowIssue = () => null;\n\n/**\n * Describes the root queries, param definitions and other metadata for a given\n * path (URI).\n */\nclass RelayRoute<Tv: Object> extends RelayQueryConfig<Tv> {\n  uri: ?StringOrURI;\n\n  static path: ?string;\n  static paramDefinitions: ?ParamDefinitions;\n  static prepareParams: ?(prevParams: Tv) => Tv;\n  static queries: ?ConfigQueries;\n  static routeName: string;\n\n  constructor(initialVariables?: ?Tv, uri?: StringOrURI) {\n    super(initialVariables);\n    const constructor = this.constructor;\n    const {\n      routeName,\n      path,\n    } = constructor;\n\n    invariant(\n      constructor !== RelayRoute,\n      'RelayRoute: Abstract class cannot be instantiated.'\n    );\n    invariant(\n      routeName,\n      '%s: Subclasses of RelayRoute must define a `routeName`.',\n      constructor.name || '<<anonymous>>'\n    );\n\n\n    // $FlowIssue #9905535 - Object.defineProperty doesn't understand getters\n    Object.defineProperty(this, 'uri', {\n      enumerable: true,\n      get: function() {\n        if (!uri && path) {\n          uri = createURI(constructor, this.params);\n        }\n        return uri;\n      },\n    });\n  }\n\n  prepareVariables(prevVariables: ?Tv): ?Tv {\n    const {\n      paramDefinitions,\n      prepareParams,\n      routeName,\n    } = this.constructor;\n    let params = prevVariables;\n    if (prepareParams) {\n      /* $FlowFixMe(>=0.17.0) - params is ?Tv but prepareParams expects Tv */\n      params = prepareParams(params);\n    }\n    forEachObject(paramDefinitions, (paramDefinition, paramName) => {\n      if (params) {\n        if (params.hasOwnProperty(paramName)) {\n          return;\n        } else {\n          // Backfill param so that a call variable is created for it.\n          params[paramName] = undefined;\n        }\n      }\n      invariant(\n        !paramDefinition.required,\n        'RelayRoute: Missing required parameter `%s` in `%s`. Check the ' +\n        'supplied params or URI.',\n        paramName,\n        routeName,\n      );\n    });\n    return params;\n  }\n\n  static injectURICreator(creator: URICreator): void {\n    createURI = creator;\n  }\n\n}\n\nmodule.exports = RelayRoute;\n","dependencies":["URI","RelayQueryConfig","forEachObject","invariant","RelayRoute"],"id":"RelayRoute","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRoute\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type URI from 'URI';\nimport type {ConfigQueries} from 'RelayQueryConfig';\nconst RelayQueryConfig = require('RelayQueryConfig');\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\n\ntype ParamDefinition = {\n  type: string;\n  required: boolean;\n};\nexport type ParamDefinitions = {[param: string]: ParamDefinition};\ntype StringOrURI = string | URI;\ntype URICreator = (routeConstructor: any, params: Object) => ?StringOrURI;\n\nlet createURI: $FlowIssue = () => null;\n\n/**\n * Describes the root queries, param definitions and other metadata for a given\n * path (URI).\n */\nclass RelayRoute<Tv: Object> extends RelayQueryConfig<Tv> {\n  uri: ?StringOrURI;\n\n  static path: ?string;\n  static paramDefinitions: ?ParamDefinitions;\n  static prepareParams: ?(prevParams: Tv) => Tv;\n  static queries: ?ConfigQueries;\n  static routeName: string;\n\n  constructor(initialVariables?: ?Tv, uri?: StringOrURI) {\n    super(initialVariables);\n    const constructor = this.constructor;\n    const {\n      routeName,\n      path,\n    } = constructor;\n\n    invariant(\n      constructor !== RelayRoute,\n      'RelayRoute: Abstract class cannot be instantiated.'\n    );\n    invariant(\n      routeName,\n      '%s: Subclasses of RelayRoute must define a `routeName`.',\n      constructor.name || '<<anonymous>>'\n    );\n\n\n    // $FlowIssue #9905535 - Object.defineProperty doesn't understand getters\n    Object.defineProperty(this, 'uri', {\n      enumerable: true,\n      get: function() {\n        if (!uri && path) {\n          uri = createURI(constructor, this.params);\n        }\n        return uri;\n      },\n    });\n  }\n\n  prepareVariables(prevVariables: ?Tv): ?Tv {\n    const {\n      paramDefinitions,\n      prepareParams,\n      routeName,\n    } = this.constructor;\n    let params = prevVariables;\n    if (prepareParams) {\n      /* $FlowFixMe(>=0.17.0) - params is ?Tv but prepareParams expects Tv */\n      params = prepareParams(params);\n    }\n    forEachObject(paramDefinitions, (paramDefinition, paramName) => {\n      if (params) {\n        if (params.hasOwnProperty(paramName)) {\n          return;\n        } else {\n          // Backfill param so that a call variable is created for it.\n          params[paramName] = undefined;\n        }\n      }\n      invariant(\n        !paramDefinition.required,\n        'RelayRoute: Missing required parameter `%s` in `%s`. Check the ' +\n        'supplied params or URI.',\n        paramName,\n        routeName,\n      );\n    });\n    return params;\n  }\n\n  static injectURICreator(creator: URICreator): void {\n    createURI = creator;\n  }\n\n}\n\nmodule.exports = RelayRoute;\n"}}},"/Users/cpojer/Projects/relay/src/route/RelayMetaRoute.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMetaRoute","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMetaRoute\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Meta route based on the real route; provides access to the route name in\n * queries.\n */\nclass RelayMetaRoute {\n  name: string;\n\n  constructor(name: string) {\n    Object.defineProperty(this, 'name', {\n      enumerable: true,\n      value: name,\n      writable: false,\n    });\n  }\n\n  static get(name: string) {\n    return cache[name] || (cache[name] = new RelayMetaRoute(name));\n  }\n\n}\n\nvar cache: {[key: string]: RelayMetaRoute} = {};\n\nmodule.exports = RelayMetaRoute;\n","dependencies":["RelayMetaRoute"],"id":"RelayMetaRoute","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMetaRoute\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Meta route based on the real route; provides access to the route name in\n * queries.\n */\nclass RelayMetaRoute {\n  name: string;\n\n  constructor(name: string) {\n    Object.defineProperty(this, 'name', {\n      enumerable: true,\n      value: name,\n      writable: false,\n    });\n  }\n\n  static get(name: string) {\n    return cache[name] || (cache[name] = new RelayMetaRoute(name));\n  }\n\n}\n\nvar cache: {[key: string]: RelayMetaRoute} = {};\n\nmodule.exports = RelayMetaRoute;\n"}}},"/Users/cpojer/Projects/relay/src/store/validateRelayReadQuery.js":{"metadata":{"mtime":1455679339000},"data":{"name":"validateRelayReadQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule validateRelayReadQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nimport type {StoreReaderOptions} from 'RelayTypes';\n\nconst emptyFunction = require('emptyFunction');\n\ntype AliasMap = {\n  children: {[applicationName: string]: AliasMap};\n  hash: ?string;\n};\n\nlet validateRelayReadQuery = emptyFunction;\n\nif (__DEV__) {\n  // Wrap in an IIFE to avoid unwanted function hoisting.\n  (function() {\n    /**\n     * @internal\n     *\n     * `validateRelayReadQuery` is a `__DEV__`-only validator that checks that a\n     * query used to read data from `RelayStore` is well-formed. Validation\n     * problems are reported via `console.error`.\n     *\n     * At the moment, \"well-formed\" means that the query does not contain\n     * duplicate aliases.\n     */\n    validateRelayReadQuery = function validateRelayReadQuery(\n      queryNode: RelayQuery.Node,\n      options?: StoreReaderOptions\n    ): void {\n      var validator = new RelayStoreReadValidator(options);\n      validator.visit(queryNode, {\n        children: {},\n        hash: null,\n      });\n    };\n\n    /**\n     * Returns the nested AliasMap for `node`, initializing if it necessary.\n     */\n    function getAliasMap(\n      node: RelayQuery.Field,\n      parentAliasMap: AliasMap\n    ): AliasMap {\n      const applicationName = node.getApplicationName();\n      const hash = node.getShallowHash();\n      const {children} = parentAliasMap;\n      if (!children.hasOwnProperty(applicationName)) {\n        children[applicationName] = {\n          children: {},\n          hash,\n        };\n      } else if (children[applicationName].hash !== hash) {\n        console.error(\n          '`%s` is used as an alias more than once. Please use unique aliases.',\n          applicationName\n        );\n      }\n      return children[applicationName];\n    }\n\n    class RelayStoreReadValidator extends RelayQueryVisitor<AliasMap> {\n      _traverseFragmentReferences: boolean;\n\n      constructor(\n        options?: StoreReaderOptions\n      ) {\n        super();\n        this._traverseFragmentReferences =\n          (options && options.traverseFragmentReferences) || false;\n      }\n\n      visitField(\n        node: RelayQuery.Field,\n        parentAliasMap: AliasMap\n      ): void {\n        const aliasMap = getAliasMap(node, parentAliasMap);\n\n        if (node.isGenerated()) {\n          return;\n        } else if (!node.canHaveSubselections()) {\n          return;\n        } else if (node.isPlural()) {\n          this._readPlural(node, aliasMap);\n        } else {\n          // No special handling needed for connections, edges, page_info etc.\n          this._readLinkedField(node, aliasMap);\n        }\n      }\n\n      visitFragment(\n        node: RelayQuery.Fragment,\n        aliasMap: AliasMap\n      ): void {\n        if (this._traverseFragmentReferences || !node.isContainerFragment()) {\n          this.traverse(node, aliasMap);\n        }\n      }\n\n      _readPlural(node: RelayQuery.Field, aliasMap: AliasMap): void {\n        node.getChildren().forEach(child => this.visit(child, aliasMap));\n      }\n\n      _readLinkedField(node: RelayQuery.Field, aliasMap: AliasMap): void {\n        aliasMap = getAliasMap(node, aliasMap);\n        this.traverse(node, aliasMap);\n      }\n    }\n  }());\n}\n\nmodule.exports = validateRelayReadQuery;\n","dependencies":["RelayQuery","RelayTypes","RelayQueryVisitor","emptyFunction","validateRelayReadQuery"],"id":"validateRelayReadQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule validateRelayReadQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nimport type {StoreReaderOptions} from 'RelayTypes';\n\nconst emptyFunction = require('emptyFunction');\n\ntype AliasMap = {\n  children: {[applicationName: string]: AliasMap};\n  hash: ?string;\n};\n\nlet validateRelayReadQuery = emptyFunction;\n\nif (__DEV__) {\n  // Wrap in an IIFE to avoid unwanted function hoisting.\n  (function() {\n    /**\n     * @internal\n     *\n     * `validateRelayReadQuery` is a `__DEV__`-only validator that checks that a\n     * query used to read data from `RelayStore` is well-formed. Validation\n     * problems are reported via `console.error`.\n     *\n     * At the moment, \"well-formed\" means that the query does not contain\n     * duplicate aliases.\n     */\n    validateRelayReadQuery = function validateRelayReadQuery(\n      queryNode: RelayQuery.Node,\n      options?: StoreReaderOptions\n    ): void {\n      var validator = new RelayStoreReadValidator(options);\n      validator.visit(queryNode, {\n        children: {},\n        hash: null,\n      });\n    };\n\n    /**\n     * Returns the nested AliasMap for `node`, initializing if it necessary.\n     */\n    function getAliasMap(\n      node: RelayQuery.Field,\n      parentAliasMap: AliasMap\n    ): AliasMap {\n      const applicationName = node.getApplicationName();\n      const hash = node.getShallowHash();\n      const {children} = parentAliasMap;\n      if (!children.hasOwnProperty(applicationName)) {\n        children[applicationName] = {\n          children: {},\n          hash,\n        };\n      } else if (children[applicationName].hash !== hash) {\n        console.error(\n          '`%s` is used as an alias more than once. Please use unique aliases.',\n          applicationName\n        );\n      }\n      return children[applicationName];\n    }\n\n    class RelayStoreReadValidator extends RelayQueryVisitor<AliasMap> {\n      _traverseFragmentReferences: boolean;\n\n      constructor(\n        options?: StoreReaderOptions\n      ) {\n        super();\n        this._traverseFragmentReferences =\n          (options && options.traverseFragmentReferences) || false;\n      }\n\n      visitField(\n        node: RelayQuery.Field,\n        parentAliasMap: AliasMap\n      ): void {\n        const aliasMap = getAliasMap(node, parentAliasMap);\n\n        if (node.isGenerated()) {\n          return;\n        } else if (!node.canHaveSubselections()) {\n          return;\n        } else if (node.isPlural()) {\n          this._readPlural(node, aliasMap);\n        } else {\n          // No special handling needed for connections, edges, page_info etc.\n          this._readLinkedField(node, aliasMap);\n        }\n      }\n\n      visitFragment(\n        node: RelayQuery.Fragment,\n        aliasMap: AliasMap\n      ): void {\n        if (this._traverseFragmentReferences || !node.isContainerFragment()) {\n          this.traverse(node, aliasMap);\n        }\n      }\n\n      _readPlural(node: RelayQuery.Field, aliasMap: AliasMap): void {\n        node.getChildren().forEach(child => this.visit(child, aliasMap));\n      }\n\n      _readLinkedField(node: RelayQuery.Field, aliasMap: AliasMap): void {\n        aliasMap = getAliasMap(node, aliasMap);\n        this.traverse(node, aliasMap);\n      }\n    }\n  }());\n}\n\nmodule.exports = validateRelayReadQuery;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayStoreData.js":{"metadata":{"mtime":1456974578000},"data":{"name":"RelayStoreData","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayStoreData\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLQueryRunner = require('GraphQLQueryRunner');\nconst GraphQLStoreChangeEmitter = require('GraphQLStoreChangeEmitter');\nconst GraphQLStoreRangeUtils = require('GraphQLStoreRangeUtils');\nconst RelayChangeTracker = require('RelayChangeTracker');\nimport type {ChangeSet} from 'RelayChangeTracker';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayDiskCacheReader = require('RelayDiskCacheReader');\nimport type {GarbageCollectionScheduler} from 'RelayGarbageCollector';\nconst RelayGarbageCollector = require('RelayGarbageCollector');\nconst RelayMutationQueue = require('RelayMutationQueue');\nimport type {\n  ClientMutationID,\n  DataID,\n  NodeRangeMap,\n  QueryPayload,\n  RelayQuerySet,\n  RootCallMap,\n  UpdateOptions,\n} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayPendingQueryTracker = require('RelayPendingQueryTracker');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayQueryWriter = require('RelayQueryWriter');\nconst RelayRecord = require('RelayRecord');\nimport type {RecordMap} from 'RelayRecord';\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nimport type {CacheManager, CacheReadCallbacks} from 'RelayTypes';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst generateForceIndex = require('generateForceIndex');\nconst warning = require('warning');\nconst writeRelayQueryPayload = require('writeRelayQueryPayload');\nconst writeRelayUpdatePayload = require('writeRelayUpdatePayload');\n\nvar {CLIENT_MUTATION_ID} = RelayConnectionInterface;\nvar {ID, ID_TYPE, NODE, NODE_TYPE, TYPENAME} = RelayNodeInterface;\n\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  type: 'String',\n});\nconst typeField = RelayQuery.Field.build({\n  fieldName: TYPENAME,\n  type: 'String',\n});\n\n/**\n * @internal\n *\n * Wraps the data caches and associated metadata tracking objects used by\n * GraphQLStore/RelayStore.\n */\nclass RelayStoreData {\n  _cacheManager: ?CacheManager;\n  _cachedRecords: RecordMap;\n  _cachedRootCallMap: RootCallMap;\n  _cachedStore: RelayRecordStore;\n  _changeEmitter: GraphQLStoreChangeEmitter;\n  _garbageCollector: ?RelayGarbageCollector;\n  _mutationQueue: RelayMutationQueue;\n  _nodeRangeMap: NodeRangeMap;\n  _pendingQueryTracker: RelayPendingQueryTracker;\n  _records: RecordMap;\n  _queuedRecords: RecordMap;\n  _queuedStore: RelayRecordStore;\n  _recordStore: RelayRecordStore;\n  _queryTracker: RelayQueryTracker;\n  _queryRunner: GraphQLQueryRunner;\n  _rangeData: GraphQLStoreRangeUtils;\n  _rootCallMap: RootCallMap;\n\n  constructor() {\n    const cachedRecords: RecordMap = {};\n    const cachedRootCallMap: RootCallMap = {};\n    const queuedRecords: RecordMap = {};\n    const records: RecordMap = {};\n    const rootCallMap: RootCallMap = {};\n    const nodeRangeMap: NodeRangeMap = {};\n    const {\n      cachedStore,\n      queuedStore,\n      recordStore,\n    } = createRecordCollection({\n      cachedRecords,\n      cachedRootCallMap,\n      cacheWriter: null,\n      queuedRecords,\n      nodeRangeMap,\n      records,\n      rootCallMap,\n    });\n    const rangeData = new GraphQLStoreRangeUtils();\n\n    this._cacheManager = null;\n    this._cachedRecords = cachedRecords;\n    this._cachedRootCallMap = cachedRootCallMap;\n    this._cachedStore = cachedStore;\n    this._changeEmitter = new GraphQLStoreChangeEmitter(rangeData);\n    this._mutationQueue = new RelayMutationQueue(this);\n    this._nodeRangeMap = nodeRangeMap;\n    this._pendingQueryTracker = new RelayPendingQueryTracker(this);\n    this._queryRunner = new GraphQLQueryRunner(this);\n    this._queryTracker = new RelayQueryTracker();\n    this._queuedRecords = queuedRecords;\n    this._queuedStore = queuedStore;\n    this._records = records;\n    this._recordStore = recordStore;\n    this._rangeData = rangeData;\n    this._rootCallMap = rootCallMap;\n  }\n\n  /**\n   * Creates a garbage collector for this instance. After initialization all\n   * newly added DataIDs will be registered in the created garbage collector.\n   * This will show a warning if data has already been added to the instance.\n   */\n  initializeGarbageCollector(scheduler: GarbageCollectionScheduler): void {\n    invariant(\n      !this._garbageCollector,\n      'RelayStoreData: Garbage collector is already initialized.'\n    );\n    var shouldInitialize = this._isStoreDataEmpty();\n    warning(\n      shouldInitialize,\n      'RelayStoreData: Garbage collection can only be initialized when no ' +\n      'data is present.'\n    );\n    if (shouldInitialize) {\n      this._garbageCollector = new RelayGarbageCollector(this, scheduler);\n    }\n  }\n\n  /**\n   * Sets/clears the cache manager that is used to cache changes written to\n   * the store.\n   */\n  injectCacheManager(cacheManager: ?CacheManager): void {\n    const {\n      cachedStore,\n      queuedStore,\n      recordStore,\n    } = createRecordCollection({\n      cachedRecords: this._cachedRecords,\n      cachedRootCallMap: this._cachedRootCallMap,\n      cacheWriter: cacheManager ? cacheManager.getQueryWriter() : null,\n      queuedRecords: this._queuedRecords,\n      nodeRangeMap: this._nodeRangeMap,\n      records: this._records,\n      rootCallMap: this._rootCallMap,\n    });\n\n    this._cacheManager = cacheManager;\n    this._cachedStore = cachedStore;\n    this._queuedStore = queuedStore;\n    this._recordStore = recordStore;\n  }\n\n  clearCacheManager(): void {\n    const {\n      cachedStore,\n      queuedStore,\n      recordStore,\n    } = createRecordCollection({\n      cachedRecords: this._cachedRecords,\n      cachedRootCallMap: this._cachedRootCallMap,\n      cacheWriter: null,\n      queuedRecords: this._queuedRecords,\n      nodeRangeMap: this._nodeRangeMap,\n      records: this._records,\n      rootCallMap: this._rootCallMap,\n    });\n\n    this._cacheManager = null;\n    this._cachedStore = cachedStore;\n    this._queuedStore = queuedStore;\n    this._recordStore = recordStore;\n  }\n\n  hasCacheManager(): boolean {\n    return !!this._cacheManager;\n  }\n\n  /**\n   * Returns whether a given record is affected by an optimistic update.\n   */\n  hasOptimisticUpdate(dataID: DataID): boolean {\n    dataID = this.getRangeData().getCanonicalClientID(dataID);\n    return this.getQueuedStore().hasOptimisticUpdate(dataID);\n  }\n\n  /**\n   * Returns a list of client mutation IDs for queued mutations whose optimistic\n   * updates are affecting the record corresponding the given dataID. Returns\n   * null if the record isn't affected by any optimistic updates.\n   */\n  getClientMutationIDs(dataID: DataID): ?Array<ClientMutationID> {\n    dataID = this.getRangeData().getCanonicalClientID(dataID);\n    return this.getQueuedStore().getClientMutationIDs(dataID);\n  }\n\n  /**\n   * Reads data for queries incrementally from disk cache.\n   * It calls onSuccess when all the data has been loaded into memory.\n   * It calls onFailure when some data is unabled to be satisfied from disk.\n   */\n  readFromDiskCache(\n    queries: RelayQuerySet,\n    callbacks: CacheReadCallbacks\n  ): void {\n    const cacheManager = this._cacheManager;\n    invariant(\n      cacheManager,\n      'RelayStoreData: `readFromDiskCache` should only be called when cache ' +\n      'manager is available.'\n    );\n    const changeTracker = new RelayChangeTracker();\n    const profile = RelayProfiler.profile('RelayStoreData.readFromDiskCache');\n    RelayDiskCacheReader.readQueries(\n      queries,\n      this._queuedStore,\n      this._cachedRecords,\n      this._cachedRootCallMap,\n      this._garbageCollector,\n      cacheManager,\n      changeTracker,\n      {\n        onSuccess: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onSuccess && callbacks.onSuccess();\n        },\n        onFailure: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onFailure && callbacks.onFailure();\n        },\n      }\n    );\n  }\n\n  /**\n   * Reads data for a fragment incrementally from disk cache.\n   * It calls onSuccess when all the data has been loaded into memory.\n   * It calls onFailure when some data is unabled to be satisfied from disk.\n   */\n  readFragmentFromDiskCache(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment,\n    path: RelayQueryPath,\n    callbacks: CacheReadCallbacks\n  ): void {\n    const cacheManager = this._cacheManager;\n    invariant(\n      cacheManager,\n      'RelayStoreData: `readFragmentFromDiskCache` should only be called ' +\n      'when cache manager is available.'\n    );\n    const changeTracker = new RelayChangeTracker();\n    const profile =\n      RelayProfiler.profile('RelayStoreData.readFragmentFromDiskCache');\n    RelayDiskCacheReader.readFragment(\n      dataID,\n      fragment,\n      path,\n      this._queuedStore,\n      this._cachedRecords,\n      this._cachedRootCallMap,\n      this._garbageCollector,\n      cacheManager,\n      changeTracker,\n      {\n        onSuccess: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onSuccess && callbacks.onSuccess();\n        },\n        onFailure: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onFailure && callbacks.onFailure();\n        },\n      }\n    );\n  }\n\n  /**\n   * Write the results of a query into the base record store.\n   */\n  handleQueryPayload(\n    query: RelayQuery.Root,\n    response: QueryPayload,\n    forceIndex: ?number\n  ): void {\n    var profiler = RelayProfiler.profile('RelayStoreData.handleQueryPayload');\n    var changeTracker = new RelayChangeTracker();\n    var writer = new RelayQueryWriter(\n      this._recordStore,\n      this.getRecordWriter(),\n      this._queryTracker,\n      changeTracker,\n      {\n        forceIndex,\n        updateTrackedQueries: true,\n      }\n    );\n    writeRelayQueryPayload(\n      writer,\n      query,\n      response\n    );\n    this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n    profiler.stop();\n  }\n\n  /**\n   * Write the results of an update into the base record store.\n   */\n  handleUpdatePayload(\n    operation: RelayQuery.Operation,\n    payload: {[key: string]: mixed},\n    {configs, isOptimisticUpdate}: UpdateOptions\n  ): void {\n    var profiler = RelayProfiler.profile('RelayStoreData.handleUpdatePayload');\n    var changeTracker = new RelayChangeTracker();\n    var store;\n    var recordWriter;\n    if (isOptimisticUpdate) {\n      var clientMutationID = payload[CLIENT_MUTATION_ID];\n      invariant(\n        typeof clientMutationID === 'string',\n        'RelayStoreData.handleUpdatePayload(): Expected optimistic payload ' +\n        'to have a valid `%s`.',\n        CLIENT_MUTATION_ID\n      );\n      store = this.getRecordStoreForOptimisticMutation(clientMutationID);\n      recordWriter =\n        this.getRecordWriterForOptimisticMutation(clientMutationID);\n    } else {\n      store = this._getRecordStoreForMutation();\n      recordWriter = this._getRecordWriterForMutation();\n    }\n    var writer = new RelayQueryWriter(\n      store,\n      recordWriter,\n      this._queryTracker,\n      changeTracker,\n      {\n        forceIndex: generateForceIndex(),\n        isOptimisticUpdate,\n        updateTrackedQueries: false,\n      }\n    );\n    writeRelayUpdatePayload(\n      writer,\n      operation,\n      payload,\n      {configs, isOptimisticUpdate}\n    );\n    this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n    profiler.stop();\n  }\n\n  /**\n   * Given a query fragment and a data ID, returns a root query that applies\n   * the fragment to the object specified by the data ID.\n   */\n  buildFragmentQueryForDataID(\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): RelayQuery.Root {\n    if (RelayRecord.isClientID(dataID)) {\n      const path = this._queuedStore.getPathToRecord(\n        this._rangeData.getCanonicalClientID(dataID),\n      );\n      invariant(\n        path,\n        'RelayStoreData.buildFragmentQueryForDataID(): Cannot refetch ' +\n        'record `%s` without a path.',\n        dataID\n      );\n      return path.getQuery(this._cachedStore, fragment);\n    }\n    // Fragment fields cannot be spread directly into the root because they\n    // may not exist on the `Node` type.\n    return RelayQuery.Root.build(\n      fragment.getDebugName() || 'UnknownQuery',\n      NODE,\n      dataID,\n      [idField, typeField, fragment],\n      {\n        identifyingArgName: ID,\n        identifyingArgType: ID_TYPE,\n        isAbstract: true,\n        isDeferred: false,\n        isPlural: false,\n      },\n      NODE_TYPE\n    );\n  }\n\n  getNodeData(): RecordMap {\n    return this._records;\n  }\n\n  getQueuedData(): RecordMap {\n    return this._queuedRecords;\n  }\n\n  clearQueuedData(): void {\n    forEachObject(this._queuedRecords, (_, key) => {\n      delete this._queuedRecords[key];\n      this._changeEmitter.broadcastChangeForID(key);\n    });\n  }\n\n  getCachedData(): RecordMap {\n    return this._cachedRecords;\n  }\n\n  getGarbageCollector(): ?RelayGarbageCollector {\n    return this._garbageCollector;\n  }\n\n  getMutationQueue(): RelayMutationQueue {\n    return this._mutationQueue;\n  }\n\n  /**\n   * Get the record store with only the cached and base data (no queued data).\n   */\n  getCachedStore(): RelayRecordStore {\n    return this._cachedStore;\n  }\n\n  /**\n   * Get the record store with full data (cached, base, queued).\n   */\n  getQueuedStore(): RelayRecordStore {\n    return this._queuedStore;\n  }\n\n  /**\n   * Get the record store with only the base data (no queued/cached data).\n   */\n  getRecordStore(): RelayRecordStore {\n    return this._recordStore;\n  }\n\n  /**\n   * Get the record writer for the base data.\n   */\n  getRecordWriter(): RelayRecordWriter {\n    return new RelayRecordWriter(\n      this._records,\n      this._rootCallMap,\n      false, // isOptimistic\n      (this._nodeRangeMap: $FixMe),\n      this._cacheManager ?\n        this._cacheManager.getQueryWriter() :\n        null\n    );\n  }\n\n  getQueryTracker(): RelayQueryTracker {\n    return this._queryTracker;\n  }\n\n  getQueryRunner(): GraphQLQueryRunner {\n    return this._queryRunner;\n  }\n\n  getChangeEmitter(): GraphQLStoreChangeEmitter {\n    return this._changeEmitter;\n  }\n\n  getRangeData(): GraphQLStoreRangeUtils {\n    return this._rangeData;\n  }\n\n  getPendingQueryTracker(): RelayPendingQueryTracker {\n    return this._pendingQueryTracker;\n  }\n\n  /**\n   * @deprecated\n   *\n   * Used temporarily by GraphQLStore, but all updates to this object are now\n   * handled through a `RelayRecordStore` instance.\n   */\n  getRootCallData(): RootCallMap {\n    return this._rootCallMap;\n  }\n\n  _isStoreDataEmpty(): boolean {\n    return (\n      Object.keys(this._records).length === 0 &&\n      Object.keys(this._queuedRecords).length === 0 &&\n      Object.keys(this._cachedRecords).length === 0\n    );\n  }\n\n  /**\n   * Given a ChangeSet, broadcasts changes for updated DataIDs\n   * and registers new DataIDs with the garbage collector.\n   */\n  _handleChangedAndNewDataIDs(changeSet: ChangeSet): void {\n    var updatedDataIDs = Object.keys(changeSet.updated);\n    updatedDataIDs.forEach(id => this._changeEmitter.broadcastChangeForID(id));\n    if (this._garbageCollector) {\n      var createdDataIDs = Object.keys(changeSet.created);\n      var garbageCollector = this._garbageCollector;\n      createdDataIDs.forEach(dataID => garbageCollector.register(dataID));\n    }\n  }\n\n  _getRecordStoreForMutation(): RelayRecordStore {\n    var records = this._records;\n    var rootCallMap = this._rootCallMap;\n\n    return new RelayRecordStore(\n      {records},\n      {rootCallMap},\n      this._nodeRangeMap\n    );\n  }\n\n  _getRecordWriterForMutation(): RelayRecordWriter {\n    return new RelayRecordWriter(\n      this._records,\n      this._rootCallMap,\n      false, // isOptimistic\n      (this._nodeRangeMap: $FixMe),\n      this._cacheManager ?\n        this._cacheManager.getMutationWriter() :\n        null\n    );\n  }\n\n  getRecordStoreForOptimisticMutation(\n    clientMutationID: ClientMutationID\n  ): RelayRecordStore {\n    var cachedRecords = this._cachedRecords;\n    var cachedRootCallMap = this._cachedRootCallMap;\n    var rootCallMap = this._rootCallMap;\n    var queuedRecords = this._queuedRecords;\n    var records = this._records;\n\n    return new RelayRecordStore(\n      {cachedRecords, queuedRecords, records},\n      {cachedRootCallMap, rootCallMap},\n      this._nodeRangeMap\n    );\n  }\n\n  getRecordWriterForOptimisticMutation(\n    clientMutationID: ClientMutationID\n  ): RelayRecordWriter {\n    return new RelayRecordWriter(\n      this._queuedRecords,\n      this._rootCallMap,\n      true, // isOptimistic\n      this._nodeRangeMap,\n      null, // don't cache optimistic data\n      clientMutationID\n    );\n  }\n\n}\n\nfunction createRecordCollection({\n  cachedRecords,\n  cachedRootCallMap,\n  cacheWriter,\n  queuedRecords,\n  nodeRangeMap,\n  records,\n  rootCallMap,\n}): {\n  cachedStore: RelayRecordStore,\n  queuedStore: RelayRecordStore,\n  recordStore: RelayRecordStore\n} {\n  return {\n    queuedStore: new RelayRecordStore(\n      {cachedRecords, queuedRecords, records},\n      {cachedRootCallMap, rootCallMap},\n      nodeRangeMap\n    ),\n    cachedStore: new RelayRecordStore(\n      {cachedRecords, records},\n      {cachedRootCallMap, rootCallMap},\n      nodeRangeMap\n    ),\n    recordStore: new RelayRecordStore(\n      {records},\n      {rootCallMap},\n      nodeRangeMap\n    ),\n  };\n}\n\nRelayProfiler.instrumentMethods(RelayStoreData.prototype, {\n  handleQueryPayload: 'RelayStoreData.prototype.handleQueryPayload',\n  handleUpdatePayload: 'RelayStoreData.prototype.handleUpdatePayload',\n});\n\nmodule.exports = RelayStoreData;\n","dependencies":["RelayChangeTracker","RelayGarbageCollector","RelayInternalTypes","RelayQueryPath","RelayRecord","RelayTypes","GraphQLQueryRunner","GraphQLStoreChangeEmitter","GraphQLStoreRangeUtils","RelayConnectionInterface","RelayDiskCacheReader","RelayMutationQueue","RelayNodeInterface","RelayPendingQueryTracker","RelayProfiler","RelayQuery","RelayQueryTracker","RelayQueryWriter","RelayRecordStore","RelayRecordWriter","forEachObject","invariant","generateForceIndex","warning","writeRelayQueryPayload","writeRelayUpdatePayload","RelayStoreData"],"id":"RelayStoreData","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayStoreData\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLQueryRunner = require('GraphQLQueryRunner');\nconst GraphQLStoreChangeEmitter = require('GraphQLStoreChangeEmitter');\nconst GraphQLStoreRangeUtils = require('GraphQLStoreRangeUtils');\nconst RelayChangeTracker = require('RelayChangeTracker');\nimport type {ChangeSet} from 'RelayChangeTracker';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayDiskCacheReader = require('RelayDiskCacheReader');\nimport type {GarbageCollectionScheduler} from 'RelayGarbageCollector';\nconst RelayGarbageCollector = require('RelayGarbageCollector');\nconst RelayMutationQueue = require('RelayMutationQueue');\nimport type {\n  ClientMutationID,\n  DataID,\n  NodeRangeMap,\n  QueryPayload,\n  RelayQuerySet,\n  RootCallMap,\n  UpdateOptions,\n} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayPendingQueryTracker = require('RelayPendingQueryTracker');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayQueryTracker = require('RelayQueryTracker');\nconst RelayQueryWriter = require('RelayQueryWriter');\nconst RelayRecord = require('RelayRecord');\nimport type {RecordMap} from 'RelayRecord';\nconst RelayRecordStore = require('RelayRecordStore');\nconst RelayRecordWriter = require('RelayRecordWriter');\nimport type {CacheManager, CacheReadCallbacks} from 'RelayTypes';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst generateForceIndex = require('generateForceIndex');\nconst warning = require('warning');\nconst writeRelayQueryPayload = require('writeRelayQueryPayload');\nconst writeRelayUpdatePayload = require('writeRelayUpdatePayload');\n\nvar {CLIENT_MUTATION_ID} = RelayConnectionInterface;\nvar {ID, ID_TYPE, NODE, NODE_TYPE, TYPENAME} = RelayNodeInterface;\n\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  type: 'String',\n});\nconst typeField = RelayQuery.Field.build({\n  fieldName: TYPENAME,\n  type: 'String',\n});\n\n/**\n * @internal\n *\n * Wraps the data caches and associated metadata tracking objects used by\n * GraphQLStore/RelayStore.\n */\nclass RelayStoreData {\n  _cacheManager: ?CacheManager;\n  _cachedRecords: RecordMap;\n  _cachedRootCallMap: RootCallMap;\n  _cachedStore: RelayRecordStore;\n  _changeEmitter: GraphQLStoreChangeEmitter;\n  _garbageCollector: ?RelayGarbageCollector;\n  _mutationQueue: RelayMutationQueue;\n  _nodeRangeMap: NodeRangeMap;\n  _pendingQueryTracker: RelayPendingQueryTracker;\n  _records: RecordMap;\n  _queuedRecords: RecordMap;\n  _queuedStore: RelayRecordStore;\n  _recordStore: RelayRecordStore;\n  _queryTracker: RelayQueryTracker;\n  _queryRunner: GraphQLQueryRunner;\n  _rangeData: GraphQLStoreRangeUtils;\n  _rootCallMap: RootCallMap;\n\n  constructor() {\n    const cachedRecords: RecordMap = {};\n    const cachedRootCallMap: RootCallMap = {};\n    const queuedRecords: RecordMap = {};\n    const records: RecordMap = {};\n    const rootCallMap: RootCallMap = {};\n    const nodeRangeMap: NodeRangeMap = {};\n    const {\n      cachedStore,\n      queuedStore,\n      recordStore,\n    } = createRecordCollection({\n      cachedRecords,\n      cachedRootCallMap,\n      cacheWriter: null,\n      queuedRecords,\n      nodeRangeMap,\n      records,\n      rootCallMap,\n    });\n    const rangeData = new GraphQLStoreRangeUtils();\n\n    this._cacheManager = null;\n    this._cachedRecords = cachedRecords;\n    this._cachedRootCallMap = cachedRootCallMap;\n    this._cachedStore = cachedStore;\n    this._changeEmitter = new GraphQLStoreChangeEmitter(rangeData);\n    this._mutationQueue = new RelayMutationQueue(this);\n    this._nodeRangeMap = nodeRangeMap;\n    this._pendingQueryTracker = new RelayPendingQueryTracker(this);\n    this._queryRunner = new GraphQLQueryRunner(this);\n    this._queryTracker = new RelayQueryTracker();\n    this._queuedRecords = queuedRecords;\n    this._queuedStore = queuedStore;\n    this._records = records;\n    this._recordStore = recordStore;\n    this._rangeData = rangeData;\n    this._rootCallMap = rootCallMap;\n  }\n\n  /**\n   * Creates a garbage collector for this instance. After initialization all\n   * newly added DataIDs will be registered in the created garbage collector.\n   * This will show a warning if data has already been added to the instance.\n   */\n  initializeGarbageCollector(scheduler: GarbageCollectionScheduler): void {\n    invariant(\n      !this._garbageCollector,\n      'RelayStoreData: Garbage collector is already initialized.'\n    );\n    var shouldInitialize = this._isStoreDataEmpty();\n    warning(\n      shouldInitialize,\n      'RelayStoreData: Garbage collection can only be initialized when no ' +\n      'data is present.'\n    );\n    if (shouldInitialize) {\n      this._garbageCollector = new RelayGarbageCollector(this, scheduler);\n    }\n  }\n\n  /**\n   * Sets/clears the cache manager that is used to cache changes written to\n   * the store.\n   */\n  injectCacheManager(cacheManager: ?CacheManager): void {\n    const {\n      cachedStore,\n      queuedStore,\n      recordStore,\n    } = createRecordCollection({\n      cachedRecords: this._cachedRecords,\n      cachedRootCallMap: this._cachedRootCallMap,\n      cacheWriter: cacheManager ? cacheManager.getQueryWriter() : null,\n      queuedRecords: this._queuedRecords,\n      nodeRangeMap: this._nodeRangeMap,\n      records: this._records,\n      rootCallMap: this._rootCallMap,\n    });\n\n    this._cacheManager = cacheManager;\n    this._cachedStore = cachedStore;\n    this._queuedStore = queuedStore;\n    this._recordStore = recordStore;\n  }\n\n  clearCacheManager(): void {\n    const {\n      cachedStore,\n      queuedStore,\n      recordStore,\n    } = createRecordCollection({\n      cachedRecords: this._cachedRecords,\n      cachedRootCallMap: this._cachedRootCallMap,\n      cacheWriter: null,\n      queuedRecords: this._queuedRecords,\n      nodeRangeMap: this._nodeRangeMap,\n      records: this._records,\n      rootCallMap: this._rootCallMap,\n    });\n\n    this._cacheManager = null;\n    this._cachedStore = cachedStore;\n    this._queuedStore = queuedStore;\n    this._recordStore = recordStore;\n  }\n\n  hasCacheManager(): boolean {\n    return !!this._cacheManager;\n  }\n\n  /**\n   * Returns whether a given record is affected by an optimistic update.\n   */\n  hasOptimisticUpdate(dataID: DataID): boolean {\n    dataID = this.getRangeData().getCanonicalClientID(dataID);\n    return this.getQueuedStore().hasOptimisticUpdate(dataID);\n  }\n\n  /**\n   * Returns a list of client mutation IDs for queued mutations whose optimistic\n   * updates are affecting the record corresponding the given dataID. Returns\n   * null if the record isn't affected by any optimistic updates.\n   */\n  getClientMutationIDs(dataID: DataID): ?Array<ClientMutationID> {\n    dataID = this.getRangeData().getCanonicalClientID(dataID);\n    return this.getQueuedStore().getClientMutationIDs(dataID);\n  }\n\n  /**\n   * Reads data for queries incrementally from disk cache.\n   * It calls onSuccess when all the data has been loaded into memory.\n   * It calls onFailure when some data is unabled to be satisfied from disk.\n   */\n  readFromDiskCache(\n    queries: RelayQuerySet,\n    callbacks: CacheReadCallbacks\n  ): void {\n    const cacheManager = this._cacheManager;\n    invariant(\n      cacheManager,\n      'RelayStoreData: `readFromDiskCache` should only be called when cache ' +\n      'manager is available.'\n    );\n    const changeTracker = new RelayChangeTracker();\n    const profile = RelayProfiler.profile('RelayStoreData.readFromDiskCache');\n    RelayDiskCacheReader.readQueries(\n      queries,\n      this._queuedStore,\n      this._cachedRecords,\n      this._cachedRootCallMap,\n      this._garbageCollector,\n      cacheManager,\n      changeTracker,\n      {\n        onSuccess: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onSuccess && callbacks.onSuccess();\n        },\n        onFailure: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onFailure && callbacks.onFailure();\n        },\n      }\n    );\n  }\n\n  /**\n   * Reads data for a fragment incrementally from disk cache.\n   * It calls onSuccess when all the data has been loaded into memory.\n   * It calls onFailure when some data is unabled to be satisfied from disk.\n   */\n  readFragmentFromDiskCache(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment,\n    path: RelayQueryPath,\n    callbacks: CacheReadCallbacks\n  ): void {\n    const cacheManager = this._cacheManager;\n    invariant(\n      cacheManager,\n      'RelayStoreData: `readFragmentFromDiskCache` should only be called ' +\n      'when cache manager is available.'\n    );\n    const changeTracker = new RelayChangeTracker();\n    const profile =\n      RelayProfiler.profile('RelayStoreData.readFragmentFromDiskCache');\n    RelayDiskCacheReader.readFragment(\n      dataID,\n      fragment,\n      path,\n      this._queuedStore,\n      this._cachedRecords,\n      this._cachedRootCallMap,\n      this._garbageCollector,\n      cacheManager,\n      changeTracker,\n      {\n        onSuccess: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onSuccess && callbacks.onSuccess();\n        },\n        onFailure: () => {\n          this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n          profile.stop();\n          callbacks.onFailure && callbacks.onFailure();\n        },\n      }\n    );\n  }\n\n  /**\n   * Write the results of a query into the base record store.\n   */\n  handleQueryPayload(\n    query: RelayQuery.Root,\n    response: QueryPayload,\n    forceIndex: ?number\n  ): void {\n    var profiler = RelayProfiler.profile('RelayStoreData.handleQueryPayload');\n    var changeTracker = new RelayChangeTracker();\n    var writer = new RelayQueryWriter(\n      this._recordStore,\n      this.getRecordWriter(),\n      this._queryTracker,\n      changeTracker,\n      {\n        forceIndex,\n        updateTrackedQueries: true,\n      }\n    );\n    writeRelayQueryPayload(\n      writer,\n      query,\n      response\n    );\n    this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n    profiler.stop();\n  }\n\n  /**\n   * Write the results of an update into the base record store.\n   */\n  handleUpdatePayload(\n    operation: RelayQuery.Operation,\n    payload: {[key: string]: mixed},\n    {configs, isOptimisticUpdate}: UpdateOptions\n  ): void {\n    var profiler = RelayProfiler.profile('RelayStoreData.handleUpdatePayload');\n    var changeTracker = new RelayChangeTracker();\n    var store;\n    var recordWriter;\n    if (isOptimisticUpdate) {\n      var clientMutationID = payload[CLIENT_MUTATION_ID];\n      invariant(\n        typeof clientMutationID === 'string',\n        'RelayStoreData.handleUpdatePayload(): Expected optimistic payload ' +\n        'to have a valid `%s`.',\n        CLIENT_MUTATION_ID\n      );\n      store = this.getRecordStoreForOptimisticMutation(clientMutationID);\n      recordWriter =\n        this.getRecordWriterForOptimisticMutation(clientMutationID);\n    } else {\n      store = this._getRecordStoreForMutation();\n      recordWriter = this._getRecordWriterForMutation();\n    }\n    var writer = new RelayQueryWriter(\n      store,\n      recordWriter,\n      this._queryTracker,\n      changeTracker,\n      {\n        forceIndex: generateForceIndex(),\n        isOptimisticUpdate,\n        updateTrackedQueries: false,\n      }\n    );\n    writeRelayUpdatePayload(\n      writer,\n      operation,\n      payload,\n      {configs, isOptimisticUpdate}\n    );\n    this._handleChangedAndNewDataIDs(changeTracker.getChangeSet());\n    profiler.stop();\n  }\n\n  /**\n   * Given a query fragment and a data ID, returns a root query that applies\n   * the fragment to the object specified by the data ID.\n   */\n  buildFragmentQueryForDataID(\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): RelayQuery.Root {\n    if (RelayRecord.isClientID(dataID)) {\n      const path = this._queuedStore.getPathToRecord(\n        this._rangeData.getCanonicalClientID(dataID),\n      );\n      invariant(\n        path,\n        'RelayStoreData.buildFragmentQueryForDataID(): Cannot refetch ' +\n        'record `%s` without a path.',\n        dataID\n      );\n      return path.getQuery(this._cachedStore, fragment);\n    }\n    // Fragment fields cannot be spread directly into the root because they\n    // may not exist on the `Node` type.\n    return RelayQuery.Root.build(\n      fragment.getDebugName() || 'UnknownQuery',\n      NODE,\n      dataID,\n      [idField, typeField, fragment],\n      {\n        identifyingArgName: ID,\n        identifyingArgType: ID_TYPE,\n        isAbstract: true,\n        isDeferred: false,\n        isPlural: false,\n      },\n      NODE_TYPE\n    );\n  }\n\n  getNodeData(): RecordMap {\n    return this._records;\n  }\n\n  getQueuedData(): RecordMap {\n    return this._queuedRecords;\n  }\n\n  clearQueuedData(): void {\n    forEachObject(this._queuedRecords, (_, key) => {\n      delete this._queuedRecords[key];\n      this._changeEmitter.broadcastChangeForID(key);\n    });\n  }\n\n  getCachedData(): RecordMap {\n    return this._cachedRecords;\n  }\n\n  getGarbageCollector(): ?RelayGarbageCollector {\n    return this._garbageCollector;\n  }\n\n  getMutationQueue(): RelayMutationQueue {\n    return this._mutationQueue;\n  }\n\n  /**\n   * Get the record store with only the cached and base data (no queued data).\n   */\n  getCachedStore(): RelayRecordStore {\n    return this._cachedStore;\n  }\n\n  /**\n   * Get the record store with full data (cached, base, queued).\n   */\n  getQueuedStore(): RelayRecordStore {\n    return this._queuedStore;\n  }\n\n  /**\n   * Get the record store with only the base data (no queued/cached data).\n   */\n  getRecordStore(): RelayRecordStore {\n    return this._recordStore;\n  }\n\n  /**\n   * Get the record writer for the base data.\n   */\n  getRecordWriter(): RelayRecordWriter {\n    return new RelayRecordWriter(\n      this._records,\n      this._rootCallMap,\n      false, // isOptimistic\n      (this._nodeRangeMap: $FixMe),\n      this._cacheManager ?\n        this._cacheManager.getQueryWriter() :\n        null\n    );\n  }\n\n  getQueryTracker(): RelayQueryTracker {\n    return this._queryTracker;\n  }\n\n  getQueryRunner(): GraphQLQueryRunner {\n    return this._queryRunner;\n  }\n\n  getChangeEmitter(): GraphQLStoreChangeEmitter {\n    return this._changeEmitter;\n  }\n\n  getRangeData(): GraphQLStoreRangeUtils {\n    return this._rangeData;\n  }\n\n  getPendingQueryTracker(): RelayPendingQueryTracker {\n    return this._pendingQueryTracker;\n  }\n\n  /**\n   * @deprecated\n   *\n   * Used temporarily by GraphQLStore, but all updates to this object are now\n   * handled through a `RelayRecordStore` instance.\n   */\n  getRootCallData(): RootCallMap {\n    return this._rootCallMap;\n  }\n\n  _isStoreDataEmpty(): boolean {\n    return (\n      Object.keys(this._records).length === 0 &&\n      Object.keys(this._queuedRecords).length === 0 &&\n      Object.keys(this._cachedRecords).length === 0\n    );\n  }\n\n  /**\n   * Given a ChangeSet, broadcasts changes for updated DataIDs\n   * and registers new DataIDs with the garbage collector.\n   */\n  _handleChangedAndNewDataIDs(changeSet: ChangeSet): void {\n    var updatedDataIDs = Object.keys(changeSet.updated);\n    updatedDataIDs.forEach(id => this._changeEmitter.broadcastChangeForID(id));\n    if (this._garbageCollector) {\n      var createdDataIDs = Object.keys(changeSet.created);\n      var garbageCollector = this._garbageCollector;\n      createdDataIDs.forEach(dataID => garbageCollector.register(dataID));\n    }\n  }\n\n  _getRecordStoreForMutation(): RelayRecordStore {\n    var records = this._records;\n    var rootCallMap = this._rootCallMap;\n\n    return new RelayRecordStore(\n      {records},\n      {rootCallMap},\n      this._nodeRangeMap\n    );\n  }\n\n  _getRecordWriterForMutation(): RelayRecordWriter {\n    return new RelayRecordWriter(\n      this._records,\n      this._rootCallMap,\n      false, // isOptimistic\n      (this._nodeRangeMap: $FixMe),\n      this._cacheManager ?\n        this._cacheManager.getMutationWriter() :\n        null\n    );\n  }\n\n  getRecordStoreForOptimisticMutation(\n    clientMutationID: ClientMutationID\n  ): RelayRecordStore {\n    var cachedRecords = this._cachedRecords;\n    var cachedRootCallMap = this._cachedRootCallMap;\n    var rootCallMap = this._rootCallMap;\n    var queuedRecords = this._queuedRecords;\n    var records = this._records;\n\n    return new RelayRecordStore(\n      {cachedRecords, queuedRecords, records},\n      {cachedRootCallMap, rootCallMap},\n      this._nodeRangeMap\n    );\n  }\n\n  getRecordWriterForOptimisticMutation(\n    clientMutationID: ClientMutationID\n  ): RelayRecordWriter {\n    return new RelayRecordWriter(\n      this._queuedRecords,\n      this._rootCallMap,\n      true, // isOptimistic\n      this._nodeRangeMap,\n      null, // don't cache optimistic data\n      clientMutationID\n    );\n  }\n\n}\n\nfunction createRecordCollection({\n  cachedRecords,\n  cachedRootCallMap,\n  cacheWriter,\n  queuedRecords,\n  nodeRangeMap,\n  records,\n  rootCallMap,\n}): {\n  cachedStore: RelayRecordStore,\n  queuedStore: RelayRecordStore,\n  recordStore: RelayRecordStore\n} {\n  return {\n    queuedStore: new RelayRecordStore(\n      {cachedRecords, queuedRecords, records},\n      {cachedRootCallMap, rootCallMap},\n      nodeRangeMap\n    ),\n    cachedStore: new RelayRecordStore(\n      {cachedRecords, records},\n      {cachedRootCallMap, rootCallMap},\n      nodeRangeMap\n    ),\n    recordStore: new RelayRecordStore(\n      {records},\n      {rootCallMap},\n      nodeRangeMap\n    ),\n  };\n}\n\nRelayProfiler.instrumentMethods(RelayStoreData.prototype, {\n  handleQueryPayload: 'RelayStoreData.prototype.handleQueryPayload',\n  handleUpdatePayload: 'RelayStoreData.prototype.handleUpdatePayload',\n});\n\nmodule.exports = RelayStoreData;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayStore.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayStore","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayStore\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayContext = require('RelayContext');\n\nmodule.exports = new RelayContext();\n","dependencies":["RelayContext","RelayStore"],"id":"RelayStore","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayStore\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayContext = require('RelayContext');\n\nmodule.exports = new RelayContext();\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayRecordWriter.js":{"metadata":{"mtime":1456974578000},"data":{"name":"RelayRecordWriter","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordWriter\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  ClientMutationID,\n  DataID,\n  FieldValue,\n  NodeRangeMap,\n  RootCallMap,\n} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayRecord = require('RelayRecord');\nimport type {\n  Record,\n  RecordMap,\n} from 'RelayRecord';\nimport type {RecordState} from 'RelayRecordState';\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nimport type {CacheWriter} from 'RelayTypes';\n\nconst invariant = require('invariant');\nconst rangeOperationToMetadataKey = require('rangeOperationToMetadataKey');\n\nconst {CURSOR, NODE} = RelayConnectionInterface;\nconst EMPTY = '';\nconst FILTER_CALLS = '__filterCalls__';\nconst FORCE_INDEX = '__forceIndex__';\nconst RANGE = '__range__';\nconst RESOLVED_FRAGMENT_MAP = '__resolvedFragmentMap__';\nconst RESOLVED_FRAGMENT_MAP_GENERATION = '__resolvedFragmentMapGeneration__';\nconst PATH = '__path__';\nconst {APPEND, PREPEND, REMOVE} = GraphQLMutatorConstants;\n\nimport type {\n  PageInfo,\n} from 'RelayConnectionInterface';\n\ntype EdgeData = {\n  __dataID__: DataID;\n  cursor: mixed;\n  node: {\n    __dataID__: DataID;\n  };\n};\n\ntype RangeOperation = $Keys<GraphQLMutatorConstants.RANGE_OPERATIONS>;\n\n/**\n * @internal\n *\n * `RelayRecordWriter` is the helper module to write data into RelayRecordStore.\n */\nclass RelayRecordWriter {\n  _cacheWriter: ?CacheWriter;\n  _clientMutationID: ?ClientMutationID;\n  _isOptimisticWrite: boolean;\n  _records: RecordMap;\n  _nodeConnectionMap: NodeRangeMap;\n  _rootCallMap: RootCallMap;\n\n  constructor(\n    records: RecordMap,\n    rootCallMap: RootCallMap,\n    isOptimistic: boolean,\n    nodeConnectionMap?: ?NodeRangeMap,\n    cacheWriter?: ?CacheWriter,\n    clientMutationID?: ?ClientMutationID\n  ) {\n    this._cacheWriter = cacheWriter;\n    this._clientMutationID = clientMutationID;\n    this._isOptimisticWrite = isOptimistic;\n    this._nodeConnectionMap = nodeConnectionMap || {};\n    this._records = records;\n    this._rootCallMap = rootCallMap;\n  }\n\n  /**\n   * Get the data ID associated with a storage key (and optionally an\n   * identifying argument value) for a root query.\n   */\n  getDataID(\n    storageKey: string,\n    identifyingArgValue: ?string\n  ): ?DataID {\n    if (RelayNodeInterface.isNodeRootCall(storageKey)) {\n      invariant(\n        identifyingArgValue != null,\n        'RelayRecordWriter.getDataID(): Argument to `%s()` ' +\n        'cannot be null or undefined.',\n        storageKey\n      );\n      return identifyingArgValue;\n    }\n    if (identifyingArgValue == null) {\n      identifyingArgValue = EMPTY;\n    }\n    if (this._rootCallMap.hasOwnProperty(storageKey) &&\n        this._rootCallMap[storageKey].hasOwnProperty(identifyingArgValue)) {\n      return this._rootCallMap[storageKey][identifyingArgValue];\n    }\n  }\n\n  /**\n   * Associate a data ID with a storage key (and optionally an identifying\n   * argument value) for a root query.\n   */\n  putDataID(\n    storageKey: string,\n    identifyingArgValue: ?string,\n    dataID: DataID\n  ): void {\n    if (RelayNodeInterface.isNodeRootCall(storageKey)) {\n      invariant(\n        identifyingArgValue != null,\n        'RelayRecordWriter.putDataID(): Argument to `%s()` ' +\n        'cannot be null or undefined.',\n        storageKey\n      );\n      return;\n    }\n    if (identifyingArgValue == null) {\n      identifyingArgValue = EMPTY;\n    }\n    this._rootCallMap[storageKey] = this._rootCallMap[storageKey] || {};\n    this._rootCallMap[storageKey][identifyingArgValue] = dataID;\n    if (this._cacheWriter) {\n      this._cacheWriter.writeRootCall(storageKey, identifyingArgValue, dataID);\n    }\n  }\n\n  /**\n   * Returns the status of the record stored at `dataID`.\n   */\n  getRecordState(dataID: DataID): RecordState {\n    const record = this._records[dataID];\n    if (record === null) {\n      return 'NONEXISTENT';\n    } else if (record === undefined) {\n      return 'UNKNOWN';\n    }\n    return 'EXISTENT';\n  }\n\n  /**\n   * Create an empty record at `dataID` if a record does not already exist.\n   */\n  putRecord(\n    dataID: DataID,\n    typeName: ?string,\n    path?: RelayQueryPath\n  ): void {\n    const prevRecord = this._getRecordForWrite(dataID);\n    if (prevRecord) {\n      return;\n    }\n    const nextRecord = RelayRecord.createWithFields(dataID, {\n      __typename: typeName,\n    });\n    if (this._isOptimisticWrite) {\n      this._setClientMutationID(nextRecord);\n    }\n    if (RelayRecord.isClientID(dataID)) {\n      invariant(\n        path,\n        'RelayRecordWriter.putRecord(): Expected a path for non-refetchable ' +\n        'record `%s`.',\n        dataID\n      );\n      nextRecord[PATH] = path;\n    }\n    this._records[dataID] = nextRecord;\n    const cacheWriter = this._cacheWriter;\n    if (!this._isOptimisticWrite && cacheWriter) {\n      cacheWriter.writeField(dataID, '__dataID__', dataID, typeName);\n    }\n  }\n\n  /**\n   * Returns the path to a non-refetchable record.\n   */\n  getPathToRecord(\n    dataID: DataID\n  ): ?RelayQueryPath {\n    return (this._getField(dataID, PATH): any);\n  }\n\n  /**\n   * Check whether a given record has received data for a deferred fragment.\n   */\n  hasDeferredFragmentData(dataID: DataID, fragmentID: string): boolean {\n    const resolvedFragmentMap = this._getField(dataID, RESOLVED_FRAGMENT_MAP);\n    invariant(\n      typeof resolvedFragmentMap === 'object' || resolvedFragmentMap == null,\n      'RelayRecordWriter.hasDeferredFragmentData(): Expected the map of ' +\n      'resolved deferred fragments associated with record `%s` to be null or ' +\n      'an object. Found a(n) `%s`.',\n      dataID,\n      typeof resolvedFragmentMap\n    );\n    return !!(resolvedFragmentMap && resolvedFragmentMap[fragmentID]);\n  }\n\n  /**\n   * Mark a given record as having received data for a deferred fragment.\n   */\n  setHasDeferredFragmentData(\n    dataID: DataID,\n    fragmentID: string\n  ): void {\n    const record = this._getRecordForWrite(dataID);\n    invariant(\n      record,\n      'RelayRecordWriter.setHasDeferredFragmentData(): Expected record `%s` ' +\n      'to exist before marking it as having received data for the deferred ' +\n      'fragment with id `%s`.',\n      dataID,\n      fragmentID\n    );\n    let resolvedFragmentMap = record[RESOLVED_FRAGMENT_MAP];\n    if (typeof resolvedFragmentMap !== 'object' || !resolvedFragmentMap) {\n      resolvedFragmentMap = {};\n    }\n    resolvedFragmentMap[fragmentID] = true;\n    record[RESOLVED_FRAGMENT_MAP] = resolvedFragmentMap;\n    if (typeof record[RESOLVED_FRAGMENT_MAP_GENERATION] === 'number') {\n      record[RESOLVED_FRAGMENT_MAP_GENERATION]++;\n    } else {\n      record[RESOLVED_FRAGMENT_MAP_GENERATION] = 0;\n    }\n  }\n\n  /**\n   * Delete the record at `dataID`, setting its value to `null`.\n   */\n  deleteRecord(\n    dataID: DataID\n  ): void {\n    this._records[dataID] = null;\n\n    // Remove any links for this record\n    if (!this._isOptimisticWrite) {\n      delete this._nodeConnectionMap[dataID];\n      if (this._cacheWriter) {\n        this._cacheWriter.writeNode(dataID, null);\n      }\n    }\n  }\n\n  getType(dataID: DataID): ?string {\n    // `__typename` property is typed as `string`\n    return (this._getField(dataID, '__typename'): any);\n  }\n\n  /**\n   * Returns the value of the field for the given dataID.\n   */\n  getField(\n    dataID: DataID,\n    storageKey: string\n  ): ?FieldValue {\n    return this._getField(dataID, storageKey);\n  }\n\n  /**\n   * Sets the value of a scalar field.\n   */\n  putField(\n    dataID: DataID,\n    storageKey: string,\n    value: FieldValue\n  ) {\n    const record = this._getRecordForWrite(dataID);\n    invariant(\n      record,\n      'RelayRecordWriter.putField(): Expected record `%s` to exist before ' +\n      'writing field `%s`.',\n      dataID,\n      storageKey\n    );\n    record[storageKey] = value;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      const typeName = record.__typename;\n      this._cacheWriter.writeField(dataID, storageKey, value, typeName);\n    }\n  }\n\n  /**\n   * Clears the value of a field by setting it to null/undefined.\n   */\n  deleteField(\n    dataID: DataID,\n    storageKey: string\n  ): void {\n    const record = this._getRecordForWrite(dataID);\n    invariant(\n      record,\n      'RelayRecordWriter.deleteField(): Expected record `%s` to exist before ' +\n      'deleting field `%s`.',\n      dataID,\n      storageKey\n    );\n    record[storageKey] = null;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(dataID, storageKey, null);\n    }\n  }\n\n  /**\n   * Returns the Data ID of a linked record (eg the ID of the `address` record\n   * in `actor{address}`).\n   */\n  getLinkedRecordID(\n    dataID: DataID,\n    storageKey: string\n  ): ?DataID {\n    const field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      typeof field === 'object' &&\n        field !== null &&\n        !Array.isArray(field),\n      'RelayRecordWriter.getLinkedRecordID(): Expected field `%s` for record ' +\n      '`%s` to have a linked record.',\n      storageKey,\n      dataID\n    );\n    return field.__dataID__;\n  }\n\n  /**\n   * Creates/updates a link between two records via the given field.\n   */\n  putLinkedRecordID(\n    parentID: DataID,\n    storageKey: string,\n    recordID: DataID\n  ): void {\n    const parent = this._getRecordForWrite(parentID);\n    invariant(\n      parent,\n      'RelayRecordWriter.putLinkedRecordID(): Expected record `%s` to exist ' +\n      'before linking to record `%s`.',\n      parentID,\n      recordID\n    );\n    const record = this._records[recordID];\n    invariant(\n      record,\n      'RelayRecordWriter.putLinkedRecordID(): Expected record `%s` to exist ' +\n      'before linking from record `%s`.',\n      recordID,\n      parentID\n    );\n    const fieldValue = RelayRecord.create(recordID);\n    parent[storageKey] = fieldValue;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(parentID, storageKey, fieldValue);\n    }\n  }\n\n  /**\n   * Returns an array of Data ID for a plural linked field (eg the actor IDs of\n   * the `likers` in `story{likers}`).\n   */\n  getLinkedRecordIDs(\n    dataID: DataID,\n    storageKey: string\n  ): ?Array<DataID> {\n    const field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      Array.isArray(field),\n      'RelayRecordWriter.getLinkedRecordIDs(): Expected field `%s` for ' +\n      'record `%s` to have an array of linked records.',\n      storageKey,\n      dataID\n    );\n    return field.map((item, ii) => {\n      invariant(\n        typeof item === 'object' && item.__dataID__,\n        'RelayRecordWriter.getLinkedRecordIDs(): Expected element at index ' +\n        '%s in field `%s` for record `%s` to be a linked record.',\n        ii,\n        storageKey,\n        dataID\n      );\n      return item.__dataID__;\n    });\n  }\n\n  /**\n   * Creates/updates a one-to-many link between records via the given field.\n   */\n  putLinkedRecordIDs(\n    parentID: DataID,\n    storageKey: string,\n    recordIDs: Array<DataID>\n  ): void {\n    const parent = this._getRecordForWrite(parentID);\n    invariant(\n      parent,\n      'RelayRecordWriter.putLinkedRecordIDs(): Expected record `%s` to exist ' +\n      'before linking records.',\n      parentID\n    );\n    const records = recordIDs.map(recordID => {\n      const record = this._records[recordID];\n      invariant(\n        record,\n        'RelayRecordWriter.putLinkedRecordIDs(): Expected record `%s` to ' +\n        'exist before linking from `%s`.',\n        recordID,\n        parentID\n      );\n      return RelayRecord.create(recordID);\n    });\n    parent[storageKey] = records;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(parentID, storageKey, records);\n    }\n  }\n\n  /**\n   * Get the force index associated with the range at `connectionID`.\n   */\n  getRangeForceIndex(\n    connectionID: DataID\n  ): number {\n    const forceIndex: ?number =\n      (this._getField(connectionID, FORCE_INDEX): any);\n    if (forceIndex === null) {\n      return -1;\n    }\n    // __forceIndex__ can only be a number\n    return forceIndex || 0;\n  }\n\n  /**\n   * Get the condition calls that were used to fetch the given connection.\n   * Ex: for a field `photos.orderby(recent)`, this would be\n   * [{name: 'orderby', value: 'recent'}]\n   */\n  getRangeFilterCalls(\n    connectionID: DataID\n  ): ?Array<Call> {\n    return (this._getField(connectionID, FILTER_CALLS): any);\n  }\n\n  /**\n   * Creates a range at `dataID` with an optional `forceIndex`.\n   */\n  putRange(\n    connectionID: DataID,\n    calls: Array<Call>,\n    forceIndex?: ?number\n  ): void {\n    invariant(\n      !this._isOptimisticWrite,\n      'RelayRecordWriter.putRange(): Cannot create a queued range.'\n    );\n    const record = this._getRecordForWrite(connectionID);\n    invariant(\n      record,\n      'RelayRecordWriter.putRange(): Expected record `%s` to exist before ' +\n      'adding a range.',\n      connectionID\n    );\n    const range = new GraphQLRange();\n    const filterCalls = getFilterCalls(calls);\n    forceIndex = forceIndex || 0;\n    record.__filterCalls__ = filterCalls;\n    record.__forceIndex__ = forceIndex;\n    record.__range__ = range;\n\n    const cacheWriter = this._cacheWriter;\n    if (!this._isOptimisticWrite && cacheWriter) {\n      cacheWriter.writeField(connectionID, FILTER_CALLS, filterCalls);\n      cacheWriter.writeField(connectionID, FORCE_INDEX, forceIndex);\n      cacheWriter.writeField(connectionID, RANGE, range);\n    }\n  }\n\n  /**\n   * Returns whether there is a range at `connectionID`.\n   */\n  hasRange(connectionID: DataID): boolean {\n    return !!this._getField(connectionID, RANGE);\n  }\n\n  /**\n   * Adds newly fetched edges to a range.\n   */\n  putRangeEdges(\n    connectionID: DataID,\n    calls: Array<Call>,\n    pageInfo: PageInfo,\n    edges: Array<DataID>\n  ): void {\n    const range: ?GraphQLRange = (this._getField(connectionID, RANGE): any);\n    invariant(\n      range,\n      'RelayRecordWriter.putRangeEdges(): Expected record `%s` to exist and ' +\n      'have a range.',\n      connectionID\n    );\n    const edgesData = [];\n    edges.forEach(edgeID => {\n      const edgeData = this._getRangeEdgeData(edgeID);\n      edgesData.push(edgeData);\n      this._addConnectionForNode(connectionID, edgeData.node.__dataID__);\n    });\n    range.addItems(\n      calls,\n      edgesData,\n      pageInfo\n    );\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(connectionID, RANGE, range);\n    }\n  }\n\n  /**\n   * Prepend, append, or delete edges to/from a range.\n   */\n  applyRangeUpdate(\n    connectionID: DataID,\n    edgeID: DataID,\n    operation: RangeOperation\n  ): void {\n    if (this._isOptimisticWrite) {\n      this._applyOptimisticRangeUpdate(connectionID, edgeID, operation);\n    } else {\n      this._applyServerRangeUpdate(connectionID, edgeID, operation);\n    }\n  }\n\n  /**\n   * Get edge data in a format compatibile with `GraphQLRange`.\n   * TODO: change `GraphQLRange` to accept `(edgeID, cursor, nodeID)` tuple\n   */\n  _getRangeEdgeData(edgeID: DataID): EdgeData {\n    const nodeID = this.getLinkedRecordID(edgeID, NODE);\n    invariant(\n      nodeID,\n      'RelayRecordWriter: Expected edge `%s` to have a `node` record.',\n      edgeID\n    );\n    return RelayRecord.createWithFields(edgeID, {\n      cursor: this.getField(edgeID, CURSOR),\n      node: RelayRecord.create(nodeID),\n    });\n  }\n\n  _applyOptimisticRangeUpdate(\n    connectionID: DataID,\n    edgeID: DataID,\n    operation: RangeOperation\n  ): void {\n    let record: ?Record = this._getRecordForWrite(connectionID);\n    if (!record) {\n      record = RelayRecord.create(connectionID);\n      this._records[connectionID] = record;\n    }\n    this._setClientMutationID(record);\n    const key = rangeOperationToMetadataKey[operation];\n    let queue: ?Array<DataID> = record[key];\n    if (!queue) {\n      queue = [];\n      record[key] = queue;\n    }\n    if (operation === PREPEND) {\n      queue.unshift(edgeID);\n    } else {\n      queue.push(edgeID);\n    }\n  }\n\n  _applyServerRangeUpdate(\n    connectionID: DataID,\n    edgeID: DataID,\n    operation: RangeOperation\n  ): void {\n    const range: ?GraphQLRange = (this._getField(connectionID, RANGE): any);\n    invariant(\n      range,\n      'RelayRecordWriter: Cannot apply `%s` update to non-existent record ' +\n      '`%s`.',\n      operation,\n      connectionID\n    );\n    if (operation === REMOVE) {\n      range.removeEdgeWithID(edgeID);\n      const nodeID = this.getLinkedRecordID(edgeID, 'node');\n      if (nodeID) {\n        this._removeConnectionForNode(connectionID, nodeID);\n      }\n    } else {\n      const edgeData = this._getRangeEdgeData(edgeID);\n      this._addConnectionForNode(connectionID, edgeData.node.__dataID__);\n      if (operation === APPEND) {\n        range.appendEdge(this._getRangeEdgeData(edgeID));\n      } else {\n        // prepend\n        range.prependEdge(this._getRangeEdgeData(edgeID));\n      }\n    }\n    if (this._cacheWriter) {\n      this._cacheWriter.writeField(connectionID, RANGE, range);\n    }\n  }\n\n  /**\n   * Record that the node is contained in the connection.\n   */\n  _addConnectionForNode(\n    connectionID: DataID,\n    nodeID: DataID\n  ): void {\n    let connectionMap = this._nodeConnectionMap[nodeID];\n    if (!connectionMap) {\n      connectionMap = {};\n      this._nodeConnectionMap[nodeID] = connectionMap;\n    }\n    connectionMap[connectionID] = true;\n  }\n\n  /**\n   * Record that the given node is no longer part of the connection.\n   */\n  _removeConnectionForNode(\n    connectionID: DataID,\n    nodeID: DataID\n  ): void {\n    const connectionMap = this._nodeConnectionMap[nodeID];\n    if (connectionMap) {\n      delete connectionMap[connectionID];\n      if (Object.keys(connectionMap).length === 0) {\n        delete this._nodeConnectionMap[nodeID];\n      }\n    }\n  }\n\n  /**\n   * If the record is in the store, gets a version of the record\n   * in the store being used for writes.\n   */\n  _getRecordForWrite(dataID: DataID): ?Record {\n    const record = this._records[dataID];\n    if (!record) {\n      return record;\n    }\n    if (this._isOptimisticWrite) {\n      this._setClientMutationID(record);\n    }\n    return record;\n  }\n\n  /**\n   * Get the value of the field from the first version of the record for which\n   * the field is defined, returning `null` if the record has been deleted or\n   * `undefined` if the record has not been fetched.\n   */\n  _getField(dataID: DataID, storageKey: string): ?FieldValue {\n    const record = this._records[dataID];\n    if (record === null) {\n      return null;\n    } else if (record && record.hasOwnProperty(storageKey)) {\n      return record[storageKey];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Injects the client mutation id associated with the record store instance\n   * into the given record.\n   */\n  _setClientMutationID(record: Record): void {\n    const clientMutationID = this._clientMutationID;\n    invariant(\n      clientMutationID,\n      'RelayRecordWriter: _clientMutationID cannot be null/undefined.'\n    );\n    const mutationIDs: Array<ClientMutationID> = record.__mutationIDs__ || [];\n    if (mutationIDs.indexOf(clientMutationID) === -1) {\n      mutationIDs.push(clientMutationID);\n      record.__mutationIDs__ = mutationIDs;\n    }\n    record.__status__ = RelayRecordStatusMap.setOptimisticStatus(\n      0,\n      true\n    );\n  }\n}\n\n/**\n * Filter calls to only those that specify conditions on the returned results\n * (ex: `orderby(TOP_STORIES)`), removing generic calls (ex: `first`, `find`).\n */\nfunction getFilterCalls(calls: Array<Call>): Array<Call> {\n  return calls.filter(call => !RelayConnectionInterface.isConnectionCall(call));\n}\n\nmodule.exports = RelayRecordWriter;\n","dependencies":["RelayInternalTypes","RelayQueryPath","RelayRecord","RelayRecordState","RelayTypes","RelayConnectionInterface","GraphQLMutatorConstants","GraphQLRange","RelayNodeInterface","RelayRecordStatusMap","invariant","rangeOperationToMetadataKey","RelayRecordWriter"],"id":"RelayRecordWriter","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordWriter\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  ClientMutationID,\n  DataID,\n  FieldValue,\n  NodeRangeMap,\n  RootCallMap,\n} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayRecord = require('RelayRecord');\nimport type {\n  Record,\n  RecordMap,\n} from 'RelayRecord';\nimport type {RecordState} from 'RelayRecordState';\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nimport type {CacheWriter} from 'RelayTypes';\n\nconst invariant = require('invariant');\nconst rangeOperationToMetadataKey = require('rangeOperationToMetadataKey');\n\nconst {CURSOR, NODE} = RelayConnectionInterface;\nconst EMPTY = '';\nconst FILTER_CALLS = '__filterCalls__';\nconst FORCE_INDEX = '__forceIndex__';\nconst RANGE = '__range__';\nconst RESOLVED_FRAGMENT_MAP = '__resolvedFragmentMap__';\nconst RESOLVED_FRAGMENT_MAP_GENERATION = '__resolvedFragmentMapGeneration__';\nconst PATH = '__path__';\nconst {APPEND, PREPEND, REMOVE} = GraphQLMutatorConstants;\n\nimport type {\n  PageInfo,\n} from 'RelayConnectionInterface';\n\ntype EdgeData = {\n  __dataID__: DataID;\n  cursor: mixed;\n  node: {\n    __dataID__: DataID;\n  };\n};\n\ntype RangeOperation = $Keys<GraphQLMutatorConstants.RANGE_OPERATIONS>;\n\n/**\n * @internal\n *\n * `RelayRecordWriter` is the helper module to write data into RelayRecordStore.\n */\nclass RelayRecordWriter {\n  _cacheWriter: ?CacheWriter;\n  _clientMutationID: ?ClientMutationID;\n  _isOptimisticWrite: boolean;\n  _records: RecordMap;\n  _nodeConnectionMap: NodeRangeMap;\n  _rootCallMap: RootCallMap;\n\n  constructor(\n    records: RecordMap,\n    rootCallMap: RootCallMap,\n    isOptimistic: boolean,\n    nodeConnectionMap?: ?NodeRangeMap,\n    cacheWriter?: ?CacheWriter,\n    clientMutationID?: ?ClientMutationID\n  ) {\n    this._cacheWriter = cacheWriter;\n    this._clientMutationID = clientMutationID;\n    this._isOptimisticWrite = isOptimistic;\n    this._nodeConnectionMap = nodeConnectionMap || {};\n    this._records = records;\n    this._rootCallMap = rootCallMap;\n  }\n\n  /**\n   * Get the data ID associated with a storage key (and optionally an\n   * identifying argument value) for a root query.\n   */\n  getDataID(\n    storageKey: string,\n    identifyingArgValue: ?string\n  ): ?DataID {\n    if (RelayNodeInterface.isNodeRootCall(storageKey)) {\n      invariant(\n        identifyingArgValue != null,\n        'RelayRecordWriter.getDataID(): Argument to `%s()` ' +\n        'cannot be null or undefined.',\n        storageKey\n      );\n      return identifyingArgValue;\n    }\n    if (identifyingArgValue == null) {\n      identifyingArgValue = EMPTY;\n    }\n    if (this._rootCallMap.hasOwnProperty(storageKey) &&\n        this._rootCallMap[storageKey].hasOwnProperty(identifyingArgValue)) {\n      return this._rootCallMap[storageKey][identifyingArgValue];\n    }\n  }\n\n  /**\n   * Associate a data ID with a storage key (and optionally an identifying\n   * argument value) for a root query.\n   */\n  putDataID(\n    storageKey: string,\n    identifyingArgValue: ?string,\n    dataID: DataID\n  ): void {\n    if (RelayNodeInterface.isNodeRootCall(storageKey)) {\n      invariant(\n        identifyingArgValue != null,\n        'RelayRecordWriter.putDataID(): Argument to `%s()` ' +\n        'cannot be null or undefined.',\n        storageKey\n      );\n      return;\n    }\n    if (identifyingArgValue == null) {\n      identifyingArgValue = EMPTY;\n    }\n    this._rootCallMap[storageKey] = this._rootCallMap[storageKey] || {};\n    this._rootCallMap[storageKey][identifyingArgValue] = dataID;\n    if (this._cacheWriter) {\n      this._cacheWriter.writeRootCall(storageKey, identifyingArgValue, dataID);\n    }\n  }\n\n  /**\n   * Returns the status of the record stored at `dataID`.\n   */\n  getRecordState(dataID: DataID): RecordState {\n    const record = this._records[dataID];\n    if (record === null) {\n      return 'NONEXISTENT';\n    } else if (record === undefined) {\n      return 'UNKNOWN';\n    }\n    return 'EXISTENT';\n  }\n\n  /**\n   * Create an empty record at `dataID` if a record does not already exist.\n   */\n  putRecord(\n    dataID: DataID,\n    typeName: ?string,\n    path?: RelayQueryPath\n  ): void {\n    const prevRecord = this._getRecordForWrite(dataID);\n    if (prevRecord) {\n      return;\n    }\n    const nextRecord = RelayRecord.createWithFields(dataID, {\n      __typename: typeName,\n    });\n    if (this._isOptimisticWrite) {\n      this._setClientMutationID(nextRecord);\n    }\n    if (RelayRecord.isClientID(dataID)) {\n      invariant(\n        path,\n        'RelayRecordWriter.putRecord(): Expected a path for non-refetchable ' +\n        'record `%s`.',\n        dataID\n      );\n      nextRecord[PATH] = path;\n    }\n    this._records[dataID] = nextRecord;\n    const cacheWriter = this._cacheWriter;\n    if (!this._isOptimisticWrite && cacheWriter) {\n      cacheWriter.writeField(dataID, '__dataID__', dataID, typeName);\n    }\n  }\n\n  /**\n   * Returns the path to a non-refetchable record.\n   */\n  getPathToRecord(\n    dataID: DataID\n  ): ?RelayQueryPath {\n    return (this._getField(dataID, PATH): any);\n  }\n\n  /**\n   * Check whether a given record has received data for a deferred fragment.\n   */\n  hasDeferredFragmentData(dataID: DataID, fragmentID: string): boolean {\n    const resolvedFragmentMap = this._getField(dataID, RESOLVED_FRAGMENT_MAP);\n    invariant(\n      typeof resolvedFragmentMap === 'object' || resolvedFragmentMap == null,\n      'RelayRecordWriter.hasDeferredFragmentData(): Expected the map of ' +\n      'resolved deferred fragments associated with record `%s` to be null or ' +\n      'an object. Found a(n) `%s`.',\n      dataID,\n      typeof resolvedFragmentMap\n    );\n    return !!(resolvedFragmentMap && resolvedFragmentMap[fragmentID]);\n  }\n\n  /**\n   * Mark a given record as having received data for a deferred fragment.\n   */\n  setHasDeferredFragmentData(\n    dataID: DataID,\n    fragmentID: string\n  ): void {\n    const record = this._getRecordForWrite(dataID);\n    invariant(\n      record,\n      'RelayRecordWriter.setHasDeferredFragmentData(): Expected record `%s` ' +\n      'to exist before marking it as having received data for the deferred ' +\n      'fragment with id `%s`.',\n      dataID,\n      fragmentID\n    );\n    let resolvedFragmentMap = record[RESOLVED_FRAGMENT_MAP];\n    if (typeof resolvedFragmentMap !== 'object' || !resolvedFragmentMap) {\n      resolvedFragmentMap = {};\n    }\n    resolvedFragmentMap[fragmentID] = true;\n    record[RESOLVED_FRAGMENT_MAP] = resolvedFragmentMap;\n    if (typeof record[RESOLVED_FRAGMENT_MAP_GENERATION] === 'number') {\n      record[RESOLVED_FRAGMENT_MAP_GENERATION]++;\n    } else {\n      record[RESOLVED_FRAGMENT_MAP_GENERATION] = 0;\n    }\n  }\n\n  /**\n   * Delete the record at `dataID`, setting its value to `null`.\n   */\n  deleteRecord(\n    dataID: DataID\n  ): void {\n    this._records[dataID] = null;\n\n    // Remove any links for this record\n    if (!this._isOptimisticWrite) {\n      delete this._nodeConnectionMap[dataID];\n      if (this._cacheWriter) {\n        this._cacheWriter.writeNode(dataID, null);\n      }\n    }\n  }\n\n  getType(dataID: DataID): ?string {\n    // `__typename` property is typed as `string`\n    return (this._getField(dataID, '__typename'): any);\n  }\n\n  /**\n   * Returns the value of the field for the given dataID.\n   */\n  getField(\n    dataID: DataID,\n    storageKey: string\n  ): ?FieldValue {\n    return this._getField(dataID, storageKey);\n  }\n\n  /**\n   * Sets the value of a scalar field.\n   */\n  putField(\n    dataID: DataID,\n    storageKey: string,\n    value: FieldValue\n  ) {\n    const record = this._getRecordForWrite(dataID);\n    invariant(\n      record,\n      'RelayRecordWriter.putField(): Expected record `%s` to exist before ' +\n      'writing field `%s`.',\n      dataID,\n      storageKey\n    );\n    record[storageKey] = value;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      const typeName = record.__typename;\n      this._cacheWriter.writeField(dataID, storageKey, value, typeName);\n    }\n  }\n\n  /**\n   * Clears the value of a field by setting it to null/undefined.\n   */\n  deleteField(\n    dataID: DataID,\n    storageKey: string\n  ): void {\n    const record = this._getRecordForWrite(dataID);\n    invariant(\n      record,\n      'RelayRecordWriter.deleteField(): Expected record `%s` to exist before ' +\n      'deleting field `%s`.',\n      dataID,\n      storageKey\n    );\n    record[storageKey] = null;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(dataID, storageKey, null);\n    }\n  }\n\n  /**\n   * Returns the Data ID of a linked record (eg the ID of the `address` record\n   * in `actor{address}`).\n   */\n  getLinkedRecordID(\n    dataID: DataID,\n    storageKey: string\n  ): ?DataID {\n    const field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      typeof field === 'object' &&\n        field !== null &&\n        !Array.isArray(field),\n      'RelayRecordWriter.getLinkedRecordID(): Expected field `%s` for record ' +\n      '`%s` to have a linked record.',\n      storageKey,\n      dataID\n    );\n    return field.__dataID__;\n  }\n\n  /**\n   * Creates/updates a link between two records via the given field.\n   */\n  putLinkedRecordID(\n    parentID: DataID,\n    storageKey: string,\n    recordID: DataID\n  ): void {\n    const parent = this._getRecordForWrite(parentID);\n    invariant(\n      parent,\n      'RelayRecordWriter.putLinkedRecordID(): Expected record `%s` to exist ' +\n      'before linking to record `%s`.',\n      parentID,\n      recordID\n    );\n    const record = this._records[recordID];\n    invariant(\n      record,\n      'RelayRecordWriter.putLinkedRecordID(): Expected record `%s` to exist ' +\n      'before linking from record `%s`.',\n      recordID,\n      parentID\n    );\n    const fieldValue = RelayRecord.create(recordID);\n    parent[storageKey] = fieldValue;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(parentID, storageKey, fieldValue);\n    }\n  }\n\n  /**\n   * Returns an array of Data ID for a plural linked field (eg the actor IDs of\n   * the `likers` in `story{likers}`).\n   */\n  getLinkedRecordIDs(\n    dataID: DataID,\n    storageKey: string\n  ): ?Array<DataID> {\n    const field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      Array.isArray(field),\n      'RelayRecordWriter.getLinkedRecordIDs(): Expected field `%s` for ' +\n      'record `%s` to have an array of linked records.',\n      storageKey,\n      dataID\n    );\n    return field.map((item, ii) => {\n      invariant(\n        typeof item === 'object' && item.__dataID__,\n        'RelayRecordWriter.getLinkedRecordIDs(): Expected element at index ' +\n        '%s in field `%s` for record `%s` to be a linked record.',\n        ii,\n        storageKey,\n        dataID\n      );\n      return item.__dataID__;\n    });\n  }\n\n  /**\n   * Creates/updates a one-to-many link between records via the given field.\n   */\n  putLinkedRecordIDs(\n    parentID: DataID,\n    storageKey: string,\n    recordIDs: Array<DataID>\n  ): void {\n    const parent = this._getRecordForWrite(parentID);\n    invariant(\n      parent,\n      'RelayRecordWriter.putLinkedRecordIDs(): Expected record `%s` to exist ' +\n      'before linking records.',\n      parentID\n    );\n    const records = recordIDs.map(recordID => {\n      const record = this._records[recordID];\n      invariant(\n        record,\n        'RelayRecordWriter.putLinkedRecordIDs(): Expected record `%s` to ' +\n        'exist before linking from `%s`.',\n        recordID,\n        parentID\n      );\n      return RelayRecord.create(recordID);\n    });\n    parent[storageKey] = records;\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(parentID, storageKey, records);\n    }\n  }\n\n  /**\n   * Get the force index associated with the range at `connectionID`.\n   */\n  getRangeForceIndex(\n    connectionID: DataID\n  ): number {\n    const forceIndex: ?number =\n      (this._getField(connectionID, FORCE_INDEX): any);\n    if (forceIndex === null) {\n      return -1;\n    }\n    // __forceIndex__ can only be a number\n    return forceIndex || 0;\n  }\n\n  /**\n   * Get the condition calls that were used to fetch the given connection.\n   * Ex: for a field `photos.orderby(recent)`, this would be\n   * [{name: 'orderby', value: 'recent'}]\n   */\n  getRangeFilterCalls(\n    connectionID: DataID\n  ): ?Array<Call> {\n    return (this._getField(connectionID, FILTER_CALLS): any);\n  }\n\n  /**\n   * Creates a range at `dataID` with an optional `forceIndex`.\n   */\n  putRange(\n    connectionID: DataID,\n    calls: Array<Call>,\n    forceIndex?: ?number\n  ): void {\n    invariant(\n      !this._isOptimisticWrite,\n      'RelayRecordWriter.putRange(): Cannot create a queued range.'\n    );\n    const record = this._getRecordForWrite(connectionID);\n    invariant(\n      record,\n      'RelayRecordWriter.putRange(): Expected record `%s` to exist before ' +\n      'adding a range.',\n      connectionID\n    );\n    const range = new GraphQLRange();\n    const filterCalls = getFilterCalls(calls);\n    forceIndex = forceIndex || 0;\n    record.__filterCalls__ = filterCalls;\n    record.__forceIndex__ = forceIndex;\n    record.__range__ = range;\n\n    const cacheWriter = this._cacheWriter;\n    if (!this._isOptimisticWrite && cacheWriter) {\n      cacheWriter.writeField(connectionID, FILTER_CALLS, filterCalls);\n      cacheWriter.writeField(connectionID, FORCE_INDEX, forceIndex);\n      cacheWriter.writeField(connectionID, RANGE, range);\n    }\n  }\n\n  /**\n   * Returns whether there is a range at `connectionID`.\n   */\n  hasRange(connectionID: DataID): boolean {\n    return !!this._getField(connectionID, RANGE);\n  }\n\n  /**\n   * Adds newly fetched edges to a range.\n   */\n  putRangeEdges(\n    connectionID: DataID,\n    calls: Array<Call>,\n    pageInfo: PageInfo,\n    edges: Array<DataID>\n  ): void {\n    const range: ?GraphQLRange = (this._getField(connectionID, RANGE): any);\n    invariant(\n      range,\n      'RelayRecordWriter.putRangeEdges(): Expected record `%s` to exist and ' +\n      'have a range.',\n      connectionID\n    );\n    const edgesData = [];\n    edges.forEach(edgeID => {\n      const edgeData = this._getRangeEdgeData(edgeID);\n      edgesData.push(edgeData);\n      this._addConnectionForNode(connectionID, edgeData.node.__dataID__);\n    });\n    range.addItems(\n      calls,\n      edgesData,\n      pageInfo\n    );\n    if (!this._isOptimisticWrite && this._cacheWriter) {\n      this._cacheWriter.writeField(connectionID, RANGE, range);\n    }\n  }\n\n  /**\n   * Prepend, append, or delete edges to/from a range.\n   */\n  applyRangeUpdate(\n    connectionID: DataID,\n    edgeID: DataID,\n    operation: RangeOperation\n  ): void {\n    if (this._isOptimisticWrite) {\n      this._applyOptimisticRangeUpdate(connectionID, edgeID, operation);\n    } else {\n      this._applyServerRangeUpdate(connectionID, edgeID, operation);\n    }\n  }\n\n  /**\n   * Get edge data in a format compatibile with `GraphQLRange`.\n   * TODO: change `GraphQLRange` to accept `(edgeID, cursor, nodeID)` tuple\n   */\n  _getRangeEdgeData(edgeID: DataID): EdgeData {\n    const nodeID = this.getLinkedRecordID(edgeID, NODE);\n    invariant(\n      nodeID,\n      'RelayRecordWriter: Expected edge `%s` to have a `node` record.',\n      edgeID\n    );\n    return RelayRecord.createWithFields(edgeID, {\n      cursor: this.getField(edgeID, CURSOR),\n      node: RelayRecord.create(nodeID),\n    });\n  }\n\n  _applyOptimisticRangeUpdate(\n    connectionID: DataID,\n    edgeID: DataID,\n    operation: RangeOperation\n  ): void {\n    let record: ?Record = this._getRecordForWrite(connectionID);\n    if (!record) {\n      record = RelayRecord.create(connectionID);\n      this._records[connectionID] = record;\n    }\n    this._setClientMutationID(record);\n    const key = rangeOperationToMetadataKey[operation];\n    let queue: ?Array<DataID> = record[key];\n    if (!queue) {\n      queue = [];\n      record[key] = queue;\n    }\n    if (operation === PREPEND) {\n      queue.unshift(edgeID);\n    } else {\n      queue.push(edgeID);\n    }\n  }\n\n  _applyServerRangeUpdate(\n    connectionID: DataID,\n    edgeID: DataID,\n    operation: RangeOperation\n  ): void {\n    const range: ?GraphQLRange = (this._getField(connectionID, RANGE): any);\n    invariant(\n      range,\n      'RelayRecordWriter: Cannot apply `%s` update to non-existent record ' +\n      '`%s`.',\n      operation,\n      connectionID\n    );\n    if (operation === REMOVE) {\n      range.removeEdgeWithID(edgeID);\n      const nodeID = this.getLinkedRecordID(edgeID, 'node');\n      if (nodeID) {\n        this._removeConnectionForNode(connectionID, nodeID);\n      }\n    } else {\n      const edgeData = this._getRangeEdgeData(edgeID);\n      this._addConnectionForNode(connectionID, edgeData.node.__dataID__);\n      if (operation === APPEND) {\n        range.appendEdge(this._getRangeEdgeData(edgeID));\n      } else {\n        // prepend\n        range.prependEdge(this._getRangeEdgeData(edgeID));\n      }\n    }\n    if (this._cacheWriter) {\n      this._cacheWriter.writeField(connectionID, RANGE, range);\n    }\n  }\n\n  /**\n   * Record that the node is contained in the connection.\n   */\n  _addConnectionForNode(\n    connectionID: DataID,\n    nodeID: DataID\n  ): void {\n    let connectionMap = this._nodeConnectionMap[nodeID];\n    if (!connectionMap) {\n      connectionMap = {};\n      this._nodeConnectionMap[nodeID] = connectionMap;\n    }\n    connectionMap[connectionID] = true;\n  }\n\n  /**\n   * Record that the given node is no longer part of the connection.\n   */\n  _removeConnectionForNode(\n    connectionID: DataID,\n    nodeID: DataID\n  ): void {\n    const connectionMap = this._nodeConnectionMap[nodeID];\n    if (connectionMap) {\n      delete connectionMap[connectionID];\n      if (Object.keys(connectionMap).length === 0) {\n        delete this._nodeConnectionMap[nodeID];\n      }\n    }\n  }\n\n  /**\n   * If the record is in the store, gets a version of the record\n   * in the store being used for writes.\n   */\n  _getRecordForWrite(dataID: DataID): ?Record {\n    const record = this._records[dataID];\n    if (!record) {\n      return record;\n    }\n    if (this._isOptimisticWrite) {\n      this._setClientMutationID(record);\n    }\n    return record;\n  }\n\n  /**\n   * Get the value of the field from the first version of the record for which\n   * the field is defined, returning `null` if the record has been deleted or\n   * `undefined` if the record has not been fetched.\n   */\n  _getField(dataID: DataID, storageKey: string): ?FieldValue {\n    const record = this._records[dataID];\n    if (record === null) {\n      return null;\n    } else if (record && record.hasOwnProperty(storageKey)) {\n      return record[storageKey];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Injects the client mutation id associated with the record store instance\n   * into the given record.\n   */\n  _setClientMutationID(record: Record): void {\n    const clientMutationID = this._clientMutationID;\n    invariant(\n      clientMutationID,\n      'RelayRecordWriter: _clientMutationID cannot be null/undefined.'\n    );\n    const mutationIDs: Array<ClientMutationID> = record.__mutationIDs__ || [];\n    if (mutationIDs.indexOf(clientMutationID) === -1) {\n      mutationIDs.push(clientMutationID);\n      record.__mutationIDs__ = mutationIDs;\n    }\n    record.__status__ = RelayRecordStatusMap.setOptimisticStatus(\n      0,\n      true\n    );\n  }\n}\n\n/**\n * Filter calls to only those that specify conditions on the returned results\n * (ex: `orderby(TOP_STORIES)`), removing generic calls (ex: `first`, `find`).\n */\nfunction getFilterCalls(calls: Array<Call>): Array<Call> {\n  return calls.filter(call => !RelayConnectionInterface.isConnectionCall(call));\n}\n\nmodule.exports = RelayRecordWriter;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayRecordStore.js":{"metadata":{"mtime":1456974578000},"data":{"name":"RelayRecordStore","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordStore\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  ClientMutationID,\n  DataID,\n  FieldValue,\n  NodeRangeMap,\n  RootCallMap,\n} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nimport type RelayQueryPath from 'RelayQueryPath';\nimport type {\n  Record,\n  RecordMap,\n} from 'RelayRecord';\nimport type {RecordState} from 'RelayRecordState';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nconst {NODE} = RelayConnectionInterface;\nconst EMPTY = '';\nconst FILTER_CALLS = '__filterCalls__';\nconst FORCE_INDEX = '__forceIndex__';\nconst RANGE = '__range__';\nconst RESOLVED_FRAGMENT_MAP = '__resolvedFragmentMap__';\nconst PATH = '__path__';\n\nimport type {\n  PageInfo,\n} from 'RelayConnectionInterface';\n\ntype RangeEdge = {\n  edgeID: string;\n  nodeID: ?string;\n};\n\nexport type RangeInfo = {\n  diffCalls: Array<Call>;\n  filterCalls: Array<Call>;\n  pageInfo: ?PageInfo;\n  requestedEdgeIDs: Array<string>;\n  filteredEdges: Array<RangeEdge>;\n};\n\ntype RecordCollection = {\n  cachedRecords?: ?RecordMap;\n  queuedRecords?: ?RecordMap;\n  records: RecordMap;\n};\n\ntype RootCallMapCollection = {\n  cachedRootCallMap?: RootCallMap;\n  rootCallMap: RootCallMap;\n};\n\n/**\n * @internal\n *\n * `RelayRecordStore` is the central repository for all data fetched by the\n * client. Data is stored as a map of IDs to Records. Records are maps of\n * field names to values.\n *\n * TODO: #6584253 Mediate access to node/cached/queued data via RelayRecordStore\n */\nclass RelayRecordStore {\n  _cachedRecords: ?RecordMap;\n  _cachedRootCallMap: RootCallMap;\n  _queuedRecords: ?RecordMap;\n  _records: RecordMap;\n  _nodeConnectionMap: NodeRangeMap;\n  _rootCallMap: RootCallMap;\n  _storage: Array<RecordMap>;\n\n  constructor(\n    records: RecordCollection,\n    rootCallMaps?: ?RootCallMapCollection,\n    nodeConnectionMap?: ?NodeRangeMap,\n  ) {\n    this._cachedRecords = records.cachedRecords;\n    this._cachedRootCallMap =\n      (rootCallMaps && rootCallMaps.cachedRootCallMap) || {};\n    this._queuedRecords = records.queuedRecords;\n    this._nodeConnectionMap = nodeConnectionMap || {};\n    this._records = records.records;\n    this._rootCallMap = (rootCallMaps && rootCallMaps.rootCallMap) || {};\n    this._storage = [];\n    if (this._queuedRecords) {\n      this._storage.push(this._queuedRecords);\n    }\n    if (this._records) {\n      this._storage.push(this._records);\n    }\n    if (this._cachedRecords) {\n      this._storage.push(this._cachedRecords);\n    }\n  }\n\n  /**\n   * Get the data ID associated with a storage key (and optionally an\n   * identifying argument value) for a root query.\n   */\n  getDataID(\n    storageKey: string,\n    identifyingArgValue: ?string\n  ): ?DataID {\n    if (RelayNodeInterface.isNodeRootCall(storageKey)) {\n      invariant(\n        identifyingArgValue != null,\n        'RelayRecordStore.getDataID(): Argument to `%s()` ' +\n        'cannot be null or undefined.',\n        storageKey\n      );\n      return identifyingArgValue;\n    }\n    if (identifyingArgValue == null) {\n      identifyingArgValue = EMPTY;\n    }\n    if (this._rootCallMap.hasOwnProperty(storageKey) &&\n        this._rootCallMap[storageKey].hasOwnProperty(identifyingArgValue)) {\n      return this._rootCallMap[storageKey][identifyingArgValue];\n    } else if (this._cachedRootCallMap.hasOwnProperty(storageKey)) {\n      return this._cachedRootCallMap[storageKey][identifyingArgValue];\n    }\n  }\n\n  /**\n   * Returns the status of the record stored at `dataID`.\n   */\n  getRecordState(dataID: DataID): RecordState {\n    var record = this._getRecord(dataID);\n    if (record === null) {\n      return 'NONEXISTENT';\n    } else if (record === undefined) {\n      return 'UNKNOWN';\n    }\n    return 'EXISTENT';\n  }\n\n  /**\n   * Returns the path to a non-refetchable record.\n   */\n  getPathToRecord(\n    dataID: DataID\n  ): ?RelayQueryPath {\n    var path: ?RelayQueryPath = (this._getField(dataID, PATH): any);\n    return path;\n  }\n\n  /**\n   * Returns whether a given record is affected by an optimistic update.\n   */\n  hasOptimisticUpdate(dataID: DataID): boolean {\n    invariant(\n      this._queuedRecords,\n      'RelayRecordStore.hasOptimisticUpdate(): Optimistic updates require ' +\n      'queued records.'\n    );\n    return this._queuedRecords.hasOwnProperty(dataID);\n  }\n\n  /**\n   * Returns a list of client mutation IDs for queued mutations whose optimistic\n   * updates are affecting the record corresponding the given dataID. Returns\n   * null if the record isn't affected by any optimistic updates.\n   */\n  getClientMutationIDs(dataID: DataID): ?Array<ClientMutationID> {\n    invariant(\n      this._queuedRecords,\n      'RelayRecordStore.getClientMutationIDs(): Optimistic updates require ' +\n      'queued records.'\n    );\n    var record = this._queuedRecords[dataID];\n    return record ? record.__mutationIDs__ : null;\n  }\n\n  /**\n   * Check whether a given record has received data for a deferred fragment.\n   */\n  hasDeferredFragmentData(dataID: DataID, fragmentID: string): boolean {\n    const resolvedFragmentMap = this._getField(dataID, RESOLVED_FRAGMENT_MAP);\n    invariant(\n      typeof resolvedFragmentMap === 'object' || resolvedFragmentMap == null,\n      'RelayRecordStore.hasDeferredFragmentData(): Expected the map of ' +\n      'resolved deferred fragments associated with record `%s` to be null or ' +\n      'an object. Found a(n) `%s`.',\n      dataID,\n      typeof resolvedFragmentMap\n    );\n    return !!(resolvedFragmentMap && resolvedFragmentMap[fragmentID]);\n  }\n\n  getType(dataID: DataID): ?string {\n    // `__typename` property is typed as `string`\n    return (this._getField(dataID, '__typename'): any);\n  }\n\n  /**\n   * Returns the value of the field for the given dataID.\n   */\n  getField(\n    dataID: DataID,\n    storageKey: string\n  ): ?FieldValue {\n    return this._getField(dataID, storageKey);\n  }\n\n  /**\n   * Returns the Data ID of a linked record (eg the ID of the `address` record\n   * in `actor{address}`).\n   */\n  getLinkedRecordID(\n    dataID: DataID,\n    storageKey: string\n  ): ?DataID {\n    var field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      typeof field === 'object' &&\n        field !== null &&\n        !Array.isArray(field),\n      'RelayRecordStore.getLinkedRecordID(): Expected field `%s` for record ' +\n      '`%s` to have a linked record.',\n      storageKey,\n      dataID\n    );\n    return field.__dataID__;\n  }\n\n  /**\n   * Returns an array of Data ID for a plural linked field (eg the actor IDs of\n   * the `likers` in `story{likers}`).\n   */\n  getLinkedRecordIDs(\n    dataID: DataID,\n    storageKey: string\n  ): ?Array<DataID> {\n    var field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      Array.isArray(field),\n      'RelayRecordStore.getLinkedRecordIDs(): Expected field `%s` for ' +\n      'record `%s` to have an array of linked records.',\n      storageKey,\n      dataID\n    );\n    return field.map((item, ii) => {\n      invariant(\n        typeof item === 'object' && item.__dataID__,\n        'RelayRecordStore.getLinkedRecordIDs(): Expected element at index %s ' +\n        'in field `%s` for record `%s` to be a linked record.',\n        ii,\n        storageKey,\n        dataID\n      );\n      return item.__dataID__;\n    });\n  }\n\n  /**\n   * Gets the connectionIDs for all the connections that contain the given\n   * record as a `node`, or null if the record does not appear as a `node` in\n   * any connection.\n   */\n  getConnectionIDsForRecord(\n    dataID: DataID\n  ): ?Array<DataID> {\n    var connectionIDs = this._nodeConnectionMap[dataID];\n    if (connectionIDs) {\n      return Object.keys(connectionIDs);\n    }\n    return null;\n  }\n\n  /**\n   * Gets the connectionIDs for all variations of calls for the given base\n   * schema name (Ex: `posts.orderby(recent)` and `posts.orderby(likes)`).\n   */\n  getConnectionIDsForField(\n    dataID: DataID,\n    schemaName: string\n  ): ?Array<DataID> {\n    // ignore queued records because not all range fields may be present there\n    var record = this._records[dataID];\n    if (record == null) {\n      return record;\n    }\n    var connectionIDs;\n    forEachObject(record, (datum, key) => {\n      if (datum && getFieldNameFromKey(key) === schemaName) {\n        var dataID = datum.__dataID__;\n        if (dataID) {\n          connectionIDs = connectionIDs || [];\n          connectionIDs.push(dataID);\n        }\n      }\n    });\n    return connectionIDs;\n  }\n\n  /**\n   * Get the force index associated with the range at `connectionID`.\n   */\n  getRangeForceIndex(\n    connectionID: DataID\n  ): number {\n    var forceIndex: ?number = (this._getField(connectionID, FORCE_INDEX): any);\n    if (forceIndex === null) {\n      return -1;\n    }\n    // __forceIndex__ can only be a number\n    return forceIndex || 0;\n  }\n\n  /**\n   * Get the condition calls that were used to fetch the given connection.\n   * Ex: for a field `photos.orderby(recent)`, this would be\n   * [{name: 'orderby', value: 'recent'}]\n   */\n  getRangeFilterCalls(\n    connectionID: DataID\n  ): ?Array<Call> {\n    return (this._getField(connectionID, FILTER_CALLS): any);\n  }\n\n  /**\n   * Returns range information for the given connection field:\n   * - `filteredEdges`: any edges already fetched for the given `calls`.\n   * - `diffCalls`: an array of calls describing the difference\n   *   between the given `calls` and already fetched data. Includes conditional\n   *   calls (`orderby`) and range/offset calls (`first`, `after`).\n   * - `filterCalls`: the subset of `calls` that are condition calls\n   *   (`orderby`).\n   */\n  getRangeMetadata(\n    connectionID: ?DataID,\n    calls: Array<Call>\n  ): ?RangeInfo {\n    if (connectionID == null) {\n      return connectionID;\n    }\n    var range: ?GraphQLRange = (this._getField(connectionID, RANGE): any);\n    if (range == null) {\n      if (range === null) {\n        warning(\n          false,\n          'RelayRecordStore.getRangeMetadata(): Expected range to exist if ' +\n          '`edges` has been fetched.'\n        );\n      }\n      return undefined;\n    }\n    var filterCalls = getFilterCalls(calls);\n    // Edges can only be fetched if a range call (first/last/find) is given.\n    // Otherwise return diffCalls/filterCalls with empty edges.\n    if (calls.length === filterCalls.length) {\n      return {\n        diffCalls: calls,\n        filterCalls,\n        pageInfo: undefined,\n        requestedEdgeIDs: [],\n        filteredEdges: [],\n      };\n    }\n    var queuedRecord = this._queuedRecords ?\n      this._queuedRecords[connectionID] :\n      null;\n    var {\n      diffCalls,\n      pageInfo,\n      requestedEdgeIDs,\n    } = range.retrieveRangeInfoForQuery(calls, queuedRecord);\n    if (diffCalls && diffCalls.length) {\n      diffCalls = filterCalls.concat(diffCalls);\n    } else {\n      diffCalls = [];\n    }\n    var filteredEdges;\n    if (requestedEdgeIDs) {\n      filteredEdges = requestedEdgeIDs\n        .map(edgeID => ({\n          edgeID,\n          nodeID: this.getLinkedRecordID(edgeID, NODE),\n        }))\n        .filter(edge => this._getRecord(edge.nodeID));\n    } else {\n      filteredEdges = [];\n    }\n    return {\n      diffCalls,\n      filterCalls,\n      pageInfo,\n      requestedEdgeIDs,\n      filteredEdges,\n    };\n  }\n\n  /**\n   * Returns whether there is a range at `connectionID`.\n   */\n  hasRange(connectionID: DataID): boolean {\n    return !!this._getField(connectionID, RANGE);\n  }\n\n  /**\n   * Completely removes the record identified by `dataID` from the store.\n   * This is only used by garbage collection.\n   */\n  removeRecord(dataID: DataID): void {\n    delete this._records[dataID];\n    if (this._queuedRecords) {\n      delete this._queuedRecords[dataID];\n    }\n    if (this._cachedRecords) {\n      delete this._cachedRecords[dataID];\n    }\n    delete this._nodeConnectionMap[dataID];\n  }\n\n  /**\n   * Gets the first version of the record from the available caches.\n   */\n  _getRecord(dataID: DataID): ?Record {\n    if (this._queuedRecords && this._queuedRecords.hasOwnProperty(dataID)) {\n      return this._queuedRecords[dataID];\n    } else if (this._records.hasOwnProperty(dataID)) {\n      return this._records[dataID];\n    } else if (this._cachedRecords) {\n      return this._cachedRecords[dataID];\n    }\n  }\n\n  /**\n   * Get the value of the field from the first version of the record for which\n   * the field is defined, returning `null` if the record has been deleted or\n   * `undefined` if the record has not been fetched.\n   */\n  _getField(dataID: DataID, storageKey: string): ?FieldValue {\n    var storage = this._storage;\n    for (var ii = 0; ii < storage.length; ii++) {\n      var record = storage[ii][dataID];\n      if (record === null) {\n        return null;\n      } else if (record && record.hasOwnProperty(storageKey)) {\n        return record[storageKey];\n      }\n    }\n    return undefined;\n  }\n}\n\n/**\n * Filter calls to only those that specify conditions on the returned results\n * (ex: `orderby(TOP_STORIES)`), removing generic calls (ex: `first`, `find`).\n */\nfunction getFilterCalls(calls: Array<Call>): Array<Call> {\n  return calls.filter(call => !RelayConnectionInterface.isConnectionCall(call));\n}\n\n/**\n * Returns the field name based on the object key used to store the data in\n * nodeData. It returns the field name without any calls. For example, the\n * field name for 'profile_picture{size:\"50\"}' will be 'profile_picture'\n */\nfunction getFieldNameFromKey(key: string): ?string {\n  // This is based on the GraphQL spec for what constitutes a valid field name.\n  return key.split(/(?![_A-Za-z][_0-9A-Za-z]*)/, 1)[0];\n}\n\nmodule.exports = RelayRecordStore;\n","dependencies":["RelayInternalTypes","RelayQueryPath","RelayRecord","RelayRecordState","RelayConnectionInterface","GraphQLRange","RelayNodeInterface","forEachObject","invariant","warning","RelayRecordStore"],"id":"RelayRecordStore","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordStore\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLRange = require('GraphQLRange');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  ClientMutationID,\n  DataID,\n  FieldValue,\n  NodeRangeMap,\n  RootCallMap,\n} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nimport type RelayQueryPath from 'RelayQueryPath';\nimport type {\n  Record,\n  RecordMap,\n} from 'RelayRecord';\nimport type {RecordState} from 'RelayRecordState';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nconst {NODE} = RelayConnectionInterface;\nconst EMPTY = '';\nconst FILTER_CALLS = '__filterCalls__';\nconst FORCE_INDEX = '__forceIndex__';\nconst RANGE = '__range__';\nconst RESOLVED_FRAGMENT_MAP = '__resolvedFragmentMap__';\nconst PATH = '__path__';\n\nimport type {\n  PageInfo,\n} from 'RelayConnectionInterface';\n\ntype RangeEdge = {\n  edgeID: string;\n  nodeID: ?string;\n};\n\nexport type RangeInfo = {\n  diffCalls: Array<Call>;\n  filterCalls: Array<Call>;\n  pageInfo: ?PageInfo;\n  requestedEdgeIDs: Array<string>;\n  filteredEdges: Array<RangeEdge>;\n};\n\ntype RecordCollection = {\n  cachedRecords?: ?RecordMap;\n  queuedRecords?: ?RecordMap;\n  records: RecordMap;\n};\n\ntype RootCallMapCollection = {\n  cachedRootCallMap?: RootCallMap;\n  rootCallMap: RootCallMap;\n};\n\n/**\n * @internal\n *\n * `RelayRecordStore` is the central repository for all data fetched by the\n * client. Data is stored as a map of IDs to Records. Records are maps of\n * field names to values.\n *\n * TODO: #6584253 Mediate access to node/cached/queued data via RelayRecordStore\n */\nclass RelayRecordStore {\n  _cachedRecords: ?RecordMap;\n  _cachedRootCallMap: RootCallMap;\n  _queuedRecords: ?RecordMap;\n  _records: RecordMap;\n  _nodeConnectionMap: NodeRangeMap;\n  _rootCallMap: RootCallMap;\n  _storage: Array<RecordMap>;\n\n  constructor(\n    records: RecordCollection,\n    rootCallMaps?: ?RootCallMapCollection,\n    nodeConnectionMap?: ?NodeRangeMap,\n  ) {\n    this._cachedRecords = records.cachedRecords;\n    this._cachedRootCallMap =\n      (rootCallMaps && rootCallMaps.cachedRootCallMap) || {};\n    this._queuedRecords = records.queuedRecords;\n    this._nodeConnectionMap = nodeConnectionMap || {};\n    this._records = records.records;\n    this._rootCallMap = (rootCallMaps && rootCallMaps.rootCallMap) || {};\n    this._storage = [];\n    if (this._queuedRecords) {\n      this._storage.push(this._queuedRecords);\n    }\n    if (this._records) {\n      this._storage.push(this._records);\n    }\n    if (this._cachedRecords) {\n      this._storage.push(this._cachedRecords);\n    }\n  }\n\n  /**\n   * Get the data ID associated with a storage key (and optionally an\n   * identifying argument value) for a root query.\n   */\n  getDataID(\n    storageKey: string,\n    identifyingArgValue: ?string\n  ): ?DataID {\n    if (RelayNodeInterface.isNodeRootCall(storageKey)) {\n      invariant(\n        identifyingArgValue != null,\n        'RelayRecordStore.getDataID(): Argument to `%s()` ' +\n        'cannot be null or undefined.',\n        storageKey\n      );\n      return identifyingArgValue;\n    }\n    if (identifyingArgValue == null) {\n      identifyingArgValue = EMPTY;\n    }\n    if (this._rootCallMap.hasOwnProperty(storageKey) &&\n        this._rootCallMap[storageKey].hasOwnProperty(identifyingArgValue)) {\n      return this._rootCallMap[storageKey][identifyingArgValue];\n    } else if (this._cachedRootCallMap.hasOwnProperty(storageKey)) {\n      return this._cachedRootCallMap[storageKey][identifyingArgValue];\n    }\n  }\n\n  /**\n   * Returns the status of the record stored at `dataID`.\n   */\n  getRecordState(dataID: DataID): RecordState {\n    var record = this._getRecord(dataID);\n    if (record === null) {\n      return 'NONEXISTENT';\n    } else if (record === undefined) {\n      return 'UNKNOWN';\n    }\n    return 'EXISTENT';\n  }\n\n  /**\n   * Returns the path to a non-refetchable record.\n   */\n  getPathToRecord(\n    dataID: DataID\n  ): ?RelayQueryPath {\n    var path: ?RelayQueryPath = (this._getField(dataID, PATH): any);\n    return path;\n  }\n\n  /**\n   * Returns whether a given record is affected by an optimistic update.\n   */\n  hasOptimisticUpdate(dataID: DataID): boolean {\n    invariant(\n      this._queuedRecords,\n      'RelayRecordStore.hasOptimisticUpdate(): Optimistic updates require ' +\n      'queued records.'\n    );\n    return this._queuedRecords.hasOwnProperty(dataID);\n  }\n\n  /**\n   * Returns a list of client mutation IDs for queued mutations whose optimistic\n   * updates are affecting the record corresponding the given dataID. Returns\n   * null if the record isn't affected by any optimistic updates.\n   */\n  getClientMutationIDs(dataID: DataID): ?Array<ClientMutationID> {\n    invariant(\n      this._queuedRecords,\n      'RelayRecordStore.getClientMutationIDs(): Optimistic updates require ' +\n      'queued records.'\n    );\n    var record = this._queuedRecords[dataID];\n    return record ? record.__mutationIDs__ : null;\n  }\n\n  /**\n   * Check whether a given record has received data for a deferred fragment.\n   */\n  hasDeferredFragmentData(dataID: DataID, fragmentID: string): boolean {\n    const resolvedFragmentMap = this._getField(dataID, RESOLVED_FRAGMENT_MAP);\n    invariant(\n      typeof resolvedFragmentMap === 'object' || resolvedFragmentMap == null,\n      'RelayRecordStore.hasDeferredFragmentData(): Expected the map of ' +\n      'resolved deferred fragments associated with record `%s` to be null or ' +\n      'an object. Found a(n) `%s`.',\n      dataID,\n      typeof resolvedFragmentMap\n    );\n    return !!(resolvedFragmentMap && resolvedFragmentMap[fragmentID]);\n  }\n\n  getType(dataID: DataID): ?string {\n    // `__typename` property is typed as `string`\n    return (this._getField(dataID, '__typename'): any);\n  }\n\n  /**\n   * Returns the value of the field for the given dataID.\n   */\n  getField(\n    dataID: DataID,\n    storageKey: string\n  ): ?FieldValue {\n    return this._getField(dataID, storageKey);\n  }\n\n  /**\n   * Returns the Data ID of a linked record (eg the ID of the `address` record\n   * in `actor{address}`).\n   */\n  getLinkedRecordID(\n    dataID: DataID,\n    storageKey: string\n  ): ?DataID {\n    var field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      typeof field === 'object' &&\n        field !== null &&\n        !Array.isArray(field),\n      'RelayRecordStore.getLinkedRecordID(): Expected field `%s` for record ' +\n      '`%s` to have a linked record.',\n      storageKey,\n      dataID\n    );\n    return field.__dataID__;\n  }\n\n  /**\n   * Returns an array of Data ID for a plural linked field (eg the actor IDs of\n   * the `likers` in `story{likers}`).\n   */\n  getLinkedRecordIDs(\n    dataID: DataID,\n    storageKey: string\n  ): ?Array<DataID> {\n    var field = this._getField(dataID, storageKey);\n    if (field == null) {\n      return field;\n    }\n    invariant(\n      Array.isArray(field),\n      'RelayRecordStore.getLinkedRecordIDs(): Expected field `%s` for ' +\n      'record `%s` to have an array of linked records.',\n      storageKey,\n      dataID\n    );\n    return field.map((item, ii) => {\n      invariant(\n        typeof item === 'object' && item.__dataID__,\n        'RelayRecordStore.getLinkedRecordIDs(): Expected element at index %s ' +\n        'in field `%s` for record `%s` to be a linked record.',\n        ii,\n        storageKey,\n        dataID\n      );\n      return item.__dataID__;\n    });\n  }\n\n  /**\n   * Gets the connectionIDs for all the connections that contain the given\n   * record as a `node`, or null if the record does not appear as a `node` in\n   * any connection.\n   */\n  getConnectionIDsForRecord(\n    dataID: DataID\n  ): ?Array<DataID> {\n    var connectionIDs = this._nodeConnectionMap[dataID];\n    if (connectionIDs) {\n      return Object.keys(connectionIDs);\n    }\n    return null;\n  }\n\n  /**\n   * Gets the connectionIDs for all variations of calls for the given base\n   * schema name (Ex: `posts.orderby(recent)` and `posts.orderby(likes)`).\n   */\n  getConnectionIDsForField(\n    dataID: DataID,\n    schemaName: string\n  ): ?Array<DataID> {\n    // ignore queued records because not all range fields may be present there\n    var record = this._records[dataID];\n    if (record == null) {\n      return record;\n    }\n    var connectionIDs;\n    forEachObject(record, (datum, key) => {\n      if (datum && getFieldNameFromKey(key) === schemaName) {\n        var dataID = datum.__dataID__;\n        if (dataID) {\n          connectionIDs = connectionIDs || [];\n          connectionIDs.push(dataID);\n        }\n      }\n    });\n    return connectionIDs;\n  }\n\n  /**\n   * Get the force index associated with the range at `connectionID`.\n   */\n  getRangeForceIndex(\n    connectionID: DataID\n  ): number {\n    var forceIndex: ?number = (this._getField(connectionID, FORCE_INDEX): any);\n    if (forceIndex === null) {\n      return -1;\n    }\n    // __forceIndex__ can only be a number\n    return forceIndex || 0;\n  }\n\n  /**\n   * Get the condition calls that were used to fetch the given connection.\n   * Ex: for a field `photos.orderby(recent)`, this would be\n   * [{name: 'orderby', value: 'recent'}]\n   */\n  getRangeFilterCalls(\n    connectionID: DataID\n  ): ?Array<Call> {\n    return (this._getField(connectionID, FILTER_CALLS): any);\n  }\n\n  /**\n   * Returns range information for the given connection field:\n   * - `filteredEdges`: any edges already fetched for the given `calls`.\n   * - `diffCalls`: an array of calls describing the difference\n   *   between the given `calls` and already fetched data. Includes conditional\n   *   calls (`orderby`) and range/offset calls (`first`, `after`).\n   * - `filterCalls`: the subset of `calls` that are condition calls\n   *   (`orderby`).\n   */\n  getRangeMetadata(\n    connectionID: ?DataID,\n    calls: Array<Call>\n  ): ?RangeInfo {\n    if (connectionID == null) {\n      return connectionID;\n    }\n    var range: ?GraphQLRange = (this._getField(connectionID, RANGE): any);\n    if (range == null) {\n      if (range === null) {\n        warning(\n          false,\n          'RelayRecordStore.getRangeMetadata(): Expected range to exist if ' +\n          '`edges` has been fetched.'\n        );\n      }\n      return undefined;\n    }\n    var filterCalls = getFilterCalls(calls);\n    // Edges can only be fetched if a range call (first/last/find) is given.\n    // Otherwise return diffCalls/filterCalls with empty edges.\n    if (calls.length === filterCalls.length) {\n      return {\n        diffCalls: calls,\n        filterCalls,\n        pageInfo: undefined,\n        requestedEdgeIDs: [],\n        filteredEdges: [],\n      };\n    }\n    var queuedRecord = this._queuedRecords ?\n      this._queuedRecords[connectionID] :\n      null;\n    var {\n      diffCalls,\n      pageInfo,\n      requestedEdgeIDs,\n    } = range.retrieveRangeInfoForQuery(calls, queuedRecord);\n    if (diffCalls && diffCalls.length) {\n      diffCalls = filterCalls.concat(diffCalls);\n    } else {\n      diffCalls = [];\n    }\n    var filteredEdges;\n    if (requestedEdgeIDs) {\n      filteredEdges = requestedEdgeIDs\n        .map(edgeID => ({\n          edgeID,\n          nodeID: this.getLinkedRecordID(edgeID, NODE),\n        }))\n        .filter(edge => this._getRecord(edge.nodeID));\n    } else {\n      filteredEdges = [];\n    }\n    return {\n      diffCalls,\n      filterCalls,\n      pageInfo,\n      requestedEdgeIDs,\n      filteredEdges,\n    };\n  }\n\n  /**\n   * Returns whether there is a range at `connectionID`.\n   */\n  hasRange(connectionID: DataID): boolean {\n    return !!this._getField(connectionID, RANGE);\n  }\n\n  /**\n   * Completely removes the record identified by `dataID` from the store.\n   * This is only used by garbage collection.\n   */\n  removeRecord(dataID: DataID): void {\n    delete this._records[dataID];\n    if (this._queuedRecords) {\n      delete this._queuedRecords[dataID];\n    }\n    if (this._cachedRecords) {\n      delete this._cachedRecords[dataID];\n    }\n    delete this._nodeConnectionMap[dataID];\n  }\n\n  /**\n   * Gets the first version of the record from the available caches.\n   */\n  _getRecord(dataID: DataID): ?Record {\n    if (this._queuedRecords && this._queuedRecords.hasOwnProperty(dataID)) {\n      return this._queuedRecords[dataID];\n    } else if (this._records.hasOwnProperty(dataID)) {\n      return this._records[dataID];\n    } else if (this._cachedRecords) {\n      return this._cachedRecords[dataID];\n    }\n  }\n\n  /**\n   * Get the value of the field from the first version of the record for which\n   * the field is defined, returning `null` if the record has been deleted or\n   * `undefined` if the record has not been fetched.\n   */\n  _getField(dataID: DataID, storageKey: string): ?FieldValue {\n    var storage = this._storage;\n    for (var ii = 0; ii < storage.length; ii++) {\n      var record = storage[ii][dataID];\n      if (record === null) {\n        return null;\n      } else if (record && record.hasOwnProperty(storageKey)) {\n        return record[storageKey];\n      }\n    }\n    return undefined;\n  }\n}\n\n/**\n * Filter calls to only those that specify conditions on the returned results\n * (ex: `orderby(TOP_STORIES)`), removing generic calls (ex: `first`, `find`).\n */\nfunction getFilterCalls(calls: Array<Call>): Array<Call> {\n  return calls.filter(call => !RelayConnectionInterface.isConnectionCall(call));\n}\n\n/**\n * Returns the field name based on the object key used to store the data in\n * nodeData. It returns the field name without any calls. For example, the\n * field name for 'profile_picture{size:\"50\"}' will be 'profile_picture'\n */\nfunction getFieldNameFromKey(key: string): ?string {\n  // This is based on the GraphQL spec for what constitutes a valid field name.\n  return key.split(/(?![_A-Za-z][_0-9A-Za-z]*)/, 1)[0];\n}\n\nmodule.exports = RelayRecordStore;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayRecordStatusMap.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayRecordStatusMap","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordStatusMap\n * @flow\n * @typechecks\n */\n\n'use strict';\n/**\n * Record might contain data from optimistic update.\n */\nvar OPTIMISTIC_MASK = 0x01;\n/**\n * Record was part of a mutation that resulted in an error.\n */\nvar ERROR_MASK = 0x02;\n/**\n * The subtree of data from this record contains partial data.\n */\nvar PARTIAL_MASK = 0x04;\n\nfunction set(status: ?number, value: boolean, mask: number): number {\n  status = status || 0;\n  if (value) {\n    return status | mask; // eslint-disable-line no-bitwise\n  } else {\n    return status & ~mask; // eslint-disable-line no-bitwise\n  }\n}\n\nfunction check(status: ?number, mask: number): boolean {\n  return ((status || 0) & mask) != 0; // eslint-disable-line no-bitwise\n}\n/**\n * A set of functions for modifying `__status__` on records inside of\n * RelayStore.\n */\nvar RelayRecordStatusMap = {\n  setOptimisticStatus: function(status: ?number, value: boolean): number {\n    return set(status, value, OPTIMISTIC_MASK);\n  },\n\n  isOptimisticStatus: function(status: ?number): boolean {\n    return check(status, OPTIMISTIC_MASK);\n  },\n\n  setErrorStatus: function(status: ?number, value: boolean): number {\n    return set(status, value, ERROR_MASK);\n  },\n\n  isErrorStatus: function(status: ?number): boolean {\n    return check(status, ERROR_MASK);\n  },\n\n  // Should only be used on records read out from RelayRecordStore\n  // by `readRelayQueryData`.\n  setPartialStatus: function(status: ?number, value: boolean): number {\n    return set(status, value, PARTIAL_MASK);\n  },\n\n  isPartialStatus: function(status: ?number): boolean {\n    return check(status, PARTIAL_MASK);\n  },\n};\n\nmodule.exports = RelayRecordStatusMap;\n","dependencies":["RelayRecordStatusMap"],"id":"RelayRecordStatusMap","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordStatusMap\n * @flow\n * @typechecks\n */\n\n'use strict';\n/**\n * Record might contain data from optimistic update.\n */\nvar OPTIMISTIC_MASK = 0x01;\n/**\n * Record was part of a mutation that resulted in an error.\n */\nvar ERROR_MASK = 0x02;\n/**\n * The subtree of data from this record contains partial data.\n */\nvar PARTIAL_MASK = 0x04;\n\nfunction set(status: ?number, value: boolean, mask: number): number {\n  status = status || 0;\n  if (value) {\n    return status | mask; // eslint-disable-line no-bitwise\n  } else {\n    return status & ~mask; // eslint-disable-line no-bitwise\n  }\n}\n\nfunction check(status: ?number, mask: number): boolean {\n  return ((status || 0) & mask) != 0; // eslint-disable-line no-bitwise\n}\n/**\n * A set of functions for modifying `__status__` on records inside of\n * RelayStore.\n */\nvar RelayRecordStatusMap = {\n  setOptimisticStatus: function(status: ?number, value: boolean): number {\n    return set(status, value, OPTIMISTIC_MASK);\n  },\n\n  isOptimisticStatus: function(status: ?number): boolean {\n    return check(status, OPTIMISTIC_MASK);\n  },\n\n  setErrorStatus: function(status: ?number, value: boolean): number {\n    return set(status, value, ERROR_MASK);\n  },\n\n  isErrorStatus: function(status: ?number): boolean {\n    return check(status, ERROR_MASK);\n  },\n\n  // Should only be used on records read out from RelayRecordStore\n  // by `readRelayQueryData`.\n  setPartialStatus: function(status: ?number, value: boolean): number {\n    return set(status, value, PARTIAL_MASK);\n  },\n\n  isPartialStatus: function(status: ?number): boolean {\n    return check(status, PARTIAL_MASK);\n  },\n};\n\nmodule.exports = RelayRecordStatusMap;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayRecordState.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayRecordState","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordState\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nexport type RecordState = $Keys<typeof RelayRecordState>;\n\nvar RelayRecordState = {\n  /**\n   * Record exists (either fetched from the server or produced by a local,\n   * optimistic update).\n   */\n  EXISTENT: 'EXISTENT',\n\n  /**\n   * Record is known not to exist (either as the result of a mutation, or\n   * because the server returned `null` when queried for the record).\n   */\n  NONEXISTENT: 'NONEXISTENT',\n\n  /**\n   * Record State is unknown because it has not yet been fetched from the\n   * server.\n   */\n  UNKNOWN: 'UNKNOWN',\n};\n\nmodule.exports = RelayRecordState;\n","dependencies":["RelayRecordState"],"id":"RelayRecordState","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecordState\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nexport type RecordState = $Keys<typeof RelayRecordState>;\n\nvar RelayRecordState = {\n  /**\n   * Record exists (either fetched from the server or produced by a local,\n   * optimistic update).\n   */\n  EXISTENT: 'EXISTENT',\n\n  /**\n   * Record is known not to exist (either as the result of a mutation, or\n   * because the server returned `null` when queried for the record).\n   */\n  NONEXISTENT: 'NONEXISTENT',\n\n  /**\n   * Record State is unknown because it has not yet been fetched from the\n   * server.\n   */\n  UNKNOWN: 'UNKNOWN',\n};\n\nmodule.exports = RelayRecordState;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayRecord.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayRecord","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecord\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type GraphQLRange from 'GraphQLRange';\nimport type {\n  Call,\n  ClientMutationID,\n  DataID,\n} from 'RelayInternalTypes';\nimport type RelayQueryPath from 'RelayQueryPath';\n\ntype FieldMap = {\n  [key: string]: mixed;\n};\n\nexport type Record = {\n  [key: string]: mixed;\n  __dataID__: string;\n  __filterCalls__?: Array<Call>;\n  __forceIndex__?: number;\n  __mutationIDs__?: Array<ClientMutationID>;\n  __path__?: RelayQueryPath;\n  __range__?: GraphQLRange;\n  __resolvedDeferredFragments__?: {[fragmentID: string]: boolean};\n  __resolvedFragmentMapGeneration__?: number;\n  __resolvedFragmentMap__?: {[fragmentID: string]: boolean};\n  __status__?: number;\n  __typename?: ?string;\n};\n\nexport type RecordMap = {[key: DataID]: ?Record};\n\nconst MetadataKey = {\n  DATA_ID: '__dataID__',\n  FILTER_CALLS: '__filterCalls__',\n  FORCE_INDEX: '__forceIndex__',\n  MUTATION_IDS: '__mutationIDs__',\n  PATH: '__path__',\n  RANGE: '__range__',\n  RESOLVED_DEFERRED_FRAGMENTS: '__resolvedDeferredFragments__',\n  RESOLVED_FRAGMENT_MAP: '__resolvedFragmentMap__',\n  RESOLVED_FRAGMENT_MAP_GENERATION: '__resolvedFragmentMapGeneration__',\n  STATUS: '__status__',\n};\n\nconst metadataKeyLookup = {};\nObject.keys(MetadataKey).forEach(name => {\n  metadataKeyLookup[MetadataKey[name]] = true;\n});\n\n/**\n * Records are plain objects with special metadata properties.\n */\nconst RelayRecord = {\n\n  MetadataKey,\n\n  create(dataID: string): Record {\n    return {__dataID__: dataID};\n  },\n\n  createWithFields(dataID: string, fieldMap: FieldMap): Record {\n    return {\n      __dataID__: dataID,\n      ...fieldMap,\n    };\n  },\n\n  isRecord(value: mixed): boolean {\n    return (\n      typeof value === 'object' &&\n      value != null &&\n      !Array.isArray(value) &&\n      typeof value.__dataID__ === 'string'\n    );\n  },\n\n  getDataID(record: Object): ?string {\n    return record.__dataID__;\n  },\n\n /**\n  * Checks whether the given ID was created on the client, as opposed to an ID\n  * that's understood by the server as well.\n  */\n  isClientID(dataID: string): boolean {\n    return dataID.substring(0, 7) === 'client:';\n  },\n\n  isMetadataKey(key: string): boolean {\n    return metadataKeyLookup.hasOwnProperty(key);\n  },\n};\n\nmodule.exports = RelayRecord;\n","dependencies":["GraphQLRange","RelayInternalTypes","RelayQueryPath","RelayRecord"],"id":"RelayRecord","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayRecord\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type GraphQLRange from 'GraphQLRange';\nimport type {\n  Call,\n  ClientMutationID,\n  DataID,\n} from 'RelayInternalTypes';\nimport type RelayQueryPath from 'RelayQueryPath';\n\ntype FieldMap = {\n  [key: string]: mixed;\n};\n\nexport type Record = {\n  [key: string]: mixed;\n  __dataID__: string;\n  __filterCalls__?: Array<Call>;\n  __forceIndex__?: number;\n  __mutationIDs__?: Array<ClientMutationID>;\n  __path__?: RelayQueryPath;\n  __range__?: GraphQLRange;\n  __resolvedDeferredFragments__?: {[fragmentID: string]: boolean};\n  __resolvedFragmentMapGeneration__?: number;\n  __resolvedFragmentMap__?: {[fragmentID: string]: boolean};\n  __status__?: number;\n  __typename?: ?string;\n};\n\nexport type RecordMap = {[key: DataID]: ?Record};\n\nconst MetadataKey = {\n  DATA_ID: '__dataID__',\n  FILTER_CALLS: '__filterCalls__',\n  FORCE_INDEX: '__forceIndex__',\n  MUTATION_IDS: '__mutationIDs__',\n  PATH: '__path__',\n  RANGE: '__range__',\n  RESOLVED_DEFERRED_FRAGMENTS: '__resolvedDeferredFragments__',\n  RESOLVED_FRAGMENT_MAP: '__resolvedFragmentMap__',\n  RESOLVED_FRAGMENT_MAP_GENERATION: '__resolvedFragmentMapGeneration__',\n  STATUS: '__status__',\n};\n\nconst metadataKeyLookup = {};\nObject.keys(MetadataKey).forEach(name => {\n  metadataKeyLookup[MetadataKey[name]] = true;\n});\n\n/**\n * Records are plain objects with special metadata properties.\n */\nconst RelayRecord = {\n\n  MetadataKey,\n\n  create(dataID: string): Record {\n    return {__dataID__: dataID};\n  },\n\n  createWithFields(dataID: string, fieldMap: FieldMap): Record {\n    return {\n      __dataID__: dataID,\n      ...fieldMap,\n    };\n  },\n\n  isRecord(value: mixed): boolean {\n    return (\n      typeof value === 'object' &&\n      value != null &&\n      !Array.isArray(value) &&\n      typeof value.__dataID__ === 'string'\n    );\n  },\n\n  getDataID(record: Object): ?string {\n    return record.__dataID__;\n  },\n\n /**\n  * Checks whether the given ID was created on the client, as opposed to an ID\n  * that's understood by the server as well.\n  */\n  isClientID(dataID: string): boolean {\n    return dataID.substring(0, 7) === 'client:';\n  },\n\n  isMetadataKey(key: string): boolean {\n    return metadataKeyLookup.hasOwnProperty(key);\n  },\n};\n\nmodule.exports = RelayRecord;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayReadyState.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayReadyState","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayReadyState\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {\n  ReadyState,\n  ReadyStateChangeCallback,\n} from 'RelayTypes';\n\nconst resolveImmediate = require('resolveImmediate');\nconst warning = require('warning');\n\ntype PartialReadyState = {\n  aborted?: boolean;\n  done?: boolean;\n  error?: Error;\n  ready?: boolean;\n  stale?: boolean;\n};\n\n/**\n * @internal\n */\nclass RelayReadyState {\n  _onReadyStateChange: ReadyStateChangeCallback;\n  _readyState: ReadyState;\n  _scheduled: boolean;\n\n  constructor(onReadyStateChange: ReadyStateChangeCallback) {\n    this._onReadyStateChange = onReadyStateChange;\n    this._readyState = {\n      aborted: false,\n      done: false,\n      error: null,\n      ready: false,\n      stale: false,\n    };\n    this._scheduled = false;\n  }\n\n  update(nextReadyState: PartialReadyState): void {\n    const prevReadyState = this._readyState;\n    if (prevReadyState.aborted) {\n      return;\n    }\n    if (prevReadyState.done || prevReadyState.error) {\n      if (!nextReadyState.aborted) {\n        warning(\n          false,\n          'RelayReadyState: Invalid state change from `%s` to `%s`.',\n          JSON.stringify(prevReadyState),\n          JSON.stringify(nextReadyState)\n        );\n      }\n      return;\n    }\n    this._readyState = {\n      ...prevReadyState,\n      ...nextReadyState,\n    };\n    if (this._scheduled) {\n      return;\n    }\n    this._scheduled = true;\n    resolveImmediate(() => {\n      this._scheduled = false;\n      this._onReadyStateChange(this._readyState);\n    });\n  }\n}\n\nmodule.exports = RelayReadyState;\n","dependencies":["RelayTypes","resolveImmediate","warning","RelayReadyState"],"id":"RelayReadyState","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayReadyState\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type {\n  ReadyState,\n  ReadyStateChangeCallback,\n} from 'RelayTypes';\n\nconst resolveImmediate = require('resolveImmediate');\nconst warning = require('warning');\n\ntype PartialReadyState = {\n  aborted?: boolean;\n  done?: boolean;\n  error?: Error;\n  ready?: boolean;\n  stale?: boolean;\n};\n\n/**\n * @internal\n */\nclass RelayReadyState {\n  _onReadyStateChange: ReadyStateChangeCallback;\n  _readyState: ReadyState;\n  _scheduled: boolean;\n\n  constructor(onReadyStateChange: ReadyStateChangeCallback) {\n    this._onReadyStateChange = onReadyStateChange;\n    this._readyState = {\n      aborted: false,\n      done: false,\n      error: null,\n      ready: false,\n      stale: false,\n    };\n    this._scheduled = false;\n  }\n\n  update(nextReadyState: PartialReadyState): void {\n    const prevReadyState = this._readyState;\n    if (prevReadyState.aborted) {\n      return;\n    }\n    if (prevReadyState.done || prevReadyState.error) {\n      if (!nextReadyState.aborted) {\n        warning(\n          false,\n          'RelayReadyState: Invalid state change from `%s` to `%s`.',\n          JSON.stringify(prevReadyState),\n          JSON.stringify(nextReadyState)\n        );\n      }\n      return;\n    }\n    this._readyState = {\n      ...prevReadyState,\n      ...nextReadyState,\n    };\n    if (this._scheduled) {\n      return;\n    }\n    this._scheduled = true;\n    resolveImmediate(() => {\n      this._scheduled = false;\n      this._onReadyStateChange(this._readyState);\n    });\n  }\n}\n\nmodule.exports = RelayReadyState;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayQueryWriter.js":{"metadata":{"mtime":1456300207000},"data":{"name":"RelayQueryWriter","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryWriter\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nimport type RelayChangeTracker from 'RelayChangeTracker';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayNodeInterface = require('RelayNodeInterface');\nimport type RelayQueryPath from 'RelayQueryPath';\nimport type RelayQueryTracker from 'RelayQueryTracker';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type RelayRecordWriter from 'RelayRecordWriter';\n\nconst generateClientEdgeID = require('generateClientEdgeID');\nconst generateClientID = require('generateClientID');\nconst invariant = require('invariant');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\nconst warning = require('warning');\n\nimport type {DataID} from 'RelayInternalTypes';\n\ntype WriterOptions = {\n  forceIndex?: ?number;\n  isOptimisticUpdate?: boolean;\n  updateTrackedQueries?: boolean;\n};\ntype WriterState = {\n  nodeID: ?DataID;\n  path: RelayQueryPath;\n  recordID: DataID;\n  responseData: ?mixed;\n};\n\nconst {ANY_TYPE, ID, TYPENAME} = RelayNodeInterface;\nconst {EDGES, NODE, PAGE_INFO} = RelayConnectionInterface;\nconst {EXISTENT} = RelayRecordState;\n\n/**\n * @internal\n *\n * Helper for writing the result of one or more queries/operations into the\n * store, updating tracked queries, and recording changed record IDs.\n */\nclass RelayQueryWriter extends RelayQueryVisitor<WriterState> {\n  _changeTracker: RelayChangeTracker;\n  _forceIndex: number;\n  _isOptimisticUpdate: boolean;\n  _store: RelayRecordStore;\n  _queryTracker: RelayQueryTracker;\n  _updateTrackedQueries: boolean;\n  _writer: RelayRecordWriter;\n\n  constructor(\n    store: RelayRecordStore,\n    writer: RelayRecordWriter,\n    queryTracker: RelayQueryTracker,\n    changeTracker: RelayChangeTracker,\n    options?: WriterOptions\n  ) {\n    super();\n    this._changeTracker = changeTracker;\n    this._forceIndex = options && options.forceIndex ? options.forceIndex : 0;\n    this._isOptimisticUpdate = !!(options && options.isOptimisticUpdate);\n    this._store = store;\n    this._queryTracker = queryTracker;\n    this._updateTrackedQueries = !!(options && options.updateTrackedQueries);\n    this._writer = writer;\n  }\n\n  getRecordStore(): RelayRecordStore {\n    return this._store;\n  }\n\n  getRecordWriter(): RelayRecordWriter {\n    return this._writer;\n  }\n\n  getRecordTypeName(\n    node: RelayQuery.Node,\n    recordID: DataID,\n    payload: Object\n  ): ?string {\n    if (this._isOptimisticUpdate) {\n      // Optimistic queries are inferred and fields have a generic 'any' type.\n      return null;\n    }\n    let typeName = payload[TYPENAME];\n    if (typeName == null) {\n      if (!node.isAbstract()) {\n        typeName = node.getType();\n      } else {\n        typeName = this._store.getType(recordID);\n      }\n    }\n    warning(\n      typeName && typeName !== ANY_TYPE,\n      'RelayQueryWriter: Could not find a type name for record `%s`.',\n      recordID\n    );\n    return typeName || null;\n  }\n\n  /**\n   * Traverses a query and payload in parallel, writing the results into the\n   * store.\n   */\n  writePayload(\n    node: RelayQuery.Node,\n    recordID: DataID,\n    responseData: mixed,\n    path: RelayQueryPath\n  ): void {\n    const state = {\n      nodeID: null,\n      path,\n      recordID,\n      responseData,\n    };\n\n    if (node instanceof RelayQuery.Field && node.canHaveSubselections()) {\n      // for non-scalar fields, the recordID is the parent\n      node.getChildren().forEach(child => {\n        this.visit(child, state);\n      });\n      return;\n    }\n\n    this.visit(node, state);\n  }\n\n  /**\n   * Records are \"created\" whenever an entry did not previously exist for the\n   * `recordID`, including cases when a `recordID` is created with a null value.\n   */\n  recordCreate(\n    recordID: DataID\n  ): void {\n    this._changeTracker.createID(recordID);\n  }\n\n  /**\n   * Records are \"updated\" if any field changes (including being set to null).\n   * Updates are not recorded for newly created records.\n   */\n  recordUpdate(\n    recordID: DataID\n  ): void {\n    this._changeTracker.updateID(recordID);\n  }\n\n  /**\n   * Determine if the record was created or updated by this write operation.\n   */\n  hasChangeToRecord(recordID: DataID): boolean {\n    return this._changeTracker.hasChange(recordID);\n  }\n\n  /**\n   * Determine if the record was created by this write operation.\n   */\n  isNewRecord(recordID: DataID): boolean {\n    return this._changeTracker.isNewRecord(recordID);\n  }\n\n  /**\n   * Helper to create a record and the corresponding notification.\n   */\n  createRecordIfMissing(\n    node: RelayQuery.Node,\n    recordID: DataID,\n    path: RelayQueryPath,\n    payload: ?Object\n  ): void {\n    const recordState = this._store.getRecordState(recordID);\n    const typeName = payload && this.getRecordTypeName(node, recordID, payload);\n    this._writer.putRecord(recordID, typeName, path);\n    if (recordState !== EXISTENT) {\n      this.recordCreate(recordID);\n    }\n    if (this.isNewRecord(recordID) || this._updateTrackedQueries) {\n      this._queryTracker.trackNodeForID(node, recordID, path);\n    }\n  }\n\n  visitRoot(\n    root: RelayQuery.Root,\n    state: WriterState\n  ): void {\n    const {path, recordID, responseData} = state;\n    const recordState = this._store.getRecordState(recordID);\n\n    // GraphQL should never return undefined for a field\n    if (responseData == null) {\n      invariant(\n        responseData !== undefined,\n        'RelayQueryWriter: Unexpectedly encountered `undefined` in payload. ' +\n        'Cannot set root record `%s` to undefined.',\n        recordID\n      );\n      this._writer.deleteRecord(recordID);\n      if (recordState === EXISTENT) {\n        this.recordUpdate(recordID);\n      }\n      return;\n    }\n    invariant(\n      typeof responseData === 'object' && responseData !== null,\n      'RelayQueryWriter: Cannot update record `%s`, expected response to be ' +\n      'an array or object.',\n      recordID\n    );\n    this.createRecordIfMissing(root, recordID, path, responseData);\n    this.traverse(root, state);\n  }\n\n  visitFragment(\n    fragment: RelayQuery.Fragment,\n    state: WriterState\n  ): void {\n    const {recordID} = state;\n    if (fragment.isDeferred()) {\n      this._writer.setHasDeferredFragmentData(\n        recordID,\n        fragment.getCompositeHash()\n      );\n      this.recordUpdate(recordID);\n    }\n    // Skip fragments that do not match the record's concrete type. Fragments\n    // cannot be skipped for optimistic writes because optimistically created\n    // records *may* have a default `Node` type.\n    if (\n      this._isOptimisticUpdate ||\n      isCompatibleRelayFragmentType(fragment, this._store.getType(recordID))\n    ) {\n      const path = state.path.getPath(fragment, recordID);\n      this.traverse(fragment, {\n        ...state,\n        path,\n      });\n    }\n  }\n\n  visitField(\n    field: RelayQuery.Field,\n    state: WriterState\n  ): void {\n    const {\n      recordID,\n      responseData,\n    } = state;\n    invariant(\n      this._writer.getRecordState(recordID) === EXISTENT,\n      'RelayQueryWriter: Cannot update a non-existent record, `%s`.',\n      recordID\n    );\n    invariant(\n      typeof responseData === 'object' && responseData !== null,\n      'RelayQueryWriter: Cannot update record `%s`, expected response to be ' +\n      'an object.',\n      recordID\n    );\n\n    // handle missing data\n    const fieldData = responseData[field.getSerializationKey()];\n    if (fieldData === undefined) {\n      return;\n    }\n    if (fieldData === null) {\n      this._writer.deleteField(recordID, field.getStorageKey());\n      this.recordUpdate(recordID);\n      return;\n    }\n\n    if (!field.canHaveSubselections()) {\n      this._writeScalar(field, state, recordID, fieldData);\n    } else if (field.isConnection()) {\n      this._writeConnection(field, state, recordID, fieldData);\n    } else if (field.isPlural()) {\n      this._writePluralLink(field, state, recordID, fieldData);\n    } else {\n      this._writeLink(field, state, recordID, fieldData);\n    }\n  }\n\n  /**\n   * Writes the value for a 'scalar' field such as `id` or `name`. The response\n   * data is expected to be scalar values or arrays of scalar values.\n   */\n  _writeScalar(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    nextValue: mixed\n  ): void {\n    const storageKey = field.getStorageKey();\n    const prevValue = this._store.getField(recordID, storageKey);\n\n    // always update the store to ensure the value is present in the appropriate\n    // data sink (records/queuedRecords), but only record an update if the value\n    // changed.\n    this._writer.putField(recordID, storageKey, nextValue);\n\n    // TODO: Flow: `nextValue` is an array, array indexing should work\n    if (\n      Array.isArray(prevValue) &&\n      Array.isArray(nextValue) &&\n      prevValue.length === nextValue.length &&\n      prevValue.every((prev, ii) => prev === (nextValue: any)[ii])\n    ) {\n      return;\n    } else if (prevValue === nextValue) {\n      return;\n    }\n    this.recordUpdate(recordID);\n  }\n\n  /**\n   * Writes data for connection fields such as `news_feed` or `friends`. The\n   * response data is expected to be array of edge objects.\n   */\n  _writeConnection(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    connectionData: mixed\n  ): void {\n    // Each unique combination of filter calls is stored in its own\n    // generated record (ex: `field.orderby(x)` results are separate from\n    // `field.orderby(y)` results).\n    const storageKey = field.getStorageKey();\n    const connectionID =\n      this._store.getLinkedRecordID(recordID, storageKey) ||\n      generateClientID();\n\n    const connectionRecordState = this._store.getRecordState(connectionID);\n    const hasEdges = !!(\n      field.getFieldByStorageKey(EDGES) ||\n      (\n        connectionData != null &&\n        typeof connectionData === 'object' &&\n        (connectionData: $FixMe)[EDGES]\n      )\n    );\n    const path = state.path.getPath(field, connectionID);\n    // always update the store to ensure the value is present in the appropriate\n    // data sink (records/queuedRecords), but only record an update if the value\n    // changed.\n    this._writer.putRecord(connectionID, null, path);\n    this._writer.putLinkedRecordID(recordID, storageKey, connectionID);\n    // record the create/update only if something changed\n    if (connectionRecordState !== EXISTENT) {\n      this.recordUpdate(recordID);\n      this.recordCreate(connectionID);\n    }\n    if (this.isNewRecord(connectionID) || this._updateTrackedQueries) {\n      this._queryTracker.trackNodeForID(field, connectionID, path);\n    }\n\n    // Only create a range if `edges` field is present\n    // Overwrite an existing range only if the new force index is greater\n    if (hasEdges &&\n        (!this._store.hasRange(connectionID) ||\n         (this._forceIndex &&\n          this._forceIndex > this._store.getRangeForceIndex(connectionID)))) {\n      this._writer.putRange(\n        connectionID,\n        field.getCallsWithValues(),\n        this._forceIndex\n      );\n      this.recordUpdate(connectionID);\n    }\n\n    const connectionState = {\n      nodeID: null,\n      path,\n      recordID: connectionID,\n      responseData: connectionData,\n    };\n    this._traverseConnection(field, field, connectionState);\n  }\n\n  /**\n   * Recurse through connection subfields and write their results. This is\n   * necessary because handling an `edges` field also requires information about\n   * the parent connection field (see `_writeEdges`).\n   */\n  _traverseConnection(\n    connection: RelayQuery.Field, // the parent connection\n    node: RelayQuery.Node, // the parent connection or an intermediary fragment\n    state: WriterState\n  ): void {\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Field) {\n        if (child.getSchemaName() === EDGES) {\n          this._writeEdges(connection, child, state);\n        } else if (child.getSchemaName() !== PAGE_INFO) {\n          // Page info is handled by the range\n          // Otherwise, write metadata fields normally (ex: `count`)\n          this.visit(child, state);\n        }\n      } else {\n        // Fragment case, recurse keeping track of parent connection\n        this._traverseConnection(connection, child, state);\n      }\n    });\n  }\n\n  /**\n   * Update a connection with newly fetched edges.\n   */\n  _writeEdges(\n    connection: RelayQuery.Field,\n    edges: RelayQuery.Field,\n    state: WriterState\n  ): void {\n    const {\n      recordID: connectionID,\n      responseData: connectionData,\n    } = state;\n    invariant(\n      typeof connectionData === 'object' && connectionData !== null,\n      'RelayQueryWriter: Cannot write edges for malformed connection `%s` on ' +\n      'record `%s`, expected the response to be an object.',\n      connection.getDebugName(),\n      connectionID\n    );\n    const edgesData = connectionData[EDGES];\n\n    // Validate response data.\n    if (edgesData == null) {\n      warning(\n        false,\n        'RelayQueryWriter: Cannot write edges for connection `%s` on record ' +\n        '`%s`, expected a response for field `edges`.',\n        connection.getDebugName(),\n        connectionID\n      );\n      return;\n    }\n    invariant(\n      Array.isArray(edgesData),\n      'RelayQueryWriter: Cannot write edges for connection `%s` on record ' +\n      '`%s`, expected `edges` to be an array.',\n      connection.getDebugName(),\n      connectionID\n    );\n\n    const rangeCalls = connection.getCallsWithValues();\n    invariant(\n      RelayConnectionInterface.hasRangeCalls(rangeCalls),\n      'RelayQueryWriter: Cannot write edges for connection `%s` on record ' +\n      '`%s` without `first`, `last`, or `find` argument.',\n      connection.getDebugName(),\n      connectionID\n    );\n    const rangeInfo = this._store.getRangeMetadata(\n      connectionID,\n      rangeCalls\n    );\n    invariant(\n      rangeInfo,\n      'RelayQueryWriter: Expected a range to exist for connection field `%s` ' +\n      'on record `%s`.',\n      connection.getDebugName(),\n      connectionID\n    );\n    const fetchedEdgeIDs = [];\n    const filteredEdges = rangeInfo.filteredEdges;\n    let isUpdate = false;\n    let nextIndex = 0;\n    // Traverse connection edges, reusing existing edges if they exist\n    edgesData.forEach(edgeData => {\n      // validate response data\n      if (edgeData == null) {\n        return;\n      }\n      invariant(\n        typeof edgeData === 'object' && edgeData,\n        'RelayQueryWriter: Cannot write edge for connection field `%s` on ' +\n        'record `%s`, expected an object.',\n        connection.getDebugName(),\n        connectionID\n      );\n\n      const nodeData = edgeData[NODE];\n      if (nodeData == null) {\n        return;\n      }\n\n      invariant(\n        typeof nodeData === 'object',\n        'RelayQueryWriter: Expected node to be an object for field `%s` on ' +\n        'record `%s`.',\n        connection.getDebugName(),\n        connectionID\n      );\n\n      // For consistency, edge IDs are calculated from the connection & node ID.\n      // A node ID is only generated if the node does not have an id and\n      // there is no existing edge.\n      const prevEdge = filteredEdges[nextIndex++];\n      const nodeID = (\n        (nodeData && nodeData[ID]) ||\n        (prevEdge && this._store.getLinkedRecordID(prevEdge.edgeID, NODE)) ||\n        generateClientID()\n      );\n      // TODO: Flow: `nodeID` is `string`\n      const edgeID = generateClientEdgeID(connectionID, nodeID);\n      const path = state.path.getPath(edges, edgeID);\n      this.createRecordIfMissing(edges, edgeID, path, null);\n      fetchedEdgeIDs.push(edgeID);\n\n      // Write data for the edge, using `nodeID` as the id for direct descendant\n      // `node` fields. This is necessary for `node`s that do not have an `id`,\n      // which would cause the generated ID here to not match the ID generated\n      // in `_writeLink`.\n      this.traverse(edges, {\n        nodeID,\n        path,\n        recordID: edgeID,\n        responseData: edgeData,\n      });\n      isUpdate = isUpdate || this.hasChangeToRecord(edgeID);\n    });\n\n    const pageInfo = connectionData[PAGE_INFO] ||\n      RelayConnectionInterface.getDefaultPageInfo();\n    this._writer.putRangeEdges(\n      connectionID,\n      rangeCalls,\n      pageInfo,\n      fetchedEdgeIDs\n    );\n\n    // Only broadcast an update to the range if an edge was added/changed.\n    // Node-level changes will broadcast at the node ID.\n    if (isUpdate) {\n      this.recordUpdate(connectionID);\n    }\n  }\n\n  /**\n   * Writes a plural linked field such as `actors`. The response data is\n   * expected to be an array of item objects. These fields are similar to\n   * connections, but do not support range calls such as `first` or `after`.\n   */\n  _writePluralLink(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    fieldData: mixed\n  ): void {\n    const storageKey = field.getStorageKey();\n    invariant(\n      Array.isArray(fieldData),\n      'RelayQueryWriter: Expected array data for field `%s` on record `%s`.',\n      field.getDebugName(),\n      recordID\n    );\n\n    const prevLinkedIDs = this._store.getLinkedRecordIDs(recordID, storageKey);\n    const nextLinkedIDs = [];\n    let isUpdate = !prevLinkedIDs;\n    let nextIndex = 0;\n    fieldData.forEach(nextRecord => {\n      // validate response data\n      if (nextRecord == null) {\n        return;\n      }\n      invariant(\n        typeof nextRecord === 'object' && nextRecord,\n        'RelayQueryWriter: Expected elements for plural field `%s` to be ' +\n        'objects.',\n        storageKey\n      );\n\n      // Reuse existing generated IDs if the node does not have its own `id`.\n      const prevLinkedID = prevLinkedIDs && prevLinkedIDs[nextIndex];\n      const nextLinkedID = (\n        nextRecord[ID] ||\n        prevLinkedID ||\n        generateClientID()\n      );\n      nextLinkedIDs.push(nextLinkedID);\n\n      const path = state.path.getPath(field, nextLinkedID);\n      this.createRecordIfMissing(field, nextLinkedID, path, nextRecord);\n      isUpdate = (\n        isUpdate ||\n        nextLinkedID !== prevLinkedID ||\n        this.isNewRecord(nextLinkedID)\n      );\n\n      this.traverse(field, {\n        nodeID: null, // never propagate `nodeID` past the first linked field\n        path,\n        recordID: nextLinkedID,\n        responseData: nextRecord,\n      });\n      isUpdate = isUpdate || this.hasChangeToRecord(nextLinkedID);\n      nextIndex++;\n    });\n\n    this._writer.putLinkedRecordIDs(recordID, storageKey, nextLinkedIDs);\n\n    // Check if length has changed\n    isUpdate = (\n      isUpdate ||\n      !prevLinkedIDs ||\n      prevLinkedIDs.length !== nextLinkedIDs.length\n    );\n\n    // Only broadcast a list-level change if a record was changed/added\n    if (isUpdate) {\n      this.recordUpdate(recordID);\n    }\n  }\n\n  /**\n   * Writes a link from one record to another, for example linking the `viewer`\n   * record to the `actor` record in the query `viewer { actor }`. The `field`\n   * variable is the field being linked (`actor` in the example).\n   */\n  _writeLink(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    fieldData: mixed\n  ): void {\n    const {nodeID} = state;\n    const storageKey = field.getStorageKey();\n    invariant(\n      typeof fieldData === 'object' && fieldData !== null,\n      'RelayQueryWriter: Expected data for non-scalar field `%s` on record ' +\n      '`%s` to be an object.',\n      field.getDebugName(),\n      recordID\n    );\n\n    // Prefer the actual `id` if present, otherwise generate one (if an id\n    // was already generated it is reused). `node`s within a connection are\n    // a special case as the ID used here must match the one generated prior to\n    // storing the parent `edge`.\n    const prevLinkedID = this._store.getLinkedRecordID(recordID, storageKey);\n    const nextLinkedID = (\n      (field.getSchemaName() === NODE && nodeID) ||\n      fieldData[ID] ||\n      prevLinkedID ||\n      generateClientID()\n    );\n\n    const path = state.path.getPath(field, nextLinkedID);\n    this.createRecordIfMissing(field, nextLinkedID, path, fieldData);\n    // always update the store to ensure the value is present in the appropriate\n    // data sink (record/queuedRecords), but only record an update if the value\n    // changed.\n    this._writer.putLinkedRecordID(recordID, storageKey, nextLinkedID);\n    if (prevLinkedID !== nextLinkedID || this.isNewRecord(nextLinkedID)) {\n      this.recordUpdate(recordID);\n    }\n\n    this.traverse(field, {\n      nodeID: null,\n      path,\n      recordID: nextLinkedID,\n      responseData: fieldData,\n    });\n  }\n}\n\nmodule.exports = RelayQueryWriter;\n","dependencies":["RelayChangeTracker","RelayQueryPath","RelayQueryTracker","RelayRecordStore","RelayRecordWriter","RelayInternalTypes","RelayQuery","RelayConnectionInterface","RelayNodeInterface","RelayQueryVisitor","RelayRecordState","generateClientEdgeID","generateClientID","invariant","isCompatibleRelayFragmentType","warning","RelayQueryWriter"],"id":"RelayQueryWriter","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryWriter\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nimport type RelayChangeTracker from 'RelayChangeTracker';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayNodeInterface = require('RelayNodeInterface');\nimport type RelayQueryPath from 'RelayQueryPath';\nimport type RelayQueryTracker from 'RelayQueryTracker';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type RelayRecordWriter from 'RelayRecordWriter';\n\nconst generateClientEdgeID = require('generateClientEdgeID');\nconst generateClientID = require('generateClientID');\nconst invariant = require('invariant');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\nconst warning = require('warning');\n\nimport type {DataID} from 'RelayInternalTypes';\n\ntype WriterOptions = {\n  forceIndex?: ?number;\n  isOptimisticUpdate?: boolean;\n  updateTrackedQueries?: boolean;\n};\ntype WriterState = {\n  nodeID: ?DataID;\n  path: RelayQueryPath;\n  recordID: DataID;\n  responseData: ?mixed;\n};\n\nconst {ANY_TYPE, ID, TYPENAME} = RelayNodeInterface;\nconst {EDGES, NODE, PAGE_INFO} = RelayConnectionInterface;\nconst {EXISTENT} = RelayRecordState;\n\n/**\n * @internal\n *\n * Helper for writing the result of one or more queries/operations into the\n * store, updating tracked queries, and recording changed record IDs.\n */\nclass RelayQueryWriter extends RelayQueryVisitor<WriterState> {\n  _changeTracker: RelayChangeTracker;\n  _forceIndex: number;\n  _isOptimisticUpdate: boolean;\n  _store: RelayRecordStore;\n  _queryTracker: RelayQueryTracker;\n  _updateTrackedQueries: boolean;\n  _writer: RelayRecordWriter;\n\n  constructor(\n    store: RelayRecordStore,\n    writer: RelayRecordWriter,\n    queryTracker: RelayQueryTracker,\n    changeTracker: RelayChangeTracker,\n    options?: WriterOptions\n  ) {\n    super();\n    this._changeTracker = changeTracker;\n    this._forceIndex = options && options.forceIndex ? options.forceIndex : 0;\n    this._isOptimisticUpdate = !!(options && options.isOptimisticUpdate);\n    this._store = store;\n    this._queryTracker = queryTracker;\n    this._updateTrackedQueries = !!(options && options.updateTrackedQueries);\n    this._writer = writer;\n  }\n\n  getRecordStore(): RelayRecordStore {\n    return this._store;\n  }\n\n  getRecordWriter(): RelayRecordWriter {\n    return this._writer;\n  }\n\n  getRecordTypeName(\n    node: RelayQuery.Node,\n    recordID: DataID,\n    payload: Object\n  ): ?string {\n    if (this._isOptimisticUpdate) {\n      // Optimistic queries are inferred and fields have a generic 'any' type.\n      return null;\n    }\n    let typeName = payload[TYPENAME];\n    if (typeName == null) {\n      if (!node.isAbstract()) {\n        typeName = node.getType();\n      } else {\n        typeName = this._store.getType(recordID);\n      }\n    }\n    warning(\n      typeName && typeName !== ANY_TYPE,\n      'RelayQueryWriter: Could not find a type name for record `%s`.',\n      recordID\n    );\n    return typeName || null;\n  }\n\n  /**\n   * Traverses a query and payload in parallel, writing the results into the\n   * store.\n   */\n  writePayload(\n    node: RelayQuery.Node,\n    recordID: DataID,\n    responseData: mixed,\n    path: RelayQueryPath\n  ): void {\n    const state = {\n      nodeID: null,\n      path,\n      recordID,\n      responseData,\n    };\n\n    if (node instanceof RelayQuery.Field && node.canHaveSubselections()) {\n      // for non-scalar fields, the recordID is the parent\n      node.getChildren().forEach(child => {\n        this.visit(child, state);\n      });\n      return;\n    }\n\n    this.visit(node, state);\n  }\n\n  /**\n   * Records are \"created\" whenever an entry did not previously exist for the\n   * `recordID`, including cases when a `recordID` is created with a null value.\n   */\n  recordCreate(\n    recordID: DataID\n  ): void {\n    this._changeTracker.createID(recordID);\n  }\n\n  /**\n   * Records are \"updated\" if any field changes (including being set to null).\n   * Updates are not recorded for newly created records.\n   */\n  recordUpdate(\n    recordID: DataID\n  ): void {\n    this._changeTracker.updateID(recordID);\n  }\n\n  /**\n   * Determine if the record was created or updated by this write operation.\n   */\n  hasChangeToRecord(recordID: DataID): boolean {\n    return this._changeTracker.hasChange(recordID);\n  }\n\n  /**\n   * Determine if the record was created by this write operation.\n   */\n  isNewRecord(recordID: DataID): boolean {\n    return this._changeTracker.isNewRecord(recordID);\n  }\n\n  /**\n   * Helper to create a record and the corresponding notification.\n   */\n  createRecordIfMissing(\n    node: RelayQuery.Node,\n    recordID: DataID,\n    path: RelayQueryPath,\n    payload: ?Object\n  ): void {\n    const recordState = this._store.getRecordState(recordID);\n    const typeName = payload && this.getRecordTypeName(node, recordID, payload);\n    this._writer.putRecord(recordID, typeName, path);\n    if (recordState !== EXISTENT) {\n      this.recordCreate(recordID);\n    }\n    if (this.isNewRecord(recordID) || this._updateTrackedQueries) {\n      this._queryTracker.trackNodeForID(node, recordID, path);\n    }\n  }\n\n  visitRoot(\n    root: RelayQuery.Root,\n    state: WriterState\n  ): void {\n    const {path, recordID, responseData} = state;\n    const recordState = this._store.getRecordState(recordID);\n\n    // GraphQL should never return undefined for a field\n    if (responseData == null) {\n      invariant(\n        responseData !== undefined,\n        'RelayQueryWriter: Unexpectedly encountered `undefined` in payload. ' +\n        'Cannot set root record `%s` to undefined.',\n        recordID\n      );\n      this._writer.deleteRecord(recordID);\n      if (recordState === EXISTENT) {\n        this.recordUpdate(recordID);\n      }\n      return;\n    }\n    invariant(\n      typeof responseData === 'object' && responseData !== null,\n      'RelayQueryWriter: Cannot update record `%s`, expected response to be ' +\n      'an array or object.',\n      recordID\n    );\n    this.createRecordIfMissing(root, recordID, path, responseData);\n    this.traverse(root, state);\n  }\n\n  visitFragment(\n    fragment: RelayQuery.Fragment,\n    state: WriterState\n  ): void {\n    const {recordID} = state;\n    if (fragment.isDeferred()) {\n      this._writer.setHasDeferredFragmentData(\n        recordID,\n        fragment.getCompositeHash()\n      );\n      this.recordUpdate(recordID);\n    }\n    // Skip fragments that do not match the record's concrete type. Fragments\n    // cannot be skipped for optimistic writes because optimistically created\n    // records *may* have a default `Node` type.\n    if (\n      this._isOptimisticUpdate ||\n      isCompatibleRelayFragmentType(fragment, this._store.getType(recordID))\n    ) {\n      const path = state.path.getPath(fragment, recordID);\n      this.traverse(fragment, {\n        ...state,\n        path,\n      });\n    }\n  }\n\n  visitField(\n    field: RelayQuery.Field,\n    state: WriterState\n  ): void {\n    const {\n      recordID,\n      responseData,\n    } = state;\n    invariant(\n      this._writer.getRecordState(recordID) === EXISTENT,\n      'RelayQueryWriter: Cannot update a non-existent record, `%s`.',\n      recordID\n    );\n    invariant(\n      typeof responseData === 'object' && responseData !== null,\n      'RelayQueryWriter: Cannot update record `%s`, expected response to be ' +\n      'an object.',\n      recordID\n    );\n\n    // handle missing data\n    const fieldData = responseData[field.getSerializationKey()];\n    if (fieldData === undefined) {\n      return;\n    }\n    if (fieldData === null) {\n      this._writer.deleteField(recordID, field.getStorageKey());\n      this.recordUpdate(recordID);\n      return;\n    }\n\n    if (!field.canHaveSubselections()) {\n      this._writeScalar(field, state, recordID, fieldData);\n    } else if (field.isConnection()) {\n      this._writeConnection(field, state, recordID, fieldData);\n    } else if (field.isPlural()) {\n      this._writePluralLink(field, state, recordID, fieldData);\n    } else {\n      this._writeLink(field, state, recordID, fieldData);\n    }\n  }\n\n  /**\n   * Writes the value for a 'scalar' field such as `id` or `name`. The response\n   * data is expected to be scalar values or arrays of scalar values.\n   */\n  _writeScalar(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    nextValue: mixed\n  ): void {\n    const storageKey = field.getStorageKey();\n    const prevValue = this._store.getField(recordID, storageKey);\n\n    // always update the store to ensure the value is present in the appropriate\n    // data sink (records/queuedRecords), but only record an update if the value\n    // changed.\n    this._writer.putField(recordID, storageKey, nextValue);\n\n    // TODO: Flow: `nextValue` is an array, array indexing should work\n    if (\n      Array.isArray(prevValue) &&\n      Array.isArray(nextValue) &&\n      prevValue.length === nextValue.length &&\n      prevValue.every((prev, ii) => prev === (nextValue: any)[ii])\n    ) {\n      return;\n    } else if (prevValue === nextValue) {\n      return;\n    }\n    this.recordUpdate(recordID);\n  }\n\n  /**\n   * Writes data for connection fields such as `news_feed` or `friends`. The\n   * response data is expected to be array of edge objects.\n   */\n  _writeConnection(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    connectionData: mixed\n  ): void {\n    // Each unique combination of filter calls is stored in its own\n    // generated record (ex: `field.orderby(x)` results are separate from\n    // `field.orderby(y)` results).\n    const storageKey = field.getStorageKey();\n    const connectionID =\n      this._store.getLinkedRecordID(recordID, storageKey) ||\n      generateClientID();\n\n    const connectionRecordState = this._store.getRecordState(connectionID);\n    const hasEdges = !!(\n      field.getFieldByStorageKey(EDGES) ||\n      (\n        connectionData != null &&\n        typeof connectionData === 'object' &&\n        (connectionData: $FixMe)[EDGES]\n      )\n    );\n    const path = state.path.getPath(field, connectionID);\n    // always update the store to ensure the value is present in the appropriate\n    // data sink (records/queuedRecords), but only record an update if the value\n    // changed.\n    this._writer.putRecord(connectionID, null, path);\n    this._writer.putLinkedRecordID(recordID, storageKey, connectionID);\n    // record the create/update only if something changed\n    if (connectionRecordState !== EXISTENT) {\n      this.recordUpdate(recordID);\n      this.recordCreate(connectionID);\n    }\n    if (this.isNewRecord(connectionID) || this._updateTrackedQueries) {\n      this._queryTracker.trackNodeForID(field, connectionID, path);\n    }\n\n    // Only create a range if `edges` field is present\n    // Overwrite an existing range only if the new force index is greater\n    if (hasEdges &&\n        (!this._store.hasRange(connectionID) ||\n         (this._forceIndex &&\n          this._forceIndex > this._store.getRangeForceIndex(connectionID)))) {\n      this._writer.putRange(\n        connectionID,\n        field.getCallsWithValues(),\n        this._forceIndex\n      );\n      this.recordUpdate(connectionID);\n    }\n\n    const connectionState = {\n      nodeID: null,\n      path,\n      recordID: connectionID,\n      responseData: connectionData,\n    };\n    this._traverseConnection(field, field, connectionState);\n  }\n\n  /**\n   * Recurse through connection subfields and write their results. This is\n   * necessary because handling an `edges` field also requires information about\n   * the parent connection field (see `_writeEdges`).\n   */\n  _traverseConnection(\n    connection: RelayQuery.Field, // the parent connection\n    node: RelayQuery.Node, // the parent connection or an intermediary fragment\n    state: WriterState\n  ): void {\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Field) {\n        if (child.getSchemaName() === EDGES) {\n          this._writeEdges(connection, child, state);\n        } else if (child.getSchemaName() !== PAGE_INFO) {\n          // Page info is handled by the range\n          // Otherwise, write metadata fields normally (ex: `count`)\n          this.visit(child, state);\n        }\n      } else {\n        // Fragment case, recurse keeping track of parent connection\n        this._traverseConnection(connection, child, state);\n      }\n    });\n  }\n\n  /**\n   * Update a connection with newly fetched edges.\n   */\n  _writeEdges(\n    connection: RelayQuery.Field,\n    edges: RelayQuery.Field,\n    state: WriterState\n  ): void {\n    const {\n      recordID: connectionID,\n      responseData: connectionData,\n    } = state;\n    invariant(\n      typeof connectionData === 'object' && connectionData !== null,\n      'RelayQueryWriter: Cannot write edges for malformed connection `%s` on ' +\n      'record `%s`, expected the response to be an object.',\n      connection.getDebugName(),\n      connectionID\n    );\n    const edgesData = connectionData[EDGES];\n\n    // Validate response data.\n    if (edgesData == null) {\n      warning(\n        false,\n        'RelayQueryWriter: Cannot write edges for connection `%s` on record ' +\n        '`%s`, expected a response for field `edges`.',\n        connection.getDebugName(),\n        connectionID\n      );\n      return;\n    }\n    invariant(\n      Array.isArray(edgesData),\n      'RelayQueryWriter: Cannot write edges for connection `%s` on record ' +\n      '`%s`, expected `edges` to be an array.',\n      connection.getDebugName(),\n      connectionID\n    );\n\n    const rangeCalls = connection.getCallsWithValues();\n    invariant(\n      RelayConnectionInterface.hasRangeCalls(rangeCalls),\n      'RelayQueryWriter: Cannot write edges for connection `%s` on record ' +\n      '`%s` without `first`, `last`, or `find` argument.',\n      connection.getDebugName(),\n      connectionID\n    );\n    const rangeInfo = this._store.getRangeMetadata(\n      connectionID,\n      rangeCalls\n    );\n    invariant(\n      rangeInfo,\n      'RelayQueryWriter: Expected a range to exist for connection field `%s` ' +\n      'on record `%s`.',\n      connection.getDebugName(),\n      connectionID\n    );\n    const fetchedEdgeIDs = [];\n    const filteredEdges = rangeInfo.filteredEdges;\n    let isUpdate = false;\n    let nextIndex = 0;\n    // Traverse connection edges, reusing existing edges if they exist\n    edgesData.forEach(edgeData => {\n      // validate response data\n      if (edgeData == null) {\n        return;\n      }\n      invariant(\n        typeof edgeData === 'object' && edgeData,\n        'RelayQueryWriter: Cannot write edge for connection field `%s` on ' +\n        'record `%s`, expected an object.',\n        connection.getDebugName(),\n        connectionID\n      );\n\n      const nodeData = edgeData[NODE];\n      if (nodeData == null) {\n        return;\n      }\n\n      invariant(\n        typeof nodeData === 'object',\n        'RelayQueryWriter: Expected node to be an object for field `%s` on ' +\n        'record `%s`.',\n        connection.getDebugName(),\n        connectionID\n      );\n\n      // For consistency, edge IDs are calculated from the connection & node ID.\n      // A node ID is only generated if the node does not have an id and\n      // there is no existing edge.\n      const prevEdge = filteredEdges[nextIndex++];\n      const nodeID = (\n        (nodeData && nodeData[ID]) ||\n        (prevEdge && this._store.getLinkedRecordID(prevEdge.edgeID, NODE)) ||\n        generateClientID()\n      );\n      // TODO: Flow: `nodeID` is `string`\n      const edgeID = generateClientEdgeID(connectionID, nodeID);\n      const path = state.path.getPath(edges, edgeID);\n      this.createRecordIfMissing(edges, edgeID, path, null);\n      fetchedEdgeIDs.push(edgeID);\n\n      // Write data for the edge, using `nodeID` as the id for direct descendant\n      // `node` fields. This is necessary for `node`s that do not have an `id`,\n      // which would cause the generated ID here to not match the ID generated\n      // in `_writeLink`.\n      this.traverse(edges, {\n        nodeID,\n        path,\n        recordID: edgeID,\n        responseData: edgeData,\n      });\n      isUpdate = isUpdate || this.hasChangeToRecord(edgeID);\n    });\n\n    const pageInfo = connectionData[PAGE_INFO] ||\n      RelayConnectionInterface.getDefaultPageInfo();\n    this._writer.putRangeEdges(\n      connectionID,\n      rangeCalls,\n      pageInfo,\n      fetchedEdgeIDs\n    );\n\n    // Only broadcast an update to the range if an edge was added/changed.\n    // Node-level changes will broadcast at the node ID.\n    if (isUpdate) {\n      this.recordUpdate(connectionID);\n    }\n  }\n\n  /**\n   * Writes a plural linked field such as `actors`. The response data is\n   * expected to be an array of item objects. These fields are similar to\n   * connections, but do not support range calls such as `first` or `after`.\n   */\n  _writePluralLink(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    fieldData: mixed\n  ): void {\n    const storageKey = field.getStorageKey();\n    invariant(\n      Array.isArray(fieldData),\n      'RelayQueryWriter: Expected array data for field `%s` on record `%s`.',\n      field.getDebugName(),\n      recordID\n    );\n\n    const prevLinkedIDs = this._store.getLinkedRecordIDs(recordID, storageKey);\n    const nextLinkedIDs = [];\n    let isUpdate = !prevLinkedIDs;\n    let nextIndex = 0;\n    fieldData.forEach(nextRecord => {\n      // validate response data\n      if (nextRecord == null) {\n        return;\n      }\n      invariant(\n        typeof nextRecord === 'object' && nextRecord,\n        'RelayQueryWriter: Expected elements for plural field `%s` to be ' +\n        'objects.',\n        storageKey\n      );\n\n      // Reuse existing generated IDs if the node does not have its own `id`.\n      const prevLinkedID = prevLinkedIDs && prevLinkedIDs[nextIndex];\n      const nextLinkedID = (\n        nextRecord[ID] ||\n        prevLinkedID ||\n        generateClientID()\n      );\n      nextLinkedIDs.push(nextLinkedID);\n\n      const path = state.path.getPath(field, nextLinkedID);\n      this.createRecordIfMissing(field, nextLinkedID, path, nextRecord);\n      isUpdate = (\n        isUpdate ||\n        nextLinkedID !== prevLinkedID ||\n        this.isNewRecord(nextLinkedID)\n      );\n\n      this.traverse(field, {\n        nodeID: null, // never propagate `nodeID` past the first linked field\n        path,\n        recordID: nextLinkedID,\n        responseData: nextRecord,\n      });\n      isUpdate = isUpdate || this.hasChangeToRecord(nextLinkedID);\n      nextIndex++;\n    });\n\n    this._writer.putLinkedRecordIDs(recordID, storageKey, nextLinkedIDs);\n\n    // Check if length has changed\n    isUpdate = (\n      isUpdate ||\n      !prevLinkedIDs ||\n      prevLinkedIDs.length !== nextLinkedIDs.length\n    );\n\n    // Only broadcast a list-level change if a record was changed/added\n    if (isUpdate) {\n      this.recordUpdate(recordID);\n    }\n  }\n\n  /**\n   * Writes a link from one record to another, for example linking the `viewer`\n   * record to the `actor` record in the query `viewer { actor }`. The `field`\n   * variable is the field being linked (`actor` in the example).\n   */\n  _writeLink(\n    field: RelayQuery.Field,\n    state: WriterState,\n    recordID: DataID,\n    fieldData: mixed\n  ): void {\n    const {nodeID} = state;\n    const storageKey = field.getStorageKey();\n    invariant(\n      typeof fieldData === 'object' && fieldData !== null,\n      'RelayQueryWriter: Expected data for non-scalar field `%s` on record ' +\n      '`%s` to be an object.',\n      field.getDebugName(),\n      recordID\n    );\n\n    // Prefer the actual `id` if present, otherwise generate one (if an id\n    // was already generated it is reused). `node`s within a connection are\n    // a special case as the ID used here must match the one generated prior to\n    // storing the parent `edge`.\n    const prevLinkedID = this._store.getLinkedRecordID(recordID, storageKey);\n    const nextLinkedID = (\n      (field.getSchemaName() === NODE && nodeID) ||\n      fieldData[ID] ||\n      prevLinkedID ||\n      generateClientID()\n    );\n\n    const path = state.path.getPath(field, nextLinkedID);\n    this.createRecordIfMissing(field, nextLinkedID, path, fieldData);\n    // always update the store to ensure the value is present in the appropriate\n    // data sink (record/queuedRecords), but only record an update if the value\n    // changed.\n    this._writer.putLinkedRecordID(recordID, storageKey, nextLinkedID);\n    if (prevLinkedID !== nextLinkedID || this.isNewRecord(nextLinkedID)) {\n      this.recordUpdate(recordID);\n    }\n\n    this.traverse(field, {\n      nodeID: null,\n      path,\n      recordID: nextLinkedID,\n      responseData: fieldData,\n    });\n  }\n}\n\nmodule.exports = RelayQueryWriter;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayQueryTracker.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayQueryTracker","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryTracker\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayRecord = require('RelayRecord');\n\nconst invariant = require('invariant');\n\nconst TYPE = '__type__';\n\nclass RelayQueryTracker {\n  _trackedNodesByID: {[key: string]: {\n    isMerged: boolean;\n    trackedNodes: Array<RelayQuery.Node>;\n  }};\n\n  constructor() {\n    this._trackedNodesByID = {};\n  }\n\n  trackNodeForID(\n    node: RelayQuery.Node,\n    dataID: DataID,\n    path: ?RelayQueryPath\n  ): void {\n    // Non-refetchable nodes are tracked via their nearest-refetchable parent\n    // (except for root call nodes)\n    if (RelayRecord.isClientID(dataID)) {\n      invariant(\n        path,\n        'RelayQueryTracker.trackNodeForID(): Expected `path` for client ID, ' +\n        '`%s`.',\n        dataID\n      );\n      if (!path.isRootPath()) {\n        return;\n      }\n    }\n    // Don't track `__type__` fields\n    if (node instanceof RelayQuery.Field && node.getSchemaName() === TYPE) {\n      return;\n    }\n\n    this._trackedNodesByID[dataID] = this._trackedNodesByID[dataID] || {\n      trackedNodes: [],\n      isMerged: false,\n    };\n    this._trackedNodesByID[dataID].trackedNodes.push(node);\n    this._trackedNodesByID[dataID].isMerged = false;\n  }\n\n  /**\n   * Get the children that are tracked for the given `dataID`, if any.\n   */\n  getTrackedChildrenForID(\n    dataID: DataID\n  ): Array<RelayQuery.Node> {\n    const trackedNodesByID = this._trackedNodesByID[dataID];\n    if (!trackedNodesByID) {\n      return [];\n    }\n    const {isMerged, trackedNodes} = trackedNodesByID;\n    if (!isMerged) {\n      const trackedChildren = [];\n      trackedNodes.forEach(trackedQuery => {\n        trackedChildren.push(...trackedQuery.getChildren());\n      });\n      trackedNodes.length = 0;\n      trackedNodesByID.isMerged = true;\n      const containerNode = RelayQuery.Fragment.build(\n        'RelayQueryTracker',\n        RelayNodeInterface.NODE_TYPE,\n        trackedChildren\n      );\n      if (containerNode) {\n        trackedNodes.push(containerNode);\n      }\n    }\n    const trackedNode = trackedNodes[0];\n    if (trackedNode) {\n      return trackedNode.getChildren();\n    }\n    return [];\n  }\n\n  /**\n   * Removes all nodes that are tracking the given DataID from the\n   * query-tracker.\n   */\n  untrackNodesForID(\n    dataID: DataID\n  ): void {\n    delete this._trackedNodesByID[dataID];\n  }\n}\n\nmodule.exports = RelayQueryTracker;\n","dependencies":["RelayInternalTypes","RelayQueryPath","RelayNodeInterface","RelayQuery","RelayRecord","invariant"],"id":"RelayQueryTracker","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryTracker\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayRecord = require('RelayRecord');\n\nconst invariant = require('invariant');\n\nconst TYPE = '__type__';\n\nclass RelayQueryTracker {\n  _trackedNodesByID: {[key: string]: {\n    isMerged: boolean;\n    trackedNodes: Array<RelayQuery.Node>;\n  }};\n\n  constructor() {\n    this._trackedNodesByID = {};\n  }\n\n  trackNodeForID(\n    node: RelayQuery.Node,\n    dataID: DataID,\n    path: ?RelayQueryPath\n  ): void {\n    // Non-refetchable nodes are tracked via their nearest-refetchable parent\n    // (except for root call nodes)\n    if (RelayRecord.isClientID(dataID)) {\n      invariant(\n        path,\n        'RelayQueryTracker.trackNodeForID(): Expected `path` for client ID, ' +\n        '`%s`.',\n        dataID\n      );\n      if (!path.isRootPath()) {\n        return;\n      }\n    }\n    // Don't track `__type__` fields\n    if (node instanceof RelayQuery.Field && node.getSchemaName() === TYPE) {\n      return;\n    }\n\n    this._trackedNodesByID[dataID] = this._trackedNodesByID[dataID] || {\n      trackedNodes: [],\n      isMerged: false,\n    };\n    this._trackedNodesByID[dataID].trackedNodes.push(node);\n    this._trackedNodesByID[dataID].isMerged = false;\n  }\n\n  /**\n   * Get the children that are tracked for the given `dataID`, if any.\n   */\n  getTrackedChildrenForID(\n    dataID: DataID\n  ): Array<RelayQuery.Node> {\n    const trackedNodesByID = this._trackedNodesByID[dataID];\n    if (!trackedNodesByID) {\n      return [];\n    }\n    const {isMerged, trackedNodes} = trackedNodesByID;\n    if (!isMerged) {\n      const trackedChildren = [];\n      trackedNodes.forEach(trackedQuery => {\n        trackedChildren.push(...trackedQuery.getChildren());\n      });\n      trackedNodes.length = 0;\n      trackedNodesByID.isMerged = true;\n      const containerNode = RelayQuery.Fragment.build(\n        'RelayQueryTracker',\n        RelayNodeInterface.NODE_TYPE,\n        trackedChildren\n      );\n      if (containerNode) {\n        trackedNodes.push(containerNode);\n      }\n    }\n    const trackedNode = trackedNodes[0];\n    if (trackedNode) {\n      return trackedNode.getChildren();\n    }\n    return [];\n  }\n\n  /**\n   * Removes all nodes that are tracking the given DataID from the\n   * query-tracker.\n   */\n  untrackNodesForID(\n    dataID: DataID\n  ): void {\n    delete this._trackedNodesByID[dataID];\n  }\n}\n\nmodule.exports = RelayQueryTracker;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayQueryResultObservable.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayQueryResultObservable","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryResultObservable\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nimport type {DataID} from 'RelayInternalTypes';\nimport type RelayQuery from 'RelayQuery';\nimport type RelayStoreData from 'RelayStoreData';\nimport type {\n  StoreReaderData,\n  Subscription,\n  SubscriptionCallbacks,\n} from 'RelayTypes';\n\nconst invariant = require('invariant');\n\n/**\n * An Rx Observable representing the results of a fragment in the local cache.\n * Subscribers are notified as follows:\n *\n * `onNext`: Called with the latest results of a fragment. Results may be `null`\n * if the data was marked as deleted or `undefined` if the fragment was either\n * not fetched or evicted from the cache. Note that required fields may be\n * missing if the fragment was not fetched with `Relay.Store.primeCache` or\n * `Relay.Store.forceFetch` before creating a subscription.\n * - Called synchronously on `subscribe()`.\n * - Called whenever the results of the fragment change.\n *\n * `onError`: Currently not called. In the future this may be used to indicate\n * that required data for the fragment has not been fetched or was evicted\n * from the cache.\n *\n * `onCompleted`: Not called.\n *\n * @see http://reactivex.io/documentation/observable.html\n */\nclass RelayQueryResultObservable {\n  _data: ?StoreReaderData;\n  _dataID: DataID;\n  _fragment: RelayQuery.Fragment;\n  _fragmentResolver: ?GraphQLStoreQueryResolver;\n  _storeData: RelayStoreData;\n  _subscriptionCallbacks: Array<SubscriptionCallbacks<?StoreReaderData>>;\n  _subscriptionCount: number;\n\n  constructor(\n    storeData: RelayStoreData,\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ) {\n    this._data = undefined;\n    this._dataID = dataID;\n    this._fragment = fragment;\n    this._fragmentResolver = null;\n    this._storeData = storeData;\n    this._subscriptionCallbacks = [];\n    this._subscriptionCount = 0;\n  }\n\n  subscribe(callbacks: SubscriptionCallbacks<?StoreReaderData>): Subscription {\n    this._subscriptionCount++;\n    var subscriptionIndex = this._subscriptionCallbacks.length;\n    var subscription = {\n      dispose: () => {\n        invariant(\n          this._subscriptionCallbacks[subscriptionIndex],\n          'RelayQueryResultObservable: Subscriptions may only be disposed once.'\n        );\n        delete this._subscriptionCallbacks[subscriptionIndex];\n        this._subscriptionCount--;\n        if (this._subscriptionCount === 0) {\n          this._unobserve();\n        }\n      },\n    };\n    this._subscriptionCallbacks.push(callbacks);\n\n    if (this._subscriptionCount === 1) {\n      this._resolveData(this._observe());\n    }\n    this._fire(callbacks);\n\n    return subscription;\n  }\n\n  _observe(): GraphQLStoreQueryResolver {\n    invariant(\n      !this._fragmentResolver,\n      'RelayQueryResultObservable: Initialized twice.'\n    );\n    var fragmentResolver = new GraphQLStoreQueryResolver(\n      this._storeData,\n      this._fragment,\n      () => this._onUpdate(fragmentResolver)\n    );\n    this._fragmentResolver = fragmentResolver;\n    return fragmentResolver;\n  }\n\n  _unobserve(): void {\n    if (this._fragmentResolver) {\n      this._data = undefined;\n      this._fragmentResolver.dispose();\n      this._fragmentResolver = null;\n    }\n  }\n\n  _onUpdate(fragmentResolver: GraphQLStoreQueryResolver): void {\n    this._resolveData(fragmentResolver);\n    this._subscriptionCallbacks.forEach(callbacks => this._fire(callbacks));\n  }\n\n  _fire(callbacks: SubscriptionCallbacks<?StoreReaderData>): void {\n    callbacks.onNext && callbacks.onNext(this._data);\n  }\n\n  _resolveData(fragmentResolver: GraphQLStoreQueryResolver): void {\n    var data = fragmentResolver.resolve(this._fragment, this._dataID);\n    invariant(\n      !Array.isArray(data),\n      'RelayQueryResultObservable: Plural fragments are not supported.'\n    );\n    this._data = data;\n  }\n}\n\nmodule.exports = RelayQueryResultObservable;\n","dependencies":["RelayInternalTypes","RelayQuery","RelayStoreData","RelayTypes","GraphQLStoreQueryResolver","invariant","RelayQueryResultObservable"],"id":"RelayQueryResultObservable","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayQueryResultObservable\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nimport type {DataID} from 'RelayInternalTypes';\nimport type RelayQuery from 'RelayQuery';\nimport type RelayStoreData from 'RelayStoreData';\nimport type {\n  StoreReaderData,\n  Subscription,\n  SubscriptionCallbacks,\n} from 'RelayTypes';\n\nconst invariant = require('invariant');\n\n/**\n * An Rx Observable representing the results of a fragment in the local cache.\n * Subscribers are notified as follows:\n *\n * `onNext`: Called with the latest results of a fragment. Results may be `null`\n * if the data was marked as deleted or `undefined` if the fragment was either\n * not fetched or evicted from the cache. Note that required fields may be\n * missing if the fragment was not fetched with `Relay.Store.primeCache` or\n * `Relay.Store.forceFetch` before creating a subscription.\n * - Called synchronously on `subscribe()`.\n * - Called whenever the results of the fragment change.\n *\n * `onError`: Currently not called. In the future this may be used to indicate\n * that required data for the fragment has not been fetched or was evicted\n * from the cache.\n *\n * `onCompleted`: Not called.\n *\n * @see http://reactivex.io/documentation/observable.html\n */\nclass RelayQueryResultObservable {\n  _data: ?StoreReaderData;\n  _dataID: DataID;\n  _fragment: RelayQuery.Fragment;\n  _fragmentResolver: ?GraphQLStoreQueryResolver;\n  _storeData: RelayStoreData;\n  _subscriptionCallbacks: Array<SubscriptionCallbacks<?StoreReaderData>>;\n  _subscriptionCount: number;\n\n  constructor(\n    storeData: RelayStoreData,\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ) {\n    this._data = undefined;\n    this._dataID = dataID;\n    this._fragment = fragment;\n    this._fragmentResolver = null;\n    this._storeData = storeData;\n    this._subscriptionCallbacks = [];\n    this._subscriptionCount = 0;\n  }\n\n  subscribe(callbacks: SubscriptionCallbacks<?StoreReaderData>): Subscription {\n    this._subscriptionCount++;\n    var subscriptionIndex = this._subscriptionCallbacks.length;\n    var subscription = {\n      dispose: () => {\n        invariant(\n          this._subscriptionCallbacks[subscriptionIndex],\n          'RelayQueryResultObservable: Subscriptions may only be disposed once.'\n        );\n        delete this._subscriptionCallbacks[subscriptionIndex];\n        this._subscriptionCount--;\n        if (this._subscriptionCount === 0) {\n          this._unobserve();\n        }\n      },\n    };\n    this._subscriptionCallbacks.push(callbacks);\n\n    if (this._subscriptionCount === 1) {\n      this._resolveData(this._observe());\n    }\n    this._fire(callbacks);\n\n    return subscription;\n  }\n\n  _observe(): GraphQLStoreQueryResolver {\n    invariant(\n      !this._fragmentResolver,\n      'RelayQueryResultObservable: Initialized twice.'\n    );\n    var fragmentResolver = new GraphQLStoreQueryResolver(\n      this._storeData,\n      this._fragment,\n      () => this._onUpdate(fragmentResolver)\n    );\n    this._fragmentResolver = fragmentResolver;\n    return fragmentResolver;\n  }\n\n  _unobserve(): void {\n    if (this._fragmentResolver) {\n      this._data = undefined;\n      this._fragmentResolver.dispose();\n      this._fragmentResolver = null;\n    }\n  }\n\n  _onUpdate(fragmentResolver: GraphQLStoreQueryResolver): void {\n    this._resolveData(fragmentResolver);\n    this._subscriptionCallbacks.forEach(callbacks => this._fire(callbacks));\n  }\n\n  _fire(callbacks: SubscriptionCallbacks<?StoreReaderData>): void {\n    callbacks.onNext && callbacks.onNext(this._data);\n  }\n\n  _resolveData(fragmentResolver: GraphQLStoreQueryResolver): void {\n    var data = fragmentResolver.resolve(this._fragment, this._dataID);\n    invariant(\n      !Array.isArray(data),\n      'RelayQueryResultObservable: Plural fragments are not supported.'\n    );\n    this._data = data;\n  }\n}\n\nmodule.exports = RelayQueryResultObservable;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayPendingQueryTracker.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayPendingQueryTracker","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayPendingQueryTracker\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Deferred = require('Deferred');\nconst PromiseMap = require('PromiseMap');\nconst RelayFetchMode = require('RelayFetchMode');\nimport type {FetchMode} from 'RelayFetchMode';\nimport type RelayQuery from 'RelayQuery';\nimport type RelayStoreData from 'RelayStoreData';\nconst RelayTaskScheduler = require('RelayTaskScheduler');\nimport type {QueryResult} from 'RelayTypes';\n\nconst containsRelayQueryRootCall = require('containsRelayQueryRootCall');\nconst everyObject = require('everyObject');\nconst fetchRelayQuery = require('fetchRelayQuery');\nconst invariant = require('invariant');\nconst subtractRelayQuery = require('subtractRelayQuery');\n\ntype PendingQueryParameters = {\n  fetchMode: FetchMode;\n  forceIndex: ?number;\n  query: RelayQuery.Root;\n};\ntype PendingState = {\n  fetch: PendingFetch;\n  query: RelayQuery.Root;\n};\n\n/**\n * @internal\n *\n * Tracks pending (in-flight) queries.\n *\n * In order to send minimal queries and avoid re-retrieving data,\n * `RelayPendingQueryTracker` maintains a registry of pending queries, and\n * \"subtracts\" those from any new queries that callers enqueue.\n */\nclass RelayPendingQueryTracker {\n  _pendingFetchMap: {[queryID: string]: PendingState};\n  // Asynchronous mapping from preload query IDs to results.\n  _preloadQueryMap: PromiseMap<Object, Error>;\n  _storeData: RelayStoreData;\n\n  constructor(storeData: RelayStoreData) {\n    this._pendingFetchMap = {};\n    this._preloadQueryMap = new PromiseMap();\n    this._storeData = storeData;\n  }\n\n  /**\n   * Used by `GraphQLQueryRunner` to enqueue new queries.\n   */\n  add(params: PendingQueryParameters): PendingFetch {\n    return new PendingFetch(params, {\n      pendingFetchMap: this._pendingFetchMap,\n      preloadQueryMap: this._preloadQueryMap,\n      storeData: this._storeData,\n    });\n  }\n\n  hasPendingQueries(): boolean {\n    return hasItems(this._pendingFetchMap);\n  }\n\n  /**\n   * Clears all pending query tracking. Does not cancel the queries themselves.\n   */\n  resetPending(): void {\n    this._pendingFetchMap = {};\n  }\n\n  resolvePreloadQuery(queryID: string, result: Object): void {\n    this._preloadQueryMap.resolveKey(queryID, result);\n  }\n\n  rejectPreloadQuery(queryID: string, error: Error): void {\n    this._preloadQueryMap.rejectKey(queryID, error);\n  }\n}\n\n/**\n * @private\n */\nclass PendingFetch {\n  _pendingFetchMap: {[queryID: string]: PendingState};\n  _preloadQueryMap: PromiseMap<Object, Error>;\n  _query: RelayQuery.Root;\n\n  _forceIndex: ?number;\n\n  _dependents: Array<PendingFetch>;\n  _pendingDependencyMap: {[queryID: string]: PendingFetch};\n\n  _fetchedSubtractedQuery: boolean;\n  _fetchSubtractedQueryPromise: Promise;\n\n  _resolvedSubtractedQuery: boolean;\n  _resolvedDeferred: Deferred<void, ?Error>;\n\n  _storeData: RelayStoreData;\n\n  /**\n   * Error(s) in fetching/handleUpdate-ing its or one of its pending\n   * dependency's subtracted query. There may be more than one error. However,\n   * `_resolvedDeferred` is rejected with the earliest encountered error.\n   */\n  _errors: Array<?Error>;\n\n  constructor(\n    {fetchMode, forceIndex, query}: PendingQueryParameters,\n    {pendingFetchMap, preloadQueryMap, storeData}: {\n      pendingFetchMap: {[queryID: string]: PendingState};\n      preloadQueryMap: PromiseMap<Object, Error>;\n      storeData: RelayStoreData;\n    }\n  ) {\n    var queryID = query.getID();\n    this._dependents = [];\n    this._forceIndex = forceIndex;\n    this._pendingDependencyMap = {};\n    this._pendingFetchMap = pendingFetchMap;\n    this._preloadQueryMap = preloadQueryMap;\n    this._query = query;\n    this._resolvedDeferred = new Deferred();\n    this._resolvedSubtractedQuery = false;\n    this._storeData = storeData;\n\n    var subtractedQuery;\n    if (fetchMode === RelayFetchMode.PRELOAD) {\n      subtractedQuery = query;\n      this._fetchSubtractedQueryPromise = this._preloadQueryMap.get(queryID);\n    } else {\n      subtractedQuery = this._subtractPending(query);\n      this._fetchSubtractedQueryPromise = subtractedQuery ?\n        fetchRelayQuery(subtractedQuery) :\n        Promise.resolve();\n    }\n\n    this._fetchedSubtractedQuery = !subtractedQuery;\n    this._errors = [];\n\n    if (subtractedQuery) {\n      this._pendingFetchMap[queryID] = {\n        fetch: this,\n        query: subtractedQuery,\n      };\n      this._fetchSubtractedQueryPromise.done(\n        this._handleSubtractedQuerySuccess.bind(this, subtractedQuery),\n        this._handleSubtractedQueryFailure.bind(this, subtractedQuery)\n      );\n    } else {\n      this._markSubtractedQueryAsResolved();\n    }\n  }\n\n  /**\n   * A pending query is resolvable if it is already resolved or will be resolved\n   * imminently (i.e. its subtracted query and the subtracted queries of all its\n   * pending dependencies have been fetched).\n   */\n  isResolvable(): boolean {\n    if (this._fetchedSubtractedQuery) {\n      return everyObject(\n        this._pendingDependencyMap,\n        pendingDependency => pendingDependency._fetchedSubtractedQuery\n      );\n      // Pending dependencies further down the graph either don't affect the\n      // result or are already in `_pendingDependencyMap`.\n    }\n    return false;\n  }\n\n  getQuery(): RelayQuery.Root {\n    return this._query;\n  }\n\n  getResolvedPromise(): Promise {\n    return this._resolvedDeferred.getPromise();\n  }\n\n  /**\n   * Subtracts all pending queries from the supplied `query` and returns the\n   * resulting difference. The difference can be null if the entire query is\n   * pending.\n   *\n   * If any pending queries were subtracted, they will be added as dependencies\n   * and the query will only resolve once the subtracted query and all\n   * dependencies have resolved.\n   *\n   * This, combined with our use of diff queries (see `diffRelayQuery`) means\n   * that we only go to the server for things that are not in (or not on their\n   * way to) the cache (`RelayRecordStore`).\n   */\n  _subtractPending(query: ?RelayQuery.Root): ?RelayQuery.Root {\n    everyObject(this._pendingFetchMap, pending => {\n      // Stop if the entire query is subtracted.\n      if (!query) {\n        return false;\n      }\n      if (containsRelayQueryRootCall(pending.query, query)) {\n        var subtractedQuery = subtractRelayQuery(query, pending.query);\n        if (subtractedQuery !== query) {\n          query = subtractedQuery;\n          this._addPendingDependency(pending.fetch);\n        }\n      }\n      return true;\n    });\n    return query;\n  }\n\n  _addPendingDependency(pendingFetch: PendingFetch): void {\n    var queryID = pendingFetch.getQuery().getID();\n    this._pendingDependencyMap[queryID] = pendingFetch;\n    pendingFetch._addDependent(this);\n  }\n\n  _addDependent(pendingFetch: PendingFetch): void {\n    this._dependents.push(pendingFetch);\n  }\n\n  _handleSubtractedQuerySuccess(\n    subtractedQuery: RelayQuery.Root,\n    result: QueryResult\n  ): void {\n    this._fetchedSubtractedQuery = true;\n\n    RelayTaskScheduler.enqueue(() => {\n      var response = result.response;\n      invariant(\n        response && typeof response === 'object',\n        'RelayPendingQueryTracker: Expected response to be an object, got ' +\n        '`%s`.',\n        response ? typeof response : response\n      );\n      this._storeData.handleQueryPayload(\n        subtractedQuery,\n        response,\n        this._forceIndex\n      );\n    }).done(\n      this._markSubtractedQueryAsResolved.bind(this),\n      this._markAsRejected.bind(this)\n    );\n  }\n\n  _handleSubtractedQueryFailure(\n    subtractedQuery: RelayQuery.Root,\n    error: Error\n  ): void {\n    this._markAsRejected(error);\n  }\n\n  _markSubtractedQueryAsResolved(): void {\n    var queryID = this.getQuery().getID();\n    delete this._pendingFetchMap[queryID];\n\n    this._resolvedSubtractedQuery = true;\n    this._updateResolvedDeferred();\n\n    this._dependents.forEach(dependent =>\n      dependent._markDependencyAsResolved(queryID)\n    );\n  }\n\n  _markAsRejected(error: Error): void {\n    var queryID = this.getQuery().getID();\n    delete this._pendingFetchMap[queryID];\n\n    console.warn(error.message);\n\n    this._errors.push(error);\n    this._updateResolvedDeferred();\n\n    this._dependents.forEach(dependent =>\n      dependent._markDependencyAsRejected(queryID, error)\n    );\n  }\n\n  _markDependencyAsResolved(dependencyQueryID: string): void {\n    delete this._pendingDependencyMap[dependencyQueryID];\n\n    this._updateResolvedDeferred();\n  }\n\n  _markDependencyAsRejected(dependencyQueryID: string, error: Error): void {\n    delete this._pendingDependencyMap[dependencyQueryID];\n\n    this._errors.push(error);\n    this._updateResolvedDeferred();\n\n    // Dependencies further down the graph are either not affected or informed\n    // by `dependencyQueryID`.\n  }\n\n  _updateResolvedDeferred(): void {\n    if (this._isSettled() && !this._resolvedDeferred.isSettled()) {\n      if (this._errors.length) {\n        this._resolvedDeferred.reject(this._errors[0]);\n      } else {\n        this._resolvedDeferred.resolve(undefined);\n      }\n    }\n  }\n\n  _isSettled(): boolean {\n    return this._errors.length > 0 ||\n      (this._resolvedSubtractedQuery && !hasItems(this._pendingDependencyMap));\n  }\n}\n\nfunction hasItems(map: Object): boolean {\n  return !!Object.keys(map).length;\n}\n\nexport type {PendingFetch};\nmodule.exports = RelayPendingQueryTracker;\n","dependencies":["RelayFetchMode","RelayQuery","RelayStoreData","RelayTypes","Deferred","PromiseMap","RelayTaskScheduler","containsRelayQueryRootCall","everyObject","fetchRelayQuery","invariant","subtractRelayQuery","RelayPendingQueryTracker"],"id":"RelayPendingQueryTracker","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayPendingQueryTracker\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Deferred = require('Deferred');\nconst PromiseMap = require('PromiseMap');\nconst RelayFetchMode = require('RelayFetchMode');\nimport type {FetchMode} from 'RelayFetchMode';\nimport type RelayQuery from 'RelayQuery';\nimport type RelayStoreData from 'RelayStoreData';\nconst RelayTaskScheduler = require('RelayTaskScheduler');\nimport type {QueryResult} from 'RelayTypes';\n\nconst containsRelayQueryRootCall = require('containsRelayQueryRootCall');\nconst everyObject = require('everyObject');\nconst fetchRelayQuery = require('fetchRelayQuery');\nconst invariant = require('invariant');\nconst subtractRelayQuery = require('subtractRelayQuery');\n\ntype PendingQueryParameters = {\n  fetchMode: FetchMode;\n  forceIndex: ?number;\n  query: RelayQuery.Root;\n};\ntype PendingState = {\n  fetch: PendingFetch;\n  query: RelayQuery.Root;\n};\n\n/**\n * @internal\n *\n * Tracks pending (in-flight) queries.\n *\n * In order to send minimal queries and avoid re-retrieving data,\n * `RelayPendingQueryTracker` maintains a registry of pending queries, and\n * \"subtracts\" those from any new queries that callers enqueue.\n */\nclass RelayPendingQueryTracker {\n  _pendingFetchMap: {[queryID: string]: PendingState};\n  // Asynchronous mapping from preload query IDs to results.\n  _preloadQueryMap: PromiseMap<Object, Error>;\n  _storeData: RelayStoreData;\n\n  constructor(storeData: RelayStoreData) {\n    this._pendingFetchMap = {};\n    this._preloadQueryMap = new PromiseMap();\n    this._storeData = storeData;\n  }\n\n  /**\n   * Used by `GraphQLQueryRunner` to enqueue new queries.\n   */\n  add(params: PendingQueryParameters): PendingFetch {\n    return new PendingFetch(params, {\n      pendingFetchMap: this._pendingFetchMap,\n      preloadQueryMap: this._preloadQueryMap,\n      storeData: this._storeData,\n    });\n  }\n\n  hasPendingQueries(): boolean {\n    return hasItems(this._pendingFetchMap);\n  }\n\n  /**\n   * Clears all pending query tracking. Does not cancel the queries themselves.\n   */\n  resetPending(): void {\n    this._pendingFetchMap = {};\n  }\n\n  resolvePreloadQuery(queryID: string, result: Object): void {\n    this._preloadQueryMap.resolveKey(queryID, result);\n  }\n\n  rejectPreloadQuery(queryID: string, error: Error): void {\n    this._preloadQueryMap.rejectKey(queryID, error);\n  }\n}\n\n/**\n * @private\n */\nclass PendingFetch {\n  _pendingFetchMap: {[queryID: string]: PendingState};\n  _preloadQueryMap: PromiseMap<Object, Error>;\n  _query: RelayQuery.Root;\n\n  _forceIndex: ?number;\n\n  _dependents: Array<PendingFetch>;\n  _pendingDependencyMap: {[queryID: string]: PendingFetch};\n\n  _fetchedSubtractedQuery: boolean;\n  _fetchSubtractedQueryPromise: Promise;\n\n  _resolvedSubtractedQuery: boolean;\n  _resolvedDeferred: Deferred<void, ?Error>;\n\n  _storeData: RelayStoreData;\n\n  /**\n   * Error(s) in fetching/handleUpdate-ing its or one of its pending\n   * dependency's subtracted query. There may be more than one error. However,\n   * `_resolvedDeferred` is rejected with the earliest encountered error.\n   */\n  _errors: Array<?Error>;\n\n  constructor(\n    {fetchMode, forceIndex, query}: PendingQueryParameters,\n    {pendingFetchMap, preloadQueryMap, storeData}: {\n      pendingFetchMap: {[queryID: string]: PendingState};\n      preloadQueryMap: PromiseMap<Object, Error>;\n      storeData: RelayStoreData;\n    }\n  ) {\n    var queryID = query.getID();\n    this._dependents = [];\n    this._forceIndex = forceIndex;\n    this._pendingDependencyMap = {};\n    this._pendingFetchMap = pendingFetchMap;\n    this._preloadQueryMap = preloadQueryMap;\n    this._query = query;\n    this._resolvedDeferred = new Deferred();\n    this._resolvedSubtractedQuery = false;\n    this._storeData = storeData;\n\n    var subtractedQuery;\n    if (fetchMode === RelayFetchMode.PRELOAD) {\n      subtractedQuery = query;\n      this._fetchSubtractedQueryPromise = this._preloadQueryMap.get(queryID);\n    } else {\n      subtractedQuery = this._subtractPending(query);\n      this._fetchSubtractedQueryPromise = subtractedQuery ?\n        fetchRelayQuery(subtractedQuery) :\n        Promise.resolve();\n    }\n\n    this._fetchedSubtractedQuery = !subtractedQuery;\n    this._errors = [];\n\n    if (subtractedQuery) {\n      this._pendingFetchMap[queryID] = {\n        fetch: this,\n        query: subtractedQuery,\n      };\n      this._fetchSubtractedQueryPromise.done(\n        this._handleSubtractedQuerySuccess.bind(this, subtractedQuery),\n        this._handleSubtractedQueryFailure.bind(this, subtractedQuery)\n      );\n    } else {\n      this._markSubtractedQueryAsResolved();\n    }\n  }\n\n  /**\n   * A pending query is resolvable if it is already resolved or will be resolved\n   * imminently (i.e. its subtracted query and the subtracted queries of all its\n   * pending dependencies have been fetched).\n   */\n  isResolvable(): boolean {\n    if (this._fetchedSubtractedQuery) {\n      return everyObject(\n        this._pendingDependencyMap,\n        pendingDependency => pendingDependency._fetchedSubtractedQuery\n      );\n      // Pending dependencies further down the graph either don't affect the\n      // result or are already in `_pendingDependencyMap`.\n    }\n    return false;\n  }\n\n  getQuery(): RelayQuery.Root {\n    return this._query;\n  }\n\n  getResolvedPromise(): Promise {\n    return this._resolvedDeferred.getPromise();\n  }\n\n  /**\n   * Subtracts all pending queries from the supplied `query` and returns the\n   * resulting difference. The difference can be null if the entire query is\n   * pending.\n   *\n   * If any pending queries were subtracted, they will be added as dependencies\n   * and the query will only resolve once the subtracted query and all\n   * dependencies have resolved.\n   *\n   * This, combined with our use of diff queries (see `diffRelayQuery`) means\n   * that we only go to the server for things that are not in (or not on their\n   * way to) the cache (`RelayRecordStore`).\n   */\n  _subtractPending(query: ?RelayQuery.Root): ?RelayQuery.Root {\n    everyObject(this._pendingFetchMap, pending => {\n      // Stop if the entire query is subtracted.\n      if (!query) {\n        return false;\n      }\n      if (containsRelayQueryRootCall(pending.query, query)) {\n        var subtractedQuery = subtractRelayQuery(query, pending.query);\n        if (subtractedQuery !== query) {\n          query = subtractedQuery;\n          this._addPendingDependency(pending.fetch);\n        }\n      }\n      return true;\n    });\n    return query;\n  }\n\n  _addPendingDependency(pendingFetch: PendingFetch): void {\n    var queryID = pendingFetch.getQuery().getID();\n    this._pendingDependencyMap[queryID] = pendingFetch;\n    pendingFetch._addDependent(this);\n  }\n\n  _addDependent(pendingFetch: PendingFetch): void {\n    this._dependents.push(pendingFetch);\n  }\n\n  _handleSubtractedQuerySuccess(\n    subtractedQuery: RelayQuery.Root,\n    result: QueryResult\n  ): void {\n    this._fetchedSubtractedQuery = true;\n\n    RelayTaskScheduler.enqueue(() => {\n      var response = result.response;\n      invariant(\n        response && typeof response === 'object',\n        'RelayPendingQueryTracker: Expected response to be an object, got ' +\n        '`%s`.',\n        response ? typeof response : response\n      );\n      this._storeData.handleQueryPayload(\n        subtractedQuery,\n        response,\n        this._forceIndex\n      );\n    }).done(\n      this._markSubtractedQueryAsResolved.bind(this),\n      this._markAsRejected.bind(this)\n    );\n  }\n\n  _handleSubtractedQueryFailure(\n    subtractedQuery: RelayQuery.Root,\n    error: Error\n  ): void {\n    this._markAsRejected(error);\n  }\n\n  _markSubtractedQueryAsResolved(): void {\n    var queryID = this.getQuery().getID();\n    delete this._pendingFetchMap[queryID];\n\n    this._resolvedSubtractedQuery = true;\n    this._updateResolvedDeferred();\n\n    this._dependents.forEach(dependent =>\n      dependent._markDependencyAsResolved(queryID)\n    );\n  }\n\n  _markAsRejected(error: Error): void {\n    var queryID = this.getQuery().getID();\n    delete this._pendingFetchMap[queryID];\n\n    console.warn(error.message);\n\n    this._errors.push(error);\n    this._updateResolvedDeferred();\n\n    this._dependents.forEach(dependent =>\n      dependent._markDependencyAsRejected(queryID, error)\n    );\n  }\n\n  _markDependencyAsResolved(dependencyQueryID: string): void {\n    delete this._pendingDependencyMap[dependencyQueryID];\n\n    this._updateResolvedDeferred();\n  }\n\n  _markDependencyAsRejected(dependencyQueryID: string, error: Error): void {\n    delete this._pendingDependencyMap[dependencyQueryID];\n\n    this._errors.push(error);\n    this._updateResolvedDeferred();\n\n    // Dependencies further down the graph are either not affected or informed\n    // by `dependencyQueryID`.\n  }\n\n  _updateResolvedDeferred(): void {\n    if (this._isSettled() && !this._resolvedDeferred.isSettled()) {\n      if (this._errors.length) {\n        this._resolvedDeferred.reject(this._errors[0]);\n      } else {\n        this._resolvedDeferred.resolve(undefined);\n      }\n    }\n  }\n\n  _isSettled(): boolean {\n    return this._errors.length > 0 ||\n      (this._resolvedSubtractedQuery && !hasItems(this._pendingDependencyMap));\n  }\n}\n\nfunction hasItems(map: Object): boolean {\n  return !!Object.keys(map).length;\n}\n\nexport type {PendingFetch};\nmodule.exports = RelayPendingQueryTracker;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayMutationTracker.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayMutationTracker","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationTracker\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayRecord = require('RelayRecord');\n\nimport type {\n  DataID,\n  ClientMutationID,\n} from 'RelayInternalTypes';\n\n// Maintains a map from the client id to the server id of\n// optimistically added nodes\nvar clientIDToServerIDMap = {};\n\n// For node-create mutations, maintains an index of the mutation to the\n// client ID of an optimistically created node (if it exists).\nvar mutationIDToClientNodeIDMap = {};\n\n// For mutations that have errors, maintains a two-directional index of the\n// mutation and node with an error.\nvar clientMutationIDToErrorNodeID = {};\nvar clientNodeIDToErrorMutationID = {};\n\n/**\n * @internal\n *\n * Records the client ID and error status of mutations as well as maintaining\n * a mapping of optimistic client IDs to server IDs.\n */\nvar RelayMutationTracker = {\n\n /**\n  * Checks if the given id represents an object only known on the client side\n  * or not. In this case, it is both a client id and does not have a\n  * corresponding mapping in the client server id map.\n  */\n  isClientOnlyID: function(dataID: DataID): boolean {\n    return (\n      RelayRecord.isClientID(dataID) &&\n      !clientIDToServerIDMap[dataID]\n    );\n  },\n\n  /**\n   * Updates the map from the client id to the server id for optimistically\n   * added nodes.\n   */\n  updateClientServerIDMap: function(\n    clientID: DataID,\n    serverID: DataID\n  ): void {\n    clientIDToServerIDMap[clientID] = serverID;\n  },\n\n  /**\n   * Gets the serverID (if one exists) for a given clientID\n   */\n  getServerIDForClientID: function(\n    clientID: DataID\n  ): ?DataID {\n    return clientIDToServerIDMap[clientID] || null;\n  },\n\n  /**\n   * Record the root node ID associated with the mutation.\n   */\n  putClientIDForMutation: function(\n    clientID: DataID,\n    clientMutationID: ClientMutationID\n  ): void {\n    mutationIDToClientNodeIDMap[clientMutationID] = clientID;\n\n    // if an error exists for this mutation ID, remove the error on the previous\n    // client ID and 'move' the error on the new client ID\n    var errorNodeID =\n      RelayMutationTracker.getErrorNodeForMutation(clientMutationID);\n    if (errorNodeID) {\n      RelayMutationTracker.deleteMutationForErrorNode(errorNodeID);\n      RelayMutationTracker.putErrorNodeForMutation(clientID, clientMutationID);\n    }\n  },\n\n  /**\n   * Get the root record ID associated with the muation.\n   */\n  getClientIDForMutation: function(\n    clientMutationID: ClientMutationID\n  ): ?string {\n    return mutationIDToClientNodeIDMap[clientMutationID];\n  },\n\n  /**\n   * Delete the root record ID associated with the mutation.\n   */\n  deleteClientIDForMutation: function(\n    clientMutationID: ClientMutationID\n  ): void {\n    delete mutationIDToClientNodeIDMap[clientMutationID];\n  },\n\n  /**\n   * Record that an error occurred while creating the given (client) record ID.\n   */\n  putErrorNodeForMutation: function(\n    clientID: DataID,\n    clientMutationID: ClientMutationID\n  ): void {\n    clientNodeIDToErrorMutationID[clientID] = clientMutationID;\n    clientMutationIDToErrorNodeID[clientMutationID] = clientID;\n  },\n\n  /**\n   * Find the failed mutation that created the given (client) record ID,\n   * if any.\n   */\n  getMutationForErrorNode: function(\n    clientID: DataID\n  ): ?ClientMutationID {\n    return clientNodeIDToErrorMutationID[clientID];\n  },\n\n  /**\n   * Find the (client) ID of the record associated with the given mutation,\n   * if any.\n   */\n  getErrorNodeForMutation: function(\n    clientMutationID: ClientMutationID\n  ): ?DataID {\n    return clientMutationIDToErrorNodeID[clientMutationID];\n  },\n\n  deleteMutationForErrorNode: function(\n    clientID: DataID\n  ): void {\n    delete clientNodeIDToErrorMutationID[clientID];\n  },\n\n  deleteErrorNodeForMutation: function(\n    clientMutationID: ClientMutationID\n  ): void {\n    delete clientMutationIDToErrorNodeID[clientMutationID];\n  },\n};\n\nmodule.exports = RelayMutationTracker;\n","dependencies":["RelayInternalTypes","RelayRecord","RelayMutationTracker"],"id":"RelayMutationTracker","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMutationTracker\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayRecord = require('RelayRecord');\n\nimport type {\n  DataID,\n  ClientMutationID,\n} from 'RelayInternalTypes';\n\n// Maintains a map from the client id to the server id of\n// optimistically added nodes\nvar clientIDToServerIDMap = {};\n\n// For node-create mutations, maintains an index of the mutation to the\n// client ID of an optimistically created node (if it exists).\nvar mutationIDToClientNodeIDMap = {};\n\n// For mutations that have errors, maintains a two-directional index of the\n// mutation and node with an error.\nvar clientMutationIDToErrorNodeID = {};\nvar clientNodeIDToErrorMutationID = {};\n\n/**\n * @internal\n *\n * Records the client ID and error status of mutations as well as maintaining\n * a mapping of optimistic client IDs to server IDs.\n */\nvar RelayMutationTracker = {\n\n /**\n  * Checks if the given id represents an object only known on the client side\n  * or not. In this case, it is both a client id and does not have a\n  * corresponding mapping in the client server id map.\n  */\n  isClientOnlyID: function(dataID: DataID): boolean {\n    return (\n      RelayRecord.isClientID(dataID) &&\n      !clientIDToServerIDMap[dataID]\n    );\n  },\n\n  /**\n   * Updates the map from the client id to the server id for optimistically\n   * added nodes.\n   */\n  updateClientServerIDMap: function(\n    clientID: DataID,\n    serverID: DataID\n  ): void {\n    clientIDToServerIDMap[clientID] = serverID;\n  },\n\n  /**\n   * Gets the serverID (if one exists) for a given clientID\n   */\n  getServerIDForClientID: function(\n    clientID: DataID\n  ): ?DataID {\n    return clientIDToServerIDMap[clientID] || null;\n  },\n\n  /**\n   * Record the root node ID associated with the mutation.\n   */\n  putClientIDForMutation: function(\n    clientID: DataID,\n    clientMutationID: ClientMutationID\n  ): void {\n    mutationIDToClientNodeIDMap[clientMutationID] = clientID;\n\n    // if an error exists for this mutation ID, remove the error on the previous\n    // client ID and 'move' the error on the new client ID\n    var errorNodeID =\n      RelayMutationTracker.getErrorNodeForMutation(clientMutationID);\n    if (errorNodeID) {\n      RelayMutationTracker.deleteMutationForErrorNode(errorNodeID);\n      RelayMutationTracker.putErrorNodeForMutation(clientID, clientMutationID);\n    }\n  },\n\n  /**\n   * Get the root record ID associated with the muation.\n   */\n  getClientIDForMutation: function(\n    clientMutationID: ClientMutationID\n  ): ?string {\n    return mutationIDToClientNodeIDMap[clientMutationID];\n  },\n\n  /**\n   * Delete the root record ID associated with the mutation.\n   */\n  deleteClientIDForMutation: function(\n    clientMutationID: ClientMutationID\n  ): void {\n    delete mutationIDToClientNodeIDMap[clientMutationID];\n  },\n\n  /**\n   * Record that an error occurred while creating the given (client) record ID.\n   */\n  putErrorNodeForMutation: function(\n    clientID: DataID,\n    clientMutationID: ClientMutationID\n  ): void {\n    clientNodeIDToErrorMutationID[clientID] = clientMutationID;\n    clientMutationIDToErrorNodeID[clientMutationID] = clientID;\n  },\n\n  /**\n   * Find the failed mutation that created the given (client) record ID,\n   * if any.\n   */\n  getMutationForErrorNode: function(\n    clientID: DataID\n  ): ?ClientMutationID {\n    return clientNodeIDToErrorMutationID[clientID];\n  },\n\n  /**\n   * Find the (client) ID of the record associated with the given mutation,\n   * if any.\n   */\n  getErrorNodeForMutation: function(\n    clientMutationID: ClientMutationID\n  ): ?DataID {\n    return clientMutationIDToErrorNodeID[clientMutationID];\n  },\n\n  deleteMutationForErrorNode: function(\n    clientID: DataID\n  ): void {\n    delete clientNodeIDToErrorMutationID[clientID];\n  },\n\n  deleteErrorNodeForMutation: function(\n    clientMutationID: ClientMutationID\n  ): void {\n    delete clientMutationIDToErrorNodeID[clientMutationID];\n  },\n};\n\nmodule.exports = RelayMutationTracker;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayGarbageCollector.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayGarbageCollector","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayGarbageCollector\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLRange = require('GraphQLRange');\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecord = require('RelayRecord');\nimport type RelayStoreData from 'RelayStoreData';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst resolveImmediate = require('resolveImmediate');\nconst warning = require('warning');\n\nexport type GarbageCollectionHold = {release: () => void};\nexport type GarbageCollectionScheduler = (collect: () => boolean) => void;\n\n/**\n * @internal\n *\n * Provides methods to track the number of references to registered records and\n * remove un-referenced records from Relay's cache.\n */\nclass RelayGarbageCollector {\n  _activeHoldCount: number;\n  _collectionQueue: Array<DataID>;\n  _isCollecting: boolean;\n  _isScheduled: boolean;\n  _refCounts: {[key: DataID]: number};\n  _scheduler: GarbageCollectionScheduler;\n  _storeData: RelayStoreData;\n\n  constructor(\n    storeData: RelayStoreData,\n    scheduler: GarbageCollectionScheduler\n  ) {\n    this._activeHoldCount = 0;\n    this._collectionQueue = [];\n    this._isCollecting = false;\n    this._isScheduled = false;\n    this._refCounts = {};\n    this._scheduler = scheduler;\n    this._storeData = storeData;\n  }\n\n  register(dataID: DataID): void {\n    if (!this._refCounts.hasOwnProperty(dataID)) {\n      this._refCounts[dataID] = 0;\n    }\n  }\n\n  incrementReferenceCount(dataID: DataID): void {\n    // Inlined `register` since this is a reasonably hot code path.\n    if (!this._refCounts.hasOwnProperty(dataID)) {\n      this._refCounts[dataID] = 0;\n    }\n    this._refCounts[dataID]++;\n  }\n\n  decrementReferenceCount(dataID: DataID): void {\n    if (\n      !this._refCounts.hasOwnProperty(dataID) ||\n      this._refCounts[dataID] <= 0\n    ) {\n      warning(\n        false,\n        'RelayGarbageCollector: Expected id `%s` be referenced before being ' +\n        'unreferenced.',\n        dataID\n      );\n      this._refCounts[dataID] = 0;\n      return;\n    }\n    this._refCounts[dataID]--;\n  }\n\n  /**\n   * Notify the collector that GC should be put on hold/paused. The hold can be\n   * released by calling the returned callback.\n   *\n   * Example use cases:\n   * - In-flight queries may have been diffed against cached records that are\n   *   unreferenced and eligible for GC. If these records were collected there\n   *   would be insufficient data in the cache to render.\n   * - There may be a gap between a query response being processed and rendering\n   *   the component that initiated the fetch. If records were collected there\n   *   would be insufficient data in the cache to render.\n   */\n  acquireHold(): GarbageCollectionHold {\n    let isReleased = false;\n    this._activeHoldCount++;\n    return {\n      release: () => {\n        invariant(\n          !isReleased,\n          'RelayGarbageCollector: hold can only be released once.'\n        );\n        invariant(\n          this._activeHoldCount > 0,\n          'RelayGarbageCollector: cannot decrease hold count below zero.'\n        );\n        isReleased = true;\n        this._activeHoldCount--;\n        if (this._activeHoldCount === 0) {\n          this._scheduleCollection();\n        }\n      },\n    };\n  }\n\n  /**\n   * Schedules a collection starting at the given record.\n   */\n  collectFromNode(dataID: DataID): void {\n    if (this._refCounts[dataID] === 0) {\n      this._collectionQueue.push(dataID);\n      this._scheduleCollection();\n    }\n  }\n\n  /**\n   * Schedules a collection for any currently unreferenced records.\n   */\n  collect(): void {\n    forEachObject(this._refCounts, (refCount, dataID) => {\n      if (refCount === 0) {\n        this._collectionQueue.push(dataID);\n      }\n    });\n    this._scheduleCollection();\n  }\n\n  _scheduleCollection(): void {\n    if (this._isScheduled) {\n      return;\n    }\n    this._isScheduled = true;\n    resolveImmediate(() => {\n      this._isScheduled = false;\n      this._processQueue();\n    });\n  }\n\n  _processQueue() {\n    if (\n      this._isCollecting ||\n      this._activeHoldCount ||\n      !this._collectionQueue.length\n    ) {\n      // already scheduled, active hold, or nothing to do\n      return;\n    }\n    this._isCollecting = true;\n\n    const cachedRecords = this._storeData.getCachedData();\n    const freshRecords = this._storeData.getNodeData();\n    this._scheduler(() => {\n      // exit if a hold was acquired since the last execution\n      if (this._activeHoldCount) {\n        this._isCollecting = false;\n        return false;\n      }\n\n      const dataID = this._getNextUnreferencedID();\n      if (dataID) {\n        const cachedRecord = cachedRecords[dataID];\n        if (cachedRecord) {\n          this._traverseRecord(cachedRecord);\n        }\n        const freshRecord = freshRecords[dataID];\n        if (freshRecord) {\n          this._traverseRecord(freshRecord);\n        }\n        this._collectRecord(dataID);\n      }\n\n      // only allow new collections to be scheduled once the current one\n      // is complete\n      this._isCollecting = !!this._collectionQueue.length;\n      return this._isCollecting;\n    });\n  }\n\n  _getNextUnreferencedID(): ?DataID {\n    while (this._collectionQueue.length) {\n      const dataID = this._collectionQueue.shift();\n      if (\n        this._refCounts.hasOwnProperty(dataID) &&\n        this._refCounts[dataID] === 0\n      ) {\n        return dataID;\n      }\n    }\n    return null;\n  }\n\n  _traverseRecord(record: {[key: string]: mixed}): void {\n    forEachObject(record, (value, storageKey) => {\n      if (value instanceof RelayQueryPath) {\n        return;\n      } else if (value instanceof GraphQLRange) {\n        value.getEdgeIDs().forEach(id => {\n          if (id != null) {\n            this._collectionQueue.push(id);\n          }\n        });\n      } else if (Array.isArray(value)) {\n        value.forEach(item => {\n          if (typeof item === 'object' && item !== null) {\n            const linkedID = RelayRecord.getDataID(item);\n            if (linkedID != null) {\n              this._collectionQueue.push(linkedID);\n            }\n          }\n        });\n      } else if (typeof value === 'object' && value !== null) {\n        const linkedID = RelayRecord.getDataID(value);\n        if (linkedID != null) {\n          this._collectionQueue.push(linkedID);\n        }\n      }\n    });\n  }\n\n  _collectRecord(dataID: DataID): void {\n    this._storeData.getQueryTracker().untrackNodesForID(dataID);\n    this._storeData.getQueuedStore().removeRecord(dataID);\n    this._storeData.getRangeData().removeRecord(dataID);\n    delete this._refCounts[dataID];\n  }\n}\n\nmodule.exports = RelayGarbageCollector;\n","dependencies":["RelayInternalTypes","RelayStoreData","GraphQLRange","RelayQueryPath","RelayRecord","forEachObject","invariant","resolveImmediate","warning","RelayGarbageCollector"],"id":"RelayGarbageCollector","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayGarbageCollector\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLRange = require('GraphQLRange');\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecord = require('RelayRecord');\nimport type RelayStoreData from 'RelayStoreData';\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst resolveImmediate = require('resolveImmediate');\nconst warning = require('warning');\n\nexport type GarbageCollectionHold = {release: () => void};\nexport type GarbageCollectionScheduler = (collect: () => boolean) => void;\n\n/**\n * @internal\n *\n * Provides methods to track the number of references to registered records and\n * remove un-referenced records from Relay's cache.\n */\nclass RelayGarbageCollector {\n  _activeHoldCount: number;\n  _collectionQueue: Array<DataID>;\n  _isCollecting: boolean;\n  _isScheduled: boolean;\n  _refCounts: {[key: DataID]: number};\n  _scheduler: GarbageCollectionScheduler;\n  _storeData: RelayStoreData;\n\n  constructor(\n    storeData: RelayStoreData,\n    scheduler: GarbageCollectionScheduler\n  ) {\n    this._activeHoldCount = 0;\n    this._collectionQueue = [];\n    this._isCollecting = false;\n    this._isScheduled = false;\n    this._refCounts = {};\n    this._scheduler = scheduler;\n    this._storeData = storeData;\n  }\n\n  register(dataID: DataID): void {\n    if (!this._refCounts.hasOwnProperty(dataID)) {\n      this._refCounts[dataID] = 0;\n    }\n  }\n\n  incrementReferenceCount(dataID: DataID): void {\n    // Inlined `register` since this is a reasonably hot code path.\n    if (!this._refCounts.hasOwnProperty(dataID)) {\n      this._refCounts[dataID] = 0;\n    }\n    this._refCounts[dataID]++;\n  }\n\n  decrementReferenceCount(dataID: DataID): void {\n    if (\n      !this._refCounts.hasOwnProperty(dataID) ||\n      this._refCounts[dataID] <= 0\n    ) {\n      warning(\n        false,\n        'RelayGarbageCollector: Expected id `%s` be referenced before being ' +\n        'unreferenced.',\n        dataID\n      );\n      this._refCounts[dataID] = 0;\n      return;\n    }\n    this._refCounts[dataID]--;\n  }\n\n  /**\n   * Notify the collector that GC should be put on hold/paused. The hold can be\n   * released by calling the returned callback.\n   *\n   * Example use cases:\n   * - In-flight queries may have been diffed against cached records that are\n   *   unreferenced and eligible for GC. If these records were collected there\n   *   would be insufficient data in the cache to render.\n   * - There may be a gap between a query response being processed and rendering\n   *   the component that initiated the fetch. If records were collected there\n   *   would be insufficient data in the cache to render.\n   */\n  acquireHold(): GarbageCollectionHold {\n    let isReleased = false;\n    this._activeHoldCount++;\n    return {\n      release: () => {\n        invariant(\n          !isReleased,\n          'RelayGarbageCollector: hold can only be released once.'\n        );\n        invariant(\n          this._activeHoldCount > 0,\n          'RelayGarbageCollector: cannot decrease hold count below zero.'\n        );\n        isReleased = true;\n        this._activeHoldCount--;\n        if (this._activeHoldCount === 0) {\n          this._scheduleCollection();\n        }\n      },\n    };\n  }\n\n  /**\n   * Schedules a collection starting at the given record.\n   */\n  collectFromNode(dataID: DataID): void {\n    if (this._refCounts[dataID] === 0) {\n      this._collectionQueue.push(dataID);\n      this._scheduleCollection();\n    }\n  }\n\n  /**\n   * Schedules a collection for any currently unreferenced records.\n   */\n  collect(): void {\n    forEachObject(this._refCounts, (refCount, dataID) => {\n      if (refCount === 0) {\n        this._collectionQueue.push(dataID);\n      }\n    });\n    this._scheduleCollection();\n  }\n\n  _scheduleCollection(): void {\n    if (this._isScheduled) {\n      return;\n    }\n    this._isScheduled = true;\n    resolveImmediate(() => {\n      this._isScheduled = false;\n      this._processQueue();\n    });\n  }\n\n  _processQueue() {\n    if (\n      this._isCollecting ||\n      this._activeHoldCount ||\n      !this._collectionQueue.length\n    ) {\n      // already scheduled, active hold, or nothing to do\n      return;\n    }\n    this._isCollecting = true;\n\n    const cachedRecords = this._storeData.getCachedData();\n    const freshRecords = this._storeData.getNodeData();\n    this._scheduler(() => {\n      // exit if a hold was acquired since the last execution\n      if (this._activeHoldCount) {\n        this._isCollecting = false;\n        return false;\n      }\n\n      const dataID = this._getNextUnreferencedID();\n      if (dataID) {\n        const cachedRecord = cachedRecords[dataID];\n        if (cachedRecord) {\n          this._traverseRecord(cachedRecord);\n        }\n        const freshRecord = freshRecords[dataID];\n        if (freshRecord) {\n          this._traverseRecord(freshRecord);\n        }\n        this._collectRecord(dataID);\n      }\n\n      // only allow new collections to be scheduled once the current one\n      // is complete\n      this._isCollecting = !!this._collectionQueue.length;\n      return this._isCollecting;\n    });\n  }\n\n  _getNextUnreferencedID(): ?DataID {\n    while (this._collectionQueue.length) {\n      const dataID = this._collectionQueue.shift();\n      if (\n        this._refCounts.hasOwnProperty(dataID) &&\n        this._refCounts[dataID] === 0\n      ) {\n        return dataID;\n      }\n    }\n    return null;\n  }\n\n  _traverseRecord(record: {[key: string]: mixed}): void {\n    forEachObject(record, (value, storageKey) => {\n      if (value instanceof RelayQueryPath) {\n        return;\n      } else if (value instanceof GraphQLRange) {\n        value.getEdgeIDs().forEach(id => {\n          if (id != null) {\n            this._collectionQueue.push(id);\n          }\n        });\n      } else if (Array.isArray(value)) {\n        value.forEach(item => {\n          if (typeof item === 'object' && item !== null) {\n            const linkedID = RelayRecord.getDataID(item);\n            if (linkedID != null) {\n              this._collectionQueue.push(linkedID);\n            }\n          }\n        });\n      } else if (typeof value === 'object' && value !== null) {\n        const linkedID = RelayRecord.getDataID(value);\n        if (linkedID != null) {\n          this._collectionQueue.push(linkedID);\n        }\n      }\n    });\n  }\n\n  _collectRecord(dataID: DataID): void {\n    this._storeData.getQueryTracker().untrackNodesForID(dataID);\n    this._storeData.getQueuedStore().removeRecord(dataID);\n    this._storeData.getRangeData().removeRecord(dataID);\n    delete this._refCounts[dataID];\n  }\n}\n\nmodule.exports = RelayGarbageCollector;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayGarbageCollection.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayGarbageCollection","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayGarbageCollection\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayStore = require('RelayStore');\nconst RelayTaskScheduler = require('RelayTaskScheduler');\n\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nlet _stepLength = -1; // collect in a single pass by default\n\n/**\n * Public API for controlling garbage collection of `RelayStoreData`.\n *\n * Provides methods to control the garbage collection of records in\n * `RelayStoreData`.\n */\nvar RelayGarbageCollection = {\n  /**\n   * Initializes garbage collection: must be called before any records are\n   * fetched. When records are collected after calls to `scheduleCollection` or\n   * `scheduleCollectionFromNode`, records are collected in steps, with a\n   * maximum of `stepLength` records traversed in a step. Steps are scheduled\n   * via `RelayTaskScheduler`.\n   */\n  initialize(stepLength: number): void {\n    invariant(\n      stepLength > 0,\n      'RelayGarbageCollection: step length must be greater than zero, got ' +\n      '`%s`.',\n      stepLength\n    );\n    _stepLength = stepLength;\n    RelayStore.getStoreData().initializeGarbageCollector(scheduler);\n  },\n\n  /**\n   * Collects any un-referenced records in the store.\n   */\n  scheduleCollection(): void {\n    var garbageCollector = RelayStore.getStoreData().getGarbageCollector();\n\n    if (garbageCollector) {\n      garbageCollector.collect();\n    }\n  },\n\n  /**\n   * Collects any un-referenced records reachable from the given record via\n   * graph traversal of fields.\n   *\n   * NOTE: If the given record is still referenced, no records are collected.\n   */\n  scheduleCollectionFromNode(dataID: DataID): void {\n    var garbageCollector = RelayStore.getStoreData().getGarbageCollector();\n\n    if (garbageCollector) {\n      garbageCollector.collectFromNode(dataID);\n    }\n  },\n};\n\nfunction scheduler(run: () => boolean): void {\n  const pendingQueryTracker =\n      RelayStore.getStoreData().getPendingQueryTracker();\n  const runIteration = () => {\n    // TODO: #9366746: integrate RelayRenderer/Container with GC hold\n    warning(\n      !pendingQueryTracker.hasPendingQueries(),\n      'RelayGarbageCollection: GC is executing during a fetch, but the ' +\n      'pending query may rely on data that is collected.'\n    );\n    let iterations = 0;\n    let hasNext = true;\n    while (hasNext && (_stepLength < 0 || iterations < _stepLength)) {\n      hasNext = run();\n      iterations++;\n    }\n    // This is effectively a (possibly async) `while` loop\n    if (hasNext) {\n      RelayTaskScheduler.enqueue(runIteration);\n    }\n  };\n  RelayTaskScheduler.enqueue(runIteration);\n}\n\nmodule.exports = RelayGarbageCollection;\n","dependencies":["RelayInternalTypes","RelayStore","RelayTaskScheduler","invariant","warning"],"id":"RelayGarbageCollection","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayGarbageCollection\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayStore = require('RelayStore');\nconst RelayTaskScheduler = require('RelayTaskScheduler');\n\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nlet _stepLength = -1; // collect in a single pass by default\n\n/**\n * Public API for controlling garbage collection of `RelayStoreData`.\n *\n * Provides methods to control the garbage collection of records in\n * `RelayStoreData`.\n */\nvar RelayGarbageCollection = {\n  /**\n   * Initializes garbage collection: must be called before any records are\n   * fetched. When records are collected after calls to `scheduleCollection` or\n   * `scheduleCollectionFromNode`, records are collected in steps, with a\n   * maximum of `stepLength` records traversed in a step. Steps are scheduled\n   * via `RelayTaskScheduler`.\n   */\n  initialize(stepLength: number): void {\n    invariant(\n      stepLength > 0,\n      'RelayGarbageCollection: step length must be greater than zero, got ' +\n      '`%s`.',\n      stepLength\n    );\n    _stepLength = stepLength;\n    RelayStore.getStoreData().initializeGarbageCollector(scheduler);\n  },\n\n  /**\n   * Collects any un-referenced records in the store.\n   */\n  scheduleCollection(): void {\n    var garbageCollector = RelayStore.getStoreData().getGarbageCollector();\n\n    if (garbageCollector) {\n      garbageCollector.collect();\n    }\n  },\n\n  /**\n   * Collects any un-referenced records reachable from the given record via\n   * graph traversal of fields.\n   *\n   * NOTE: If the given record is still referenced, no records are collected.\n   */\n  scheduleCollectionFromNode(dataID: DataID): void {\n    var garbageCollector = RelayStore.getStoreData().getGarbageCollector();\n\n    if (garbageCollector) {\n      garbageCollector.collectFromNode(dataID);\n    }\n  },\n};\n\nfunction scheduler(run: () => boolean): void {\n  const pendingQueryTracker =\n      RelayStore.getStoreData().getPendingQueryTracker();\n  const runIteration = () => {\n    // TODO: #9366746: integrate RelayRenderer/Container with GC hold\n    warning(\n      !pendingQueryTracker.hasPendingQueries(),\n      'RelayGarbageCollection: GC is executing during a fetch, but the ' +\n      'pending query may rely on data that is collected.'\n    );\n    let iterations = 0;\n    let hasNext = true;\n    while (hasNext && (_stepLength < 0 || iterations < _stepLength)) {\n      hasNext = run();\n      iterations++;\n    }\n    // This is effectively a (possibly async) `while` loop\n    if (hasNext) {\n      RelayTaskScheduler.enqueue(runIteration);\n    }\n  };\n  RelayTaskScheduler.enqueue(runIteration);\n}\n\nmodule.exports = RelayGarbageCollection;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayFetchMode.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayFetchMode","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayFetchMode\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nexport type FetchMode = $Keys<typeof RelayFetchMode>;\n\nconst RelayFetchMode = Object.freeze({\n  CLIENT: 'CLIENT',\n  PRELOAD: 'PRELOAD',\n  REFETCH: 'REFETCH',\n});\n\nmodule.exports = RelayFetchMode;\n","dependencies":["RelayFetchMode"],"id":"RelayFetchMode","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayFetchMode\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nexport type FetchMode = $Keys<typeof RelayFetchMode>;\n\nconst RelayFetchMode = Object.freeze({\n  CLIENT: 'CLIENT',\n  PRELOAD: 'PRELOAD',\n  REFETCH: 'REFETCH',\n});\n\nmodule.exports = RelayFetchMode;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayDiskCacheReader.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayDiskCacheReader","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayDiskCacheReader\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayChangeTracker = require('RelayChangeTracker');\nimport type RelayGarbageCollector from 'RelayGarbageCollector';\nimport type {\n  DataID,\n  RelayQuerySet,\n  RootCallMap,\n} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecord = require('RelayRecord');\nimport type {RecordMap} from 'RelayRecord';\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {\n  Abortable,\n  CacheManager,\n  CacheReadCallbacks,\n} from 'RelayTypes';\n\nconst findRelayQueryLeaves = require('findRelayQueryLeaves');\nimport type {\n  PendingItem,\n  PendingNodes,\n} from 'findRelayQueryLeaves';\nconst forEachObject = require('forEachObject');\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst invariant = require('invariant');\nconst isEmpty = require('isEmpty');\n\ntype PendingRoots = {[key: string]: Array<RelayQuery.Root>};\n\n/**\n * @internal\n *\n * Retrieves data for queries or fragments from disk into `cachedRecords`.\n */\nconst RelayDiskCacheReader = {\n  readFragment(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment,\n    path: RelayQueryPath,\n    store: RelayRecordStore,\n    cachedRecords: RecordMap,\n    cachedRootCallMap: RootCallMap,\n    garbageCollector: ?RelayGarbageCollector,\n    cacheManager: CacheManager,\n    changeTracker: RelayChangeTracker,\n    callbacks: CacheReadCallbacks,\n  ): Abortable {\n    var reader = new RelayCacheReader(\n      store,\n      cachedRecords,\n      cachedRootCallMap,\n      garbageCollector,\n      cacheManager,\n      changeTracker,\n      callbacks\n    );\n    reader.readFragment(dataID, fragment, path);\n\n    return {\n      abort() {\n        reader.abort();\n      },\n    };\n  },\n\n  readQueries(\n    queries: RelayQuerySet,\n    store: RelayRecordStore,\n    cachedRecords: RecordMap,\n    cachedRootCallMap: RootCallMap,\n    garbageCollector: ?RelayGarbageCollector,\n    cacheManager: CacheManager,\n    changeTracker: RelayChangeTracker,\n    callbacks: CacheReadCallbacks,\n  ): Abortable {\n    var reader = new RelayCacheReader(\n      store,\n      cachedRecords,\n      cachedRootCallMap,\n      garbageCollector,\n      cacheManager,\n      changeTracker,\n      callbacks\n    );\n    reader.read(queries);\n\n    return {\n      abort() {\n        reader.abort();\n      },\n    };\n  },\n};\n\nclass RelayCacheReader {\n  _store: RelayRecordStore;\n  _cachedRecords: RecordMap;\n  _cachedRootCallMap: RootCallMap;\n  _cacheManager: CacheManager;\n  _callbacks: CacheReadCallbacks;\n  _changeTracker: RelayChangeTracker;\n  _garbageCollector: ?RelayGarbageCollector;\n  _pendingNodes: PendingNodes;\n  _pendingRoots: PendingRoots;\n  _state: 'PENDING' | 'LOADING' | 'COMPLETED';\n\n  constructor(\n    store: RelayRecordStore,\n    cachedRecords: RecordMap,\n    cachedRootCallMap: RootCallMap,\n    garbageCollector: ?RelayGarbageCollector,\n    cacheManager: CacheManager,\n    changeTracker: RelayChangeTracker,\n    callbacks: CacheReadCallbacks,\n  ) {\n    this._store = store;\n    this._cachedRecords = cachedRecords;\n    this._cachedRootCallMap = cachedRootCallMap;\n    this._cacheManager = cacheManager;\n    this._callbacks = callbacks;\n    this._changeTracker = changeTracker;\n    this._garbageCollector = garbageCollector;\n\n    this._pendingNodes = {};\n    this._pendingRoots = {};\n    this._state = 'PENDING';\n  }\n\n  abort(): void {\n    invariant(\n      this._state === 'LOADING',\n      'RelayCacheReader: Can only abort an in-progress read operation.'\n    );\n    this._state = 'COMPLETED';\n  }\n\n  read(queries: RelayQuerySet): void {\n    invariant(\n      this._state === 'PENDING',\n      'RelayCacheReader: A `read` is in progress.'\n    );\n    this._state = 'LOADING';\n    forEachObject(queries, query => {\n      if (this._state === 'COMPLETED') {\n        return;\n      }\n      if (query) {\n        const storageKey = query.getStorageKey();\n        forEachRootCallArg(query, identifyingArgValue => {\n          if (this._state === 'COMPLETED') {\n            return;\n          }\n          identifyingArgValue = identifyingArgValue || '';\n          this.visitRoot(storageKey, identifyingArgValue, query);\n        });\n      }\n    });\n\n    if (this._isDone()) {\n      this._handleSuccess();\n    }\n  }\n\n  readFragment(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment,\n    path: RelayQueryPath\n  ): void {\n    invariant(\n      this._state === 'PENDING',\n      'RelayCacheReader: A `read` is in progress.'\n    );\n    this._state = 'LOADING';\n    this.visitNode(\n      dataID,\n      {\n        node: fragment,\n        path,\n        rangeCalls: undefined,\n      }\n    );\n\n    if (this._isDone()) {\n      this._handleSuccess();\n    }\n  }\n\n  visitRoot(\n    storageKey: string,\n    identifyingArgValue: string,\n    query: RelayQuery.Root\n  ): void {\n    var dataID = this._store.getDataID(storageKey, identifyingArgValue);\n    if (dataID == null) {\n      if (this._cachedRootCallMap.hasOwnProperty(storageKey) &&\n          this._cachedRootCallMap[storageKey].hasOwnProperty(\n            identifyingArgValue\n          )\n      ) {\n        // Already attempted to read this root from cache.\n        this._handleFailed();\n      } else {\n        this.queueRoot(storageKey, identifyingArgValue, query);\n      }\n    } else {\n      this.visitNode(\n        dataID,\n        {\n          node: query,\n          path: new RelayQueryPath(query),\n          rangeCalls: undefined,\n        }\n      );\n    }\n  }\n\n  queueRoot(\n    storageKey: string,\n    identifyingArgValue: string,\n    query: RelayQuery.Root\n  ) {\n    var rootKey = storageKey + '*' + identifyingArgValue;\n    if (this._pendingRoots.hasOwnProperty(rootKey)) {\n      this._pendingRoots[rootKey].push(query);\n    } else {\n      this._pendingRoots[rootKey] = [query];\n      this._cacheManager.readRootCall(\n        storageKey,\n        identifyingArgValue,\n        (error, value) => {\n          if (this._state === 'COMPLETED') {\n            return;\n          }\n          if (error) {\n            this._handleFailed();\n            return;\n          }\n          var roots = this._pendingRoots[rootKey];\n          delete this._pendingRoots[rootKey];\n\n          this._cachedRootCallMap[storageKey] =\n            this._cachedRootCallMap[storageKey] || {};\n          this._cachedRootCallMap[storageKey][identifyingArgValue] = value;\n          if (this._cachedRootCallMap[storageKey][identifyingArgValue] ==\n              null) {\n            // Read from cache and we still don't have valid `dataID`.\n            this._handleFailed();\n          } else {\n            const dataID = value;\n            roots.forEach(root => {\n              if (this._state === 'COMPLETED') {\n                return;\n              }\n              this.visitNode(\n                dataID,\n                {\n                  node: root,\n                  path: new RelayQueryPath(root),\n                  rangeCalls: undefined,\n                }\n              );\n            });\n          }\n          if (this._isDone()) {\n            this._handleSuccess();\n          }\n        }\n      );\n    }\n  }\n\n  visitNode(dataID: DataID, pendingItem: PendingItem): void {\n    var {missingData, pendingNodes} = findRelayQueryLeaves(\n      this._store,\n      this._cachedRecords,\n      pendingItem.node,\n      dataID,\n      pendingItem.path,\n      pendingItem.rangeCalls\n    );\n\n    if (missingData) {\n      this._handleFailed();\n      return;\n    }\n    forEachObject(pendingNodes, (pendingItems, dataID) => {\n      this.queueNode(dataID, pendingItems);\n    });\n  }\n\n  queueNode(dataID: DataID, pendingItems: Array<PendingItem>): void {\n    if (this._pendingNodes.hasOwnProperty(dataID)) {\n      this._pendingNodes[dataID].push(...pendingItems);\n    } else {\n      this._pendingNodes[dataID] = pendingItems;\n      this._cacheManager.readNode(\n        dataID,\n        (error, value) => {\n          if (this._state === 'COMPLETED') {\n            return;\n          }\n          if (error) {\n            this._handleFailed();\n            return;\n          }\n          if (value && RelayRecord.isClientID(dataID)) {\n            value.__path__ = pendingItems[0].path;\n          }\n          // Mark records as created/updated as necessary. Note that if the\n          // record is known to be deleted in the store then it will have been\n          // been marked as created already. Further, it does not need to be\n          // updated since no additional data can be read about a deleted node.\n          const recordState = this._store.getRecordState(dataID);\n          if (recordState === 'UNKNOWN' && value !== undefined) {\n            // Register immediately in case anything tries to read and subscribe\n            // to this record (which means incrementing reference counts).\n            if (this._garbageCollector) {\n              this._garbageCollector.register(dataID);\n            }\n            // Mark as created if the store did not have a value but disk cache\n            // did (either a known value or known deletion).\n            this._changeTracker.createID(dataID);\n          } else if (recordState === 'EXISTENT' && value != null) {\n            // Mark as updated only if a record exists in both the store and\n            // disk cache.\n            this._changeTracker.updateID(dataID);\n          }\n          this._cachedRecords[dataID] = value;\n          var items = this._pendingNodes[dataID];\n          delete this._pendingNodes[dataID];\n          if (this._cachedRecords[dataID] === undefined) {\n            // We are out of luck if disk doesn't have the node either.\n            this._handleFailed();\n          } else {\n            items.forEach(item => {\n              if (this._state === 'COMPLETED') {\n                return;\n              }\n              this.visitNode(dataID, item);\n            });\n          }\n          if (this._isDone()) {\n            this._handleSuccess();\n          }\n        }\n      );\n    }\n  }\n\n  _isDone(): boolean {\n    return (\n      isEmpty(this._pendingRoots) &&\n      isEmpty(this._pendingNodes) &&\n      this._state === 'LOADING'\n    );\n  }\n\n  _handleFailed(): void {\n    invariant(\n      this._state !== 'COMPLETED',\n      'RelayStoreReader: Query set already failed/completed.'\n    );\n\n    this._state = 'COMPLETED';\n    this._callbacks.onFailure && this._callbacks.onFailure();\n  }\n\n  _handleSuccess(): void {\n    invariant(\n      this._state !== 'COMPLETED',\n      'RelayStoreReader: Query set already failed/completed.'\n    );\n\n    this._state = 'COMPLETED';\n    this._callbacks.onSuccess && this._callbacks.onSuccess();\n  }\n\n}\n\nRelayProfiler.instrumentMethods(RelayCacheReader.prototype, {\n  read: 'RelayCacheReader.read',\n  readFragment: 'RelayCacheReader.readFragment',\n  visitRoot: 'RelayCacheReader.visitRoot',\n  queueRoot: 'RelayCacheReader.queueRoot',\n  visitNode: 'RelayCacheReader.visitNode',\n  queueNode: 'RelayCacheReader.queueNode',\n});\n\nmodule.exports = RelayDiskCacheReader;\n","dependencies":["RelayGarbageCollector","RelayInternalTypes","RelayRecord","RelayRecordStore","RelayTypes","findRelayQueryLeaves","RelayChangeTracker","RelayProfiler","RelayQuery","RelayQueryPath","forEachObject","forEachRootCallArg","invariant","isEmpty","RelayDiskCacheReader"],"id":"RelayDiskCacheReader","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayDiskCacheReader\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayChangeTracker = require('RelayChangeTracker');\nimport type RelayGarbageCollector from 'RelayGarbageCollector';\nimport type {\n  DataID,\n  RelayQuerySet,\n  RootCallMap,\n} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nconst RelayRecord = require('RelayRecord');\nimport type {RecordMap} from 'RelayRecord';\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {\n  Abortable,\n  CacheManager,\n  CacheReadCallbacks,\n} from 'RelayTypes';\n\nconst findRelayQueryLeaves = require('findRelayQueryLeaves');\nimport type {\n  PendingItem,\n  PendingNodes,\n} from 'findRelayQueryLeaves';\nconst forEachObject = require('forEachObject');\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst invariant = require('invariant');\nconst isEmpty = require('isEmpty');\n\ntype PendingRoots = {[key: string]: Array<RelayQuery.Root>};\n\n/**\n * @internal\n *\n * Retrieves data for queries or fragments from disk into `cachedRecords`.\n */\nconst RelayDiskCacheReader = {\n  readFragment(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment,\n    path: RelayQueryPath,\n    store: RelayRecordStore,\n    cachedRecords: RecordMap,\n    cachedRootCallMap: RootCallMap,\n    garbageCollector: ?RelayGarbageCollector,\n    cacheManager: CacheManager,\n    changeTracker: RelayChangeTracker,\n    callbacks: CacheReadCallbacks,\n  ): Abortable {\n    var reader = new RelayCacheReader(\n      store,\n      cachedRecords,\n      cachedRootCallMap,\n      garbageCollector,\n      cacheManager,\n      changeTracker,\n      callbacks\n    );\n    reader.readFragment(dataID, fragment, path);\n\n    return {\n      abort() {\n        reader.abort();\n      },\n    };\n  },\n\n  readQueries(\n    queries: RelayQuerySet,\n    store: RelayRecordStore,\n    cachedRecords: RecordMap,\n    cachedRootCallMap: RootCallMap,\n    garbageCollector: ?RelayGarbageCollector,\n    cacheManager: CacheManager,\n    changeTracker: RelayChangeTracker,\n    callbacks: CacheReadCallbacks,\n  ): Abortable {\n    var reader = new RelayCacheReader(\n      store,\n      cachedRecords,\n      cachedRootCallMap,\n      garbageCollector,\n      cacheManager,\n      changeTracker,\n      callbacks\n    );\n    reader.read(queries);\n\n    return {\n      abort() {\n        reader.abort();\n      },\n    };\n  },\n};\n\nclass RelayCacheReader {\n  _store: RelayRecordStore;\n  _cachedRecords: RecordMap;\n  _cachedRootCallMap: RootCallMap;\n  _cacheManager: CacheManager;\n  _callbacks: CacheReadCallbacks;\n  _changeTracker: RelayChangeTracker;\n  _garbageCollector: ?RelayGarbageCollector;\n  _pendingNodes: PendingNodes;\n  _pendingRoots: PendingRoots;\n  _state: 'PENDING' | 'LOADING' | 'COMPLETED';\n\n  constructor(\n    store: RelayRecordStore,\n    cachedRecords: RecordMap,\n    cachedRootCallMap: RootCallMap,\n    garbageCollector: ?RelayGarbageCollector,\n    cacheManager: CacheManager,\n    changeTracker: RelayChangeTracker,\n    callbacks: CacheReadCallbacks,\n  ) {\n    this._store = store;\n    this._cachedRecords = cachedRecords;\n    this._cachedRootCallMap = cachedRootCallMap;\n    this._cacheManager = cacheManager;\n    this._callbacks = callbacks;\n    this._changeTracker = changeTracker;\n    this._garbageCollector = garbageCollector;\n\n    this._pendingNodes = {};\n    this._pendingRoots = {};\n    this._state = 'PENDING';\n  }\n\n  abort(): void {\n    invariant(\n      this._state === 'LOADING',\n      'RelayCacheReader: Can only abort an in-progress read operation.'\n    );\n    this._state = 'COMPLETED';\n  }\n\n  read(queries: RelayQuerySet): void {\n    invariant(\n      this._state === 'PENDING',\n      'RelayCacheReader: A `read` is in progress.'\n    );\n    this._state = 'LOADING';\n    forEachObject(queries, query => {\n      if (this._state === 'COMPLETED') {\n        return;\n      }\n      if (query) {\n        const storageKey = query.getStorageKey();\n        forEachRootCallArg(query, identifyingArgValue => {\n          if (this._state === 'COMPLETED') {\n            return;\n          }\n          identifyingArgValue = identifyingArgValue || '';\n          this.visitRoot(storageKey, identifyingArgValue, query);\n        });\n      }\n    });\n\n    if (this._isDone()) {\n      this._handleSuccess();\n    }\n  }\n\n  readFragment(\n    dataID: DataID,\n    fragment: RelayQuery.Fragment,\n    path: RelayQueryPath\n  ): void {\n    invariant(\n      this._state === 'PENDING',\n      'RelayCacheReader: A `read` is in progress.'\n    );\n    this._state = 'LOADING';\n    this.visitNode(\n      dataID,\n      {\n        node: fragment,\n        path,\n        rangeCalls: undefined,\n      }\n    );\n\n    if (this._isDone()) {\n      this._handleSuccess();\n    }\n  }\n\n  visitRoot(\n    storageKey: string,\n    identifyingArgValue: string,\n    query: RelayQuery.Root\n  ): void {\n    var dataID = this._store.getDataID(storageKey, identifyingArgValue);\n    if (dataID == null) {\n      if (this._cachedRootCallMap.hasOwnProperty(storageKey) &&\n          this._cachedRootCallMap[storageKey].hasOwnProperty(\n            identifyingArgValue\n          )\n      ) {\n        // Already attempted to read this root from cache.\n        this._handleFailed();\n      } else {\n        this.queueRoot(storageKey, identifyingArgValue, query);\n      }\n    } else {\n      this.visitNode(\n        dataID,\n        {\n          node: query,\n          path: new RelayQueryPath(query),\n          rangeCalls: undefined,\n        }\n      );\n    }\n  }\n\n  queueRoot(\n    storageKey: string,\n    identifyingArgValue: string,\n    query: RelayQuery.Root\n  ) {\n    var rootKey = storageKey + '*' + identifyingArgValue;\n    if (this._pendingRoots.hasOwnProperty(rootKey)) {\n      this._pendingRoots[rootKey].push(query);\n    } else {\n      this._pendingRoots[rootKey] = [query];\n      this._cacheManager.readRootCall(\n        storageKey,\n        identifyingArgValue,\n        (error, value) => {\n          if (this._state === 'COMPLETED') {\n            return;\n          }\n          if (error) {\n            this._handleFailed();\n            return;\n          }\n          var roots = this._pendingRoots[rootKey];\n          delete this._pendingRoots[rootKey];\n\n          this._cachedRootCallMap[storageKey] =\n            this._cachedRootCallMap[storageKey] || {};\n          this._cachedRootCallMap[storageKey][identifyingArgValue] = value;\n          if (this._cachedRootCallMap[storageKey][identifyingArgValue] ==\n              null) {\n            // Read from cache and we still don't have valid `dataID`.\n            this._handleFailed();\n          } else {\n            const dataID = value;\n            roots.forEach(root => {\n              if (this._state === 'COMPLETED') {\n                return;\n              }\n              this.visitNode(\n                dataID,\n                {\n                  node: root,\n                  path: new RelayQueryPath(root),\n                  rangeCalls: undefined,\n                }\n              );\n            });\n          }\n          if (this._isDone()) {\n            this._handleSuccess();\n          }\n        }\n      );\n    }\n  }\n\n  visitNode(dataID: DataID, pendingItem: PendingItem): void {\n    var {missingData, pendingNodes} = findRelayQueryLeaves(\n      this._store,\n      this._cachedRecords,\n      pendingItem.node,\n      dataID,\n      pendingItem.path,\n      pendingItem.rangeCalls\n    );\n\n    if (missingData) {\n      this._handleFailed();\n      return;\n    }\n    forEachObject(pendingNodes, (pendingItems, dataID) => {\n      this.queueNode(dataID, pendingItems);\n    });\n  }\n\n  queueNode(dataID: DataID, pendingItems: Array<PendingItem>): void {\n    if (this._pendingNodes.hasOwnProperty(dataID)) {\n      this._pendingNodes[dataID].push(...pendingItems);\n    } else {\n      this._pendingNodes[dataID] = pendingItems;\n      this._cacheManager.readNode(\n        dataID,\n        (error, value) => {\n          if (this._state === 'COMPLETED') {\n            return;\n          }\n          if (error) {\n            this._handleFailed();\n            return;\n          }\n          if (value && RelayRecord.isClientID(dataID)) {\n            value.__path__ = pendingItems[0].path;\n          }\n          // Mark records as created/updated as necessary. Note that if the\n          // record is known to be deleted in the store then it will have been\n          // been marked as created already. Further, it does not need to be\n          // updated since no additional data can be read about a deleted node.\n          const recordState = this._store.getRecordState(dataID);\n          if (recordState === 'UNKNOWN' && value !== undefined) {\n            // Register immediately in case anything tries to read and subscribe\n            // to this record (which means incrementing reference counts).\n            if (this._garbageCollector) {\n              this._garbageCollector.register(dataID);\n            }\n            // Mark as created if the store did not have a value but disk cache\n            // did (either a known value or known deletion).\n            this._changeTracker.createID(dataID);\n          } else if (recordState === 'EXISTENT' && value != null) {\n            // Mark as updated only if a record exists in both the store and\n            // disk cache.\n            this._changeTracker.updateID(dataID);\n          }\n          this._cachedRecords[dataID] = value;\n          var items = this._pendingNodes[dataID];\n          delete this._pendingNodes[dataID];\n          if (this._cachedRecords[dataID] === undefined) {\n            // We are out of luck if disk doesn't have the node either.\n            this._handleFailed();\n          } else {\n            items.forEach(item => {\n              if (this._state === 'COMPLETED') {\n                return;\n              }\n              this.visitNode(dataID, item);\n            });\n          }\n          if (this._isDone()) {\n            this._handleSuccess();\n          }\n        }\n      );\n    }\n  }\n\n  _isDone(): boolean {\n    return (\n      isEmpty(this._pendingRoots) &&\n      isEmpty(this._pendingNodes) &&\n      this._state === 'LOADING'\n    );\n  }\n\n  _handleFailed(): void {\n    invariant(\n      this._state !== 'COMPLETED',\n      'RelayStoreReader: Query set already failed/completed.'\n    );\n\n    this._state = 'COMPLETED';\n    this._callbacks.onFailure && this._callbacks.onFailure();\n  }\n\n  _handleSuccess(): void {\n    invariant(\n      this._state !== 'COMPLETED',\n      'RelayStoreReader: Query set already failed/completed.'\n    );\n\n    this._state = 'COMPLETED';\n    this._callbacks.onSuccess && this._callbacks.onSuccess();\n  }\n\n}\n\nRelayProfiler.instrumentMethods(RelayCacheReader.prototype, {\n  read: 'RelayCacheReader.read',\n  readFragment: 'RelayCacheReader.readFragment',\n  visitRoot: 'RelayCacheReader.visitRoot',\n  queueRoot: 'RelayCacheReader.queueRoot',\n  visitNode: 'RelayCacheReader.visitNode',\n  queueNode: 'RelayCacheReader.queueNode',\n});\n\nmodule.exports = RelayDiskCacheReader;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayContext.js":{"metadata":{"mtime":1456103379000},"data":{"name":"RelayContext","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayContext\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nimport type RelayMutation from 'RelayMutation';\nimport type RelayMutationTransaction from 'RelayMutationTransaction';\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryResultObservable = require('RelayQueryResultObservable');\nconst RelayStoreData = require('RelayStoreData');\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst readRelayQueryData = require('readRelayQueryData');\nconst relayUnstableBatchedUpdates = require('relayUnstableBatchedUpdates');\nconst warning = require('warning');\n\nimport type {\n  Abortable,\n  Observable,\n  RelayMutationTransactionCommitCallbacks,\n  ReadyStateChangeCallback,\n  StoreReaderData,\n  StoreReaderOptions,\n} from 'RelayTypes';\n\nimport type {\n  DataID,\n  RelayQuerySet,\n} from 'RelayInternalTypes';\n\nexport type FragmentResolver = {\n  dispose: () => void;\n  resolve: (\n    fragment: RelayQuery.Fragment,\n    dataIDs: DataID | Array<DataID>\n  ) => ?(StoreReaderData | Array<?StoreReaderData>);\n};\n\nexport type RelayContextInterface = {\n  forceFetch: (\n    querySet: RelayQuerySet,\n    onReadyStateChange: ReadyStateChangeCallback\n  ) => Abortable;\n  getFragmentResolver: (\n    fragment: RelayQuery.Fragment,\n    onNext: () => void\n  ) => FragmentResolver;\n  getStoreData: () => RelayStoreData;\n  primeCache: (\n    querySet: RelayQuerySet,\n    onReadyStateChange: ReadyStateChangeCallback\n  ) => Abortable;\n};\n\n/**\n * @public\n *\n * RelayContext is a caching layer that records GraphQL response data and\n * enables resolving and subscribing to queries.\n *\n * === onReadyStateChange ===\n *\n * Whenever Relay sends a request for data via GraphQL, an \"onReadyStateChange\"\n * callback can be supplied. This callback is called one or more times with a\n * `readyState` object with the following properties:\n *\n *   aborted: Whether the request was aborted.\n *   done: Whether all response data has been fetched.\n *   error: An error in the event of a failure, or null if none.\n *   ready: Whether the queries are at least partially resolvable.\n *   stale: When resolvable during `forceFetch`, whether data is stale.\n *\n * If the callback is invoked with `aborted`, `done`, or a non-null `error`, the\n * callback will never be called again. Example usage:\n *\n *  function onReadyStateChange(readyState) {\n *    if (readyState.aborted) {\n *      // Request was aborted.\n *    } else if (readyState.error) {\n *      // Failure occurred.\n *    } else if (readyState.ready) {\n *      // Queries are at least partially resolvable.\n *      if (readyState.done) {\n *        // Queries are completely resolvable.\n *      }\n *    }\n *  }\n *\n */\nclass RelayContext {\n  _storeData: RelayStoreData;\n\n  constructor() {\n    this._storeData = new RelayStoreData();\n    this._storeData.getChangeEmitter().injectBatchingStrategy(\n      relayUnstableBatchedUpdates\n    );\n  }\n\n  /**\n   * @internal\n   */\n  getStoreData(): RelayStoreData {\n    return this._storeData;\n  }\n\n  /**\n   * Primes the store by sending requests for any missing data that would be\n   * required to satisfy the supplied set of queries.\n   */\n  primeCache(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback\n  ): Abortable {\n    return this._storeData.getQueryRunner().run(querySet, callback);\n  }\n\n  /**\n   * Forces the supplied set of queries to be fetched and written to the store.\n   * Any data that previously satisfied the queries will be overwritten.\n   */\n  forceFetch(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback\n  ): Abortable {\n    return this._storeData.getQueryRunner().forceFetch(querySet, callback);\n  }\n\n  /**\n   * Reads query data anchored at the supplied data ID.\n   */\n  read(\n    node: RelayQuery.Node,\n    dataID: DataID,\n    options?: StoreReaderOptions\n  ): ?StoreReaderData {\n    return readRelayQueryData(this._storeData, node, dataID, options).data;\n  }\n\n  /**\n   * Reads query data anchored at the supplied data IDs.\n   */\n  readAll(\n    node: RelayQuery.Node,\n    dataIDs: Array<DataID>,\n    options?: StoreReaderOptions\n  ): Array<?StoreReaderData> {\n    return dataIDs.map(\n      dataID => readRelayQueryData(this._storeData, node, dataID, options).data\n    );\n  }\n\n  /**\n   * Reads query data, where each element in the result array corresponds to a\n   * root call argument. If the root call has no arguments, the result array\n   * will contain exactly one element.\n   */\n  readQuery(\n    root: RelayQuery.Root,\n    options?: StoreReaderOptions\n  ): Array<?StoreReaderData> {\n    const queuedStore = this._storeData.getQueuedStore();\n    const storageKey = root.getStorageKey();\n    var results = [];\n    forEachRootCallArg(root, identifyingArgValue => {\n      let data;\n      const dataID = queuedStore.getDataID(storageKey, identifyingArgValue);\n      if (dataID != null) {\n        data = this.read(root, dataID, options);\n      }\n      results.push(data);\n    });\n    return results;\n  }\n\n  /**\n   * Reads and subscribes to query data anchored at the supplied data ID. The\n   * returned observable emits updates as the data changes over time.\n   */\n  observe(\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): Observable<?StoreReaderData> {\n    return new RelayQueryResultObservable(this._storeData, fragment, dataID);\n  }\n\n  /**\n   * @internal\n   *\n   * Returns a fragment \"resolver\" - a subscription to the results of a fragment\n   * and a means to access the latest results. This is a transitional API and\n   * not recommended for general use.\n   */\n  getFragmentResolver(\n    fragment: RelayQuery.Fragment,\n    onNext: () => void\n  ): FragmentResolver {\n    return new GraphQLStoreQueryResolver(\n      this._storeData,\n      fragment,\n      onNext\n    );\n  }\n\n  /**\n   * Adds an update to the store without committing it. The returned\n   * RelayMutationTransaction can be committed or rolled back at a later time.\n   */\n  applyUpdate(\n    mutation: RelayMutation,\n    callbacks?: RelayMutationTransactionCommitCallbacks\n  ): RelayMutationTransaction {\n    return this._storeData.getMutationQueue().createTransaction(\n      mutation,\n      callbacks\n    );\n  }\n\n  /**\n   * Adds an update to the store and commits it immediately. Returns\n   * the RelayMutationTransaction.\n   */\n  commitUpdate(\n    mutation: RelayMutation,\n    callbacks?: RelayMutationTransactionCommitCallbacks\n  ): RelayMutationTransaction {\n    const transaction = this.applyUpdate(mutation, callbacks);\n    transaction.commit();\n    return transaction;\n  }\n\n  /**\n   * @deprecated\n   *\n   * Method renamed to commitUpdate\n   */\n  update(\n    mutation: RelayMutation,\n    callbacks?: RelayMutationTransactionCommitCallbacks\n  ): void {\n    warning(\n      false,\n      '`Relay.Store.update` is deprecated. Please use' +\n      ' `Relay.Store.commitUpdate` or `Relay.Store.applyUpdate` instead.'\n    );\n    this.commitUpdate(mutation, callbacks);\n  }\n}\n\nmodule.exports = RelayContext;\n","dependencies":["RelayMutation","RelayMutationTransaction","RelayQuery","RelayTypes","RelayInternalTypes","GraphQLStoreQueryResolver","RelayQueryResultObservable","RelayStoreData","forEachRootCallArg","readRelayQueryData","relayUnstableBatchedUpdates","warning","RelayContext"],"id":"RelayContext","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayContext\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst GraphQLStoreQueryResolver = require('GraphQLStoreQueryResolver');\nimport type RelayMutation from 'RelayMutation';\nimport type RelayMutationTransaction from 'RelayMutationTransaction';\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryResultObservable = require('RelayQueryResultObservable');\nconst RelayStoreData = require('RelayStoreData');\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst readRelayQueryData = require('readRelayQueryData');\nconst relayUnstableBatchedUpdates = require('relayUnstableBatchedUpdates');\nconst warning = require('warning');\n\nimport type {\n  Abortable,\n  Observable,\n  RelayMutationTransactionCommitCallbacks,\n  ReadyStateChangeCallback,\n  StoreReaderData,\n  StoreReaderOptions,\n} from 'RelayTypes';\n\nimport type {\n  DataID,\n  RelayQuerySet,\n} from 'RelayInternalTypes';\n\nexport type FragmentResolver = {\n  dispose: () => void;\n  resolve: (\n    fragment: RelayQuery.Fragment,\n    dataIDs: DataID | Array<DataID>\n  ) => ?(StoreReaderData | Array<?StoreReaderData>);\n};\n\nexport type RelayContextInterface = {\n  forceFetch: (\n    querySet: RelayQuerySet,\n    onReadyStateChange: ReadyStateChangeCallback\n  ) => Abortable;\n  getFragmentResolver: (\n    fragment: RelayQuery.Fragment,\n    onNext: () => void\n  ) => FragmentResolver;\n  getStoreData: () => RelayStoreData;\n  primeCache: (\n    querySet: RelayQuerySet,\n    onReadyStateChange: ReadyStateChangeCallback\n  ) => Abortable;\n};\n\n/**\n * @public\n *\n * RelayContext is a caching layer that records GraphQL response data and\n * enables resolving and subscribing to queries.\n *\n * === onReadyStateChange ===\n *\n * Whenever Relay sends a request for data via GraphQL, an \"onReadyStateChange\"\n * callback can be supplied. This callback is called one or more times with a\n * `readyState` object with the following properties:\n *\n *   aborted: Whether the request was aborted.\n *   done: Whether all response data has been fetched.\n *   error: An error in the event of a failure, or null if none.\n *   ready: Whether the queries are at least partially resolvable.\n *   stale: When resolvable during `forceFetch`, whether data is stale.\n *\n * If the callback is invoked with `aborted`, `done`, or a non-null `error`, the\n * callback will never be called again. Example usage:\n *\n *  function onReadyStateChange(readyState) {\n *    if (readyState.aborted) {\n *      // Request was aborted.\n *    } else if (readyState.error) {\n *      // Failure occurred.\n *    } else if (readyState.ready) {\n *      // Queries are at least partially resolvable.\n *      if (readyState.done) {\n *        // Queries are completely resolvable.\n *      }\n *    }\n *  }\n *\n */\nclass RelayContext {\n  _storeData: RelayStoreData;\n\n  constructor() {\n    this._storeData = new RelayStoreData();\n    this._storeData.getChangeEmitter().injectBatchingStrategy(\n      relayUnstableBatchedUpdates\n    );\n  }\n\n  /**\n   * @internal\n   */\n  getStoreData(): RelayStoreData {\n    return this._storeData;\n  }\n\n  /**\n   * Primes the store by sending requests for any missing data that would be\n   * required to satisfy the supplied set of queries.\n   */\n  primeCache(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback\n  ): Abortable {\n    return this._storeData.getQueryRunner().run(querySet, callback);\n  }\n\n  /**\n   * Forces the supplied set of queries to be fetched and written to the store.\n   * Any data that previously satisfied the queries will be overwritten.\n   */\n  forceFetch(\n    querySet: RelayQuerySet,\n    callback: ReadyStateChangeCallback\n  ): Abortable {\n    return this._storeData.getQueryRunner().forceFetch(querySet, callback);\n  }\n\n  /**\n   * Reads query data anchored at the supplied data ID.\n   */\n  read(\n    node: RelayQuery.Node,\n    dataID: DataID,\n    options?: StoreReaderOptions\n  ): ?StoreReaderData {\n    return readRelayQueryData(this._storeData, node, dataID, options).data;\n  }\n\n  /**\n   * Reads query data anchored at the supplied data IDs.\n   */\n  readAll(\n    node: RelayQuery.Node,\n    dataIDs: Array<DataID>,\n    options?: StoreReaderOptions\n  ): Array<?StoreReaderData> {\n    return dataIDs.map(\n      dataID => readRelayQueryData(this._storeData, node, dataID, options).data\n    );\n  }\n\n  /**\n   * Reads query data, where each element in the result array corresponds to a\n   * root call argument. If the root call has no arguments, the result array\n   * will contain exactly one element.\n   */\n  readQuery(\n    root: RelayQuery.Root,\n    options?: StoreReaderOptions\n  ): Array<?StoreReaderData> {\n    const queuedStore = this._storeData.getQueuedStore();\n    const storageKey = root.getStorageKey();\n    var results = [];\n    forEachRootCallArg(root, identifyingArgValue => {\n      let data;\n      const dataID = queuedStore.getDataID(storageKey, identifyingArgValue);\n      if (dataID != null) {\n        data = this.read(root, dataID, options);\n      }\n      results.push(data);\n    });\n    return results;\n  }\n\n  /**\n   * Reads and subscribes to query data anchored at the supplied data ID. The\n   * returned observable emits updates as the data changes over time.\n   */\n  observe(\n    fragment: RelayQuery.Fragment,\n    dataID: DataID\n  ): Observable<?StoreReaderData> {\n    return new RelayQueryResultObservable(this._storeData, fragment, dataID);\n  }\n\n  /**\n   * @internal\n   *\n   * Returns a fragment \"resolver\" - a subscription to the results of a fragment\n   * and a means to access the latest results. This is a transitional API and\n   * not recommended for general use.\n   */\n  getFragmentResolver(\n    fragment: RelayQuery.Fragment,\n    onNext: () => void\n  ): FragmentResolver {\n    return new GraphQLStoreQueryResolver(\n      this._storeData,\n      fragment,\n      onNext\n    );\n  }\n\n  /**\n   * Adds an update to the store without committing it. The returned\n   * RelayMutationTransaction can be committed or rolled back at a later time.\n   */\n  applyUpdate(\n    mutation: RelayMutation,\n    callbacks?: RelayMutationTransactionCommitCallbacks\n  ): RelayMutationTransaction {\n    return this._storeData.getMutationQueue().createTransaction(\n      mutation,\n      callbacks\n    );\n  }\n\n  /**\n   * Adds an update to the store and commits it immediately. Returns\n   * the RelayMutationTransaction.\n   */\n  commitUpdate(\n    mutation: RelayMutation,\n    callbacks?: RelayMutationTransactionCommitCallbacks\n  ): RelayMutationTransaction {\n    const transaction = this.applyUpdate(mutation, callbacks);\n    transaction.commit();\n    return transaction;\n  }\n\n  /**\n   * @deprecated\n   *\n   * Method renamed to commitUpdate\n   */\n  update(\n    mutation: RelayMutation,\n    callbacks?: RelayMutationTransactionCommitCallbacks\n  ): void {\n    warning(\n      false,\n      '`Relay.Store.update` is deprecated. Please use' +\n      ' `Relay.Store.commitUpdate` or `Relay.Store.applyUpdate` instead.'\n    );\n    this.commitUpdate(mutation, callbacks);\n  }\n}\n\nmodule.exports = RelayContext;\n"}}},"/Users/cpojer/Projects/relay/src/store/RelayChangeTracker.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayChangeTracker","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayChangeTracker\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\n\ntype ChangeMap = {[key: string]: boolean};\n\nexport type ChangeSet = {\n  created: ChangeMap;\n  updated: ChangeMap;\n};\n\n/**\n * @internal\n *\n * Keeps track of records that have been created or updated; used primarily to\n * record changes during the course of a `write` operation.\n */\nclass RelayChangeTracker {\n  _created: ChangeMap;\n  _updated: ChangeMap;\n\n  constructor() {\n    this._created = {};\n    this._updated = {};\n  }\n\n  /**\n   * Record the creation of a record.\n   */\n  createID(recordID: DataID): void {\n    this._created[recordID] = true;\n  }\n\n  /**\n   * Record an update to a record.\n   */\n  updateID(recordID: DataID): void {\n    if (!this._created.hasOwnProperty(recordID)) {\n      this._updated[recordID] = true;\n    }\n  }\n\n  /**\n   * Determine if the record has any changes (was created or updated).\n   */\n  hasChange(recordID: DataID): boolean {\n    return !!(this._updated[recordID] || this._created[recordID]);\n  }\n\n  /**\n   * Determine if the record was created.\n   */\n  isNewRecord(recordID: DataID): boolean {\n    return !!this._created[recordID];\n  }\n\n  /**\n   * Get the ids of records that were created/updated.\n   */\n  getChangeSet(): ChangeSet {\n    if (__DEV__) {\n      return {\n        created: Object.freeze(this._created),\n        updated: Object.freeze(this._updated),\n      };\n    }\n    return {\n      created: this._created,\n      updated: this._updated,\n    };\n  }\n}\n\nmodule.exports = RelayChangeTracker;\n","dependencies":["RelayInternalTypes","RelayChangeTracker"],"id":"RelayChangeTracker","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayChangeTracker\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type {DataID} from 'RelayInternalTypes';\n\ntype ChangeMap = {[key: string]: boolean};\n\nexport type ChangeSet = {\n  created: ChangeMap;\n  updated: ChangeMap;\n};\n\n/**\n * @internal\n *\n * Keeps track of records that have been created or updated; used primarily to\n * record changes during the course of a `write` operation.\n */\nclass RelayChangeTracker {\n  _created: ChangeMap;\n  _updated: ChangeMap;\n\n  constructor() {\n    this._created = {};\n    this._updated = {};\n  }\n\n  /**\n   * Record the creation of a record.\n   */\n  createID(recordID: DataID): void {\n    this._created[recordID] = true;\n  }\n\n  /**\n   * Record an update to a record.\n   */\n  updateID(recordID: DataID): void {\n    if (!this._created.hasOwnProperty(recordID)) {\n      this._updated[recordID] = true;\n    }\n  }\n\n  /**\n   * Determine if the record has any changes (was created or updated).\n   */\n  hasChange(recordID: DataID): boolean {\n    return !!(this._updated[recordID] || this._created[recordID]);\n  }\n\n  /**\n   * Determine if the record was created.\n   */\n  isNewRecord(recordID: DataID): boolean {\n    return !!this._created[recordID];\n  }\n\n  /**\n   * Get the ids of records that were created/updated.\n   */\n  getChangeSet(): ChangeSet {\n    if (__DEV__) {\n      return {\n        created: Object.freeze(this._created),\n        updated: Object.freeze(this._updated),\n      };\n    }\n    return {\n      created: this._created,\n      updated: this._updated,\n    };\n  }\n}\n\nmodule.exports = RelayChangeTracker;\n"}}},"/Users/cpojer/Projects/relay/src/store/readRelayQueryData.js":{"metadata":{"mtime":1456103379000},"data":{"name":"readRelayQueryData","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule readRelayQueryData\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nimport type GraphQLStoreRangeUtils from 'GraphQLStoreRangeUtils';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayRecord = require('RelayRecord');\nconst RelayRecordState = require('RelayRecordState');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nimport type RelayStoreData from 'RelayStoreData';\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\nimport type {\n  StoreReaderData,\n  StoreReaderOptions,\n} from 'RelayTypes';\n\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst callsToGraphQL = require('callsToGraphQL');\nconst invariant = require('invariant');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\nconst validateRelayReadQuery = require('validateRelayReadQuery');\n\nexport type DataIDSet = {[key: string]: boolean};\nexport type StoreReaderResult = {\n  data: ?StoreReaderData;\n  dataIDs: DataIDSet;\n};\n\ntype State = {\n  componentDataID: ?DataID;\n  data: mixed;\n  isPartial: boolean;\n  parent: ?RelayQuery.Field;\n  rangeInfo: ?RangeInfo;\n  seenDataIDs: DataIDSet;\n  storeDataID: DataID;\n};\n\nvar {EDGES, PAGE_INFO} = RelayConnectionInterface;\nconst METADATA_KEYS = [\n  '__status__',\n  '__resolvedFragmentMapGeneration__',\n];\n\n/**\n * @internal\n *\n * Retrieves data from the `RelayStore`.\n */\nfunction readRelayQueryData(\n  storeData: RelayStoreData,\n  queryNode: RelayQuery.Node,\n  dataID: DataID,\n  options?: StoreReaderOptions\n): StoreReaderResult {\n  var reader = new RelayStoreReader(storeData, options);\n  var data = reader.retrieveData(queryNode, dataID);\n\n  // We validate only after retrieving the data, to give our `invariant`\n  // checks below a chance to fail fast.\n  validateRelayReadQuery(queryNode, options);\n\n  return data;\n}\n\nclass RelayStoreReader extends RelayQueryVisitor<State> {\n  _rangeData: GraphQLStoreRangeUtils;\n  _recordStore: RelayRecordStore;\n  _storeData: RelayStoreData;\n  _traverseFragmentReferences: boolean;\n  _traverseGeneratedFields: boolean;\n\n  constructor(\n    storeData: RelayStoreData,\n    options?: StoreReaderOptions\n  ) {\n    super();\n    this._rangeData = storeData.getRangeData();\n    this._recordStore = storeData.getQueuedStore();\n    this._traverseFragmentReferences =\n      (options && options.traverseFragmentReferences) || false;\n    this._traverseGeneratedFields =\n      (options && options.traverseGeneratedFields) || false;\n  }\n\n  /**\n   * Runs `queryNode` against the data in `dataID` and returns the result.\n   */\n  retrieveData(\n    queryNode: RelayQuery.Node,\n    dataID: DataID\n  ): StoreReaderResult {\n    var result = {\n      data: (undefined: $FlowIssue),\n      dataIDs: {},\n    };\n    var rangeData = this._rangeData.parseRangeClientID(dataID);\n    var status = this._recordStore.getRecordState(\n      rangeData ? rangeData.dataID : dataID\n    );\n    if (status === RelayRecordState.EXISTENT) {\n      var state = {\n        componentDataID: null,\n        data: undefined,\n        isPartial: false,\n        parent: null,\n        rangeInfo: null,\n        seenDataIDs: result.dataIDs,\n        storeDataID: dataID,\n      };\n      this.visit(queryNode, state);\n      result.data = state.data;\n    } else if (status === RelayRecordState.NONEXISTENT) {\n      result.data = null;\n    }\n    return result;\n  }\n\n  visitField(node: RelayQuery.Field, state: State): void {\n    // Check for range client IDs (eg. `someID_first(25)`) and unpack if\n    // present, overriding `state`.\n    this._handleRangeInfo(node, state);\n\n    if (node.canHaveSubselections() || node.isGenerated()) {\n      // Make sure we return at least the __dataID__.\n      getDataObject(state);\n    }\n\n    if (node.isGenerated() && !this._traverseGeneratedFields) {\n      return;\n    }\n    var rangeInfo = state.rangeInfo;\n    if (\n      rangeInfo &&\n      node.getSchemaName() === EDGES\n    ) {\n      this._readEdges(node, rangeInfo, state);\n    } else if (\n      rangeInfo &&\n      node.getSchemaName() === PAGE_INFO\n    ) {\n      this._readPageInfo(node, rangeInfo, state);\n    } else if (!node.canHaveSubselections()) {\n      this._readScalar(node, state);\n    } else if (node.isPlural()) {\n      this._readPlural(node, state);\n    } else if (node.isConnection()) {\n      this._readConnection(node, state);\n    } else {\n      this._readLinkedField(node, state);\n    }\n    state.seenDataIDs[state.storeDataID] = true;\n  }\n\n  visitFragment(node: RelayQuery.Fragment, state: State): void {\n    const dataID = getComponentDataID(state);\n    if (node.isContainerFragment() && !this._traverseFragmentReferences) {\n      state.seenDataIDs[dataID] = true;\n      const data = getDataObject(state);\n      RelayFragmentPointer.addFragment(data, node, dataID);\n      this._setMetadataFields(state); // deferred fragment generation, etc\n    } else if (isCompatibleRelayFragmentType(\n      node,\n      this._recordStore.getType(dataID)\n    )) {\n      this.traverse(node, state);\n    }\n  }\n\n  _readScalar(node: RelayQuery.Field, state: State): void {\n    var storageKey = node.getStorageKey();\n    var field = this._recordStore.getField(state.storeDataID, storageKey);\n    if (field === undefined) {\n      state.isPartial = true;\n      return;\n    } else if (field === null && !state.data) {\n      state.data = null;\n    } else {\n      this._setDataValue(\n        state,\n        node.getApplicationName(),\n        Array.isArray(field) ? field.slice() : field\n      );\n    }\n  }\n\n  _readPlural(node: RelayQuery.Field, state: State): void {\n    var storageKey = node.getStorageKey();\n    var dataIDs =\n      this._recordStore.getLinkedRecordIDs(state.storeDataID, storageKey);\n    if (dataIDs) {\n      var applicationName = node.getApplicationName();\n      var previousData = getDataValue(state, applicationName);\n      var nextData = dataIDs.map((dataID, ii) => {\n        var data;\n        if (previousData instanceof Object) {\n          data = previousData[ii];\n        }\n        var nextState = {\n          componentDataID: null,\n          data,\n          isPartial: false,\n          parent: node,\n          rangeInfo: null,\n          seenDataIDs: state.seenDataIDs,\n          storeDataID: dataID,\n        };\n        node.getChildren().forEach(child => this.visit(child, nextState));\n        if (nextState.isPartial) {\n          state.isPartial = true;\n        }\n        return nextState.data;\n      });\n      this._setDataValue(state, applicationName, nextData);\n    }\n  }\n\n  _readConnection(node: RelayQuery.Field, state: State): void {\n    var applicationName = node.getApplicationName();\n    var storageKey = node.getStorageKey();\n    var calls = node.getCallsWithValues();\n    var dataID = this._recordStore.getLinkedRecordID(\n      state.storeDataID,\n      storageKey\n    );\n    if (!dataID) {\n      state.isPartial = true;\n      return;\n    }\n    enforceRangeCalls(node);\n    var metadata = this._recordStore.getRangeMetadata(dataID, calls);\n    var nextState = {\n      componentDataID: this._getConnectionClientID(node, dataID),\n      data: getDataValue(state, applicationName),\n      isPartial: false,\n      parent: node,\n      rangeInfo: metadata && calls.length ? metadata : null,\n      seenDataIDs: state.seenDataIDs,\n      storeDataID: dataID,\n    };\n    this.traverse(node, nextState);\n    if (nextState.isPartial) {\n      state.isPartial = true;\n    }\n    this._setDataValue(state, applicationName, nextState.data);\n  }\n\n  _readEdges(node: RelayQuery.Field, rangeInfo: RangeInfo, state: State): void {\n    if (rangeInfo.diffCalls.length) {\n      state.isPartial = true;\n    }\n    var previousData = getDataValue(state, EDGES);\n    var edges = rangeInfo.filteredEdges.map((edgeData, ii) => {\n      var data;\n      if (previousData instanceof Object) {\n        data = previousData[ii];\n      }\n      var nextState = {\n        componentDataID: null,\n        data,\n        isPartial: false,\n        parent: node,\n        rangeInfo: null,\n        seenDataIDs: state.seenDataIDs,\n        storeDataID: edgeData.edgeID,\n      };\n      this.traverse(node, nextState);\n      if (nextState.isPartial) {\n        state.isPartial = true;\n      }\n      return nextState.data;\n    });\n    this._setDataValue(state, EDGES, edges);\n  }\n\n  _readPageInfo(\n    node: RelayQuery.Field,\n    rangeInfo: RangeInfo,\n    state: State\n  ): void {\n    var {pageInfo} = rangeInfo;\n    invariant(\n      pageInfo,\n      'readRelayQueryData(): Missing field, `%s`.',\n      PAGE_INFO\n    );\n    if (rangeInfo.diffCalls.length) {\n      state.isPartial = true;\n    }\n    var info = pageInfo; // for Flow\n    var nextData;\n\n    // Page info comes from the range metadata, so we do a custom traversal here\n    // which is simpler than passing through page-info-related state as a hint\n    // for the normal traversal.\n    var read = child => {\n      if (child instanceof RelayQuery.Fragment) {\n        if (child.isContainerFragment() && !this._traverseFragmentReferences) {\n          const dataID = getComponentDataID(state);\n          nextData = nextData || {};\n          RelayFragmentPointer.addFragment(\n            nextData,\n            child,\n            dataID\n          );\n        } else {\n          child.getChildren().forEach(read);\n        }\n      } else {\n        var field: RelayQuery.Field = (child: any);\n        if (!field.isGenerated() || this._traverseGeneratedFields) {\n          nextData = nextData || {};\n          nextData[field.getApplicationName()] = info[field.getStorageKey()];\n        }\n      }\n    };\n    node.getChildren().forEach(read);\n\n    this._setDataValue(\n      state,\n      PAGE_INFO,\n      nextData\n    );\n  }\n\n  _readLinkedField(node: RelayQuery.Field, state: State): void {\n    var storageKey = node.getStorageKey();\n    var applicationName = node.getApplicationName();\n    var dataID = this._recordStore.getLinkedRecordID(\n      state.storeDataID, storageKey\n    );\n    if (dataID == null) {\n      if (dataID === undefined) {\n        state.isPartial = true;\n      }\n      this._setDataValue(state, applicationName, dataID);\n      return;\n    }\n    var nextState = {\n      componentDataID: null,\n      data: getDataValue(state, applicationName),\n      isPartial: false,\n      parent: node,\n      rangeInfo: null,\n      seenDataIDs: state.seenDataIDs,\n      storeDataID: dataID,\n    };\n    var status = this._recordStore.getRecordState(dataID);\n    if (status === RelayRecordState.EXISTENT) {\n      // Make sure we return at least the __dataID__.\n      getDataObject(nextState);\n    }\n    this.traverse(node, nextState);\n    if (nextState.isPartial) {\n      state.isPartial = true;\n    }\n    this._setDataValue(state, applicationName, nextState.data);\n  }\n\n  /**\n   * Assigns `value` to the property of `state.data` identified by `key`.\n   *\n   * Pre-populates `state` with a suitable `data` object if needed, and copies\n   * over any metadata fields, if present.\n   */\n  _setDataValue(state: State, key: string, value: mixed): void {\n    var data = getDataObject(state); // ensure __dataID__\n    if (value === undefined) {\n      return;\n    }\n    data[key] = value;\n    this._setMetadataFields(state);\n  }\n\n  _setMetadataFields(state: State): void {\n    var data = getDataObject(state); // ensure __dataID__\n    // Copy metadata like `__resolvedFragmentMapGeneration__` and `__status__`.\n    METADATA_KEYS.forEach(metadataKey => {\n      const metadataValue = this._recordStore.getField(\n        state.storeDataID,\n        metadataKey\n      );\n      if (metadataValue != null) {\n        data[metadataKey] = metadataValue;\n      }\n    });\n    // Set the partial bit after metadata has been copied over.\n    if (state.isPartial) {\n      data.__status__ =\n        RelayRecordStatusMap.setPartialStatus(data.__status__, true);\n    }\n  }\n\n  /**\n   * Obtains a client ID (eg. `someDataID_first(10)`) for the connection\n   * identified by `connectionID`. If there are no range calls on the supplied\n   * `node`, then a call-less connection ID (eg. `someDataID`) will be returned\n   * instead.\n   */\n  _getConnectionClientID(\n    node: RelayQuery.Field,\n    connectionID: DataID\n  ): DataID {\n    var calls = node.getCallsWithValues();\n    if (!RelayConnectionInterface.hasRangeCalls(calls)) {\n      return connectionID;\n    }\n    return this._rangeData.getClientIDForRangeWithID(\n      callsToGraphQL(calls),\n      {},\n      connectionID\n    );\n  }\n\n  /**\n   * Checks to see if we have a range client ID (eg. `someID_first(25)`), and if\n   * so, unpacks the range metadata, stashing it into (and overriding) `state`.\n   */\n  _handleRangeInfo(node: RelayQuery.Field, state: State): void {\n    var rangeData = this._rangeData.parseRangeClientID(\n      state.storeDataID\n    );\n    if (rangeData != null) {\n      state.componentDataID = state.storeDataID;\n      state.storeDataID = rangeData.dataID;\n      state.rangeInfo = this._recordStore.getRangeMetadata(\n        state.storeDataID,\n        callsFromGraphQL(rangeData.calls, rangeData.callValues)\n      );\n    }\n  }\n}\n\n/**\n * Checks that `parent` either has range calls on it or does not contain either\n * `page_info` or `edges` fields. This enforcement intentionally transcends\n * traverseFragmentReferences boundaries.\n */\nfunction enforceRangeCalls(parent: RelayQuery.Field): void {\n  if (!parent.__hasValidatedConnectionCalls__) {\n    var calls = parent.getCallsWithValues();\n    if (!RelayConnectionInterface.hasRangeCalls(calls)) {\n      rangeCallEnforcer.traverse(parent, parent);\n    }\n    parent.__hasValidatedConnectionCalls__ = true;\n  }\n}\nclass RelayRangeCallEnforcer extends RelayQueryVisitor<RelayQuery.Field> {\n  visitField(\n    node: RelayQuery.Field,\n    parent: RelayQuery.Field\n  ): void {\n    var schemaName = node.getSchemaName();\n    invariant(\n      schemaName !== EDGES &&\n      schemaName !== PAGE_INFO,\n      'readRelayQueryData(): The field `%s` is a connection. Fields `%s` and ' +\n      '`%s` cannot be fetched without a `first`, `last` or `find` argument.',\n      parent.getApplicationName(),\n      EDGES,\n      PAGE_INFO\n    );\n  }\n}\nvar rangeCallEnforcer = new RelayRangeCallEnforcer();\n\n/**\n * Returns the component-specific DataID stored in `state`, falling back to the\n * generic \"store\" DataID.\n *\n * For most nodes, the generic \"store\" DataID can be used for both reading out\n * of the store and writing into the result object that will be passed back to\n * the component. For connections with range calls on them the \"store\" and\n * \"component\" ID will be different because the component needs a special\n * client-ID that encodes the range calls.\n */\nfunction getComponentDataID(state: State): DataID {\n  if (state.componentDataID != null) {\n    return state.componentDataID;\n  } else {\n    return state.storeDataID;\n  }\n}\n\n/**\n * Retrieves `state.data`, initializing it if necessary.\n */\nfunction getDataObject(state: State): Object {\n  var data = state.data;\n  if (!data) {\n    data = state.data = RelayRecord.create(getComponentDataID(state));\n  }\n  invariant(\n    data instanceof Object,\n    'readRelayQueryData(): Unable to read field on non-object.'\n  );\n  return data;\n}\n\n/**\n * Looks up the value identified by `key` in `state.data`.\n *\n * Pre-populates `state` with a suitable `data` objects if needed.\n */\nfunction getDataValue(state: State, key: string): mixed {\n  var data = getDataObject(state);\n  return data[key];\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'readRelayQueryData',\n  readRelayQueryData\n);\n","dependencies":["GraphQLStoreRangeUtils","RelayInternalTypes","RelayStoreData","RelayRecordStore","RelayTypes","RelayFragmentPointer","RelayConnectionInterface","RelayProfiler","RelayQuery","RelayQueryVisitor","RelayRecord","RelayRecordState","RelayRecordStatusMap","callsFromGraphQL","callsToGraphQL","invariant","isCompatibleRelayFragmentType","validateRelayReadQuery","readRelayQueryData"],"id":"readRelayQueryData","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule readRelayQueryData\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayFragmentPointer = require('RelayFragmentPointer');\nimport type GraphQLStoreRangeUtils from 'GraphQLStoreRangeUtils';\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayRecord = require('RelayRecord');\nconst RelayRecordState = require('RelayRecordState');\nconst RelayRecordStatusMap = require('RelayRecordStatusMap');\nimport type RelayStoreData from 'RelayStoreData';\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\nimport type {\n  StoreReaderData,\n  StoreReaderOptions,\n} from 'RelayTypes';\n\nconst callsFromGraphQL = require('callsFromGraphQL');\nconst callsToGraphQL = require('callsToGraphQL');\nconst invariant = require('invariant');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\nconst validateRelayReadQuery = require('validateRelayReadQuery');\n\nexport type DataIDSet = {[key: string]: boolean};\nexport type StoreReaderResult = {\n  data: ?StoreReaderData;\n  dataIDs: DataIDSet;\n};\n\ntype State = {\n  componentDataID: ?DataID;\n  data: mixed;\n  isPartial: boolean;\n  parent: ?RelayQuery.Field;\n  rangeInfo: ?RangeInfo;\n  seenDataIDs: DataIDSet;\n  storeDataID: DataID;\n};\n\nvar {EDGES, PAGE_INFO} = RelayConnectionInterface;\nconst METADATA_KEYS = [\n  '__status__',\n  '__resolvedFragmentMapGeneration__',\n];\n\n/**\n * @internal\n *\n * Retrieves data from the `RelayStore`.\n */\nfunction readRelayQueryData(\n  storeData: RelayStoreData,\n  queryNode: RelayQuery.Node,\n  dataID: DataID,\n  options?: StoreReaderOptions\n): StoreReaderResult {\n  var reader = new RelayStoreReader(storeData, options);\n  var data = reader.retrieveData(queryNode, dataID);\n\n  // We validate only after retrieving the data, to give our `invariant`\n  // checks below a chance to fail fast.\n  validateRelayReadQuery(queryNode, options);\n\n  return data;\n}\n\nclass RelayStoreReader extends RelayQueryVisitor<State> {\n  _rangeData: GraphQLStoreRangeUtils;\n  _recordStore: RelayRecordStore;\n  _storeData: RelayStoreData;\n  _traverseFragmentReferences: boolean;\n  _traverseGeneratedFields: boolean;\n\n  constructor(\n    storeData: RelayStoreData,\n    options?: StoreReaderOptions\n  ) {\n    super();\n    this._rangeData = storeData.getRangeData();\n    this._recordStore = storeData.getQueuedStore();\n    this._traverseFragmentReferences =\n      (options && options.traverseFragmentReferences) || false;\n    this._traverseGeneratedFields =\n      (options && options.traverseGeneratedFields) || false;\n  }\n\n  /**\n   * Runs `queryNode` against the data in `dataID` and returns the result.\n   */\n  retrieveData(\n    queryNode: RelayQuery.Node,\n    dataID: DataID\n  ): StoreReaderResult {\n    var result = {\n      data: (undefined: $FlowIssue),\n      dataIDs: {},\n    };\n    var rangeData = this._rangeData.parseRangeClientID(dataID);\n    var status = this._recordStore.getRecordState(\n      rangeData ? rangeData.dataID : dataID\n    );\n    if (status === RelayRecordState.EXISTENT) {\n      var state = {\n        componentDataID: null,\n        data: undefined,\n        isPartial: false,\n        parent: null,\n        rangeInfo: null,\n        seenDataIDs: result.dataIDs,\n        storeDataID: dataID,\n      };\n      this.visit(queryNode, state);\n      result.data = state.data;\n    } else if (status === RelayRecordState.NONEXISTENT) {\n      result.data = null;\n    }\n    return result;\n  }\n\n  visitField(node: RelayQuery.Field, state: State): void {\n    // Check for range client IDs (eg. `someID_first(25)`) and unpack if\n    // present, overriding `state`.\n    this._handleRangeInfo(node, state);\n\n    if (node.canHaveSubselections() || node.isGenerated()) {\n      // Make sure we return at least the __dataID__.\n      getDataObject(state);\n    }\n\n    if (node.isGenerated() && !this._traverseGeneratedFields) {\n      return;\n    }\n    var rangeInfo = state.rangeInfo;\n    if (\n      rangeInfo &&\n      node.getSchemaName() === EDGES\n    ) {\n      this._readEdges(node, rangeInfo, state);\n    } else if (\n      rangeInfo &&\n      node.getSchemaName() === PAGE_INFO\n    ) {\n      this._readPageInfo(node, rangeInfo, state);\n    } else if (!node.canHaveSubselections()) {\n      this._readScalar(node, state);\n    } else if (node.isPlural()) {\n      this._readPlural(node, state);\n    } else if (node.isConnection()) {\n      this._readConnection(node, state);\n    } else {\n      this._readLinkedField(node, state);\n    }\n    state.seenDataIDs[state.storeDataID] = true;\n  }\n\n  visitFragment(node: RelayQuery.Fragment, state: State): void {\n    const dataID = getComponentDataID(state);\n    if (node.isContainerFragment() && !this._traverseFragmentReferences) {\n      state.seenDataIDs[dataID] = true;\n      const data = getDataObject(state);\n      RelayFragmentPointer.addFragment(data, node, dataID);\n      this._setMetadataFields(state); // deferred fragment generation, etc\n    } else if (isCompatibleRelayFragmentType(\n      node,\n      this._recordStore.getType(dataID)\n    )) {\n      this.traverse(node, state);\n    }\n  }\n\n  _readScalar(node: RelayQuery.Field, state: State): void {\n    var storageKey = node.getStorageKey();\n    var field = this._recordStore.getField(state.storeDataID, storageKey);\n    if (field === undefined) {\n      state.isPartial = true;\n      return;\n    } else if (field === null && !state.data) {\n      state.data = null;\n    } else {\n      this._setDataValue(\n        state,\n        node.getApplicationName(),\n        Array.isArray(field) ? field.slice() : field\n      );\n    }\n  }\n\n  _readPlural(node: RelayQuery.Field, state: State): void {\n    var storageKey = node.getStorageKey();\n    var dataIDs =\n      this._recordStore.getLinkedRecordIDs(state.storeDataID, storageKey);\n    if (dataIDs) {\n      var applicationName = node.getApplicationName();\n      var previousData = getDataValue(state, applicationName);\n      var nextData = dataIDs.map((dataID, ii) => {\n        var data;\n        if (previousData instanceof Object) {\n          data = previousData[ii];\n        }\n        var nextState = {\n          componentDataID: null,\n          data,\n          isPartial: false,\n          parent: node,\n          rangeInfo: null,\n          seenDataIDs: state.seenDataIDs,\n          storeDataID: dataID,\n        };\n        node.getChildren().forEach(child => this.visit(child, nextState));\n        if (nextState.isPartial) {\n          state.isPartial = true;\n        }\n        return nextState.data;\n      });\n      this._setDataValue(state, applicationName, nextData);\n    }\n  }\n\n  _readConnection(node: RelayQuery.Field, state: State): void {\n    var applicationName = node.getApplicationName();\n    var storageKey = node.getStorageKey();\n    var calls = node.getCallsWithValues();\n    var dataID = this._recordStore.getLinkedRecordID(\n      state.storeDataID,\n      storageKey\n    );\n    if (!dataID) {\n      state.isPartial = true;\n      return;\n    }\n    enforceRangeCalls(node);\n    var metadata = this._recordStore.getRangeMetadata(dataID, calls);\n    var nextState = {\n      componentDataID: this._getConnectionClientID(node, dataID),\n      data: getDataValue(state, applicationName),\n      isPartial: false,\n      parent: node,\n      rangeInfo: metadata && calls.length ? metadata : null,\n      seenDataIDs: state.seenDataIDs,\n      storeDataID: dataID,\n    };\n    this.traverse(node, nextState);\n    if (nextState.isPartial) {\n      state.isPartial = true;\n    }\n    this._setDataValue(state, applicationName, nextState.data);\n  }\n\n  _readEdges(node: RelayQuery.Field, rangeInfo: RangeInfo, state: State): void {\n    if (rangeInfo.diffCalls.length) {\n      state.isPartial = true;\n    }\n    var previousData = getDataValue(state, EDGES);\n    var edges = rangeInfo.filteredEdges.map((edgeData, ii) => {\n      var data;\n      if (previousData instanceof Object) {\n        data = previousData[ii];\n      }\n      var nextState = {\n        componentDataID: null,\n        data,\n        isPartial: false,\n        parent: node,\n        rangeInfo: null,\n        seenDataIDs: state.seenDataIDs,\n        storeDataID: edgeData.edgeID,\n      };\n      this.traverse(node, nextState);\n      if (nextState.isPartial) {\n        state.isPartial = true;\n      }\n      return nextState.data;\n    });\n    this._setDataValue(state, EDGES, edges);\n  }\n\n  _readPageInfo(\n    node: RelayQuery.Field,\n    rangeInfo: RangeInfo,\n    state: State\n  ): void {\n    var {pageInfo} = rangeInfo;\n    invariant(\n      pageInfo,\n      'readRelayQueryData(): Missing field, `%s`.',\n      PAGE_INFO\n    );\n    if (rangeInfo.diffCalls.length) {\n      state.isPartial = true;\n    }\n    var info = pageInfo; // for Flow\n    var nextData;\n\n    // Page info comes from the range metadata, so we do a custom traversal here\n    // which is simpler than passing through page-info-related state as a hint\n    // for the normal traversal.\n    var read = child => {\n      if (child instanceof RelayQuery.Fragment) {\n        if (child.isContainerFragment() && !this._traverseFragmentReferences) {\n          const dataID = getComponentDataID(state);\n          nextData = nextData || {};\n          RelayFragmentPointer.addFragment(\n            nextData,\n            child,\n            dataID\n          );\n        } else {\n          child.getChildren().forEach(read);\n        }\n      } else {\n        var field: RelayQuery.Field = (child: any);\n        if (!field.isGenerated() || this._traverseGeneratedFields) {\n          nextData = nextData || {};\n          nextData[field.getApplicationName()] = info[field.getStorageKey()];\n        }\n      }\n    };\n    node.getChildren().forEach(read);\n\n    this._setDataValue(\n      state,\n      PAGE_INFO,\n      nextData\n    );\n  }\n\n  _readLinkedField(node: RelayQuery.Field, state: State): void {\n    var storageKey = node.getStorageKey();\n    var applicationName = node.getApplicationName();\n    var dataID = this._recordStore.getLinkedRecordID(\n      state.storeDataID, storageKey\n    );\n    if (dataID == null) {\n      if (dataID === undefined) {\n        state.isPartial = true;\n      }\n      this._setDataValue(state, applicationName, dataID);\n      return;\n    }\n    var nextState = {\n      componentDataID: null,\n      data: getDataValue(state, applicationName),\n      isPartial: false,\n      parent: node,\n      rangeInfo: null,\n      seenDataIDs: state.seenDataIDs,\n      storeDataID: dataID,\n    };\n    var status = this._recordStore.getRecordState(dataID);\n    if (status === RelayRecordState.EXISTENT) {\n      // Make sure we return at least the __dataID__.\n      getDataObject(nextState);\n    }\n    this.traverse(node, nextState);\n    if (nextState.isPartial) {\n      state.isPartial = true;\n    }\n    this._setDataValue(state, applicationName, nextState.data);\n  }\n\n  /**\n   * Assigns `value` to the property of `state.data` identified by `key`.\n   *\n   * Pre-populates `state` with a suitable `data` object if needed, and copies\n   * over any metadata fields, if present.\n   */\n  _setDataValue(state: State, key: string, value: mixed): void {\n    var data = getDataObject(state); // ensure __dataID__\n    if (value === undefined) {\n      return;\n    }\n    data[key] = value;\n    this._setMetadataFields(state);\n  }\n\n  _setMetadataFields(state: State): void {\n    var data = getDataObject(state); // ensure __dataID__\n    // Copy metadata like `__resolvedFragmentMapGeneration__` and `__status__`.\n    METADATA_KEYS.forEach(metadataKey => {\n      const metadataValue = this._recordStore.getField(\n        state.storeDataID,\n        metadataKey\n      );\n      if (metadataValue != null) {\n        data[metadataKey] = metadataValue;\n      }\n    });\n    // Set the partial bit after metadata has been copied over.\n    if (state.isPartial) {\n      data.__status__ =\n        RelayRecordStatusMap.setPartialStatus(data.__status__, true);\n    }\n  }\n\n  /**\n   * Obtains a client ID (eg. `someDataID_first(10)`) for the connection\n   * identified by `connectionID`. If there are no range calls on the supplied\n   * `node`, then a call-less connection ID (eg. `someDataID`) will be returned\n   * instead.\n   */\n  _getConnectionClientID(\n    node: RelayQuery.Field,\n    connectionID: DataID\n  ): DataID {\n    var calls = node.getCallsWithValues();\n    if (!RelayConnectionInterface.hasRangeCalls(calls)) {\n      return connectionID;\n    }\n    return this._rangeData.getClientIDForRangeWithID(\n      callsToGraphQL(calls),\n      {},\n      connectionID\n    );\n  }\n\n  /**\n   * Checks to see if we have a range client ID (eg. `someID_first(25)`), and if\n   * so, unpacks the range metadata, stashing it into (and overriding) `state`.\n   */\n  _handleRangeInfo(node: RelayQuery.Field, state: State): void {\n    var rangeData = this._rangeData.parseRangeClientID(\n      state.storeDataID\n    );\n    if (rangeData != null) {\n      state.componentDataID = state.storeDataID;\n      state.storeDataID = rangeData.dataID;\n      state.rangeInfo = this._recordStore.getRangeMetadata(\n        state.storeDataID,\n        callsFromGraphQL(rangeData.calls, rangeData.callValues)\n      );\n    }\n  }\n}\n\n/**\n * Checks that `parent` either has range calls on it or does not contain either\n * `page_info` or `edges` fields. This enforcement intentionally transcends\n * traverseFragmentReferences boundaries.\n */\nfunction enforceRangeCalls(parent: RelayQuery.Field): void {\n  if (!parent.__hasValidatedConnectionCalls__) {\n    var calls = parent.getCallsWithValues();\n    if (!RelayConnectionInterface.hasRangeCalls(calls)) {\n      rangeCallEnforcer.traverse(parent, parent);\n    }\n    parent.__hasValidatedConnectionCalls__ = true;\n  }\n}\nclass RelayRangeCallEnforcer extends RelayQueryVisitor<RelayQuery.Field> {\n  visitField(\n    node: RelayQuery.Field,\n    parent: RelayQuery.Field\n  ): void {\n    var schemaName = node.getSchemaName();\n    invariant(\n      schemaName !== EDGES &&\n      schemaName !== PAGE_INFO,\n      'readRelayQueryData(): The field `%s` is a connection. Fields `%s` and ' +\n      '`%s` cannot be fetched without a `first`, `last` or `find` argument.',\n      parent.getApplicationName(),\n      EDGES,\n      PAGE_INFO\n    );\n  }\n}\nvar rangeCallEnforcer = new RelayRangeCallEnforcer();\n\n/**\n * Returns the component-specific DataID stored in `state`, falling back to the\n * generic \"store\" DataID.\n *\n * For most nodes, the generic \"store\" DataID can be used for both reading out\n * of the store and writing into the result object that will be passed back to\n * the component. For connections with range calls on them the \"store\" and\n * \"component\" ID will be different because the component needs a special\n * client-ID that encodes the range calls.\n */\nfunction getComponentDataID(state: State): DataID {\n  if (state.componentDataID != null) {\n    return state.componentDataID;\n  } else {\n    return state.storeDataID;\n  }\n}\n\n/**\n * Retrieves `state.data`, initializing it if necessary.\n */\nfunction getDataObject(state: State): Object {\n  var data = state.data;\n  if (!data) {\n    data = state.data = RelayRecord.create(getComponentDataID(state));\n  }\n  invariant(\n    data instanceof Object,\n    'readRelayQueryData(): Unable to read field on non-object.'\n  );\n  return data;\n}\n\n/**\n * Looks up the value identified by `key` in `state.data`.\n *\n * Pre-populates `state` with a suitable `data` objects if needed.\n */\nfunction getDataValue(state: State, key: string): mixed {\n  var data = getDataObject(state);\n  return data[key];\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'readRelayQueryData',\n  readRelayQueryData\n);\n"}}},"/Users/cpojer/Projects/relay/src/store/isRelayContext.js":{"metadata":{"mtime":1456103379000},"data":{"name":"isRelayContext","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isRelayContext\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * Determine if a given value is an object that implements the `RelayContext`\n * interface.\n */\nfunction isRelayContext(context: mixed): boolean {\n  return (\n    typeof context === 'object' &&\n    context !== null &&\n    typeof context.forceFetch === 'function' &&\n    typeof context.getFragmentResolver === 'function' &&\n    typeof context.getStoreData === 'function' &&\n    typeof context.primeCache === 'function'\n  );\n}\n\nmodule.exports = isRelayContext;\n","dependencies":["isRelayContext"],"id":"isRelayContext","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isRelayContext\n * @typechecks\n * @flow\n */\n\n'use strict';\n\n/**\n * Determine if a given value is an object that implements the `RelayContext`\n * interface.\n */\nfunction isRelayContext(context: mixed): boolean {\n  return (\n    typeof context === 'object' &&\n    context !== null &&\n    typeof context.forceFetch === 'function' &&\n    typeof context.getFragmentResolver === 'function' &&\n    typeof context.getStoreData === 'function' &&\n    typeof context.primeCache === 'function'\n  );\n}\n\nmodule.exports = isRelayContext;\n"}}},"/Users/cpojer/Projects/relay/src/store/filterExclusiveKeys.js":{"metadata":{"mtime":1455679339000},"data":{"name":"filterExclusiveKeys","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule filterExclusiveKeys\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Returns two arrays of keys that contain each object's exclusive keys.\n */\nfunction filterExclusiveKeys(\n  a: ?Object,\n  b: ?Object\n): [Array<string>, Array<string>] {\n  var keysA = a ? Object.keys(a) : [];\n  var keysB = b ? Object.keys(b) : [];\n\n  if (keysA.length === 0 ||\n      keysB.length === 0) {\n    return [keysA, keysB];\n  }\n  return [\n    keysA.filter(key => !hasOwnProperty.call(b, key)),\n    keysB.filter(key => !hasOwnProperty.call(a, key)),\n  ];\n}\n\nmodule.exports = filterExclusiveKeys;\n","dependencies":["filterExclusiveKeys"],"id":"filterExclusiveKeys","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule filterExclusiveKeys\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Returns two arrays of keys that contain each object's exclusive keys.\n */\nfunction filterExclusiveKeys(\n  a: ?Object,\n  b: ?Object\n): [Array<string>, Array<string>] {\n  var keysA = a ? Object.keys(a) : [];\n  var keysB = b ? Object.keys(b) : [];\n\n  if (keysA.length === 0 ||\n      keysB.length === 0) {\n    return [keysA, keysB];\n  }\n  return [\n    keysA.filter(key => !hasOwnProperty.call(b, key)),\n    keysB.filter(key => !hasOwnProperty.call(a, key)),\n  ];\n}\n\nmodule.exports = filterExclusiveKeys;\n"}}},"/Users/cpojer/Projects/relay/src/tools/testEditDistance.js":{"metadata":{"mtime":1455679339000},"data":{"name":"testEditDistance","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule testEditDistance\n * @flow\n * @typechecks\n *\n */\n\n/**\n * @internal\n *\n * Determines whether the edit distance between two strings is at or below the\n * specified threshold distance, using the approach described by Ukkonen (1985)\n * in \"Algorithms for Approximate String Matching\"[0] and then improved upon by\n * Berghel and Roach (1996) in \"An Extension of Ukkonen's Enhanced Dynamic\n * Programming ASM Algorithm\"[1].\n *\n * Given two strings of length `m` and `n` respectively, and threshold `t`,\n * uses `O(t*min(m,n))` time and `O(min(t,m,n))` space.\n *\n * @see [0]: http://www.cs.helsinki.fi/u/ukkonen/InfCont85.PDF\n * @see [1]: http://berghel.net/publications/asm/asm.pdf\n */\nfunction testEditDistance(a: string, b: string, threshold: number): boolean {\n  // Ensure `b` is at least as long as `a`, swapping if necessary.\n  let m = a.length;\n  let n = b.length;\n  if (n < m) {\n    [n, m] = [m, n];\n    [b, a] = [a, b];\n  }\n  if (!m) {\n    return n <= threshold;\n  }\n\n  const zeroK = n;\n  const maxK = zeroK * 2 + 1;\n  const fkp = Array.from(Array(maxK), () => []);\n\n  for (let k = -zeroK; k < 0; k++) {\n    const p = -k - 1;\n    fkp[k + zeroK][p + 1] = -k - 1;\n    fkp[k + zeroK][p] = -Infinity;\n  }\n  fkp[zeroK][0] = -1;\n  for (let k = 1; k <= zeroK; k++) {\n    const p = k - 1;\n    fkp[k + zeroK][p + 1] = -1;\n    fkp[k + zeroK][p] = -Infinity;\n  }\n\n  // This loop is the alternative form suggested in the afterword of Berghel &\n  // Roach.\n  let p = n - m - 1;\n  do {\n    if (p > threshold) {\n      return false;\n    }\n    p++;\n    for (let i = Math.floor((p - (n - m)) / 2); i >= 1; i--) {\n      f(n - m + i, p - i);\n    }\n    for (let i = Math.floor((n - m + p) / 2); i >= 1; i--) {\n      f(n - m - i, p - i);\n    }\n    f(n - m, p);\n  } while (fkp[n - m + zeroK][p] !== m);\n\n  return true;\n\n  function f(k, p) {\n    let t = fkp[k + zeroK][p] + 1;\n    let t2 = t;\n\n    // Check for transposed characters.\n    if (a[t - 1] === b[k + t] && a[t] === b[k + t - 1]) {\n      t2 = t + 1;\n    }\n\n    t = Math.max(\n      t,\n      fkp[k - 1 + zeroK][p],\n      fkp[k + 1 + zeroK][p] + 1,\n      t2\n    );\n\n    while (a[t] === b[t + k] && t < Math.min(m, n - k)) {\n      t++;\n    }\n    fkp[k + zeroK][p + 1] = t;\n  }\n}\n\nmodule.exports = testEditDistance;\n","dependencies":["testEditDistance"],"id":"testEditDistance","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule testEditDistance\n * @flow\n * @typechecks\n *\n */\n\n/**\n * @internal\n *\n * Determines whether the edit distance between two strings is at or below the\n * specified threshold distance, using the approach described by Ukkonen (1985)\n * in \"Algorithms for Approximate String Matching\"[0] and then improved upon by\n * Berghel and Roach (1996) in \"An Extension of Ukkonen's Enhanced Dynamic\n * Programming ASM Algorithm\"[1].\n *\n * Given two strings of length `m` and `n` respectively, and threshold `t`,\n * uses `O(t*min(m,n))` time and `O(min(t,m,n))` space.\n *\n * @see [0]: http://www.cs.helsinki.fi/u/ukkonen/InfCont85.PDF\n * @see [1]: http://berghel.net/publications/asm/asm.pdf\n */\nfunction testEditDistance(a: string, b: string, threshold: number): boolean {\n  // Ensure `b` is at least as long as `a`, swapping if necessary.\n  let m = a.length;\n  let n = b.length;\n  if (n < m) {\n    [n, m] = [m, n];\n    [b, a] = [a, b];\n  }\n  if (!m) {\n    return n <= threshold;\n  }\n\n  const zeroK = n;\n  const maxK = zeroK * 2 + 1;\n  const fkp = Array.from(Array(maxK), () => []);\n\n  for (let k = -zeroK; k < 0; k++) {\n    const p = -k - 1;\n    fkp[k + zeroK][p + 1] = -k - 1;\n    fkp[k + zeroK][p] = -Infinity;\n  }\n  fkp[zeroK][0] = -1;\n  for (let k = 1; k <= zeroK; k++) {\n    const p = k - 1;\n    fkp[k + zeroK][p + 1] = -1;\n    fkp[k + zeroK][p] = -Infinity;\n  }\n\n  // This loop is the alternative form suggested in the afterword of Berghel &\n  // Roach.\n  let p = n - m - 1;\n  do {\n    if (p > threshold) {\n      return false;\n    }\n    p++;\n    for (let i = Math.floor((p - (n - m)) / 2); i >= 1; i--) {\n      f(n - m + i, p - i);\n    }\n    for (let i = Math.floor((n - m + p) / 2); i >= 1; i--) {\n      f(n - m - i, p - i);\n    }\n    f(n - m, p);\n  } while (fkp[n - m + zeroK][p] !== m);\n\n  return true;\n\n  function f(k, p) {\n    let t = fkp[k + zeroK][p] + 1;\n    let t2 = t;\n\n    // Check for transposed characters.\n    if (a[t - 1] === b[k + t] && a[t] === b[k + t - 1]) {\n      t2 = t + 1;\n    }\n\n    t = Math.max(\n      t,\n      fkp[k - 1 + zeroK][p],\n      fkp[k + 1 + zeroK][p] + 1,\n      t2\n    );\n\n    while (a[t] === b[t + k] && t < Math.min(m, n - k)) {\n      t++;\n    }\n    fkp[k + zeroK][p + 1] = t;\n  }\n}\n\nmodule.exports = testEditDistance;\n"}}},"/Users/cpojer/Projects/relay/src/tools/relayUnstableBatchedUpdates.js":{"metadata":{"mtime":1455679339000},"data":{"name":"relayUnstableBatchedUpdates","isHaste":true,"moduleData":{"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule relayUnstableBatchedUpdates\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst ReactDOM = require('ReactDOM');\n\nmodule.exports = ReactDOM.unstable_batchedUpdates;\n","dependencies":["ReactDOM","relayUnstableBatchedUpdates"],"id":"relayUnstableBatchedUpdates","source":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule relayUnstableBatchedUpdates\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst ReactDOM = require('ReactDOM');\n\nmodule.exports = ReactDOM.unstable_batchedUpdates;\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayTypes.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayTypes","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayTypes\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Types that Relay framework users may find useful.\n */\nimport type URI from 'URI';\nimport type {\n  DataID,\n  FieldValue,\n} from 'RelayInternalTypes';\nimport type RelayFragmentReference from 'RelayFragmentReference';\nimport type RelayMetaRoute from 'RelayMetaRoute';\nimport type RelayMutationTransaction from 'RelayMutationTransaction';\nimport type {Record} from 'RelayRecord';\nimport type {RelayConcreteNode} from 'RelayQL';\n\n// Routes and variables\nexport type Variables = {[name: string]: mixed};\n\n// Ready state\nexport type ComponentReadyState = {\n  aborted: boolean;\n  done: boolean;\n  error: ?Error;\n  mounted: boolean;\n  ready: boolean;\n  stale: boolean;\n};\nexport type ComponentReadyStateChangeCallback =\n  (readyState: ComponentReadyState) => void;\n\nexport type ComponentFetchState = {\n  done: boolean;\n  stale: boolean;\n};\n\nexport type ReadyState = {\n  aborted: boolean;\n  done: boolean;\n  error: ?Error;\n  ready: boolean;\n  stale: boolean;\n};\nexport type ReadyStateChangeCallback = (readyState: ReadyState) => void;\n\n// Containers\nexport type RelayContainer = ReactClass<any, any, any>;\n\nexport type RelayProp = {\n  forceFetch: (\n    partialVariables?: ?Variables,\n    callback?: ?ComponentReadyStateChangeCallback\n  ) => void,\n  getPendingTransactions: (record: Object) => ?Array<RelayMutationTransaction>,\n  hasFragmentData: (\n    fragmentReference: RelayFragmentReference,\n    record: Object\n  ) => boolean,\n  hasOptimisticUpdate: (\n    record: Object\n  ) => boolean,\n  hasPartialData: (\n    record: Object\n  ) => boolean,\n  route: RelayMetaRoute,\n  setVariables: (\n    partialVariables?: ?Variables,\n    callback?: ?ComponentReadyStateChangeCallback\n  ) => void,\n  variables: Variables,\n};\n\n// Mutations\nexport type RelayMutationTransactionCommitFailureCallback = (\n  transaction: RelayMutationTransaction,\n  preventAutoRollback: () => void,\n) => void;\nexport type RelayMutationTransactionCommitSuccessCallback = (\n  response: {[key: string]: Object}\n) => void;\nexport type RelayMutationTransactionCommitCallbacks = {\n  onFailure?: ?RelayMutationTransactionCommitFailureCallback;\n  onSuccess?: ?RelayMutationTransactionCommitSuccessCallback;\n};\nexport type RelayMutationConfig = {\n  type: 'FIELDS_CHANGE',\n  fieldIDs: {[fieldName: string]: DataID | Array<DataID>},\n} | {\n  type: 'RANGE_ADD',\n  parentName: string,\n  parentID: string,\n  connectionName: string,\n  edgeName: string,\n  // from GraphQLMutatorConstants.RANGE_OPERATIONS\n  rangeBehaviors: {[call: string]: 'append' | 'prepend' | 'remove'},\n} | {\n  type: 'NODE_DELETE',\n  parentName: string;\n  parentID: string;\n  connectionName: string;\n  deletedIDFieldName: string;\n} | {\n  type: 'RANGE_DELETE';\n  parentName: string;\n  parentID: string;\n  connectionName: string;\n  deletedIDFieldName: string;\n  pathToConnection: Array<string>;\n} | {\n  type: 'REQUIRED_CHILDREN',\n  children: Array<RelayConcreteNode>,\n};\n\n// Observable\nexport type Observable<T> = {\n  subscribe: (callbacks: SubscriptionCallbacks<T>) => Subscription;\n};\n\nexport type MultiObservable<T> = {\n  subscribe: (callbacks: SubscriptionCallbacks<Array<T>>) => Subscription;\n  setDataIDs: (dataIDs: Array<DataID>) => void;\n};\n\nexport type Subscription = {\n  dispose(): void;\n};\n\nexport type SubscriptionCallbacks<T> = {\n  onNext: ((value: T) => void);\n  onError: ((error: Error) => void);\n  onCompleted: (() => void);\n};\n\n// Store\nexport type StoreReaderData = Object;\nexport type StoreReaderOptions = {\n  traverseFragmentReferences?: boolean;\n  traverseGeneratedFields?: boolean;\n};\n\n// Disk Cache\nexport type CacheManager = {\n  clear: () => void;\n  getMutationWriter: () => CacheWriter;\n  getQueryWriter: () => CacheWriter;\n  readNode: (\n    id: DataID,\n    callback: (error: any, value: any) => void\n  ) => void;\n   readRootCall: (\n    callName: string,\n    callValue: string,\n    callback: (error: any, value: any) => void\n  ) => void;\n};\n\nexport type CacheReadCallbacks = {\n  onSuccess?: () => void;\n  onFailure?: () => void;\n};\n\nexport type CacheWriter = {\n  writeField: (\n    dataID: DataID,\n    field: string,\n    value: ?FieldValue,\n    typeName: ?string\n  ) => void;\n  writeNode: (dataID: DataID, record: ?Record) => void;\n  writeRootCall: (\n    storageKey: string,\n    identifyingArgValue: string,\n    dataID: DataID\n  ) => void;\n};\n\n// Network requests\nexport type RequestOptions = {\n  data?: ?{[key: string]: mixed};\n  errorHandler?: ?(error: XHRErrorData) => void;\n  headers?: ?{[key: string]: string};\n  method: string;\n  rawData?: mixed;\n  responseHandler?: ?(\n    responseText: string,\n    responseHeaders: ?string,\n    isComplete: boolean\n  ) => void;\n  timeout?: ?number;\n  timeoutHandler?: ?() => void;\n  transportBuilder?: any;\n  uri: URI;\n};\ntype XHRErrorData = {\n  errorCode: ?string;\n  errorMsg: ?string;\n  errorType: ?string;\n};\nexport type MutationResult = {\n  response: Object;\n};\nexport type QueryResult = {\n  error?: ?Error;\n  ref_params?: ?{[name: string]: mixed};\n  response: Object;\n};\n\n// Utility\nexport type Abortable = {\n  abort: () => void;\n};\n","dependencies":["URI","RelayInternalTypes","RelayFragmentReference","RelayMetaRoute","RelayMutationTransaction","RelayRecord","RelayQL"],"id":"RelayTypes","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayTypes\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Types that Relay framework users may find useful.\n */\nimport type URI from 'URI';\nimport type {\n  DataID,\n  FieldValue,\n} from 'RelayInternalTypes';\nimport type RelayFragmentReference from 'RelayFragmentReference';\nimport type RelayMetaRoute from 'RelayMetaRoute';\nimport type RelayMutationTransaction from 'RelayMutationTransaction';\nimport type {Record} from 'RelayRecord';\nimport type {RelayConcreteNode} from 'RelayQL';\n\n// Routes and variables\nexport type Variables = {[name: string]: mixed};\n\n// Ready state\nexport type ComponentReadyState = {\n  aborted: boolean;\n  done: boolean;\n  error: ?Error;\n  mounted: boolean;\n  ready: boolean;\n  stale: boolean;\n};\nexport type ComponentReadyStateChangeCallback =\n  (readyState: ComponentReadyState) => void;\n\nexport type ComponentFetchState = {\n  done: boolean;\n  stale: boolean;\n};\n\nexport type ReadyState = {\n  aborted: boolean;\n  done: boolean;\n  error: ?Error;\n  ready: boolean;\n  stale: boolean;\n};\nexport type ReadyStateChangeCallback = (readyState: ReadyState) => void;\n\n// Containers\nexport type RelayContainer = ReactClass<any, any, any>;\n\nexport type RelayProp = {\n  forceFetch: (\n    partialVariables?: ?Variables,\n    callback?: ?ComponentReadyStateChangeCallback\n  ) => void,\n  getPendingTransactions: (record: Object) => ?Array<RelayMutationTransaction>,\n  hasFragmentData: (\n    fragmentReference: RelayFragmentReference,\n    record: Object\n  ) => boolean,\n  hasOptimisticUpdate: (\n    record: Object\n  ) => boolean,\n  hasPartialData: (\n    record: Object\n  ) => boolean,\n  route: RelayMetaRoute,\n  setVariables: (\n    partialVariables?: ?Variables,\n    callback?: ?ComponentReadyStateChangeCallback\n  ) => void,\n  variables: Variables,\n};\n\n// Mutations\nexport type RelayMutationTransactionCommitFailureCallback = (\n  transaction: RelayMutationTransaction,\n  preventAutoRollback: () => void,\n) => void;\nexport type RelayMutationTransactionCommitSuccessCallback = (\n  response: {[key: string]: Object}\n) => void;\nexport type RelayMutationTransactionCommitCallbacks = {\n  onFailure?: ?RelayMutationTransactionCommitFailureCallback;\n  onSuccess?: ?RelayMutationTransactionCommitSuccessCallback;\n};\nexport type RelayMutationConfig = {\n  type: 'FIELDS_CHANGE',\n  fieldIDs: {[fieldName: string]: DataID | Array<DataID>},\n} | {\n  type: 'RANGE_ADD',\n  parentName: string,\n  parentID: string,\n  connectionName: string,\n  edgeName: string,\n  // from GraphQLMutatorConstants.RANGE_OPERATIONS\n  rangeBehaviors: {[call: string]: 'append' | 'prepend' | 'remove'},\n} | {\n  type: 'NODE_DELETE',\n  parentName: string;\n  parentID: string;\n  connectionName: string;\n  deletedIDFieldName: string;\n} | {\n  type: 'RANGE_DELETE';\n  parentName: string;\n  parentID: string;\n  connectionName: string;\n  deletedIDFieldName: string;\n  pathToConnection: Array<string>;\n} | {\n  type: 'REQUIRED_CHILDREN',\n  children: Array<RelayConcreteNode>,\n};\n\n// Observable\nexport type Observable<T> = {\n  subscribe: (callbacks: SubscriptionCallbacks<T>) => Subscription;\n};\n\nexport type MultiObservable<T> = {\n  subscribe: (callbacks: SubscriptionCallbacks<Array<T>>) => Subscription;\n  setDataIDs: (dataIDs: Array<DataID>) => void;\n};\n\nexport type Subscription = {\n  dispose(): void;\n};\n\nexport type SubscriptionCallbacks<T> = {\n  onNext: ((value: T) => void);\n  onError: ((error: Error) => void);\n  onCompleted: (() => void);\n};\n\n// Store\nexport type StoreReaderData = Object;\nexport type StoreReaderOptions = {\n  traverseFragmentReferences?: boolean;\n  traverseGeneratedFields?: boolean;\n};\n\n// Disk Cache\nexport type CacheManager = {\n  clear: () => void;\n  getMutationWriter: () => CacheWriter;\n  getQueryWriter: () => CacheWriter;\n  readNode: (\n    id: DataID,\n    callback: (error: any, value: any) => void\n  ) => void;\n   readRootCall: (\n    callName: string,\n    callValue: string,\n    callback: (error: any, value: any) => void\n  ) => void;\n};\n\nexport type CacheReadCallbacks = {\n  onSuccess?: () => void;\n  onFailure?: () => void;\n};\n\nexport type CacheWriter = {\n  writeField: (\n    dataID: DataID,\n    field: string,\n    value: ?FieldValue,\n    typeName: ?string\n  ) => void;\n  writeNode: (dataID: DataID, record: ?Record) => void;\n  writeRootCall: (\n    storageKey: string,\n    identifyingArgValue: string,\n    dataID: DataID\n  ) => void;\n};\n\n// Network requests\nexport type RequestOptions = {\n  data?: ?{[key: string]: mixed};\n  errorHandler?: ?(error: XHRErrorData) => void;\n  headers?: ?{[key: string]: string};\n  method: string;\n  rawData?: mixed;\n  responseHandler?: ?(\n    responseText: string,\n    responseHeaders: ?string,\n    isComplete: boolean\n  ) => void;\n  timeout?: ?number;\n  timeoutHandler?: ?() => void;\n  transportBuilder?: any;\n  uri: URI;\n};\ntype XHRErrorData = {\n  errorCode: ?string;\n  errorMsg: ?string;\n  errorType: ?string;\n};\nexport type MutationResult = {\n  response: Object;\n};\nexport type QueryResult = {\n  error?: ?Error;\n  ref_params?: ?{[name: string]: mixed};\n  response: Object;\n};\n\n// Utility\nexport type Abortable = {\n  abort: () => void;\n};\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayTaskScheduler.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayTaskScheduler","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayTaskScheduler\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayTaskQueue = require('RelayTaskQueue');\n\nimport type {TaskScheduler} from 'RelayTaskQueue';\n\nlet queue: ?RelayTaskQueue;\nlet scheduler: ?TaskScheduler;\n\n/**\n * Task scheduler used by Relay internals. Each task is a synchronous unit of\n * work that can be deferred by an injected scheduler function. For example,\n * an injected scheduler can defer each task to the next animation frame:\n *\n *   RelayTaskScheduler.injectScheduler(executeTask => {\n *     // This function will be invoked whenever a task is enqueued. It will not\n *     // be invoked again until `executeTask` has been invoked. Also, invoking\n *     // `executeTask` more than once is an error.\n *     requestAnimationFrame(executeTask);\n *   });\n *\n * By default, the next task is executed synchronously after the previous one is\n * finished. An injected scheduler using `setImmediate` can alter this behavior.\n */\nvar RelayTaskScheduler = {\n  /**\n   * @internal\n   *\n   * Enqueues one or more callbacks that each represent a synchronous unit of\n   * work that can be scheduled to be executed at a later time.\n   *\n   * The return value of each callback will be passed in as an argument to the\n   * next callback. If one of the callbacks throw an error, the execution will\n   * be aborted and the returned promise be rejected with the thrown error.\n   * Otherwise, the returned promise will be resolved with the return value of\n   * the last callback. For example:\n   *\n   *   RelayTaskScheduler.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       return 'bar';\n   *     }\n   *   ).done(\n   *     function(bar) {\n   *       // ...\n   *     }\n   *   );\n   *\n   *   RelayTaskScheduler.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       throw new Error();\n   *     },\n   *     function() {\n   *       // Never executed.\n   *     }\n   *   ).catch(\n   *     function(error) {}\n   *   );\n   */\n  enqueue(...callbacks: Array<(value: any) => any>): Promise<any> {\n    if (!queue) {\n      queue = new RelayTaskQueue(scheduler);\n    }\n    return queue.enqueue(...callbacks);\n  },\n\n  /**\n   * @public\n   *\n   * Injects a scheduling function that is invoked with a callback that will\n   * execute the next unit of work. The callback will return a promise that\n   * resolves with a new callback when the next unit of work is available.\n   */\n  injectScheduler(injectedScheduler: ?TaskScheduler): void {\n    scheduler = injectedScheduler;\n    if (queue) {\n      queue.injectScheduler(scheduler);\n    }\n  },\n};\n\nmodule.exports = RelayTaskScheduler;\n","dependencies":["RelayTaskQueue","RelayTaskScheduler"],"id":"RelayTaskScheduler","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayTaskScheduler\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayTaskQueue = require('RelayTaskQueue');\n\nimport type {TaskScheduler} from 'RelayTaskQueue';\n\nlet queue: ?RelayTaskQueue;\nlet scheduler: ?TaskScheduler;\n\n/**\n * Task scheduler used by Relay internals. Each task is a synchronous unit of\n * work that can be deferred by an injected scheduler function. For example,\n * an injected scheduler can defer each task to the next animation frame:\n *\n *   RelayTaskScheduler.injectScheduler(executeTask => {\n *     // This function will be invoked whenever a task is enqueued. It will not\n *     // be invoked again until `executeTask` has been invoked. Also, invoking\n *     // `executeTask` more than once is an error.\n *     requestAnimationFrame(executeTask);\n *   });\n *\n * By default, the next task is executed synchronously after the previous one is\n * finished. An injected scheduler using `setImmediate` can alter this behavior.\n */\nvar RelayTaskScheduler = {\n  /**\n   * @internal\n   *\n   * Enqueues one or more callbacks that each represent a synchronous unit of\n   * work that can be scheduled to be executed at a later time.\n   *\n   * The return value of each callback will be passed in as an argument to the\n   * next callback. If one of the callbacks throw an error, the execution will\n   * be aborted and the returned promise be rejected with the thrown error.\n   * Otherwise, the returned promise will be resolved with the return value of\n   * the last callback. For example:\n   *\n   *   RelayTaskScheduler.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       return 'bar';\n   *     }\n   *   ).done(\n   *     function(bar) {\n   *       // ...\n   *     }\n   *   );\n   *\n   *   RelayTaskScheduler.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       throw new Error();\n   *     },\n   *     function() {\n   *       // Never executed.\n   *     }\n   *   ).catch(\n   *     function(error) {}\n   *   );\n   */\n  enqueue(...callbacks: Array<(value: any) => any>): Promise<any> {\n    if (!queue) {\n      queue = new RelayTaskQueue(scheduler);\n    }\n    return queue.enqueue(...callbacks);\n  },\n\n  /**\n   * @public\n   *\n   * Injects a scheduling function that is invoked with a callback that will\n   * execute the next unit of work. The callback will return a promise that\n   * resolves with a new callback when the next unit of work is available.\n   */\n  injectScheduler(injectedScheduler: ?TaskScheduler): void {\n    scheduler = injectedScheduler;\n    if (queue) {\n      queue.injectScheduler(scheduler);\n    }\n  },\n};\n\nmodule.exports = RelayTaskScheduler;\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayTaskQueue.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayTaskQueue","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayTaskQueue\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar invariant = require('invariant');\n\ntype TaskCallback = () => void;\nexport type TaskExecutor = () => void;\nexport type TaskScheduler = (executeTask: TaskExecutor) => void;\n\n/**\n * A task queue that can be configured with an optional scheduler function. The\n * scheduling function is invoked with a callback that will execute the next\n * unit of work. The callback will return a promise that resolves with a new\n * callback when the next unit of work is available. For example, a scheduler\n * can defer each task to the next animation frame:\n *\n *   new RelayTaskQueue(executeTask => {\n *     // This function will be invoked whenever a task is enqueued. It will not\n *     // be invoked again until `executeTask` has been invoked. Also, invoking\n *     // `executeTask` more than once is an error.\n *     requestAnimationFrame(executeTask);\n *   });\n *\n * By default, the next task is executed synchronously after the previous one is\n * finished. An injected scheduler using `setImmediate` can alter this behavior.\n */\nclass RelayTaskQueue {\n  _queue: Array<TaskCallback>;\n  _running: boolean;\n  _schedule: ?TaskScheduler;\n\n  constructor(injectedScheduler: ?TaskScheduler): void {\n    this._queue = [];\n    this._running = false;\n    this._schedule = injectedScheduler;\n  }\n\n  /**\n   * @internal\n   *\n   * Enqueues one or more callbacks that each represent a synchronous unit of\n   * work that can be scheduled to be executed at a later time.\n   *\n   * The return value of each callback will be passed in as an argument to the\n   * next callback. If one of the callbacks throw an error, the execution will\n   * be aborted and the returned promise be rejected with the thrown error.\n   * Otherwise, the returned promise will be resolved with the return value of\n   * the last callback. For example:\n   *\n   *   const taskQueue = new RelayTaskQueue();\n   *   taskQueue.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       return 'bar';\n   *     }\n   *   ).done(\n   *     function(bar) {\n   *       // ...\n   *     }\n   *   );\n   *\n   *   RelayTaskQueue.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       throw new Error();\n   *     },\n   *     function() {\n   *       // Never executed.\n   *     }\n   *   ).catch(\n   *     function(error) {}\n   *   );\n   */\n  enqueue(...callbacks: Array<(value: any) => any>): Promise<any> {\n    const promise = new Promise((resolve, reject) => {\n      let nextIndex = 0;\n      let error = null;\n      const enqueueNext = (value: any): void => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        if (nextIndex >= callbacks.length) {\n          resolve(value);\n        } else {\n          this._queue.push((): void => {\n            enqueueNext(((): any => {\n              const nextCallback = callbacks[nextIndex++];\n              try {\n                value = nextCallback(value);\n              } catch (e) {\n                error = e;\n                value = undefined;\n              }\n              return value;\n            })());\n          });\n        }\n      };\n      enqueueNext(undefined);\n    });\n    this._scheduleIfNecessary();\n    return promise;\n  }\n\n  /**\n   * @public\n   *\n   * Injects a scheduling function that is invoked with a callback that will\n   * execute the next unit of work. The callback will return a promise that\n   * resolves with a new callback when the next unit of work is available.\n   */\n  injectScheduler(injectedScheduler: ?TaskScheduler): void {\n    this._schedule = injectedScheduler;\n  }\n\n  _createTaskExecutor(callback: TaskCallback): TaskExecutor {\n    var invoked = false;\n    return () => {\n      invariant(!invoked, 'RelayTaskQueue: Tasks can only be executed once.');\n      invoked = true;\n      this._invokeWithinScopedQueue(callback);\n      this._running = false;\n      this._scheduleIfNecessary();\n    };\n  }\n\n  _invokeWithinScopedQueue(callback: TaskCallback): void {\n    var originalQueue = this._queue;\n    this._queue = [];\n    try {\n      callback();\n    } finally {\n      Array.prototype.unshift.apply(originalQueue, this._queue);\n      this._queue = originalQueue;\n    }\n  }\n\n  _scheduleIfNecessary(): void {\n    if (this._running) {\n      return;\n    }\n    if (this._queue.length) {\n      this._running = true;\n      var executeTask = this._createTaskExecutor(this._queue.shift());\n      if (this._schedule) {\n        this._schedule(executeTask);\n      } else {\n        executeTask();\n      }\n    } else {\n      this._running = false;\n    }\n  }\n}\n\nmodule.exports = RelayTaskQueue;\n","dependencies":["invariant"],"id":"RelayTaskQueue","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayTaskQueue\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar invariant = require('invariant');\n\ntype TaskCallback = () => void;\nexport type TaskExecutor = () => void;\nexport type TaskScheduler = (executeTask: TaskExecutor) => void;\n\n/**\n * A task queue that can be configured with an optional scheduler function. The\n * scheduling function is invoked with a callback that will execute the next\n * unit of work. The callback will return a promise that resolves with a new\n * callback when the next unit of work is available. For example, a scheduler\n * can defer each task to the next animation frame:\n *\n *   new RelayTaskQueue(executeTask => {\n *     // This function will be invoked whenever a task is enqueued. It will not\n *     // be invoked again until `executeTask` has been invoked. Also, invoking\n *     // `executeTask` more than once is an error.\n *     requestAnimationFrame(executeTask);\n *   });\n *\n * By default, the next task is executed synchronously after the previous one is\n * finished. An injected scheduler using `setImmediate` can alter this behavior.\n */\nclass RelayTaskQueue {\n  _queue: Array<TaskCallback>;\n  _running: boolean;\n  _schedule: ?TaskScheduler;\n\n  constructor(injectedScheduler: ?TaskScheduler): void {\n    this._queue = [];\n    this._running = false;\n    this._schedule = injectedScheduler;\n  }\n\n  /**\n   * @internal\n   *\n   * Enqueues one or more callbacks that each represent a synchronous unit of\n   * work that can be scheduled to be executed at a later time.\n   *\n   * The return value of each callback will be passed in as an argument to the\n   * next callback. If one of the callbacks throw an error, the execution will\n   * be aborted and the returned promise be rejected with the thrown error.\n   * Otherwise, the returned promise will be resolved with the return value of\n   * the last callback. For example:\n   *\n   *   const taskQueue = new RelayTaskQueue();\n   *   taskQueue.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       return 'bar';\n   *     }\n   *   ).done(\n   *     function(bar) {\n   *       // ...\n   *     }\n   *   );\n   *\n   *   RelayTaskQueue.enqueue(\n   *     function() {\n   *       return 'foo';\n   *     },\n   *     function(foo) {\n   *       throw new Error();\n   *     },\n   *     function() {\n   *       // Never executed.\n   *     }\n   *   ).catch(\n   *     function(error) {}\n   *   );\n   */\n  enqueue(...callbacks: Array<(value: any) => any>): Promise<any> {\n    const promise = new Promise((resolve, reject) => {\n      let nextIndex = 0;\n      let error = null;\n      const enqueueNext = (value: any): void => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        if (nextIndex >= callbacks.length) {\n          resolve(value);\n        } else {\n          this._queue.push((): void => {\n            enqueueNext(((): any => {\n              const nextCallback = callbacks[nextIndex++];\n              try {\n                value = nextCallback(value);\n              } catch (e) {\n                error = e;\n                value = undefined;\n              }\n              return value;\n            })());\n          });\n        }\n      };\n      enqueueNext(undefined);\n    });\n    this._scheduleIfNecessary();\n    return promise;\n  }\n\n  /**\n   * @public\n   *\n   * Injects a scheduling function that is invoked with a callback that will\n   * execute the next unit of work. The callback will return a promise that\n   * resolves with a new callback when the next unit of work is available.\n   */\n  injectScheduler(injectedScheduler: ?TaskScheduler): void {\n    this._schedule = injectedScheduler;\n  }\n\n  _createTaskExecutor(callback: TaskCallback): TaskExecutor {\n    var invoked = false;\n    return () => {\n      invariant(!invoked, 'RelayTaskQueue: Tasks can only be executed once.');\n      invoked = true;\n      this._invokeWithinScopedQueue(callback);\n      this._running = false;\n      this._scheduleIfNecessary();\n    };\n  }\n\n  _invokeWithinScopedQueue(callback: TaskCallback): void {\n    var originalQueue = this._queue;\n    this._queue = [];\n    try {\n      callback();\n    } finally {\n      Array.prototype.unshift.apply(originalQueue, this._queue);\n      this._queue = originalQueue;\n    }\n  }\n\n  _scheduleIfNecessary(): void {\n    if (this._running) {\n      return;\n    }\n    if (this._queue.length) {\n      this._running = true;\n      var executeTask = this._createTaskExecutor(this._queue.shift());\n      if (this._schedule) {\n        this._schedule(executeTask);\n      } else {\n        executeTask();\n      }\n    } else {\n      this._running = false;\n    }\n  }\n}\n\nmodule.exports = RelayTaskQueue;\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayProfiler.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayProfiler","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayProfiler\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst emptyFunction = require('emptyFunction');\nconst forEachObject = require('forEachObject');\nconst removeFromArray = require('removeFromArray');\n\ntype Handler = (name: string, callback: () => void) => void;\ntype ProfileHandler = (name: string, state?: any) => () => void;\n\nconst aggregateHandlersByName: {[name: string]: Array<Handler>} = {\n  '*': [],\n};\nconst profileHandlersByName: {[name: string]: Array<ProfileHandler>} = {\n  '*': [],\n};\n\nconst NOT_INVOKED = {};\nconst defaultProfiler = {stop: emptyFunction};\nconst shouldInstrument = name => {\n  if (__DEV__) {\n    return true;\n  }\n  return name.charAt(0) !== '@';\n};\n\n/**\n * @public\n *\n * Instruments methods to allow profiling various parts of Relay. Profiling code\n * in Relay consists of three steps:\n *\n *  - Instrument the function to be profiled.\n *  - Attach handlers to the instrumented function.\n *  - Run the code which triggers the handlers.\n *\n * Handlers attached to instrumented methods are called with an instrumentation\n * name and a callback that must be synchronously executed:\n *\n *   instrumentedMethod.attachHandler(function(name, callback) {\n *     const start = performance.now();\n *     callback();\n *     console.log('Duration', performance.now() - start);\n *   });\n *\n * Handlers for profiles consist of callbacks for `onStart` and `onStop`:\n *\n *   const start;\n *   RelayProfiler.attachProfileHandler('profileName', {\n *     onStart: function(name, state) {\n *       start = performance.now();\n *     },\n *     onStop: function(name, state) {\n *       console.log('Duration', performance.now() - start);\n *     }\n *   });\n *\n * In order to reduce the impact on performance in production, instrumented\n * methods and profilers with names that begin with `@` will only be measured\n * if `__DEV__` is true. This should be used for very hot functions.\n */\nconst RelayProfiler = {\n\n  /**\n   * Instruments methods on a class or object. This re-assigns the method in\n   * order to preserve function names in stack traces (which are detected by\n   * modern debuggers via heuristics). Example usage:\n   *\n   *   const RelayStore = { primeCache: function() {...} };\n   *   RelayProfiler.instrumentMethods(RelayStore, {\n   *     primeCache: 'RelayStore.primeCache'\n   *   });\n   *\n   *   RelayStore.primeCache.attachHandler(...);\n   *\n   * As a result, the methods will be replaced by wrappers that provide the\n   * `attachHandler` and `detachHandler` methods.\n   */\n  instrumentMethods(\n    object: Function | Object,\n    names: {[key: string]: string}\n  ): void {\n    forEachObject(names, (name, key) => {\n      object[key] = RelayProfiler.instrument(name, object[key]);\n    });\n  },\n\n  /**\n   * Wraps the supplied function with one that provides the `attachHandler` and\n   * `detachHandler` methods. Example usage:\n   *\n   *   const printRelayQuery =\n   *     RelayProfiler.instrument('printRelayQuery', printRelayQuery);\n   *\n   *   printRelayQuery.attachHandler(...);\n   *\n   * NOTE: The instrumentation assumes that no handlers are attached or detached\n   * in the course of executing another handler.\n   */\n  instrument<T: Function>(name: string, originalFunction: T): T {\n    if (!shouldInstrument(name)) {\n      originalFunction.attachHandler = emptyFunction;\n      originalFunction.detachHandler = emptyFunction;\n      return originalFunction;\n    }\n    if (!aggregateHandlersByName.hasOwnProperty(name)) {\n      aggregateHandlersByName[name] = [];\n    }\n    const catchallHandlers = aggregateHandlersByName['*'];\n    const aggregateHandlers = aggregateHandlersByName[name];\n    const handlers: Array<Handler> = [];\n    const contexts: Array<[number, number, number, any, any, any]> = [];\n    const invokeHandlers = function() {\n      const context = contexts[contexts.length - 1];\n      if (context[0]) {\n        context[0]--;\n        catchallHandlers[context[0]](name, invokeHandlers);\n      } else if (context[1]) {\n        context[1]--;\n        aggregateHandlers[context[1]](name, invokeHandlers);\n      } else if (context[2]) {\n        context[2]--;\n        handlers[context[2]](name, invokeHandlers);\n      } else {\n        context[5] = originalFunction.apply(context[3], context[4]);\n      }\n    };\n    const instrumentedCallback = function() {\n      let returnValue;\n      if (\n        aggregateHandlers.length === 0 &&\n        handlers.length === 0 &&\n        catchallHandlers.length == 0\n      ) {\n        returnValue = originalFunction.apply(this, arguments);\n      } else {\n        contexts.push([\n          catchallHandlers.length,\n          aggregateHandlers.length,\n          handlers.length,\n          this,\n          arguments,\n          NOT_INVOKED,\n        ]);\n        invokeHandlers();\n        const context = contexts.pop();\n        returnValue = context[5];\n        if (returnValue === NOT_INVOKED) {\n          throw new Error(\n            'RelayProfiler: Handler did not invoke original function.'\n          );\n        }\n      }\n      return returnValue;\n    };\n    instrumentedCallback.attachHandler = function(handler: Handler): void {\n      handlers.push(handler);\n    };\n    instrumentedCallback.detachHandler = function(handler: Handler): void {\n      removeFromArray(handlers, handler);\n    };\n    instrumentedCallback.displayName = '(instrumented ' + name + ')';\n    return (instrumentedCallback: any);\n  },\n\n  /**\n   * Attaches a handler to all methods instrumented with the supplied name.\n   *\n   *   function createRenderer() {\n   *     return RelayProfiler.instrument('render', function() {...});\n   *   }\n   *   const renderA = createRenderer();\n   *   const renderB = createRenderer();\n   *\n   *   // Only profiles `renderA`.\n   *   renderA.attachHandler(...);\n   *\n   *   // Profiles both `renderA` and `renderB`.\n   *   RelayProfiler.attachAggregateHandler('render', ...);\n   *\n   */\n  attachAggregateHandler(name: string, handler: Handler): void {\n    if (shouldInstrument(name)) {\n      if (!aggregateHandlersByName.hasOwnProperty(name)) {\n        aggregateHandlersByName[name] = [];\n      }\n      aggregateHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachAggregateHandler`.\n   */\n  detachAggregateHandler(name: string, handler: Handler): void {\n    if (shouldInstrument(name)) {\n      if (aggregateHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(aggregateHandlersByName[name], handler);\n      }\n    }\n  },\n\n  /**\n   * Instruments profiling for arbitrarily asynchronous code by a name.\n   *\n   *   const timerProfiler = RelayProfiler.profile('timeout');\n   *   setTimeout(function() {\n   *     timerProfiler.stop();\n   *   }, 1000);\n   *\n   *   RelayProfiler.attachProfileHandler('timeout', ...);\n   *\n   * Arbitrary state can also be passed into `profile` as a second argument. The\n   * attached profile handlers will receive this as the second argument.\n   */\n  profile(name: string, state?: any): {stop: () => void} {\n    const hasCatchAllHandlers = profileHandlersByName['*'].length > 0;\n    const hasNamedHandlers = profileHandlersByName.hasOwnProperty(name);\n    if (hasNamedHandlers || hasCatchAllHandlers) {\n      const profileHandlers = hasNamedHandlers && hasCatchAllHandlers ?\n        profileHandlersByName[name].concat(profileHandlersByName['*']) :\n        (hasNamedHandlers ?\n          profileHandlersByName[name] : profileHandlersByName['*']);\n      let stopHandlers;\n      for (let ii = profileHandlers.length - 1; ii >= 0; ii--) {\n        const profileHandler = profileHandlers[ii];\n        const stopHandler = profileHandler(name, state);\n        stopHandlers = stopHandlers || [];\n        stopHandlers.unshift(stopHandler);\n      }\n      return {\n        stop(): void {\n          if (stopHandlers) {\n            stopHandlers.forEach(stopHandler => stopHandler());\n          }\n        },\n      };\n    }\n    return defaultProfiler;\n  },\n\n  /**\n   * Attaches a handler to profiles with the supplied name. You can also\n   * attach to the special name '*' which is a catch all.\n   */\n  attachProfileHandler(name: string, handler: ProfileHandler): void {\n    if (shouldInstrument(name)) {\n      if (!profileHandlersByName.hasOwnProperty(name)) {\n        profileHandlersByName[name] = [];\n      }\n      profileHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachProfileHandler`.\n   */\n  detachProfileHandler(name: string, handler: ProfileHandler): void {\n    if (shouldInstrument(name)) {\n      if (profileHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(profileHandlersByName[name], handler);\n      }\n    }\n  },\n\n};\n\nmodule.exports = RelayProfiler;\n","dependencies":["emptyFunction","forEachObject","removeFromArray","RelayProfiler"],"id":"RelayProfiler","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayProfiler\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst emptyFunction = require('emptyFunction');\nconst forEachObject = require('forEachObject');\nconst removeFromArray = require('removeFromArray');\n\ntype Handler = (name: string, callback: () => void) => void;\ntype ProfileHandler = (name: string, state?: any) => () => void;\n\nconst aggregateHandlersByName: {[name: string]: Array<Handler>} = {\n  '*': [],\n};\nconst profileHandlersByName: {[name: string]: Array<ProfileHandler>} = {\n  '*': [],\n};\n\nconst NOT_INVOKED = {};\nconst defaultProfiler = {stop: emptyFunction};\nconst shouldInstrument = name => {\n  if (__DEV__) {\n    return true;\n  }\n  return name.charAt(0) !== '@';\n};\n\n/**\n * @public\n *\n * Instruments methods to allow profiling various parts of Relay. Profiling code\n * in Relay consists of three steps:\n *\n *  - Instrument the function to be profiled.\n *  - Attach handlers to the instrumented function.\n *  - Run the code which triggers the handlers.\n *\n * Handlers attached to instrumented methods are called with an instrumentation\n * name and a callback that must be synchronously executed:\n *\n *   instrumentedMethod.attachHandler(function(name, callback) {\n *     const start = performance.now();\n *     callback();\n *     console.log('Duration', performance.now() - start);\n *   });\n *\n * Handlers for profiles consist of callbacks for `onStart` and `onStop`:\n *\n *   const start;\n *   RelayProfiler.attachProfileHandler('profileName', {\n *     onStart: function(name, state) {\n *       start = performance.now();\n *     },\n *     onStop: function(name, state) {\n *       console.log('Duration', performance.now() - start);\n *     }\n *   });\n *\n * In order to reduce the impact on performance in production, instrumented\n * methods and profilers with names that begin with `@` will only be measured\n * if `__DEV__` is true. This should be used for very hot functions.\n */\nconst RelayProfiler = {\n\n  /**\n   * Instruments methods on a class or object. This re-assigns the method in\n   * order to preserve function names in stack traces (which are detected by\n   * modern debuggers via heuristics). Example usage:\n   *\n   *   const RelayStore = { primeCache: function() {...} };\n   *   RelayProfiler.instrumentMethods(RelayStore, {\n   *     primeCache: 'RelayStore.primeCache'\n   *   });\n   *\n   *   RelayStore.primeCache.attachHandler(...);\n   *\n   * As a result, the methods will be replaced by wrappers that provide the\n   * `attachHandler` and `detachHandler` methods.\n   */\n  instrumentMethods(\n    object: Function | Object,\n    names: {[key: string]: string}\n  ): void {\n    forEachObject(names, (name, key) => {\n      object[key] = RelayProfiler.instrument(name, object[key]);\n    });\n  },\n\n  /**\n   * Wraps the supplied function with one that provides the `attachHandler` and\n   * `detachHandler` methods. Example usage:\n   *\n   *   const printRelayQuery =\n   *     RelayProfiler.instrument('printRelayQuery', printRelayQuery);\n   *\n   *   printRelayQuery.attachHandler(...);\n   *\n   * NOTE: The instrumentation assumes that no handlers are attached or detached\n   * in the course of executing another handler.\n   */\n  instrument<T: Function>(name: string, originalFunction: T): T {\n    if (!shouldInstrument(name)) {\n      originalFunction.attachHandler = emptyFunction;\n      originalFunction.detachHandler = emptyFunction;\n      return originalFunction;\n    }\n    if (!aggregateHandlersByName.hasOwnProperty(name)) {\n      aggregateHandlersByName[name] = [];\n    }\n    const catchallHandlers = aggregateHandlersByName['*'];\n    const aggregateHandlers = aggregateHandlersByName[name];\n    const handlers: Array<Handler> = [];\n    const contexts: Array<[number, number, number, any, any, any]> = [];\n    const invokeHandlers = function() {\n      const context = contexts[contexts.length - 1];\n      if (context[0]) {\n        context[0]--;\n        catchallHandlers[context[0]](name, invokeHandlers);\n      } else if (context[1]) {\n        context[1]--;\n        aggregateHandlers[context[1]](name, invokeHandlers);\n      } else if (context[2]) {\n        context[2]--;\n        handlers[context[2]](name, invokeHandlers);\n      } else {\n        context[5] = originalFunction.apply(context[3], context[4]);\n      }\n    };\n    const instrumentedCallback = function() {\n      let returnValue;\n      if (\n        aggregateHandlers.length === 0 &&\n        handlers.length === 0 &&\n        catchallHandlers.length == 0\n      ) {\n        returnValue = originalFunction.apply(this, arguments);\n      } else {\n        contexts.push([\n          catchallHandlers.length,\n          aggregateHandlers.length,\n          handlers.length,\n          this,\n          arguments,\n          NOT_INVOKED,\n        ]);\n        invokeHandlers();\n        const context = contexts.pop();\n        returnValue = context[5];\n        if (returnValue === NOT_INVOKED) {\n          throw new Error(\n            'RelayProfiler: Handler did not invoke original function.'\n          );\n        }\n      }\n      return returnValue;\n    };\n    instrumentedCallback.attachHandler = function(handler: Handler): void {\n      handlers.push(handler);\n    };\n    instrumentedCallback.detachHandler = function(handler: Handler): void {\n      removeFromArray(handlers, handler);\n    };\n    instrumentedCallback.displayName = '(instrumented ' + name + ')';\n    return (instrumentedCallback: any);\n  },\n\n  /**\n   * Attaches a handler to all methods instrumented with the supplied name.\n   *\n   *   function createRenderer() {\n   *     return RelayProfiler.instrument('render', function() {...});\n   *   }\n   *   const renderA = createRenderer();\n   *   const renderB = createRenderer();\n   *\n   *   // Only profiles `renderA`.\n   *   renderA.attachHandler(...);\n   *\n   *   // Profiles both `renderA` and `renderB`.\n   *   RelayProfiler.attachAggregateHandler('render', ...);\n   *\n   */\n  attachAggregateHandler(name: string, handler: Handler): void {\n    if (shouldInstrument(name)) {\n      if (!aggregateHandlersByName.hasOwnProperty(name)) {\n        aggregateHandlersByName[name] = [];\n      }\n      aggregateHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachAggregateHandler`.\n   */\n  detachAggregateHandler(name: string, handler: Handler): void {\n    if (shouldInstrument(name)) {\n      if (aggregateHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(aggregateHandlersByName[name], handler);\n      }\n    }\n  },\n\n  /**\n   * Instruments profiling for arbitrarily asynchronous code by a name.\n   *\n   *   const timerProfiler = RelayProfiler.profile('timeout');\n   *   setTimeout(function() {\n   *     timerProfiler.stop();\n   *   }, 1000);\n   *\n   *   RelayProfiler.attachProfileHandler('timeout', ...);\n   *\n   * Arbitrary state can also be passed into `profile` as a second argument. The\n   * attached profile handlers will receive this as the second argument.\n   */\n  profile(name: string, state?: any): {stop: () => void} {\n    const hasCatchAllHandlers = profileHandlersByName['*'].length > 0;\n    const hasNamedHandlers = profileHandlersByName.hasOwnProperty(name);\n    if (hasNamedHandlers || hasCatchAllHandlers) {\n      const profileHandlers = hasNamedHandlers && hasCatchAllHandlers ?\n        profileHandlersByName[name].concat(profileHandlersByName['*']) :\n        (hasNamedHandlers ?\n          profileHandlersByName[name] : profileHandlersByName['*']);\n      let stopHandlers;\n      for (let ii = profileHandlers.length - 1; ii >= 0; ii--) {\n        const profileHandler = profileHandlers[ii];\n        const stopHandler = profileHandler(name, state);\n        stopHandlers = stopHandlers || [];\n        stopHandlers.unshift(stopHandler);\n      }\n      return {\n        stop(): void {\n          if (stopHandlers) {\n            stopHandlers.forEach(stopHandler => stopHandler());\n          }\n        },\n      };\n    }\n    return defaultProfiler;\n  },\n\n  /**\n   * Attaches a handler to profiles with the supplied name. You can also\n   * attach to the special name '*' which is a catch all.\n   */\n  attachProfileHandler(name: string, handler: ProfileHandler): void {\n    if (shouldInstrument(name)) {\n      if (!profileHandlersByName.hasOwnProperty(name)) {\n        profileHandlersByName[name] = [];\n      }\n      profileHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachProfileHandler`.\n   */\n  detachProfileHandler(name: string, handler: ProfileHandler): void {\n    if (shouldInstrument(name)) {\n      if (profileHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(profileHandlersByName[name], handler);\n      }\n    }\n  },\n\n};\n\nmodule.exports = RelayProfiler;\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayMetricsRecorder.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayMetricsRecorder","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMetricsRecorder\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayProfiler = require('RelayProfiler');\n\nconst performanceNow = require('performanceNow');\n\nconst measurementDefaults = {\n  aggregateTime: 0,\n  callCount: 0,\n};\n\ntype Measurement = {\n  aggregateTime: number;\n  callCount: number;\n};\ntype Metrics = {\n  measurements: {[name: string]: Measurement};\n  profiles: Array<ProfileEvent>;\n  recordingTime: number;\n  totalTime: number;\n};\ntype ProfileEvent = {\n  endTime: number;\n  name: string;\n  startTime: number;\n};\n\n/**\n * Collects timing information from key Relay subsystems.\n *\n * Example:\n *\n * ```\n * var recorder = new RelayMetricsRecorder();\n * recorder.start();\n * // ... do work ...\n * recorder.stop();\n * var metrics = recorder.getMetrics();\n * ```\n *\n * Metrics:\n * - `recordingTime`: the total time spent recording (between calls to `start()`\n *   and `stop()`).\n * - `totalTime`: the total time spent inside profiled Relay functions.\n * - `measurements`: an object mapping names of profiled functions to profiling\n *   data including:\n *   - `aggregateTime`: total time spent in the method.\n *   - `callCount`: number of times the method was called.\n */\nclass RelayMetricsRecorder {\n  _isEnabled: boolean;\n  _measurements: {[key: string]: Measurement};\n  _profiles: Array<ProfileEvent>;\n  _profileStack: Array<number>;\n  _recordingStartTime: number;\n  _recordingTotalTime: number;\n  _startTimesStack: Array<number>;\n\n  constructor() {\n    this._isEnabled = false;\n    this._measurements = {};\n    this._profiles = [];\n    this._profileStack = [];\n    this._recordingStartTime = 0;\n    this._recordingTotalTime = 0;\n    this._startTimesStack = [];\n\n    (this: any)._measure = this._measure.bind(this);\n    (this: any)._instrumentProfile = this._instrumentProfile.bind(this);\n    (this: any)._startMeasurement = this._startMeasurement.bind(this);\n    (this: any)._stopMeasurement = this._stopMeasurement.bind(this);\n  }\n\n  start(): void {\n    if (this._isEnabled) {\n      return;\n    }\n    this._recordingStartTime = performanceNow();\n    this._isEnabled = true;\n    this._profileStack = [0];\n    this._startTimesStack = [0];\n\n    RelayProfiler.attachAggregateHandler('*', this._measure);\n    RelayProfiler.attachProfileHandler('*', this._instrumentProfile);\n  }\n\n  stop(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    this._recordingTotalTime += performanceNow() - this._recordingStartTime;\n    this._isEnabled = false;\n\n    RelayProfiler.detachAggregateHandler('*', this._measure);\n    RelayProfiler.detachProfileHandler('*', this._instrumentProfile);\n  }\n\n  getMetrics(): Metrics {\n    const {_measurements} = this;\n    let totalTime = 0;\n    const sortedMeasurements = {};\n    Object.keys(_measurements)\n      .sort((a, b) => {\n        return _measurements[b].aggregateTime - _measurements[a].aggregateTime;\n      })\n      .forEach(name => {\n        totalTime += _measurements[name].aggregateTime;\n        sortedMeasurements[name] = _measurements[name];\n      });\n    const sortedProfiles = this._profiles.sort((a, b) => {\n      if (a.startTime < b.startTime) {\n        return -1;\n      } else if (a.startTime > b.startTime) {\n        return 1;\n      } else {\n        // lower duration first\n        return (a.endTime - a.startTime) - (b.endTime - b.startTime);\n      }\n    });\n\n    return {\n      measurements: sortedMeasurements,\n      profiles: sortedProfiles,\n      recordingTime: this._recordingTotalTime,\n      totalTime,\n    };\n  }\n\n  _measure(name: string, callback: Function): void {\n    this._startMeasurement(name);\n    callback();\n    this._stopMeasurement(name);\n  }\n\n  _instrumentProfile(name: string): () => void {\n    const startTime = performanceNow();\n    return () => {\n      this._profiles.push({\n        endTime: performanceNow(),\n        name,\n        startTime,\n      });\n    };\n  }\n\n  _startMeasurement(name: string): void {\n    this._measurements[name] =\n      this._measurements[name] || {...measurementDefaults};\n    this._profileStack.unshift(0);\n    this._startTimesStack.unshift(performanceNow());\n  }\n\n  _stopMeasurement(name: string): void {\n    const innerTime = this._profileStack.shift();\n    const start = this._startTimesStack.shift();\n    const totalTime = performanceNow() - start;\n\n    this._measurements[name].aggregateTime += totalTime - innerTime;\n    this._measurements[name].callCount++;\n\n    this._profileStack[0] += totalTime;\n  }\n}\n\nmodule.exports = RelayMetricsRecorder;\n","dependencies":["RelayProfiler","performanceNow","RelayMetricsRecorder"],"id":"RelayMetricsRecorder","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayMetricsRecorder\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayProfiler = require('RelayProfiler');\n\nconst performanceNow = require('performanceNow');\n\nconst measurementDefaults = {\n  aggregateTime: 0,\n  callCount: 0,\n};\n\ntype Measurement = {\n  aggregateTime: number;\n  callCount: number;\n};\ntype Metrics = {\n  measurements: {[name: string]: Measurement};\n  profiles: Array<ProfileEvent>;\n  recordingTime: number;\n  totalTime: number;\n};\ntype ProfileEvent = {\n  endTime: number;\n  name: string;\n  startTime: number;\n};\n\n/**\n * Collects timing information from key Relay subsystems.\n *\n * Example:\n *\n * ```\n * var recorder = new RelayMetricsRecorder();\n * recorder.start();\n * // ... do work ...\n * recorder.stop();\n * var metrics = recorder.getMetrics();\n * ```\n *\n * Metrics:\n * - `recordingTime`: the total time spent recording (between calls to `start()`\n *   and `stop()`).\n * - `totalTime`: the total time spent inside profiled Relay functions.\n * - `measurements`: an object mapping names of profiled functions to profiling\n *   data including:\n *   - `aggregateTime`: total time spent in the method.\n *   - `callCount`: number of times the method was called.\n */\nclass RelayMetricsRecorder {\n  _isEnabled: boolean;\n  _measurements: {[key: string]: Measurement};\n  _profiles: Array<ProfileEvent>;\n  _profileStack: Array<number>;\n  _recordingStartTime: number;\n  _recordingTotalTime: number;\n  _startTimesStack: Array<number>;\n\n  constructor() {\n    this._isEnabled = false;\n    this._measurements = {};\n    this._profiles = [];\n    this._profileStack = [];\n    this._recordingStartTime = 0;\n    this._recordingTotalTime = 0;\n    this._startTimesStack = [];\n\n    (this: any)._measure = this._measure.bind(this);\n    (this: any)._instrumentProfile = this._instrumentProfile.bind(this);\n    (this: any)._startMeasurement = this._startMeasurement.bind(this);\n    (this: any)._stopMeasurement = this._stopMeasurement.bind(this);\n  }\n\n  start(): void {\n    if (this._isEnabled) {\n      return;\n    }\n    this._recordingStartTime = performanceNow();\n    this._isEnabled = true;\n    this._profileStack = [0];\n    this._startTimesStack = [0];\n\n    RelayProfiler.attachAggregateHandler('*', this._measure);\n    RelayProfiler.attachProfileHandler('*', this._instrumentProfile);\n  }\n\n  stop(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    this._recordingTotalTime += performanceNow() - this._recordingStartTime;\n    this._isEnabled = false;\n\n    RelayProfiler.detachAggregateHandler('*', this._measure);\n    RelayProfiler.detachProfileHandler('*', this._instrumentProfile);\n  }\n\n  getMetrics(): Metrics {\n    const {_measurements} = this;\n    let totalTime = 0;\n    const sortedMeasurements = {};\n    Object.keys(_measurements)\n      .sort((a, b) => {\n        return _measurements[b].aggregateTime - _measurements[a].aggregateTime;\n      })\n      .forEach(name => {\n        totalTime += _measurements[name].aggregateTime;\n        sortedMeasurements[name] = _measurements[name];\n      });\n    const sortedProfiles = this._profiles.sort((a, b) => {\n      if (a.startTime < b.startTime) {\n        return -1;\n      } else if (a.startTime > b.startTime) {\n        return 1;\n      } else {\n        // lower duration first\n        return (a.endTime - a.startTime) - (b.endTime - b.startTime);\n      }\n    });\n\n    return {\n      measurements: sortedMeasurements,\n      profiles: sortedProfiles,\n      recordingTime: this._recordingTotalTime,\n      totalTime,\n    };\n  }\n\n  _measure(name: string, callback: Function): void {\n    this._startMeasurement(name);\n    callback();\n    this._stopMeasurement(name);\n  }\n\n  _instrumentProfile(name: string): () => void {\n    const startTime = performanceNow();\n    return () => {\n      this._profiles.push({\n        endTime: performanceNow(),\n        name,\n        startTime,\n      });\n    };\n  }\n\n  _startMeasurement(name: string): void {\n    this._measurements[name] =\n      this._measurements[name] || {...measurementDefaults};\n    this._profileStack.unshift(0);\n    this._startTimesStack.unshift(performanceNow());\n  }\n\n  _stopMeasurement(name: string): void {\n    const innerTime = this._profileStack.shift();\n    const start = this._startTimesStack.shift();\n    const totalTime = performanceNow() - start;\n\n    this._measurements[name].aggregateTime += totalTime - innerTime;\n    this._measurements[name].callCount++;\n\n    this._profileStack[0] += totalTime;\n  }\n}\n\nmodule.exports = RelayMetricsRecorder;\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayInternalTypes.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayInternalTypes","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayInternalTypes\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * These are types shared across multiple files within Relay internals.\n */\n\nimport typeof GraphQLMutatorConstants from 'GraphQLMutatorConstants';\nimport type RelayQuery from 'RelayQuery';\n\nexport type Call = {\n  name: string;\n  type?: string;\n  value: CallValue;\n};\nexport type CallValue = mixed;\n\nexport type ClientMutationID = string;\n\nexport type DataID = string;\n\nexport type Directive = {\n  args: Array<Call>;\n  name: string;\n};\n\nexport type FieldValue = mixed;\n\nexport type MutationVariables = {\n  input: {[key: string]: mixed};\n};\n\nexport type PrintedQuery = {\n  text: string;\n  variables: {[key: string]: mixed};\n};\n\n// Maps root calls to a single data ID through an indentifying arg (or EMPTY)\n// eg. username(name: \"joe\")   => '123'\n//     username(name: \"steve\") => '456'\n//     viewer                  => '456'\ntype IdentifyingArgsMap = {[identifyingArgValue: string]: DataID};\nexport type RootCallMap = {[storageKey: string]: IdentifyingArgsMap};\n\n// maps node IDs to the IDs of the connections that contain them\nexport type NodeRangeMap = {\n  [dataID: DataID]: {[connectionID: DataID]: boolean}\n};\n\nexport type RelayQuerySet = {[queryName: string]: ?RelayQuery.Root};\n\nexport type QueryPayload = {[key: string]: mixed};\n\nexport type UpdateOptions = {\n  configs: Array<{[key: string]: mixed}>;\n  isOptimisticUpdate: boolean;\n};\n\nexport type RangeBehaviors = {\n  [key: string]: $Keys<GraphQLMutatorConstants.RANGE_OPERATIONS>;\n};\n","dependencies":["GraphQLMutatorConstants","RelayQuery"],"id":"RelayInternalTypes","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayInternalTypes\n * @flow\n * @typechecks\n */\n\n'use strict';\n\n/**\n * @internal\n *\n * These are types shared across multiple files within Relay internals.\n */\n\nimport typeof GraphQLMutatorConstants from 'GraphQLMutatorConstants';\nimport type RelayQuery from 'RelayQuery';\n\nexport type Call = {\n  name: string;\n  type?: string;\n  value: CallValue;\n};\nexport type CallValue = mixed;\n\nexport type ClientMutationID = string;\n\nexport type DataID = string;\n\nexport type Directive = {\n  args: Array<Call>;\n  name: string;\n};\n\nexport type FieldValue = mixed;\n\nexport type MutationVariables = {\n  input: {[key: string]: mixed};\n};\n\nexport type PrintedQuery = {\n  text: string;\n  variables: {[key: string]: mixed};\n};\n\n// Maps root calls to a single data ID through an indentifying arg (or EMPTY)\n// eg. username(name: \"joe\")   => '123'\n//     username(name: \"steve\") => '456'\n//     viewer                  => '456'\ntype IdentifyingArgsMap = {[identifyingArgValue: string]: DataID};\nexport type RootCallMap = {[storageKey: string]: IdentifyingArgsMap};\n\n// maps node IDs to the IDs of the connections that contain them\nexport type NodeRangeMap = {\n  [dataID: DataID]: {[connectionID: DataID]: boolean}\n};\n\nexport type RelayQuerySet = {[queryName: string]: ?RelayQuery.Root};\n\nexport type QueryPayload = {[key: string]: mixed};\n\nexport type UpdateOptions = {\n  configs: Array<{[key: string]: mixed}>;\n  isOptimisticUpdate: boolean;\n};\n\nexport type RangeBehaviors = {\n  [key: string]: $Keys<GraphQLMutatorConstants.RANGE_OPERATIONS>;\n};\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayInternals.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayInternals","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayInternals\n * @flow\n */\n\n'use strict';\n\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayStore = require('RelayStore');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst printRelayQuery = require('printRelayQuery');\n\n/**\n * This module contains internal Relay modules that we expose for development\n * tools. They should be considered private APIs.\n *\n * @internal\n */\nvar RelayInternals = {\n  NetworkLayer: RelayNetworkLayer,\n  DefaultStoreData: RelayStore.getStoreData(),\n  flattenRelayQuery: flattenRelayQuery,\n  printRelayQuery: printRelayQuery,\n};\n\nmodule.exports = RelayInternals;\n","dependencies":["RelayNetworkLayer","RelayStore","flattenRelayQuery","printRelayQuery"],"id":"RelayInternals","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayInternals\n * @flow\n */\n\n'use strict';\n\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayStore = require('RelayStore');\n\nconst flattenRelayQuery = require('flattenRelayQuery');\nconst printRelayQuery = require('printRelayQuery');\n\n/**\n * This module contains internal Relay modules that we expose for development\n * tools. They should be considered private APIs.\n *\n * @internal\n */\nvar RelayInternals = {\n  NetworkLayer: RelayNetworkLayer,\n  DefaultStoreData: RelayStore.getStoreData(),\n  flattenRelayQuery: flattenRelayQuery,\n  printRelayQuery: printRelayQuery,\n};\n\nmodule.exports = RelayInternals;\n"}}},"/Users/cpojer/Projects/relay/src/tools/RelayError.js":{"metadata":{"mtime":1455679339000},"data":{"name":"RelayError","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayError\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst sprintf = require('sprintf');\n\n/**\n * @internal\n *\n * Factory methods for constructing errors in Relay.\n */\nconst RelayError = {\n  create(name: string, format: string, ...args: Array<mixed>): Error {\n    return createError('mustfix', name, format, args);\n  },\n  createWarning(name: string, format: string, ...args: Array<mixed>): Error {\n    return createError('warn', name, format, args);\n  },\n};\n\n/**\n * @private\n */\nfunction createError(\n  type: string,\n  name: string,\n  format: string,\n  args: Array<mixed>\n): Error {\n  /*eslint-disable fb-www/sprintf-like-args */\n  const error = new Error(sprintf(format, ...args));\n  /*eslint-enable fb-www/sprintf-like-args */\n  error.name = name;\n  (error: any).type = type;\n  (error: any).framesToPop = 2;\n  return error;\n}\n\nmodule.exports = RelayError;\n","dependencies":["sprintf","RelayError"],"id":"RelayError","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayError\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst sprintf = require('sprintf');\n\n/**\n * @internal\n *\n * Factory methods for constructing errors in Relay.\n */\nconst RelayError = {\n  create(name: string, format: string, ...args: Array<mixed>): Error {\n    return createError('mustfix', name, format, args);\n  },\n  createWarning(name: string, format: string, ...args: Array<mixed>): Error {\n    return createError('warn', name, format, args);\n  },\n};\n\n/**\n * @private\n */\nfunction createError(\n  type: string,\n  name: string,\n  format: string,\n  args: Array<mixed>\n): Error {\n  /*eslint-disable fb-www/sprintf-like-args */\n  const error = new Error(sprintf(format, ...args));\n  /*eslint-enable fb-www/sprintf-like-args */\n  error.name = name;\n  (error: any).type = type;\n  (error: any).framesToPop = 2;\n  return error;\n}\n\nmodule.exports = RelayError;\n"}}},"/Users/cpojer/Projects/relay/src/tools/isCompatibleRelayFragmentType.js":{"metadata":{"mtime":1455679339000},"data":{"name":"isCompatibleRelayFragmentType","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isCompatibleRelayFragmentType\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\n/**\n * @internal\n *\n * Determine if the given fragment's type is compatible with the given record\n * type. The types are considered compatible if they exactly match or in the\n * following cases:\n * - Types are not recorded for optimistic records; if the record type is null\n *   it is assumed to be compatible with the fragment.\n * - Abstract fragments are assumed to be compatible with all types; being more\n *   precise would require access to the full schema inheritance hierarchy.\n */\nfunction isCompatibleRelayFragmentType(\n  fragment: RelayQuery.Fragment,\n  recordType: ?string\n): boolean {\n  return (\n    recordType === fragment.getType() ||\n    !recordType ||\n    fragment.isAbstract()\n  );\n}\n\nmodule.exports = isCompatibleRelayFragmentType;\n","dependencies":["RelayQuery","isCompatibleRelayFragmentType"],"id":"isCompatibleRelayFragmentType","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isCompatibleRelayFragmentType\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\n/**\n * @internal\n *\n * Determine if the given fragment's type is compatible with the given record\n * type. The types are considered compatible if they exactly match or in the\n * following cases:\n * - Types are not recorded for optimistic records; if the record type is null\n *   it is assumed to be compatible with the fragment.\n * - Abstract fragments are assumed to be compatible with all types; being more\n *   precise would require access to the full schema inheritance hierarchy.\n */\nfunction isCompatibleRelayFragmentType(\n  fragment: RelayQuery.Fragment,\n  recordType: ?string\n): boolean {\n  return (\n    recordType === fragment.getType() ||\n    !recordType ||\n    fragment.isAbstract()\n  );\n}\n\nmodule.exports = isCompatibleRelayFragmentType;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/writeRelayUpdatePayload.js":{"metadata":{"mtime":1456300207000},"data":{"name":"writeRelayUpdatePayload","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule writeRelayUpdatePayload\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  DataID,\n  RangeBehaviors,\n  UpdateOptions,\n} from 'RelayInternalTypes';\nconst RelayMutationTracker = require('RelayMutationTracker');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nimport type RelayQueryWriter from 'RelayQueryWriter';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst generateClientEdgeID = require('generateClientEdgeID');\nconst generateClientID = require('generateClientID');\nconst invariant = require('invariant');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\nconst warning = require('warning');\n\n// TODO: Replace with enumeration for possible config types.\n/* OperationConfig was originally typed such that each property had the type\n * mixed.  Mixed is safer than any, but that safety comes from Flow forcing you\n * to inspect a mixed value at runtime before using it.  However these mixeds\n * are ending up everywhere and are not being inspected */\ntype OperationConfig = {[key: string]: $FlowFixMe};\n\ntype Payload = mixed | PayloadObject | PayloadArray;\ntype PayloadArray = Array<Payload>;\ntype PayloadObject = {[key: string]: Payload};\n\nconst {CLIENT_MUTATION_ID, EDGES} = RelayConnectionInterface;\nconst {ANY_TYPE, ID, ID_TYPE, NODE, NODE_TYPE} = RelayNodeInterface;\nconst {APPEND, PREPEND, REMOVE} = GraphQLMutatorConstants;\n\nconst EDGES_FIELD = RelayQuery.Field.build({\n  fieldName: EDGES,\n  type: ANY_TYPE,\n  metadata: {\n    canHaveSubselections: true,\n    isPlural: true,\n  },\n});\nconst IGNORED_KEYS = {\n  error: true,\n  [CLIENT_MUTATION_ID]: true,\n};\nconst STUB_CURSOR_ID = 'client:cursor';\n\n/**\n * @internal\n *\n * Applies the results of an update operation (mutation/subscription) to the\n * store.\n */\nfunction writeRelayUpdatePayload(\n  writer: RelayQueryWriter,\n  operation: RelayQuery.Operation,\n  payload: PayloadObject,\n  {configs, isOptimisticUpdate}: UpdateOptions\n): void {\n  configs.forEach(config => {\n    switch (config.type) {\n      case RelayMutationType.NODE_DELETE:\n        handleNodeDelete(writer, payload, config);\n        break;\n      case RelayMutationType.RANGE_ADD:\n        handleRangeAdd(\n          writer,\n          payload,\n          operation,\n          config,\n          isOptimisticUpdate\n        );\n        break;\n      case RelayMutationType.RANGE_DELETE:\n        handleRangeDelete(writer, payload, config);\n        break;\n      case RelayMutationType.FIELDS_CHANGE:\n      case RelayMutationType.REQUIRED_CHILDREN:\n        break;\n      default:\n        console.error(\n          'Expected a valid mutation handler type, got `%s`.',\n          config.type\n        );\n    }\n  });\n\n  handleMerge(writer, payload, operation);\n}\n\n/**\n * Handles the payload for a node deletion mutation, reading the ID of the node\n * to delete from the payload based on the config and then deleting references\n * to the node.\n */\nfunction handleNodeDelete(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  config: OperationConfig\n): void {\n  const recordIDs = payload[config.deletedIDFieldName];\n  if (!recordIDs) {\n    // for some mutations, deletions don't always occur so if there's no field\n    // in the payload, carry on\n    return;\n  }\n\n  if (Array.isArray(recordIDs)) {\n    recordIDs.forEach(id => {\n      deleteRecord(writer, id);\n    });\n  } else {\n    deleteRecord(writer, recordIDs);\n  }\n}\n\n/**\n * Deletes the record from the store, also removing any references to the node\n * from any ranges that contain it (along with the containing edges).\n */\nfunction deleteRecord(\n  writer: RelayQueryWriter,\n  recordID: DataID\n): void {\n  const store = writer.getRecordStore();\n  const recordWriter = writer.getRecordWriter();\n  // skip if already deleted\n  const status = store.getRecordState(recordID);\n  if (status === RelayRecordState.NONEXISTENT) {\n    return;\n  }\n\n  // Delete the node from any ranges it may be a part of\n  const connectionIDs = store.getConnectionIDsForRecord(recordID);\n  if (connectionIDs) {\n    connectionIDs.forEach(connectionID => {\n      const edgeID = generateClientEdgeID(connectionID, recordID);\n      recordWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n      writer.recordUpdate(edgeID);\n      writer.recordUpdate(connectionID);\n      // edges are never nodes, so this will not infinitely recurse\n      deleteRecord(writer, edgeID);\n    });\n  }\n\n  // delete the node\n  recordWriter.deleteRecord(recordID);\n  writer.recordUpdate(recordID);\n}\n\n/**\n * Handles merging the results of the mutation/subscription into the store,\n * updating each top-level field in the data according the fetched\n * fields/fragments.\n */\nfunction handleMerge(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  operation: RelayQuery.Operation\n): void {\n  const store = writer.getRecordStore();\n\n  // because optimistic payloads may not contain all fields, we loop over\n  // the data that is present and then have to recurse the query to find\n  // the matching fields.\n  //\n  // TODO #7167718: more efficient mutation/subscription writes\n  for (const fieldName in payload) {\n    if (!payload.hasOwnProperty(fieldName)) {\n      continue;\n    }\n    const payloadData = (payload[fieldName]: $FlowIssue); // #9357395\n    if (typeof payloadData !== 'object' || payloadData == null) {\n      continue;\n    }\n    // if the field is an argument-less root call, determine the corresponding\n    // root record ID\n    const rootID = store.getDataID(fieldName);\n    // check for valid data (has an ID or is an array) and write the field\n    if (\n      ID in payloadData ||\n      rootID ||\n      Array.isArray(payloadData)\n    ) {\n      mergeField(\n        writer,\n        fieldName,\n        payloadData,\n        operation\n      );\n    }\n  }\n}\n\n/**\n * Merges the results of a single top-level field into the store.\n */\nfunction mergeField(\n  writer: RelayQueryWriter,\n  fieldName: string,\n  payload: PayloadObject | PayloadArray,\n  operation: RelayQuery.Operation\n): void {\n  // don't write mutation/subscription metadata fields\n  if (fieldName in IGNORED_KEYS) {\n    return;\n  }\n  if (Array.isArray(payload)) {\n    payload.forEach(item => {\n      if (typeof item === 'object' && item != null && !Array.isArray(item)) {\n        if (getString(item, ID)) {\n          mergeField(writer, fieldName, item, operation);\n        }\n      }\n    });\n    return;\n  }\n  // reassign to preserve type information in below closure\n  const payloadData = payload;\n\n  const store = writer.getRecordStore();\n  let recordID = getString(payloadData, ID);\n  let path;\n\n  if (recordID != null) {\n    path = new RelayQueryPath(\n      RelayQuery.Root.build(\n        'writeRelayUpdatePayload',\n        NODE,\n        recordID,\n        null,\n        {\n          identifyingArgName: ID,\n          identifyingArgType: ID_TYPE,\n          isAbstract: true,\n          isDeferred: false,\n          isPlural: false,\n        },\n        NODE_TYPE\n      )\n    );\n  } else {\n    recordID = store.getDataID(fieldName);\n    // Root fields that do not accept arguments\n    path = new RelayQueryPath(RelayQuery.Root.build(\n      'writeRelayUpdatePayload',\n      fieldName,\n      null,\n      null,\n      {\n        identifyingArgName: null,\n        identifyingArgType: null,\n        isAbstract: true,\n        isDeferred: false,\n        isPlural: false,\n      },\n      ANY_TYPE\n    ));\n  }\n  invariant(\n    recordID,\n    'writeRelayUpdatePayload(): Expected a record ID in the response payload ' +\n    'supplied to update the store.'\n  );\n\n  // write the results for only the current field, for every instance of that\n  // field in any subfield/fragment in the query.\n  const handleNode = node => {\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Fragment) {\n        handleNode(child);\n      } else if (\n        child instanceof RelayQuery.Field &&\n        child.getSerializationKey() === fieldName\n      ) {\n        // for flow: types are lost in closures\n        if (path && recordID) {\n          // ensure the record exists and then update it\n          writer.createRecordIfMissing(\n            child,\n            recordID,\n            path,\n            payloadData\n          );\n          writer.writePayload(\n            child,\n            recordID,\n            payloadData,\n            path\n          );\n        }\n      }\n    });\n  };\n  handleNode(operation);\n}\n\n/**\n * Handles the payload for a range addition. The configuration specifies:\n * - which field in the payload contains data for the new edge\n * - the list of fetched ranges to which the edge should be added\n * - whether to append/prepend to each of those ranges\n */\nfunction handleRangeAdd(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  operation: RelayQuery.Operation,\n  config: OperationConfig,\n  isOptimisticUpdate: boolean\n): void {\n  const clientMutationID = getString(payload, CLIENT_MUTATION_ID);\n  invariant(\n    clientMutationID,\n    'writeRelayUpdatePayload(): Expected operation `%s` to have a `%s`.',\n    operation.getName(),\n    CLIENT_MUTATION_ID\n  );\n  const store = writer.getRecordStore();\n\n  // Extracts the new edge from the payload\n  const edge = getObject(payload, config.edgeName);\n  const edgeNode = edge && getObject(edge, NODE);\n  if (!edge || !edgeNode) {\n    warning(\n      false,\n      'writeRelayUpdatePayload(): Expected response payload to include the ' +\n      'newly created edge `%s` and its `node` field. Did you forget to ' +\n      'update the `RANGE_ADD` mutation config?',\n      config.edgeName\n    );\n    return;\n  }\n\n  // Extract the id of the node with the connection that we are adding to.\n  let connectionParentID = config.parentID;\n  if (!connectionParentID) {\n    const edgeSource = getObject(edge, 'source');\n    if (edgeSource) {\n      connectionParentID = getString(edgeSource, ID);\n    }\n  }\n  invariant(\n    connectionParentID,\n    'writeRelayUpdatePayload(): Cannot insert edge without a configured ' +\n    '`parentID` or a `%s.source.id` field.',\n    config.edgeName\n  );\n\n  const nodeID = getString(edgeNode, ID) || generateClientID();\n  const cursor = edge.cursor || STUB_CURSOR_ID;\n  const edgeData = {\n    ...edge,\n    cursor: cursor,\n    node: {\n      ...edgeNode,\n      id: nodeID,\n    },\n  };\n\n  // add the node to every connection for this field\n  const connectionIDs =\n    store.getConnectionIDsForField(connectionParentID, config.connectionName);\n  if (connectionIDs) {\n    connectionIDs.forEach(connectionID => addRangeNode(\n      writer,\n      operation,\n      config,\n      connectionID,\n      nodeID,\n      edgeData\n    ));\n  }\n\n  if (isOptimisticUpdate) {\n    // optimistic updates need to record the generated client ID for\n    // a to-be-created node\n    RelayMutationTracker.putClientIDForMutation(\n      nodeID,\n      clientMutationID\n    );\n  } else {\n    // non-optimistic updates check for the existence of a generated client\n    // ID (from the above `if` clause) and link the client ID to the actual\n    // server ID.\n    const clientNodeID =\n      RelayMutationTracker.getClientIDForMutation(clientMutationID);\n    if (clientNodeID) {\n      RelayMutationTracker.updateClientServerIDMap(\n        clientNodeID,\n        nodeID\n      );\n      RelayMutationTracker.deleteClientIDForMutation(clientMutationID);\n    }\n  }\n}\n\n/**\n * Writes the node data for the given field to the store and prepends/appends\n * the node to the given connection.\n */\nfunction addRangeNode(\n  writer: RelayQueryWriter,\n  operation: RelayQuery.Operation,\n  config: OperationConfig,\n  connectionID: DataID,\n  nodeID: DataID,\n  edgeData: any\n) {\n  const store = writer.getRecordStore();\n  const recordWriter = writer.getRecordWriter();\n  const filterCalls = store.getRangeFilterCalls(connectionID);\n  const rangeBehavior = filterCalls ?\n    getRangeBehavior(config.rangeBehaviors, filterCalls) :\n    null;\n\n  // no range behavior specified for this combination of filter calls\n  if (!rangeBehavior) {\n    return;\n  }\n\n  const edgeID = generateClientEdgeID(connectionID, nodeID);\n  let path = store.getPathToRecord(connectionID);\n  invariant(\n    path,\n    'writeRelayUpdatePayload(): Expected a path for connection record, `%s`.',\n    connectionID\n  );\n  path = path.getPath(EDGES_FIELD, edgeID);\n\n  // create the edge record\n  writer.createRecordIfMissing(EDGES_FIELD, edgeID, path, edgeData);\n\n  // write data for all `edges` fields\n  // TODO #7167718: more efficient mutation/subscription writes\n  let hasEdgeField = false;\n  const handleNode = node => {\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Fragment) {\n        handleNode(child);\n      } else if (\n        child instanceof RelayQuery.Field &&\n        child.getSchemaName() === config.edgeName\n      ) {\n        hasEdgeField = true;\n        if (path) {\n          writer.writePayload(\n            child,\n            edgeID,\n            edgeData,\n            path\n          );\n        }\n      }\n    });\n  };\n  handleNode(operation);\n\n  invariant(\n    hasEdgeField,\n    'writeRelayUpdatePayload(): Expected mutation query to include the ' +\n    'relevant edge field, `%s`.',\n    config.edgeName\n  );\n\n  // append/prepend the item to the range.\n  if (rangeBehavior in GraphQLMutatorConstants.RANGE_OPERATIONS) {\n    recordWriter.applyRangeUpdate(connectionID, edgeID, (rangeBehavior: any));\n    if (writer.hasChangeToRecord(edgeID)) {\n      writer.recordUpdate(connectionID);\n    }\n  } else {\n    console.error(\n      'writeRelayUpdatePayload(): invalid range operation `%s`, valid ' +\n      'options are `%s` or `%s`.',\n      rangeBehavior,\n      APPEND,\n      PREPEND\n    );\n  }\n}\n\n/**\n * Handles the payload for a range edge deletion, which removes the edge from\n * a specified range but does not delete the node for that edge. The config\n * specifies the path within the payload that contains the connection ID.\n */\nfunction handleRangeDelete(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  config: OperationConfig\n): void {\n  const store = writer.getRecordStore();\n\n  const recordID =\n    Array.isArray(config.deletedIDFieldName) ?\n      getIDFromPath(store, config.deletedIDFieldName, payload) :\n      getString(payload, config.deletedIDFieldName);\n\n  invariant(\n    recordID != null,\n    'writeRelayUpdatePayload(): Missing ID for deleted record at field `%s`.',\n    config.deletedIDFieldName\n  );\n\n  // Extract the id of the node with the connection that we are deleting from.\n  const connectionName = config.pathToConnection.pop();\n  const connectionParentID =\n    getIDFromPath(store, config.pathToConnection, payload);\n  // Restore pathToConnection to its original state\n  config.pathToConnection.push(connectionName);\n  if (!connectionParentID) {\n    return;\n  }\n\n  const connectionIDs = store.getConnectionIDsForField(\n    connectionParentID,\n    connectionName\n  );\n  if (connectionIDs) {\n    connectionIDs.forEach(connectionID => {\n      deleteRangeEdge(writer, connectionID, recordID);\n    });\n  }\n}\n\n/**\n * Removes an edge from a connection without modifying the node data.\n */\nfunction deleteRangeEdge(\n  writer: RelayQueryWriter,\n  connectionID: DataID,\n  nodeID: DataID\n): void {\n  const recordWriter = writer.getRecordWriter();\n  const edgeID = generateClientEdgeID(connectionID, nodeID);\n  recordWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n\n  deleteRecord(writer, edgeID);\n  if (writer.hasChangeToRecord(edgeID)) {\n    writer.recordUpdate(connectionID);\n  }\n}\n\n/**\n * Return the action (prepend/append) to use when adding an item to\n * the range with the specified calls.\n *\n * Ex:\n * rangeBehaviors: `{'orderby(recent)': 'append'}`\n * calls: `[{name: 'orderby', value: 'recent'}]`\n *\n * Returns `'append'`\n */\nfunction getRangeBehavior(\n  rangeBehaviors: RangeBehaviors,\n  calls: Array<Call>\n): ?string {\n  const call = calls.map(serializeRelayQueryCall).sort().join('').slice(1);\n  return rangeBehaviors[call] || null;\n}\n\n/**\n * Given a payload of data and a path of fields, extracts the `id` of the node\n * specified by the path.\n *\n * Example:\n * path: ['root', 'field']\n * data: {root: {field: {id: 'xyz'}}}\n *\n * Returns:\n * 'xyz'\n */\nfunction getIDFromPath(\n  store: RelayRecordStore,\n  path: Array<string>,\n  payload: PayloadObject\n): ?string {\n  // We have a special case for the path for root nodes without ids like\n  // ['viewer']. We try to match it up with something in the root call mapping\n  // first.\n  if (path.length === 1) {\n    const rootCallID = store.getDataID(path[0]);\n    if (rootCallID) {\n      return rootCallID;\n    }\n  }\n  const payloadItem = path.reduce((payloadItem, step) => {\n    return payloadItem ? getObject(payloadItem, step) : null;\n  }, payload);\n  if (payloadItem) {\n    const id = getString(payloadItem, ID);\n    invariant(\n      id != null,\n      'writeRelayUpdatePayload(): Expected `%s.id` to be a string.',\n      path.join('.')\n    );\n    return id;\n  }\n  return null;\n}\n\nfunction getString(\n  payload: PayloadObject,\n  field: string\n): ?string {\n  let value = payload[field];\n  // Coerce numbers to strings for backwards compatibility.\n  if (typeof value === 'number') {\n    warning(\n      false,\n      'writeRelayUpdatePayload(): Expected `%s` to be a string, got the ' +\n      'number `%s`.',\n      field,\n      value\n    );\n    value = '' + value;\n  }\n  invariant(\n    value == null || typeof value === 'string',\n    'writeRelayUpdatePayload(): Expected `%s` to be a string, got `%s`.',\n    field,\n    JSON.stringify(value)\n  );\n  return value;\n}\n\nfunction getObject(\n  payload: PayloadObject,\n  field: string\n): ?PayloadObject {\n  const value = payload[field];\n  invariant(\n    value == null || (typeof value === 'object' && !Array.isArray(value)),\n    'writeRelayUpdatePayload(): Expected `%s` to be an object, got `%s`.',\n    field,\n    JSON.stringify(value)\n  );\n  return value;\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'writeRelayUpdatePayload',\n  writeRelayUpdatePayload\n);\n","dependencies":["RelayInternalTypes","RelayQueryWriter","RelayRecordStore","GraphQLMutatorConstants","RelayConnectionInterface","RelayMutationTracker","RelayMutationType","RelayNodeInterface","RelayQuery","RelayQueryPath","RelayProfiler","RelayRecordState","generateClientEdgeID","generateClientID","invariant","serializeRelayQueryCall","warning","writeRelayUpdatePayload"],"id":"writeRelayUpdatePayload","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule writeRelayUpdatePayload\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst GraphQLMutatorConstants = require('GraphQLMutatorConstants');\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  DataID,\n  RangeBehaviors,\n  UpdateOptions,\n} from 'RelayInternalTypes';\nconst RelayMutationTracker = require('RelayMutationTracker');\nconst RelayMutationType = require('RelayMutationType');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nimport type RelayQueryWriter from 'RelayQueryWriter';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\n\nconst generateClientEdgeID = require('generateClientEdgeID');\nconst generateClientID = require('generateClientID');\nconst invariant = require('invariant');\nconst serializeRelayQueryCall = require('serializeRelayQueryCall');\nconst warning = require('warning');\n\n// TODO: Replace with enumeration for possible config types.\n/* OperationConfig was originally typed such that each property had the type\n * mixed.  Mixed is safer than any, but that safety comes from Flow forcing you\n * to inspect a mixed value at runtime before using it.  However these mixeds\n * are ending up everywhere and are not being inspected */\ntype OperationConfig = {[key: string]: $FlowFixMe};\n\ntype Payload = mixed | PayloadObject | PayloadArray;\ntype PayloadArray = Array<Payload>;\ntype PayloadObject = {[key: string]: Payload};\n\nconst {CLIENT_MUTATION_ID, EDGES} = RelayConnectionInterface;\nconst {ANY_TYPE, ID, ID_TYPE, NODE, NODE_TYPE} = RelayNodeInterface;\nconst {APPEND, PREPEND, REMOVE} = GraphQLMutatorConstants;\n\nconst EDGES_FIELD = RelayQuery.Field.build({\n  fieldName: EDGES,\n  type: ANY_TYPE,\n  metadata: {\n    canHaveSubselections: true,\n    isPlural: true,\n  },\n});\nconst IGNORED_KEYS = {\n  error: true,\n  [CLIENT_MUTATION_ID]: true,\n};\nconst STUB_CURSOR_ID = 'client:cursor';\n\n/**\n * @internal\n *\n * Applies the results of an update operation (mutation/subscription) to the\n * store.\n */\nfunction writeRelayUpdatePayload(\n  writer: RelayQueryWriter,\n  operation: RelayQuery.Operation,\n  payload: PayloadObject,\n  {configs, isOptimisticUpdate}: UpdateOptions\n): void {\n  configs.forEach(config => {\n    switch (config.type) {\n      case RelayMutationType.NODE_DELETE:\n        handleNodeDelete(writer, payload, config);\n        break;\n      case RelayMutationType.RANGE_ADD:\n        handleRangeAdd(\n          writer,\n          payload,\n          operation,\n          config,\n          isOptimisticUpdate\n        );\n        break;\n      case RelayMutationType.RANGE_DELETE:\n        handleRangeDelete(writer, payload, config);\n        break;\n      case RelayMutationType.FIELDS_CHANGE:\n      case RelayMutationType.REQUIRED_CHILDREN:\n        break;\n      default:\n        console.error(\n          'Expected a valid mutation handler type, got `%s`.',\n          config.type\n        );\n    }\n  });\n\n  handleMerge(writer, payload, operation);\n}\n\n/**\n * Handles the payload for a node deletion mutation, reading the ID of the node\n * to delete from the payload based on the config and then deleting references\n * to the node.\n */\nfunction handleNodeDelete(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  config: OperationConfig\n): void {\n  const recordIDs = payload[config.deletedIDFieldName];\n  if (!recordIDs) {\n    // for some mutations, deletions don't always occur so if there's no field\n    // in the payload, carry on\n    return;\n  }\n\n  if (Array.isArray(recordIDs)) {\n    recordIDs.forEach(id => {\n      deleteRecord(writer, id);\n    });\n  } else {\n    deleteRecord(writer, recordIDs);\n  }\n}\n\n/**\n * Deletes the record from the store, also removing any references to the node\n * from any ranges that contain it (along with the containing edges).\n */\nfunction deleteRecord(\n  writer: RelayQueryWriter,\n  recordID: DataID\n): void {\n  const store = writer.getRecordStore();\n  const recordWriter = writer.getRecordWriter();\n  // skip if already deleted\n  const status = store.getRecordState(recordID);\n  if (status === RelayRecordState.NONEXISTENT) {\n    return;\n  }\n\n  // Delete the node from any ranges it may be a part of\n  const connectionIDs = store.getConnectionIDsForRecord(recordID);\n  if (connectionIDs) {\n    connectionIDs.forEach(connectionID => {\n      const edgeID = generateClientEdgeID(connectionID, recordID);\n      recordWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n      writer.recordUpdate(edgeID);\n      writer.recordUpdate(connectionID);\n      // edges are never nodes, so this will not infinitely recurse\n      deleteRecord(writer, edgeID);\n    });\n  }\n\n  // delete the node\n  recordWriter.deleteRecord(recordID);\n  writer.recordUpdate(recordID);\n}\n\n/**\n * Handles merging the results of the mutation/subscription into the store,\n * updating each top-level field in the data according the fetched\n * fields/fragments.\n */\nfunction handleMerge(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  operation: RelayQuery.Operation\n): void {\n  const store = writer.getRecordStore();\n\n  // because optimistic payloads may not contain all fields, we loop over\n  // the data that is present and then have to recurse the query to find\n  // the matching fields.\n  //\n  // TODO #7167718: more efficient mutation/subscription writes\n  for (const fieldName in payload) {\n    if (!payload.hasOwnProperty(fieldName)) {\n      continue;\n    }\n    const payloadData = (payload[fieldName]: $FlowIssue); // #9357395\n    if (typeof payloadData !== 'object' || payloadData == null) {\n      continue;\n    }\n    // if the field is an argument-less root call, determine the corresponding\n    // root record ID\n    const rootID = store.getDataID(fieldName);\n    // check for valid data (has an ID or is an array) and write the field\n    if (\n      ID in payloadData ||\n      rootID ||\n      Array.isArray(payloadData)\n    ) {\n      mergeField(\n        writer,\n        fieldName,\n        payloadData,\n        operation\n      );\n    }\n  }\n}\n\n/**\n * Merges the results of a single top-level field into the store.\n */\nfunction mergeField(\n  writer: RelayQueryWriter,\n  fieldName: string,\n  payload: PayloadObject | PayloadArray,\n  operation: RelayQuery.Operation\n): void {\n  // don't write mutation/subscription metadata fields\n  if (fieldName in IGNORED_KEYS) {\n    return;\n  }\n  if (Array.isArray(payload)) {\n    payload.forEach(item => {\n      if (typeof item === 'object' && item != null && !Array.isArray(item)) {\n        if (getString(item, ID)) {\n          mergeField(writer, fieldName, item, operation);\n        }\n      }\n    });\n    return;\n  }\n  // reassign to preserve type information in below closure\n  const payloadData = payload;\n\n  const store = writer.getRecordStore();\n  let recordID = getString(payloadData, ID);\n  let path;\n\n  if (recordID != null) {\n    path = new RelayQueryPath(\n      RelayQuery.Root.build(\n        'writeRelayUpdatePayload',\n        NODE,\n        recordID,\n        null,\n        {\n          identifyingArgName: ID,\n          identifyingArgType: ID_TYPE,\n          isAbstract: true,\n          isDeferred: false,\n          isPlural: false,\n        },\n        NODE_TYPE\n      )\n    );\n  } else {\n    recordID = store.getDataID(fieldName);\n    // Root fields that do not accept arguments\n    path = new RelayQueryPath(RelayQuery.Root.build(\n      'writeRelayUpdatePayload',\n      fieldName,\n      null,\n      null,\n      {\n        identifyingArgName: null,\n        identifyingArgType: null,\n        isAbstract: true,\n        isDeferred: false,\n        isPlural: false,\n      },\n      ANY_TYPE\n    ));\n  }\n  invariant(\n    recordID,\n    'writeRelayUpdatePayload(): Expected a record ID in the response payload ' +\n    'supplied to update the store.'\n  );\n\n  // write the results for only the current field, for every instance of that\n  // field in any subfield/fragment in the query.\n  const handleNode = node => {\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Fragment) {\n        handleNode(child);\n      } else if (\n        child instanceof RelayQuery.Field &&\n        child.getSerializationKey() === fieldName\n      ) {\n        // for flow: types are lost in closures\n        if (path && recordID) {\n          // ensure the record exists and then update it\n          writer.createRecordIfMissing(\n            child,\n            recordID,\n            path,\n            payloadData\n          );\n          writer.writePayload(\n            child,\n            recordID,\n            payloadData,\n            path\n          );\n        }\n      }\n    });\n  };\n  handleNode(operation);\n}\n\n/**\n * Handles the payload for a range addition. The configuration specifies:\n * - which field in the payload contains data for the new edge\n * - the list of fetched ranges to which the edge should be added\n * - whether to append/prepend to each of those ranges\n */\nfunction handleRangeAdd(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  operation: RelayQuery.Operation,\n  config: OperationConfig,\n  isOptimisticUpdate: boolean\n): void {\n  const clientMutationID = getString(payload, CLIENT_MUTATION_ID);\n  invariant(\n    clientMutationID,\n    'writeRelayUpdatePayload(): Expected operation `%s` to have a `%s`.',\n    operation.getName(),\n    CLIENT_MUTATION_ID\n  );\n  const store = writer.getRecordStore();\n\n  // Extracts the new edge from the payload\n  const edge = getObject(payload, config.edgeName);\n  const edgeNode = edge && getObject(edge, NODE);\n  if (!edge || !edgeNode) {\n    warning(\n      false,\n      'writeRelayUpdatePayload(): Expected response payload to include the ' +\n      'newly created edge `%s` and its `node` field. Did you forget to ' +\n      'update the `RANGE_ADD` mutation config?',\n      config.edgeName\n    );\n    return;\n  }\n\n  // Extract the id of the node with the connection that we are adding to.\n  let connectionParentID = config.parentID;\n  if (!connectionParentID) {\n    const edgeSource = getObject(edge, 'source');\n    if (edgeSource) {\n      connectionParentID = getString(edgeSource, ID);\n    }\n  }\n  invariant(\n    connectionParentID,\n    'writeRelayUpdatePayload(): Cannot insert edge without a configured ' +\n    '`parentID` or a `%s.source.id` field.',\n    config.edgeName\n  );\n\n  const nodeID = getString(edgeNode, ID) || generateClientID();\n  const cursor = edge.cursor || STUB_CURSOR_ID;\n  const edgeData = {\n    ...edge,\n    cursor: cursor,\n    node: {\n      ...edgeNode,\n      id: nodeID,\n    },\n  };\n\n  // add the node to every connection for this field\n  const connectionIDs =\n    store.getConnectionIDsForField(connectionParentID, config.connectionName);\n  if (connectionIDs) {\n    connectionIDs.forEach(connectionID => addRangeNode(\n      writer,\n      operation,\n      config,\n      connectionID,\n      nodeID,\n      edgeData\n    ));\n  }\n\n  if (isOptimisticUpdate) {\n    // optimistic updates need to record the generated client ID for\n    // a to-be-created node\n    RelayMutationTracker.putClientIDForMutation(\n      nodeID,\n      clientMutationID\n    );\n  } else {\n    // non-optimistic updates check for the existence of a generated client\n    // ID (from the above `if` clause) and link the client ID to the actual\n    // server ID.\n    const clientNodeID =\n      RelayMutationTracker.getClientIDForMutation(clientMutationID);\n    if (clientNodeID) {\n      RelayMutationTracker.updateClientServerIDMap(\n        clientNodeID,\n        nodeID\n      );\n      RelayMutationTracker.deleteClientIDForMutation(clientMutationID);\n    }\n  }\n}\n\n/**\n * Writes the node data for the given field to the store and prepends/appends\n * the node to the given connection.\n */\nfunction addRangeNode(\n  writer: RelayQueryWriter,\n  operation: RelayQuery.Operation,\n  config: OperationConfig,\n  connectionID: DataID,\n  nodeID: DataID,\n  edgeData: any\n) {\n  const store = writer.getRecordStore();\n  const recordWriter = writer.getRecordWriter();\n  const filterCalls = store.getRangeFilterCalls(connectionID);\n  const rangeBehavior = filterCalls ?\n    getRangeBehavior(config.rangeBehaviors, filterCalls) :\n    null;\n\n  // no range behavior specified for this combination of filter calls\n  if (!rangeBehavior) {\n    return;\n  }\n\n  const edgeID = generateClientEdgeID(connectionID, nodeID);\n  let path = store.getPathToRecord(connectionID);\n  invariant(\n    path,\n    'writeRelayUpdatePayload(): Expected a path for connection record, `%s`.',\n    connectionID\n  );\n  path = path.getPath(EDGES_FIELD, edgeID);\n\n  // create the edge record\n  writer.createRecordIfMissing(EDGES_FIELD, edgeID, path, edgeData);\n\n  // write data for all `edges` fields\n  // TODO #7167718: more efficient mutation/subscription writes\n  let hasEdgeField = false;\n  const handleNode = node => {\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Fragment) {\n        handleNode(child);\n      } else if (\n        child instanceof RelayQuery.Field &&\n        child.getSchemaName() === config.edgeName\n      ) {\n        hasEdgeField = true;\n        if (path) {\n          writer.writePayload(\n            child,\n            edgeID,\n            edgeData,\n            path\n          );\n        }\n      }\n    });\n  };\n  handleNode(operation);\n\n  invariant(\n    hasEdgeField,\n    'writeRelayUpdatePayload(): Expected mutation query to include the ' +\n    'relevant edge field, `%s`.',\n    config.edgeName\n  );\n\n  // append/prepend the item to the range.\n  if (rangeBehavior in GraphQLMutatorConstants.RANGE_OPERATIONS) {\n    recordWriter.applyRangeUpdate(connectionID, edgeID, (rangeBehavior: any));\n    if (writer.hasChangeToRecord(edgeID)) {\n      writer.recordUpdate(connectionID);\n    }\n  } else {\n    console.error(\n      'writeRelayUpdatePayload(): invalid range operation `%s`, valid ' +\n      'options are `%s` or `%s`.',\n      rangeBehavior,\n      APPEND,\n      PREPEND\n    );\n  }\n}\n\n/**\n * Handles the payload for a range edge deletion, which removes the edge from\n * a specified range but does not delete the node for that edge. The config\n * specifies the path within the payload that contains the connection ID.\n */\nfunction handleRangeDelete(\n  writer: RelayQueryWriter,\n  payload: PayloadObject,\n  config: OperationConfig\n): void {\n  const store = writer.getRecordStore();\n\n  const recordID =\n    Array.isArray(config.deletedIDFieldName) ?\n      getIDFromPath(store, config.deletedIDFieldName, payload) :\n      getString(payload, config.deletedIDFieldName);\n\n  invariant(\n    recordID != null,\n    'writeRelayUpdatePayload(): Missing ID for deleted record at field `%s`.',\n    config.deletedIDFieldName\n  );\n\n  // Extract the id of the node with the connection that we are deleting from.\n  const connectionName = config.pathToConnection.pop();\n  const connectionParentID =\n    getIDFromPath(store, config.pathToConnection, payload);\n  // Restore pathToConnection to its original state\n  config.pathToConnection.push(connectionName);\n  if (!connectionParentID) {\n    return;\n  }\n\n  const connectionIDs = store.getConnectionIDsForField(\n    connectionParentID,\n    connectionName\n  );\n  if (connectionIDs) {\n    connectionIDs.forEach(connectionID => {\n      deleteRangeEdge(writer, connectionID, recordID);\n    });\n  }\n}\n\n/**\n * Removes an edge from a connection without modifying the node data.\n */\nfunction deleteRangeEdge(\n  writer: RelayQueryWriter,\n  connectionID: DataID,\n  nodeID: DataID\n): void {\n  const recordWriter = writer.getRecordWriter();\n  const edgeID = generateClientEdgeID(connectionID, nodeID);\n  recordWriter.applyRangeUpdate(connectionID, edgeID, REMOVE);\n\n  deleteRecord(writer, edgeID);\n  if (writer.hasChangeToRecord(edgeID)) {\n    writer.recordUpdate(connectionID);\n  }\n}\n\n/**\n * Return the action (prepend/append) to use when adding an item to\n * the range with the specified calls.\n *\n * Ex:\n * rangeBehaviors: `{'orderby(recent)': 'append'}`\n * calls: `[{name: 'orderby', value: 'recent'}]`\n *\n * Returns `'append'`\n */\nfunction getRangeBehavior(\n  rangeBehaviors: RangeBehaviors,\n  calls: Array<Call>\n): ?string {\n  const call = calls.map(serializeRelayQueryCall).sort().join('').slice(1);\n  return rangeBehaviors[call] || null;\n}\n\n/**\n * Given a payload of data and a path of fields, extracts the `id` of the node\n * specified by the path.\n *\n * Example:\n * path: ['root', 'field']\n * data: {root: {field: {id: 'xyz'}}}\n *\n * Returns:\n * 'xyz'\n */\nfunction getIDFromPath(\n  store: RelayRecordStore,\n  path: Array<string>,\n  payload: PayloadObject\n): ?string {\n  // We have a special case for the path for root nodes without ids like\n  // ['viewer']. We try to match it up with something in the root call mapping\n  // first.\n  if (path.length === 1) {\n    const rootCallID = store.getDataID(path[0]);\n    if (rootCallID) {\n      return rootCallID;\n    }\n  }\n  const payloadItem = path.reduce((payloadItem, step) => {\n    return payloadItem ? getObject(payloadItem, step) : null;\n  }, payload);\n  if (payloadItem) {\n    const id = getString(payloadItem, ID);\n    invariant(\n      id != null,\n      'writeRelayUpdatePayload(): Expected `%s.id` to be a string.',\n      path.join('.')\n    );\n    return id;\n  }\n  return null;\n}\n\nfunction getString(\n  payload: PayloadObject,\n  field: string\n): ?string {\n  let value = payload[field];\n  // Coerce numbers to strings for backwards compatibility.\n  if (typeof value === 'number') {\n    warning(\n      false,\n      'writeRelayUpdatePayload(): Expected `%s` to be a string, got the ' +\n      'number `%s`.',\n      field,\n      value\n    );\n    value = '' + value;\n  }\n  invariant(\n    value == null || typeof value === 'string',\n    'writeRelayUpdatePayload(): Expected `%s` to be a string, got `%s`.',\n    field,\n    JSON.stringify(value)\n  );\n  return value;\n}\n\nfunction getObject(\n  payload: PayloadObject,\n  field: string\n): ?PayloadObject {\n  const value = payload[field];\n  invariant(\n    value == null || (typeof value === 'object' && !Array.isArray(value)),\n    'writeRelayUpdatePayload(): Expected `%s` to be an object, got `%s`.',\n    field,\n    JSON.stringify(value)\n  );\n  return value;\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'writeRelayUpdatePayload',\n  writeRelayUpdatePayload\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/writeRelayQueryPayload.js":{"metadata":{"mtime":1455679339000},"data":{"name":"writeRelayQueryPayload","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule writeRelayQueryPayload\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryPath = require('RelayQueryPath');\nimport type RelayQueryWriter from 'RelayQueryWriter';\nimport type {QueryPayload} from 'RelayInternalTypes';\n\n/**\n * @internal\n *\n * Traverses a query and payload in parallel, writing the results into the\n * store.\n */\nfunction writeRelayQueryPayload(\n  writer: RelayQueryWriter,\n  query: RelayQuery.Root,\n  payload: QueryPayload\n): void {\n  const store = writer.getRecordStore();\n  const recordWriter = writer.getRecordWriter();\n  const path = new RelayQueryPath(query);\n\n  RelayNodeInterface.getResultsFromPayload(store, query, payload)\n    .forEach(({dataID, result, rootCallInfo}) => {\n      if (rootCallInfo) {\n        recordWriter.putDataID(\n          rootCallInfo.storageKey,\n          rootCallInfo.identifyingArgValue,\n          dataID\n        );\n      }\n      writer.writePayload(query, dataID, result, path);\n    });\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'writeRelayQueryPayload',\n  writeRelayQueryPayload\n);\n","dependencies":["RelayQuery","RelayQueryWriter","RelayInternalTypes","RelayNodeInterface","RelayProfiler","RelayQueryPath","writeRelayQueryPayload"],"id":"writeRelayQueryPayload","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule writeRelayQueryPayload\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryPath = require('RelayQueryPath');\nimport type RelayQueryWriter from 'RelayQueryWriter';\nimport type {QueryPayload} from 'RelayInternalTypes';\n\n/**\n * @internal\n *\n * Traverses a query and payload in parallel, writing the results into the\n * store.\n */\nfunction writeRelayQueryPayload(\n  writer: RelayQueryWriter,\n  query: RelayQuery.Root,\n  payload: QueryPayload\n): void {\n  const store = writer.getRecordStore();\n  const recordWriter = writer.getRecordWriter();\n  const path = new RelayQueryPath(query);\n\n  RelayNodeInterface.getResultsFromPayload(store, query, payload)\n    .forEach(({dataID, result, rootCallInfo}) => {\n      if (rootCallInfo) {\n        recordWriter.putDataID(\n          rootCallInfo.storageKey,\n          rootCallInfo.identifyingArgValue,\n          dataID\n        );\n      }\n      writer.writePayload(query, dataID, result, path);\n    });\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'writeRelayQueryPayload',\n  writeRelayQueryPayload\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/transformRelayQueryPayload.js":{"metadata":{"mtime":1455679339000},"data":{"name":"transformRelayQueryPayload","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule transformRelayQueryPayload\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nimport type {QueryPayload} from 'RelayInternalTypes';\n\nconst invariant = require('invariant');\nconst mapObject = require('mapObject');\n\ntype PayloadState = {\n  client: QueryPayload,\n  server: QueryPayload,\n};\ntype TransformConfig = {\n  getKeyForClientData: (field: RelayQuery.Field) => string;\n  traverseChildren: (\n    node: RelayQuery.Node,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ) => void;\n};\n\n/**\n * Transforms \"client\" payloads with property keys that match the \"application\"\n * names (i.e. property names are schema names or aliases) into \"server\"\n * payloads that match what the server would return for the given query (i.e.\n * property names are serialization keys instead).\n */\nfunction transformRelayQueryPayload(\n  root: RelayQuery.Root,\n  clientData: QueryPayload,\n  config?: TransformConfig\n): QueryPayload {\n  if (clientData == null) {\n    return clientData;\n  } else {\n    return mapObject(clientData, item => {\n      // Handle both FB & OSS formats for root payloads on plural calls: FB\n      // returns objects, OSS returns arrays.\n      if (Array.isArray(item)) {\n        return item.map(\n          innerItem => transform(root, innerItem, config)\n        );\n      }\n      return transform(root, item, config);\n    });\n  }\n}\n\nfunction transform(\n  root: RelayQuery.Root,\n  clientData: QueryPayload,\n  config: ?TransformConfig\n): QueryPayload {\n  if (clientData == null) {\n    return clientData;\n  }\n  const transformer = new RelayPayloadTransformer(config);\n  const serverData = {};\n  transformer.visit(root, {\n    client: clientData,\n    server: serverData,\n  });\n  return serverData;\n}\n\nclass RelayPayloadTransformer extends RelayQueryVisitor<PayloadState> {\n  _getKeyForClientData: (field: RelayQuery.Field) => string;\n  _traverseChildren: ?(\n    node: RelayQuery.Node,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ) => void;\n\n  constructor(config: ?TransformConfig) {\n    super();\n    if (config) {\n      this._getKeyForClientData = config.getKeyForClientData;\n      this._traverseChildren = config.traverseChildren;\n    }\n  }\n\n  _getKeyForClientData(field: RelayQuery.Field): string {\n    return field.getApplicationName();\n  }\n\n  traverseChildren(\n    node: RelayQuery.Node,\n    nextState: PayloadState,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ): void {\n    if (this._traverseChildren) {\n      this._traverseChildren(node, callback, context);\n    } else {\n      super.traverseChildren(node, nextState, callback, context);\n    }\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    state: PayloadState\n  ): void {\n    const {client, server} = state;\n    const applicationName = this._getKeyForClientData(node);\n    const serializationKey = node.getSerializationKey();\n    const clientData = client[applicationName];\n    let serverData = server[serializationKey];\n\n    if (!node.canHaveSubselections() || clientData == null) {\n      server[serializationKey] = clientData;\n    } else if (Array.isArray(clientData)) {\n      if (serverData == null) {\n        server[serializationKey] = serverData = [];\n      }\n      clientData.forEach((clientItem, index) => {\n        invariant(\n          Array.isArray(serverData),\n          'RelayPayloadTransformer: Got conflicting values for field `%s`: ' +\n          'expected values to be arrays.',\n          applicationName\n        );\n        if (clientItem == null) {\n          serverData[index] = clientItem;\n          return;\n        }\n        let serverItem = serverData && serverData[index];\n        if (serverItem == null) {\n          serverData[index] = serverItem = {};\n        }\n        this.traverse(node, {\n          client: clientItem,\n          server: serverItem,\n        });\n      });\n    } else {\n      invariant(\n        typeof clientData === 'object' && clientData !== null,\n        'RelayPayloadTransformer: Expected an object value for field `%s`.',\n        applicationName\n      );\n      invariant(\n        serverData == null || typeof serverData === 'object',\n        'RelayPayloadTransformer: Got conflicting values for field `%s`: ' +\n        'expected values to be objects.',\n        applicationName\n      );\n      if (serverData == null) {\n        server[serializationKey] = serverData = {};\n      }\n      this.traverse(node, {\n        client: clientData,\n        server: serverData,\n      });\n    }\n  }\n}\n\nmodule.exports = transformRelayQueryPayload;\n","dependencies":["RelayInternalTypes","RelayQuery","RelayQueryVisitor","invariant","mapObject","transformRelayQueryPayload"],"id":"transformRelayQueryPayload","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule transformRelayQueryPayload\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nimport type {QueryPayload} from 'RelayInternalTypes';\n\nconst invariant = require('invariant');\nconst mapObject = require('mapObject');\n\ntype PayloadState = {\n  client: QueryPayload,\n  server: QueryPayload,\n};\ntype TransformConfig = {\n  getKeyForClientData: (field: RelayQuery.Field) => string;\n  traverseChildren: (\n    node: RelayQuery.Node,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ) => void;\n};\n\n/**\n * Transforms \"client\" payloads with property keys that match the \"application\"\n * names (i.e. property names are schema names or aliases) into \"server\"\n * payloads that match what the server would return for the given query (i.e.\n * property names are serialization keys instead).\n */\nfunction transformRelayQueryPayload(\n  root: RelayQuery.Root,\n  clientData: QueryPayload,\n  config?: TransformConfig\n): QueryPayload {\n  if (clientData == null) {\n    return clientData;\n  } else {\n    return mapObject(clientData, item => {\n      // Handle both FB & OSS formats for root payloads on plural calls: FB\n      // returns objects, OSS returns arrays.\n      if (Array.isArray(item)) {\n        return item.map(\n          innerItem => transform(root, innerItem, config)\n        );\n      }\n      return transform(root, item, config);\n    });\n  }\n}\n\nfunction transform(\n  root: RelayQuery.Root,\n  clientData: QueryPayload,\n  config: ?TransformConfig\n): QueryPayload {\n  if (clientData == null) {\n    return clientData;\n  }\n  const transformer = new RelayPayloadTransformer(config);\n  const serverData = {};\n  transformer.visit(root, {\n    client: clientData,\n    server: serverData,\n  });\n  return serverData;\n}\n\nclass RelayPayloadTransformer extends RelayQueryVisitor<PayloadState> {\n  _getKeyForClientData: (field: RelayQuery.Field) => string;\n  _traverseChildren: ?(\n    node: RelayQuery.Node,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ) => void;\n\n  constructor(config: ?TransformConfig) {\n    super();\n    if (config) {\n      this._getKeyForClientData = config.getKeyForClientData;\n      this._traverseChildren = config.traverseChildren;\n    }\n  }\n\n  _getKeyForClientData(field: RelayQuery.Field): string {\n    return field.getApplicationName();\n  }\n\n  traverseChildren(\n    node: RelayQuery.Node,\n    nextState: PayloadState,\n    callback: (\n      child: RelayQuery.Node,\n      index: number,\n      children: Array<RelayQuery.Node>\n    ) => void,\n    context: any\n  ): void {\n    if (this._traverseChildren) {\n      this._traverseChildren(node, callback, context);\n    } else {\n      super.traverseChildren(node, nextState, callback, context);\n    }\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    state: PayloadState\n  ): void {\n    const {client, server} = state;\n    const applicationName = this._getKeyForClientData(node);\n    const serializationKey = node.getSerializationKey();\n    const clientData = client[applicationName];\n    let serverData = server[serializationKey];\n\n    if (!node.canHaveSubselections() || clientData == null) {\n      server[serializationKey] = clientData;\n    } else if (Array.isArray(clientData)) {\n      if (serverData == null) {\n        server[serializationKey] = serverData = [];\n      }\n      clientData.forEach((clientItem, index) => {\n        invariant(\n          Array.isArray(serverData),\n          'RelayPayloadTransformer: Got conflicting values for field `%s`: ' +\n          'expected values to be arrays.',\n          applicationName\n        );\n        if (clientItem == null) {\n          serverData[index] = clientItem;\n          return;\n        }\n        let serverItem = serverData && serverData[index];\n        if (serverItem == null) {\n          serverData[index] = serverItem = {};\n        }\n        this.traverse(node, {\n          client: clientItem,\n          server: serverItem,\n        });\n      });\n    } else {\n      invariant(\n        typeof clientData === 'object' && clientData !== null,\n        'RelayPayloadTransformer: Expected an object value for field `%s`.',\n        applicationName\n      );\n      invariant(\n        serverData == null || typeof serverData === 'object',\n        'RelayPayloadTransformer: Got conflicting values for field `%s`: ' +\n        'expected values to be objects.',\n        applicationName\n      );\n      if (serverData == null) {\n        server[serializationKey] = serverData = {};\n      }\n      this.traverse(node, {\n        client: clientData,\n        server: serverData,\n      });\n    }\n  }\n}\n\nmodule.exports = transformRelayQueryPayload;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/subtractRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"name":"subtractRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule subtractRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\n\nconst areEqual = require('areEqual');\nconst invariant = require('invariant');\n\ntype SubtractState = {\n  isEmpty: boolean;\n  subtrahend: RelayQuery.Node;\n};\n\n/**\n * @internal\n *\n * `subtractRelayQuery(minuend, subtrahend)` returns a new query\n * that matches the structure of `minuend`, minus any fields which also\n * occur in `subtrahend`. Returns null if all fields can be subtracted,\n * `minuend` if no fields can be subtracted, and a new query otherwise.\n */\nfunction subtractRelayQuery(\n  minuend: RelayQuery.Root,\n  subtrahend: RelayQuery.Root\n): ?RelayQuery.Root {\n  var visitor = new RelayQuerySubtractor();\n  var state = {\n    isEmpty: true,\n    subtrahend,\n  };\n  var diff = visitor.visit(minuend, state);\n  if (!state.isEmpty) {\n    invariant(\n      diff instanceof RelayQuery.Root,\n      'subtractRelayQuery(): Expected a subtracted query root.'\n    );\n    return diff;\n  }\n  return null;\n}\n\nclass RelayQuerySubtractor extends RelayQueryTransform<SubtractState> {\n  visitRoot(\n    node: RelayQuery.Root,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var {subtrahend} = state;\n    invariant(\n      subtrahend instanceof RelayQuery.Root,\n      'subtractRelayQuery(): Cannot subtract a non-root node from a root.'\n    );\n    if (!canSubtractRoot(node, subtrahend)) {\n      state.isEmpty = false;\n      return node;\n    }\n    return this._subtractChildren(node, state);\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    return this._subtractChildren(node, state);\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var diff;\n    if (!node.canHaveSubselections()) {\n      diff = this._subtractScalar(node, state);\n    } else if (node.isConnection()) {\n      diff = this._subtractConnection(node, state);\n    } else {\n      diff = this._subtractField(node, state);\n    }\n    if (diff && (diff.isRequisite() || !state.isEmpty)) {\n      return diff;\n    }\n    return null;\n  }\n\n  _subtractScalar(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var subField = state.subtrahend.getField(node);\n\n    if (subField && !node.isRequisite()) {\n      return null;\n    }\n    state.isEmpty = isEmptyField(node);\n    return node;\n  }\n\n  _subtractConnection(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var subtrahendRanges = getMatchingRangeFields(node, state.subtrahend);\n\n    if (!subtrahendRanges.length) {\n      state.isEmpty = isEmptyField(node);\n      return node;\n    }\n\n    var diff = node;\n    var fieldState;\n    for (var ii = 0; ii < subtrahendRanges.length; ii++) {\n      fieldState = {\n        isEmpty: true,\n        subtrahend: subtrahendRanges[ii],\n      };\n      diff = this._subtractChildren(diff, fieldState);\n      state.isEmpty = fieldState.isEmpty;\n      if (!diff) {\n        break;\n      }\n    }\n    return diff;\n  }\n\n  /**\n   * Subtract a non-scalar/range field.\n   */\n  _subtractField(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var subField = state.subtrahend.getField(node);\n\n    if (!subField) {\n      state.isEmpty = isEmptyField(node);\n      return node;\n    }\n\n    var fieldState = {\n      isEmpty: true,\n      subtrahend: subField,\n    };\n    var diff = this._subtractChildren(node, fieldState);\n    state.isEmpty = fieldState.isEmpty;\n    return diff;\n  }\n\n  /**\n   * Subtracts any RelayQuery.Node that contains subfields.\n   */\n  _subtractChildren(\n    node: RelayQuery.Node,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    return node.clone(node.getChildren().map(child => {\n      var childState = {\n        isEmpty: true,\n        subtrahend: state.subtrahend,\n      };\n      var diff = this.visit(child, childState);\n      state.isEmpty = state.isEmpty && childState.isEmpty;\n      return diff;\n    }));\n  }\n}\n\n/**\n * Determine if the subtree is effectively 'empty'; all non-metadata sub-fields\n * have been removed.\n */\nfunction isEmptyField(\n  node: RelayQuery.Node\n): boolean {\n  if (node instanceof RelayQuery.Field && !node.canHaveSubselections()) {\n    // Note: product-specific hacks use aliased cursors/ids to poll for data.\n    // Without the alias check these queries would be considered empty.\n    return (\n      node.isRequisite() &&\n      !node.isRefQueryDependency() &&\n      node.getApplicationName() === node.getSchemaName()\n    );\n  } else {\n    return node.getChildren().every(isEmptyField);\n  }\n}\n\n/**\n * Determine if the two queries have the same root field and identifying arg.\n */\nfunction canSubtractRoot(\n  min: RelayQuery.Root,\n  sub: RelayQuery.Root\n): boolean {\n  var minIdentifyingCall = min.getIdentifyingArg();\n  var subIdentifyingCall = sub.getIdentifyingArg();\n  return (\n    min.getFieldName() === sub.getFieldName() &&\n    areEqual(minIdentifyingCall, subIdentifyingCall)\n  );\n}\n\n/**\n * Find all subfields that may overlap with the range rooted at `node`.\n */\nfunction getMatchingRangeFields(\n  node: RelayQuery.Field,\n  subtrahend: RelayQuery.Node\n): Array<RelayQuery.Node> {\n  return subtrahend.getChildren().filter(\n    child => child instanceof RelayQuery.Field && canSubtractField(node, child)\n  );\n}\n\n/**\n * Determine if `minField` is a subset of the range specified by `subField`\n * such that they can be subtracted.\n */\nfunction canSubtractField(\n  minField: RelayQuery.Field,\n  subField: RelayQuery.Field\n): boolean {\n  if (minField.getSchemaName() !== subField.getSchemaName()) {\n    return false;\n  }\n  var minArgs = minField.getCallsWithValues();\n  var subArgs = subField.getCallsWithValues();\n  if (minArgs.length !== subArgs.length) {\n    return false;\n  }\n  return minArgs.every((minArg, ii) => {\n    var subArg = subArgs[ii];\n    if (subArg == null) {\n      return false;\n    }\n    if (minArg.name !== subArg.name) {\n      return false;\n    }\n    if (minArg.name === 'first' || minArg.name === 'last') {\n      /* $FlowFixMe(>=0.13.0)\n       *\n       * subArg and minArg are of type 'Call' (defined in RelayQueryField) which\n       * specifies that its 'value' property is nullable. This code assumes that\n       * it is not, however, and Flow points out that it may produce\n       * `parseInt('undefined')`.\n       */\n      return parseInt('' + minArg.value, 10) <= parseInt('' + subArg.value, 10);\n    }\n    return areEqual(minArg.value, subArg.value);\n  });\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'subtractRelayQuery',\n  subtractRelayQuery\n);\n","dependencies":["RelayProfiler","RelayQuery","RelayQueryTransform","areEqual","invariant","subtractRelayQuery"],"id":"subtractRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule subtractRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\n\nconst areEqual = require('areEqual');\nconst invariant = require('invariant');\n\ntype SubtractState = {\n  isEmpty: boolean;\n  subtrahend: RelayQuery.Node;\n};\n\n/**\n * @internal\n *\n * `subtractRelayQuery(minuend, subtrahend)` returns a new query\n * that matches the structure of `minuend`, minus any fields which also\n * occur in `subtrahend`. Returns null if all fields can be subtracted,\n * `minuend` if no fields can be subtracted, and a new query otherwise.\n */\nfunction subtractRelayQuery(\n  minuend: RelayQuery.Root,\n  subtrahend: RelayQuery.Root\n): ?RelayQuery.Root {\n  var visitor = new RelayQuerySubtractor();\n  var state = {\n    isEmpty: true,\n    subtrahend,\n  };\n  var diff = visitor.visit(minuend, state);\n  if (!state.isEmpty) {\n    invariant(\n      diff instanceof RelayQuery.Root,\n      'subtractRelayQuery(): Expected a subtracted query root.'\n    );\n    return diff;\n  }\n  return null;\n}\n\nclass RelayQuerySubtractor extends RelayQueryTransform<SubtractState> {\n  visitRoot(\n    node: RelayQuery.Root,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var {subtrahend} = state;\n    invariant(\n      subtrahend instanceof RelayQuery.Root,\n      'subtractRelayQuery(): Cannot subtract a non-root node from a root.'\n    );\n    if (!canSubtractRoot(node, subtrahend)) {\n      state.isEmpty = false;\n      return node;\n    }\n    return this._subtractChildren(node, state);\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    return this._subtractChildren(node, state);\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var diff;\n    if (!node.canHaveSubselections()) {\n      diff = this._subtractScalar(node, state);\n    } else if (node.isConnection()) {\n      diff = this._subtractConnection(node, state);\n    } else {\n      diff = this._subtractField(node, state);\n    }\n    if (diff && (diff.isRequisite() || !state.isEmpty)) {\n      return diff;\n    }\n    return null;\n  }\n\n  _subtractScalar(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var subField = state.subtrahend.getField(node);\n\n    if (subField && !node.isRequisite()) {\n      return null;\n    }\n    state.isEmpty = isEmptyField(node);\n    return node;\n  }\n\n  _subtractConnection(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var subtrahendRanges = getMatchingRangeFields(node, state.subtrahend);\n\n    if (!subtrahendRanges.length) {\n      state.isEmpty = isEmptyField(node);\n      return node;\n    }\n\n    var diff = node;\n    var fieldState;\n    for (var ii = 0; ii < subtrahendRanges.length; ii++) {\n      fieldState = {\n        isEmpty: true,\n        subtrahend: subtrahendRanges[ii],\n      };\n      diff = this._subtractChildren(diff, fieldState);\n      state.isEmpty = fieldState.isEmpty;\n      if (!diff) {\n        break;\n      }\n    }\n    return diff;\n  }\n\n  /**\n   * Subtract a non-scalar/range field.\n   */\n  _subtractField(\n    node: RelayQuery.Field,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    var subField = state.subtrahend.getField(node);\n\n    if (!subField) {\n      state.isEmpty = isEmptyField(node);\n      return node;\n    }\n\n    var fieldState = {\n      isEmpty: true,\n      subtrahend: subField,\n    };\n    var diff = this._subtractChildren(node, fieldState);\n    state.isEmpty = fieldState.isEmpty;\n    return diff;\n  }\n\n  /**\n   * Subtracts any RelayQuery.Node that contains subfields.\n   */\n  _subtractChildren(\n    node: RelayQuery.Node,\n    state: SubtractState\n  ): ?RelayQuery.Node {\n    return node.clone(node.getChildren().map(child => {\n      var childState = {\n        isEmpty: true,\n        subtrahend: state.subtrahend,\n      };\n      var diff = this.visit(child, childState);\n      state.isEmpty = state.isEmpty && childState.isEmpty;\n      return diff;\n    }));\n  }\n}\n\n/**\n * Determine if the subtree is effectively 'empty'; all non-metadata sub-fields\n * have been removed.\n */\nfunction isEmptyField(\n  node: RelayQuery.Node\n): boolean {\n  if (node instanceof RelayQuery.Field && !node.canHaveSubselections()) {\n    // Note: product-specific hacks use aliased cursors/ids to poll for data.\n    // Without the alias check these queries would be considered empty.\n    return (\n      node.isRequisite() &&\n      !node.isRefQueryDependency() &&\n      node.getApplicationName() === node.getSchemaName()\n    );\n  } else {\n    return node.getChildren().every(isEmptyField);\n  }\n}\n\n/**\n * Determine if the two queries have the same root field and identifying arg.\n */\nfunction canSubtractRoot(\n  min: RelayQuery.Root,\n  sub: RelayQuery.Root\n): boolean {\n  var minIdentifyingCall = min.getIdentifyingArg();\n  var subIdentifyingCall = sub.getIdentifyingArg();\n  return (\n    min.getFieldName() === sub.getFieldName() &&\n    areEqual(minIdentifyingCall, subIdentifyingCall)\n  );\n}\n\n/**\n * Find all subfields that may overlap with the range rooted at `node`.\n */\nfunction getMatchingRangeFields(\n  node: RelayQuery.Field,\n  subtrahend: RelayQuery.Node\n): Array<RelayQuery.Node> {\n  return subtrahend.getChildren().filter(\n    child => child instanceof RelayQuery.Field && canSubtractField(node, child)\n  );\n}\n\n/**\n * Determine if `minField` is a subset of the range specified by `subField`\n * such that they can be subtracted.\n */\nfunction canSubtractField(\n  minField: RelayQuery.Field,\n  subField: RelayQuery.Field\n): boolean {\n  if (minField.getSchemaName() !== subField.getSchemaName()) {\n    return false;\n  }\n  var minArgs = minField.getCallsWithValues();\n  var subArgs = subField.getCallsWithValues();\n  if (minArgs.length !== subArgs.length) {\n    return false;\n  }\n  return minArgs.every((minArg, ii) => {\n    var subArg = subArgs[ii];\n    if (subArg == null) {\n      return false;\n    }\n    if (minArg.name !== subArg.name) {\n      return false;\n    }\n    if (minArg.name === 'first' || minArg.name === 'last') {\n      /* $FlowFixMe(>=0.13.0)\n       *\n       * subArg and minArg are of type 'Call' (defined in RelayQueryField) which\n       * specifies that its 'value' property is nullable. This code assumes that\n       * it is not, however, and Flow points out that it may produce\n       * `parseInt('undefined')`.\n       */\n      return parseInt('' + minArg.value, 10) <= parseInt('' + subArg.value, 10);\n    }\n    return areEqual(minArg.value, subArg.value);\n  });\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'subtractRelayQuery',\n  subtractRelayQuery\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/splitDeferredRelayQueries.js":{"metadata":{"mtime":1455679339000},"data":{"name":"splitDeferredRelayQueries","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule splitDeferredRelayQueries\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst QueryBuilder = require('QueryBuilder');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\nconst RelayRefQueryDescriptor = require('RelayRefQueryDescriptor');\nimport type {NodePath} from 'RelayRefQueryDescriptor';\n\nconst invariant = require('invariant');\n\nexport type SplitQueries = {\n  __nodePath__: NodePath;\n  __parent__: ?SplitQueries;\n  __refQuery__: ?RelayRefQueryDescriptor;\n  deferred: Array<SplitQueries>;\n  required: ?RelayQuery.Root;\n};\n\n/**\n * Traverse `node` splitting off deferred query fragments into separate queries.\n *\n * @internal\n */\nfunction splitDeferredRelayQueries(node: RelayQuery.Root): SplitQueries {\n  const splitter = new GraphQLSplitDeferredQueries();\n  const splitQueries = {\n    __nodePath__: [],\n    __parent__: null,\n    __refQuery__: null,\n    deferred: [],\n    required: null,\n  };\n  splitter.visit(node, splitQueries);\n\n  return buildQueries(splitQueries);\n}\n\n/**\n * Returns the requisite siblings of `node`, but filters any non-requisite\n * children of those siblings.\n */\nfunction getRequisiteSiblings(\n  node: RelayQuery.Node,\n  parent: RelayQuery.Node\n): Array<RelayQuery.Node> {\n  // Get the requisite siblings.\n  const siblings = parent.getChildren().filter(child => (\n    child !== node &&\n    child instanceof RelayQuery.Field &&\n    child.isRequisite()\n  ));\n\n  // Filter the non-requisite children from those siblings.\n  return siblings.map(sibling => {\n    const children = sibling.getChildren().filter(child => (\n      child instanceof RelayQuery.Field &&\n      child.isRequisite()\n    ));\n    const clone = sibling.clone(children);\n    invariant(\n      clone,\n      'splitDeferredRelayQueries(): Unexpected non-scalar, requisite field.'\n    );\n    return clone;\n  });\n}\n\n/**\n * Traverse the parent chain of `node` wrapping it at each level until it is\n * either:\n *\n * - wrapped in a RelayQuery.Root node\n * - wrapped in a non-root node that can be split off in a \"ref query\" (ie. a\n *   root call with a ref param that references another query)\n *\n * Additionally ensures that any requisite sibling fields are embedded in each\n * layer of the wrapper.\n */\nfunction wrapNode(\n  node: RelayQuery.Node,\n  nodePath: NodePath\n): (RelayQuery.Node | RelayRefQueryDescriptor) {\n  for (let ii = nodePath.length - 1; ii >= 0; ii--) {\n    const parent = nodePath[ii];\n    if (\n      parent instanceof RelayQuery.Field &&\n      parent.getInferredRootCallName()\n    ) {\n      // We can make a \"ref query\" at this point, so stop wrapping.\n      return new RelayRefQueryDescriptor(node, nodePath.slice(0, ii + 1));\n    }\n\n    const siblings = getRequisiteSiblings(node, parent);\n    const children = [node].concat(siblings);\n\n    // Cast here because we know that `clone` will never return `null` (because\n    // we always give it at least one child).\n    node = (parent.clone(children): any);\n  }\n  invariant(\n    node instanceof RelayQuery.Root,\n    'splitDeferredRelayQueries(): Cannot build query without a root node.'\n  );\n  const identifyingArg = node.getIdentifyingArg();\n  const identifyingArgName = (identifyingArg && identifyingArg.name) || null;\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  const metadata = {\n    identifyingArgName,\n    identifyingArgType: RelayNodeInterface.ID_TYPE,\n    isAbstract: true,\n    isDeferred: true,\n    isPlural: false,\n  };\n  return RelayQuery.Root.build(\n    node.getName(),\n    node.getFieldName(),\n    identifyingArgValue,\n    node.getChildren(),\n    metadata,\n    node.getType()\n  );\n}\n\n/**\n * Returns `true` if `node` is considered \"empty\", which means that it contains\n * no non-generated fields, and no ref query dependencies.\n */\nfunction isEmpty(node: RelayQuery.Node): boolean {\n  if (!node.canHaveSubselections()) {\n    return node.isGenerated() && !node.isRefQueryDependency();\n  } else {\n    return node.getChildren().every(isEmpty);\n  }\n}\n\n/**\n * Mutates and returns a nested `SplitQueries` structure, updating any deferred\n * \"ref queries\" to actually reference their contexts.\n */\nfunction buildQueries(splitQueries: SplitQueries): SplitQueries {\n  if (splitQueries.required && isEmpty(splitQueries.required)) {\n    splitQueries.required = null;\n  }\n  splitQueries.deferred = splitQueries.deferred.map(nestedSplitQueries => {\n    const descriptor = nestedSplitQueries.__refQuery__;\n    if (descriptor) {\n      // Wrap the ref query node with a reference to the required query that is\n      // its context.\n      let context = splitQueries.required;\n      if (!context) {\n        // Traverse upwards looking for context.\n        let parentSplitQueries = splitQueries;\n        while (parentSplitQueries.__parent__) {\n          context = parentSplitQueries.__parent__.required;\n          if (context) {\n            break;\n          }\n          parentSplitQueries = parentSplitQueries.__parent__;\n        }\n      }\n      invariant(\n        context,\n        'splitDeferredRelayQueries(): Expected a context root query.'\n      );\n      nestedSplitQueries.required = createRefQuery(descriptor, context);\n    }\n\n    return buildQueries(nestedSplitQueries);\n  });\n  return splitQueries;\n}\n\n/**\n * Wraps `descriptor` in a new top-level ref query.\n */\nfunction createRefQuery(\n  descriptor: RelayRefQueryDescriptor,\n  context: RelayQuery.Root\n): RelayQuery.Root {\n  const node = descriptor.node;\n  invariant(\n    node instanceof RelayQuery.Field ||\n    node instanceof RelayQuery.Fragment,\n    'splitDeferredRelayQueries(): Ref query requires a field or fragment.'\n  );\n\n  // Build up JSONPath.\n  const jsonPath = ['$', '*'];\n  let parent;\n  for (let ii = 0; ii < descriptor.nodePath.length; ii++) {\n    parent = descriptor.nodePath[ii];\n    if (parent instanceof RelayQuery.Field) {\n      jsonPath.push(parent.getSerializationKey());\n      if (parent.isPlural()) {\n        jsonPath.push('*');\n      }\n    }\n  }\n  invariant(\n    jsonPath.length > 2,\n    'splitDeferredRelayQueries(): Ref query requires a complete path.'\n  );\n  const field: RelayQuery.Field = (parent: any); // Flow\n  const primaryKey = field.getInferredPrimaryKey();\n  invariant(\n    primaryKey,\n    'splitDeferredRelayQueries(): Ref query requires a primary key.'\n  );\n  jsonPath.push(primaryKey);\n\n  // Create the wrapper root query.\n  const root = RelayQuery.Root.build(\n    context.getName(),\n    RelayNodeInterface.NODES,\n    QueryBuilder.createBatchCallVariable(context.getID(), jsonPath.join('.')),\n    [node],\n    {\n      identifyingArgName: RelayNodeInterface.ID,\n      identifyingArgType: RelayNodeInterface.ID_TYPE,\n      isAbstract: true,\n      isDeferred: true,\n      isPlural: false,\n    },\n    RelayNodeInterface.NODE_TYPE\n  );\n\n  const result: RelayQuery.Root = (root: any); // Flow\n  return result;\n}\n\n/**\n * Traverses an input query, updating the passed in `SplitQueries` state object\n * to contain a nested structure representing the required and deferred portions\n * of the input query.\n */\nclass GraphQLSplitDeferredQueries extends RelayQueryTransform<SplitQueries> {\n  visitField(\n    node: RelayQuery.Field,\n    splitQueries: SplitQueries\n  ): ?RelayQuery.Node {\n    if (!node.hasDeferredDescendant()) {\n      return node;\n    }\n\n    splitQueries.__nodePath__.push(node);\n    let result = this.traverse(node, splitQueries);\n    splitQueries.__nodePath__.pop();\n\n    if (result && node.getInferredRootCallName()) {\n      // The node is a ref query dependency; mark it as one.\n      const key = node.getInferredPrimaryKey();\n      const children = result.getChildren().map(child => {\n        if (\n          child instanceof RelayQuery.Field &&\n          child.getSchemaName() === key\n        ) {\n          return child.cloneAsRefQueryDependency();\n        } else {\n          return child;\n        }\n      });\n      result = result.clone(children);\n    }\n\n    return result;\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    splitQueries: SplitQueries\n  ): ?RelayQuery.Node {\n    if (!node.getChildren().length) {\n      return null;\n    }\n\n    if (node.isDeferred()) {\n      const nodePath = splitQueries.__nodePath__;\n      const deferred: SplitQueries = {\n        __nodePath__: nodePath,\n        __parent__: splitQueries,\n        __refQuery__: null,\n        deferred: [],\n        required: null,\n      };\n      const result = this.traverse(node, deferred);\n      if (result) {\n        const wrapped = wrapNode(result, nodePath);\n        if (wrapped instanceof RelayQuery.Root) {\n          deferred.required = wrapped;\n        } else if (wrapped instanceof RelayRefQueryDescriptor) { // for Flow\n          deferred.__refQuery__ = (wrapped: RelayRefQueryDescriptor);\n        }\n      }\n      if (result || deferred.deferred.length) {\n        splitQueries.deferred.push(deferred);\n      }\n      return null;\n    } else if (node.hasDeferredDescendant()) {\n      return this.traverse(node, splitQueries);\n    } else {\n      return node;\n    }\n  }\n\n  visitRoot(\n    node: RelayQuery.Root,\n    splitQueries: SplitQueries\n  ): ?RelayQuery.Node {\n    if (!node.hasDeferredDescendant()) {\n      splitQueries.required = node;\n      return node;\n    } else {\n      splitQueries.__nodePath__.push(node);\n      const result = this.traverse(node, splitQueries);\n      splitQueries.__nodePath__.pop();\n      splitQueries.required = result;\n      return result;\n    }\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'splitDeferredRelayQueries',\n  splitDeferredRelayQueries\n);\n","dependencies":["RelayRefQueryDescriptor","QueryBuilder","RelayNodeInterface","RelayProfiler","RelayQuery","RelayQueryTransform","invariant","splitDeferredRelayQueries"],"id":"splitDeferredRelayQueries","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule splitDeferredRelayQueries\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst QueryBuilder = require('QueryBuilder');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\nconst RelayRefQueryDescriptor = require('RelayRefQueryDescriptor');\nimport type {NodePath} from 'RelayRefQueryDescriptor';\n\nconst invariant = require('invariant');\n\nexport type SplitQueries = {\n  __nodePath__: NodePath;\n  __parent__: ?SplitQueries;\n  __refQuery__: ?RelayRefQueryDescriptor;\n  deferred: Array<SplitQueries>;\n  required: ?RelayQuery.Root;\n};\n\n/**\n * Traverse `node` splitting off deferred query fragments into separate queries.\n *\n * @internal\n */\nfunction splitDeferredRelayQueries(node: RelayQuery.Root): SplitQueries {\n  const splitter = new GraphQLSplitDeferredQueries();\n  const splitQueries = {\n    __nodePath__: [],\n    __parent__: null,\n    __refQuery__: null,\n    deferred: [],\n    required: null,\n  };\n  splitter.visit(node, splitQueries);\n\n  return buildQueries(splitQueries);\n}\n\n/**\n * Returns the requisite siblings of `node`, but filters any non-requisite\n * children of those siblings.\n */\nfunction getRequisiteSiblings(\n  node: RelayQuery.Node,\n  parent: RelayQuery.Node\n): Array<RelayQuery.Node> {\n  // Get the requisite siblings.\n  const siblings = parent.getChildren().filter(child => (\n    child !== node &&\n    child instanceof RelayQuery.Field &&\n    child.isRequisite()\n  ));\n\n  // Filter the non-requisite children from those siblings.\n  return siblings.map(sibling => {\n    const children = sibling.getChildren().filter(child => (\n      child instanceof RelayQuery.Field &&\n      child.isRequisite()\n    ));\n    const clone = sibling.clone(children);\n    invariant(\n      clone,\n      'splitDeferredRelayQueries(): Unexpected non-scalar, requisite field.'\n    );\n    return clone;\n  });\n}\n\n/**\n * Traverse the parent chain of `node` wrapping it at each level until it is\n * either:\n *\n * - wrapped in a RelayQuery.Root node\n * - wrapped in a non-root node that can be split off in a \"ref query\" (ie. a\n *   root call with a ref param that references another query)\n *\n * Additionally ensures that any requisite sibling fields are embedded in each\n * layer of the wrapper.\n */\nfunction wrapNode(\n  node: RelayQuery.Node,\n  nodePath: NodePath\n): (RelayQuery.Node | RelayRefQueryDescriptor) {\n  for (let ii = nodePath.length - 1; ii >= 0; ii--) {\n    const parent = nodePath[ii];\n    if (\n      parent instanceof RelayQuery.Field &&\n      parent.getInferredRootCallName()\n    ) {\n      // We can make a \"ref query\" at this point, so stop wrapping.\n      return new RelayRefQueryDescriptor(node, nodePath.slice(0, ii + 1));\n    }\n\n    const siblings = getRequisiteSiblings(node, parent);\n    const children = [node].concat(siblings);\n\n    // Cast here because we know that `clone` will never return `null` (because\n    // we always give it at least one child).\n    node = (parent.clone(children): any);\n  }\n  invariant(\n    node instanceof RelayQuery.Root,\n    'splitDeferredRelayQueries(): Cannot build query without a root node.'\n  );\n  const identifyingArg = node.getIdentifyingArg();\n  const identifyingArgName = (identifyingArg && identifyingArg.name) || null;\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  const metadata = {\n    identifyingArgName,\n    identifyingArgType: RelayNodeInterface.ID_TYPE,\n    isAbstract: true,\n    isDeferred: true,\n    isPlural: false,\n  };\n  return RelayQuery.Root.build(\n    node.getName(),\n    node.getFieldName(),\n    identifyingArgValue,\n    node.getChildren(),\n    metadata,\n    node.getType()\n  );\n}\n\n/**\n * Returns `true` if `node` is considered \"empty\", which means that it contains\n * no non-generated fields, and no ref query dependencies.\n */\nfunction isEmpty(node: RelayQuery.Node): boolean {\n  if (!node.canHaveSubselections()) {\n    return node.isGenerated() && !node.isRefQueryDependency();\n  } else {\n    return node.getChildren().every(isEmpty);\n  }\n}\n\n/**\n * Mutates and returns a nested `SplitQueries` structure, updating any deferred\n * \"ref queries\" to actually reference their contexts.\n */\nfunction buildQueries(splitQueries: SplitQueries): SplitQueries {\n  if (splitQueries.required && isEmpty(splitQueries.required)) {\n    splitQueries.required = null;\n  }\n  splitQueries.deferred = splitQueries.deferred.map(nestedSplitQueries => {\n    const descriptor = nestedSplitQueries.__refQuery__;\n    if (descriptor) {\n      // Wrap the ref query node with a reference to the required query that is\n      // its context.\n      let context = splitQueries.required;\n      if (!context) {\n        // Traverse upwards looking for context.\n        let parentSplitQueries = splitQueries;\n        while (parentSplitQueries.__parent__) {\n          context = parentSplitQueries.__parent__.required;\n          if (context) {\n            break;\n          }\n          parentSplitQueries = parentSplitQueries.__parent__;\n        }\n      }\n      invariant(\n        context,\n        'splitDeferredRelayQueries(): Expected a context root query.'\n      );\n      nestedSplitQueries.required = createRefQuery(descriptor, context);\n    }\n\n    return buildQueries(nestedSplitQueries);\n  });\n  return splitQueries;\n}\n\n/**\n * Wraps `descriptor` in a new top-level ref query.\n */\nfunction createRefQuery(\n  descriptor: RelayRefQueryDescriptor,\n  context: RelayQuery.Root\n): RelayQuery.Root {\n  const node = descriptor.node;\n  invariant(\n    node instanceof RelayQuery.Field ||\n    node instanceof RelayQuery.Fragment,\n    'splitDeferredRelayQueries(): Ref query requires a field or fragment.'\n  );\n\n  // Build up JSONPath.\n  const jsonPath = ['$', '*'];\n  let parent;\n  for (let ii = 0; ii < descriptor.nodePath.length; ii++) {\n    parent = descriptor.nodePath[ii];\n    if (parent instanceof RelayQuery.Field) {\n      jsonPath.push(parent.getSerializationKey());\n      if (parent.isPlural()) {\n        jsonPath.push('*');\n      }\n    }\n  }\n  invariant(\n    jsonPath.length > 2,\n    'splitDeferredRelayQueries(): Ref query requires a complete path.'\n  );\n  const field: RelayQuery.Field = (parent: any); // Flow\n  const primaryKey = field.getInferredPrimaryKey();\n  invariant(\n    primaryKey,\n    'splitDeferredRelayQueries(): Ref query requires a primary key.'\n  );\n  jsonPath.push(primaryKey);\n\n  // Create the wrapper root query.\n  const root = RelayQuery.Root.build(\n    context.getName(),\n    RelayNodeInterface.NODES,\n    QueryBuilder.createBatchCallVariable(context.getID(), jsonPath.join('.')),\n    [node],\n    {\n      identifyingArgName: RelayNodeInterface.ID,\n      identifyingArgType: RelayNodeInterface.ID_TYPE,\n      isAbstract: true,\n      isDeferred: true,\n      isPlural: false,\n    },\n    RelayNodeInterface.NODE_TYPE\n  );\n\n  const result: RelayQuery.Root = (root: any); // Flow\n  return result;\n}\n\n/**\n * Traverses an input query, updating the passed in `SplitQueries` state object\n * to contain a nested structure representing the required and deferred portions\n * of the input query.\n */\nclass GraphQLSplitDeferredQueries extends RelayQueryTransform<SplitQueries> {\n  visitField(\n    node: RelayQuery.Field,\n    splitQueries: SplitQueries\n  ): ?RelayQuery.Node {\n    if (!node.hasDeferredDescendant()) {\n      return node;\n    }\n\n    splitQueries.__nodePath__.push(node);\n    let result = this.traverse(node, splitQueries);\n    splitQueries.__nodePath__.pop();\n\n    if (result && node.getInferredRootCallName()) {\n      // The node is a ref query dependency; mark it as one.\n      const key = node.getInferredPrimaryKey();\n      const children = result.getChildren().map(child => {\n        if (\n          child instanceof RelayQuery.Field &&\n          child.getSchemaName() === key\n        ) {\n          return child.cloneAsRefQueryDependency();\n        } else {\n          return child;\n        }\n      });\n      result = result.clone(children);\n    }\n\n    return result;\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    splitQueries: SplitQueries\n  ): ?RelayQuery.Node {\n    if (!node.getChildren().length) {\n      return null;\n    }\n\n    if (node.isDeferred()) {\n      const nodePath = splitQueries.__nodePath__;\n      const deferred: SplitQueries = {\n        __nodePath__: nodePath,\n        __parent__: splitQueries,\n        __refQuery__: null,\n        deferred: [],\n        required: null,\n      };\n      const result = this.traverse(node, deferred);\n      if (result) {\n        const wrapped = wrapNode(result, nodePath);\n        if (wrapped instanceof RelayQuery.Root) {\n          deferred.required = wrapped;\n        } else if (wrapped instanceof RelayRefQueryDescriptor) { // for Flow\n          deferred.__refQuery__ = (wrapped: RelayRefQueryDescriptor);\n        }\n      }\n      if (result || deferred.deferred.length) {\n        splitQueries.deferred.push(deferred);\n      }\n      return null;\n    } else if (node.hasDeferredDescendant()) {\n      return this.traverse(node, splitQueries);\n    } else {\n      return node;\n    }\n  }\n\n  visitRoot(\n    node: RelayQuery.Root,\n    splitQueries: SplitQueries\n  ): ?RelayQuery.Node {\n    if (!node.hasDeferredDescendant()) {\n      splitQueries.required = node;\n      return node;\n    } else {\n      splitQueries.__nodePath__.push(node);\n      const result = this.traverse(node, splitQueries);\n      splitQueries.__nodePath__.pop();\n      splitQueries.required = result;\n      return result;\n    }\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'splitDeferredRelayQueries',\n  splitDeferredRelayQueries\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/sortTypeFirst.js":{"metadata":{"mtime":1455679339000},"data":{"name":"sortTypeFirst","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule sortTypeFirst\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar TYPE = '__type__';\n\nfunction sortTypeFirst(a: string, b: string): number {\n  if (a === b) {\n    return 0;\n  }\n  if (a === TYPE) {\n    return -1;\n  }\n  if (b === TYPE) {\n    return 1;\n  }\n  return 0;\n}\n\nmodule.exports = sortTypeFirst;\n","dependencies":["sortTypeFirst"],"id":"sortTypeFirst","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule sortTypeFirst\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nvar TYPE = '__type__';\n\nfunction sortTypeFirst(a: string, b: string): number {\n  if (a === b) {\n    return 0;\n  }\n  if (a === TYPE) {\n    return -1;\n  }\n  if (b === TYPE) {\n    return 1;\n  }\n  return 0;\n}\n\nmodule.exports = sortTypeFirst;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/printRelayOSSQuery.js":{"metadata":{"mtime":1456974578000},"data":{"name":"printRelayOSSQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule printRelayOSSQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Map = require('Map');\nimport type {PrintedQuery} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\n\nconst base62 = require('base62');\nconst invariant = require('invariant');\n\ntype PrinterState = {\n  fragmentCount: number;\n  fragmentNameByHash: {[fragmentHash: string]: string};\n  fragmentNameByText: {[fragmentText: string]: string};\n  fragmentTexts: Array<string>;\n  variableCount: number;\n  variableMap: Map<mixed, Variable>;\n};\ntype Variable = {\n  type: string;\n  value: mixed;\n  variableID: string;\n};\n\n/**\n * @internal\n *\n * `printRelayOSSQuery(query)` returns a string representation of the query. The\n * supplied `node` must be flattened (and not contain fragments).\n */\nfunction printRelayOSSQuery(node: RelayQuery.Node): PrintedQuery {\n  const fragmentTexts = [];\n  const variableMap = new Map();\n  const printerState = {\n    fragmentCount: 0,\n    fragmentNameByHash: {},\n    fragmentNameByText: {},\n    fragmentTexts,\n    variableCount: 0,\n    variableMap,\n  };\n  let queryText = null;\n  if (node instanceof RelayQuery.Root) {\n    queryText = printRoot(node, printerState);\n  } else if (node instanceof RelayQuery.Mutation) {\n    queryText = printMutation(node, printerState);\n  } else if (node instanceof RelayQuery.Fragment) {\n    queryText = printFragment(node, printerState);\n  }\n  invariant(\n    queryText,\n    'printRelayOSSQuery(): Unsupported node type.'\n  );\n  const variables = {};\n  variableMap.forEach(({value, variableID}) => variables[variableID] = value);\n\n  return {\n    text: [queryText, ...fragmentTexts].join(' '),\n    variables,\n  };\n}\n\nfunction printRoot(\n  node: RelayQuery.Root,\n  printerState: PrinterState\n): string {\n  invariant(\n    !node.getBatchCall(),\n    'printRelayOSSQuery(): Deferred queries are not supported.'\n  );\n  const identifyingArg = node.getIdentifyingArg();\n  const identifyingArgName = (identifyingArg && identifyingArg.name) || null;\n  const identifyingArgType = (identifyingArg && identifyingArg.type) || null;\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  let fieldName = node.getFieldName();\n  if (identifyingArgValue != null) {\n    invariant(\n      identifyingArgName,\n      'printRelayOSSQuery(): Expected an argument name for root field `%s`.',\n      fieldName\n    );\n    const rootArgString = printArgument(\n      identifyingArgName,\n      identifyingArgValue,\n      identifyingArgType,\n      printerState\n    );\n    if (rootArgString) {\n      fieldName += '(' + rootArgString + ')';\n    }\n  }\n  // Note: children must be traversed before printing variable definitions\n  const children = printChildren(node, printerState);\n  const queryString = node.getName() + printVariableDefinitions(printerState);\n  fieldName += printDirectives(node);\n\n  return 'query ' + queryString + '{' + fieldName + children + '}';\n}\n\nfunction printMutation(\n  node: RelayQuery.Mutation,\n  printerState: PrinterState\n): string {\n  const call = node.getCall();\n  const inputString = printArgument(\n    node.getCallVariableName(),\n    call.value,\n    node.getInputType(),\n    printerState\n  );\n  invariant(\n    inputString,\n    'printRelayOSSQuery(): Expected mutation `%s` to have a value for `%s`.',\n    node.getName(),\n    node.getCallVariableName()\n  );\n  // Note: children must be traversed before printing variable definitions\n  const children = printChildren(node, printerState);\n  const mutationString =\n    node.getName() + printVariableDefinitions(printerState);\n  const fieldName = call.name + '(' + inputString + ')';\n\n  return 'mutation ' + mutationString + '{' + fieldName + children + '}';\n}\n\nfunction printVariableDefinitions({variableMap}: PrinterState): string {\n  let argStrings = null;\n  variableMap.forEach(({type, variableID}) => {\n    // To ensure that the value can flow into a nullable or non-nullable\n    // argument, print it as non-nullable. Note that variables are not created\n    // for null values (the argument is omitted instead).\n    const nonNullType = printNonNullType(type);\n    argStrings = argStrings || [];\n    argStrings.push('$' + variableID + ':' + nonNullType);\n  });\n  if (argStrings) {\n    return '(' + argStrings.join(',') + ')';\n  }\n  return '';\n}\n\nfunction printNonNullType(type: string): string {\n  if (type.endsWith('!')) {\n    return type;\n  }\n  return type + '!';\n}\n\nfunction printFragment(\n  node: RelayQuery.Fragment,\n  printerState: PrinterState\n): string {\n  const directives = printDirectives(node);\n  return 'fragment ' + node.getDebugName() + ' on ' +\n    node.getType() + directives + printChildren(node, printerState);\n}\n\nfunction printChildren(\n  node: RelayQuery.Node,\n  printerState: PrinterState\n): string {\n  const childrenText = [];\n  const children = node.getChildren();\n  let fragments;\n  for (let ii = 0; ii < children.length; ii++) {\n    const child = children[ii];\n    if (child instanceof RelayQuery.Field) {\n      let fieldText = child.getSchemaName();\n      const fieldCalls = child.getCallsWithValues();\n      if (fieldCalls.length) {\n        fieldText = child.getSerializationKey() + ':' + fieldText;\n        const argTexts = [];\n        for (let jj = 0; jj < fieldCalls.length; jj++) {\n          const {name, value} = fieldCalls[jj];\n          const argText = printArgument(\n            name,\n            value,\n            child.getCallType(name),\n            printerState\n          );\n          if (argText) {\n            argTexts.push(argText);\n          }\n        }\n        if (argTexts.length) {\n          fieldText += '(' + argTexts.join(',') + ')';\n        }\n      }\n      fieldText += printDirectives(child);\n      if (child.getChildren().length) {\n        fieldText += printChildren(child, printerState);\n      }\n      childrenText.push(fieldText);\n    } else if (child instanceof RelayQuery.Fragment) {\n      if (child.getChildren().length) {\n        const {\n          fragmentNameByHash,\n          fragmentNameByText,\n          fragmentTexts,\n        } = printerState;\n\n        // Avoid walking fragments if we have printed the same one before.\n        const fragmentHash = child.getCompositeHash();\n\n        let fragmentName;\n        if (fragmentNameByHash.hasOwnProperty(fragmentHash)) {\n          fragmentName = fragmentNameByHash[fragmentHash];\n        } else {\n          // Avoid reprinting a fragment that is identical to another fragment.\n          const fragmentText =\n            child.getType() +\n            printDirectives(child) +\n            printChildren(child, printerState);\n          if (fragmentNameByText.hasOwnProperty(fragmentText)) {\n            fragmentName = fragmentNameByText[fragmentText];\n          } else {\n            fragmentName = 'F' + base62(printerState.fragmentCount++);\n            fragmentNameByHash[fragmentHash] = fragmentName;\n            fragmentNameByText[fragmentText] = fragmentName;\n            fragmentTexts.push(\n              'fragment ' + fragmentName + ' on ' + fragmentText\n            );\n          }\n        }\n        if (!fragments || !fragments.hasOwnProperty(fragmentName)) {\n          fragments = fragments || {};\n          fragments[fragmentName] = true;\n          childrenText.push('...' + fragmentName);\n        }\n      }\n    } else {\n      invariant(\n        false,\n        'printRelayOSSQuery(): Expected a field or fragment, got `%s`.',\n        child.constructor.name\n      );\n    }\n  }\n  if (!childrenText) {\n    return '';\n  }\n  return childrenText.length ? '{' + childrenText.join(',') + '}' : '';\n}\n\nfunction printDirectives(node) {\n  let directiveStrings;\n  node.getDirectives().forEach(directive => {\n    let dirString = '@' + directive.name;\n    if (directive.args.length) {\n      dirString +=\n        '(' + directive.args.map(printDirective).join(',') + ')';\n    }\n    directiveStrings = directiveStrings || [];\n    directiveStrings.push(dirString);\n  });\n  if (!directiveStrings) {\n    return '';\n  }\n  return ' ' + directiveStrings.join(' ');\n}\n\nfunction printDirective({name, value}) {\n  invariant(\n    typeof value === 'boolean' ||\n    typeof value === 'number' ||\n    typeof value === 'string',\n    'printRelayOSSQuery(): Relay only supports directives with scalar values ' +\n    '(boolean, number, or string), got `%s: %s`.',\n    name,\n    value\n  );\n  return name + ':' + JSON.stringify(value);\n}\n\nfunction printArgument(\n  name: string,\n  value: mixed,\n  type: ?string,\n  printerState: PrinterState\n): ?string {\n  if (value == null) {\n    return value;\n  }\n  let stringValue;\n  if (type != null) {\n    const variableID = createVariable(name, value, type, printerState);\n    stringValue = '$' + variableID;\n  } else {\n    stringValue = JSON.stringify(value);\n  }\n  return name + ':' + stringValue;\n}\n\nfunction createVariable(\n  name: string,\n  value: mixed,\n  type: string,\n  printerState: PrinterState\n): string {\n  invariant(\n    value != null,\n    'printRelayOSSQuery: Expected a non-null value for variable `%s`.',\n    name\n  );\n  const valueKey = JSON.stringify(value);\n  const existingVariable = printerState.variableMap.get(valueKey);\n  if (existingVariable) {\n    return existingVariable.variableID;\n  } else {\n    const variableID = name + '_' + base62(printerState.variableCount++);\n    printerState.variableMap.set(valueKey, {\n      type,\n      value,\n      variableID,\n    });\n    return variableID;\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'printRelayQuery',\n  printRelayOSSQuery\n);\n","dependencies":["RelayInternalTypes","Map","RelayProfiler","RelayQuery","base62","invariant","printRelayOSSQuery"],"id":"printRelayOSSQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule printRelayOSSQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst Map = require('Map');\nimport type {PrintedQuery} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\n\nconst base62 = require('base62');\nconst invariant = require('invariant');\n\ntype PrinterState = {\n  fragmentCount: number;\n  fragmentNameByHash: {[fragmentHash: string]: string};\n  fragmentNameByText: {[fragmentText: string]: string};\n  fragmentTexts: Array<string>;\n  variableCount: number;\n  variableMap: Map<mixed, Variable>;\n};\ntype Variable = {\n  type: string;\n  value: mixed;\n  variableID: string;\n};\n\n/**\n * @internal\n *\n * `printRelayOSSQuery(query)` returns a string representation of the query. The\n * supplied `node` must be flattened (and not contain fragments).\n */\nfunction printRelayOSSQuery(node: RelayQuery.Node): PrintedQuery {\n  const fragmentTexts = [];\n  const variableMap = new Map();\n  const printerState = {\n    fragmentCount: 0,\n    fragmentNameByHash: {},\n    fragmentNameByText: {},\n    fragmentTexts,\n    variableCount: 0,\n    variableMap,\n  };\n  let queryText = null;\n  if (node instanceof RelayQuery.Root) {\n    queryText = printRoot(node, printerState);\n  } else if (node instanceof RelayQuery.Mutation) {\n    queryText = printMutation(node, printerState);\n  } else if (node instanceof RelayQuery.Fragment) {\n    queryText = printFragment(node, printerState);\n  }\n  invariant(\n    queryText,\n    'printRelayOSSQuery(): Unsupported node type.'\n  );\n  const variables = {};\n  variableMap.forEach(({value, variableID}) => variables[variableID] = value);\n\n  return {\n    text: [queryText, ...fragmentTexts].join(' '),\n    variables,\n  };\n}\n\nfunction printRoot(\n  node: RelayQuery.Root,\n  printerState: PrinterState\n): string {\n  invariant(\n    !node.getBatchCall(),\n    'printRelayOSSQuery(): Deferred queries are not supported.'\n  );\n  const identifyingArg = node.getIdentifyingArg();\n  const identifyingArgName = (identifyingArg && identifyingArg.name) || null;\n  const identifyingArgType = (identifyingArg && identifyingArg.type) || null;\n  const identifyingArgValue = (identifyingArg && identifyingArg.value) || null;\n  let fieldName = node.getFieldName();\n  if (identifyingArgValue != null) {\n    invariant(\n      identifyingArgName,\n      'printRelayOSSQuery(): Expected an argument name for root field `%s`.',\n      fieldName\n    );\n    const rootArgString = printArgument(\n      identifyingArgName,\n      identifyingArgValue,\n      identifyingArgType,\n      printerState\n    );\n    if (rootArgString) {\n      fieldName += '(' + rootArgString + ')';\n    }\n  }\n  // Note: children must be traversed before printing variable definitions\n  const children = printChildren(node, printerState);\n  const queryString = node.getName() + printVariableDefinitions(printerState);\n  fieldName += printDirectives(node);\n\n  return 'query ' + queryString + '{' + fieldName + children + '}';\n}\n\nfunction printMutation(\n  node: RelayQuery.Mutation,\n  printerState: PrinterState\n): string {\n  const call = node.getCall();\n  const inputString = printArgument(\n    node.getCallVariableName(),\n    call.value,\n    node.getInputType(),\n    printerState\n  );\n  invariant(\n    inputString,\n    'printRelayOSSQuery(): Expected mutation `%s` to have a value for `%s`.',\n    node.getName(),\n    node.getCallVariableName()\n  );\n  // Note: children must be traversed before printing variable definitions\n  const children = printChildren(node, printerState);\n  const mutationString =\n    node.getName() + printVariableDefinitions(printerState);\n  const fieldName = call.name + '(' + inputString + ')';\n\n  return 'mutation ' + mutationString + '{' + fieldName + children + '}';\n}\n\nfunction printVariableDefinitions({variableMap}: PrinterState): string {\n  let argStrings = null;\n  variableMap.forEach(({type, variableID}) => {\n    // To ensure that the value can flow into a nullable or non-nullable\n    // argument, print it as non-nullable. Note that variables are not created\n    // for null values (the argument is omitted instead).\n    const nonNullType = printNonNullType(type);\n    argStrings = argStrings || [];\n    argStrings.push('$' + variableID + ':' + nonNullType);\n  });\n  if (argStrings) {\n    return '(' + argStrings.join(',') + ')';\n  }\n  return '';\n}\n\nfunction printNonNullType(type: string): string {\n  if (type.endsWith('!')) {\n    return type;\n  }\n  return type + '!';\n}\n\nfunction printFragment(\n  node: RelayQuery.Fragment,\n  printerState: PrinterState\n): string {\n  const directives = printDirectives(node);\n  return 'fragment ' + node.getDebugName() + ' on ' +\n    node.getType() + directives + printChildren(node, printerState);\n}\n\nfunction printChildren(\n  node: RelayQuery.Node,\n  printerState: PrinterState\n): string {\n  const childrenText = [];\n  const children = node.getChildren();\n  let fragments;\n  for (let ii = 0; ii < children.length; ii++) {\n    const child = children[ii];\n    if (child instanceof RelayQuery.Field) {\n      let fieldText = child.getSchemaName();\n      const fieldCalls = child.getCallsWithValues();\n      if (fieldCalls.length) {\n        fieldText = child.getSerializationKey() + ':' + fieldText;\n        const argTexts = [];\n        for (let jj = 0; jj < fieldCalls.length; jj++) {\n          const {name, value} = fieldCalls[jj];\n          const argText = printArgument(\n            name,\n            value,\n            child.getCallType(name),\n            printerState\n          );\n          if (argText) {\n            argTexts.push(argText);\n          }\n        }\n        if (argTexts.length) {\n          fieldText += '(' + argTexts.join(',') + ')';\n        }\n      }\n      fieldText += printDirectives(child);\n      if (child.getChildren().length) {\n        fieldText += printChildren(child, printerState);\n      }\n      childrenText.push(fieldText);\n    } else if (child instanceof RelayQuery.Fragment) {\n      if (child.getChildren().length) {\n        const {\n          fragmentNameByHash,\n          fragmentNameByText,\n          fragmentTexts,\n        } = printerState;\n\n        // Avoid walking fragments if we have printed the same one before.\n        const fragmentHash = child.getCompositeHash();\n\n        let fragmentName;\n        if (fragmentNameByHash.hasOwnProperty(fragmentHash)) {\n          fragmentName = fragmentNameByHash[fragmentHash];\n        } else {\n          // Avoid reprinting a fragment that is identical to another fragment.\n          const fragmentText =\n            child.getType() +\n            printDirectives(child) +\n            printChildren(child, printerState);\n          if (fragmentNameByText.hasOwnProperty(fragmentText)) {\n            fragmentName = fragmentNameByText[fragmentText];\n          } else {\n            fragmentName = 'F' + base62(printerState.fragmentCount++);\n            fragmentNameByHash[fragmentHash] = fragmentName;\n            fragmentNameByText[fragmentText] = fragmentName;\n            fragmentTexts.push(\n              'fragment ' + fragmentName + ' on ' + fragmentText\n            );\n          }\n        }\n        if (!fragments || !fragments.hasOwnProperty(fragmentName)) {\n          fragments = fragments || {};\n          fragments[fragmentName] = true;\n          childrenText.push('...' + fragmentName);\n        }\n      }\n    } else {\n      invariant(\n        false,\n        'printRelayOSSQuery(): Expected a field or fragment, got `%s`.',\n        child.constructor.name\n      );\n    }\n  }\n  if (!childrenText) {\n    return '';\n  }\n  return childrenText.length ? '{' + childrenText.join(',') + '}' : '';\n}\n\nfunction printDirectives(node) {\n  let directiveStrings;\n  node.getDirectives().forEach(directive => {\n    let dirString = '@' + directive.name;\n    if (directive.args.length) {\n      dirString +=\n        '(' + directive.args.map(printDirective).join(',') + ')';\n    }\n    directiveStrings = directiveStrings || [];\n    directiveStrings.push(dirString);\n  });\n  if (!directiveStrings) {\n    return '';\n  }\n  return ' ' + directiveStrings.join(' ');\n}\n\nfunction printDirective({name, value}) {\n  invariant(\n    typeof value === 'boolean' ||\n    typeof value === 'number' ||\n    typeof value === 'string',\n    'printRelayOSSQuery(): Relay only supports directives with scalar values ' +\n    '(boolean, number, or string), got `%s: %s`.',\n    name,\n    value\n  );\n  return name + ':' + JSON.stringify(value);\n}\n\nfunction printArgument(\n  name: string,\n  value: mixed,\n  type: ?string,\n  printerState: PrinterState\n): ?string {\n  if (value == null) {\n    return value;\n  }\n  let stringValue;\n  if (type != null) {\n    const variableID = createVariable(name, value, type, printerState);\n    stringValue = '$' + variableID;\n  } else {\n    stringValue = JSON.stringify(value);\n  }\n  return name + ':' + stringValue;\n}\n\nfunction createVariable(\n  name: string,\n  value: mixed,\n  type: string,\n  printerState: PrinterState\n): string {\n  invariant(\n    value != null,\n    'printRelayOSSQuery: Expected a non-null value for variable `%s`.',\n    name\n  );\n  const valueKey = JSON.stringify(value);\n  const existingVariable = printerState.variableMap.get(valueKey);\n  if (existingVariable) {\n    return existingVariable.variableID;\n  } else {\n    const variableID = name + '_' + base62(printerState.variableCount++);\n    printerState.variableMap.set(valueKey, {\n      type,\n      value,\n      variableID,\n    });\n    return variableID;\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'printRelayQuery',\n  printRelayOSSQuery\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/intersectRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"name":"intersectRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule intersectRelayQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\n\nconst invariant = require('invariant');\n\ntype UnterminatedRangeFilter = (node: RelayQuery.Field) => boolean;\n\n/**\n * @internal\n *\n * `intersectRelayQuery(subjectNode, patternNode)` returns a node with fields in\n * `subjectNode` that also exist in `patternNode`. `patternNode` is expected to\n * be flattened (and not contain fragments).\n *\n * If any field in `patternNode` is unterminated (i.e. has no sub-fields), we\n * treat the field as though it contains every descendant sub-field.\n *\n * If `filterUnterminatedRange` is supplied, it will be invoked with any fields\n * from `subjectNode` that are connections and unterminated in `patternNode`. If\n * it returns true, the `edges` and `page_info` fields will be filtered out.\n */\nfunction intersectRelayQuery<Tn: RelayQuery.Node>(\n  subjectNode: Tn,\n  patternNode: RelayQuery.Node,\n  filterUnterminatedRange?: UnterminatedRangeFilter,\n): ?Tn {\n  filterUnterminatedRange = filterUnterminatedRange || returnsFalse;\n  var visitor = new RelayQueryIntersector(filterUnterminatedRange);\n  return visitor.traverse(subjectNode, patternNode);\n}\n\nclass RelayQueryIntersector extends RelayQueryTransform<RelayQuery.Node> {\n  _filterUnterminatedRange: UnterminatedRangeFilter;\n\n  constructor(filterUnterminatedRange: UnterminatedRangeFilter) {\n    super();\n    this._filterUnterminatedRange = filterUnterminatedRange;\n  }\n\n  traverse<Tn: RelayQuery.Node>(\n    subjectNode: Tn,\n    patternNode: RelayQuery.Node,\n  ): ?Tn {\n    if (!subjectNode.canHaveSubselections()) {\n      // Since `patternNode` exists, `subjectNode` must be in the intersection.\n      return subjectNode;\n    }\n    if (!hasChildren(patternNode)) {\n      if (subjectNode instanceof RelayQuery.Field &&\n          subjectNode.isConnection() &&\n          this._filterUnterminatedRange(subjectNode)) {\n        return filterRangeFields(subjectNode);\n      }\n      // Unterminated `patternNode` is the same as containing every descendant\n      // sub-field, so `subjectNode` must be in the intersection.\n      return subjectNode;\n    }\n    return subjectNode.clone(subjectNode.getChildren().map(subjectChild => {\n      if (subjectChild instanceof RelayQuery.Fragment) {\n        return this.visit(subjectChild, patternNode);\n      }\n      if (subjectChild instanceof RelayQuery.Field) {\n        var schemaName = subjectChild.getSchemaName();\n        var patternChild;\n        var patternChildren = patternNode.getChildren();\n        for (var ii = 0; ii < patternChildren.length; ii++) {\n          var child = patternChildren[ii];\n          invariant(\n            child instanceof RelayQuery.Field,\n            'intersectRelayQuery(): Nodes in `patternNode` must be fields.'\n          );\n          if (child.getSchemaName() === schemaName) {\n            patternChild = child;\n            break;\n          }\n        }\n        if (patternChild) {\n          return this.visit(subjectChild, patternChild);\n        }\n      }\n      return null;\n    }));\n  }\n}\n\n/**\n * @private\n */\nclass RelayQueryRangeFilter extends RelayQueryTransform<void> {\n  visitField(node: RelayQuery.Field): ?RelayQuery.Node {\n    var schemaName = node.getSchemaName();\n    if (schemaName === RelayConnectionInterface.EDGES ||\n        schemaName === RelayConnectionInterface.PAGE_INFO) {\n      return null;\n    } else {\n      return node;\n    }\n  }\n}\n\nvar rangeFilter = new RelayQueryRangeFilter();\nfunction filterRangeFields<Tn: RelayQuery.Field>(node: Tn): ?Tn {\n  return rangeFilter.traverse(node, undefined);\n}\n\nfunction returnsFalse(): boolean {\n  return false;\n}\n\nfunction hasChildren(node: RelayQuery.Node): boolean {\n  return !node.getChildren().every(isGenerated);\n}\n\nfunction isGenerated(node: RelayQuery.Node): boolean {\n  return node.isGenerated();\n}\n\nmodule.exports = intersectRelayQuery;\n","dependencies":["RelayConnectionInterface","RelayQuery","RelayQueryTransform","invariant","intersectRelayQuery"],"id":"intersectRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule intersectRelayQuery\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryTransform = require('RelayQueryTransform');\n\nconst invariant = require('invariant');\n\ntype UnterminatedRangeFilter = (node: RelayQuery.Field) => boolean;\n\n/**\n * @internal\n *\n * `intersectRelayQuery(subjectNode, patternNode)` returns a node with fields in\n * `subjectNode` that also exist in `patternNode`. `patternNode` is expected to\n * be flattened (and not contain fragments).\n *\n * If any field in `patternNode` is unterminated (i.e. has no sub-fields), we\n * treat the field as though it contains every descendant sub-field.\n *\n * If `filterUnterminatedRange` is supplied, it will be invoked with any fields\n * from `subjectNode` that are connections and unterminated in `patternNode`. If\n * it returns true, the `edges` and `page_info` fields will be filtered out.\n */\nfunction intersectRelayQuery<Tn: RelayQuery.Node>(\n  subjectNode: Tn,\n  patternNode: RelayQuery.Node,\n  filterUnterminatedRange?: UnterminatedRangeFilter,\n): ?Tn {\n  filterUnterminatedRange = filterUnterminatedRange || returnsFalse;\n  var visitor = new RelayQueryIntersector(filterUnterminatedRange);\n  return visitor.traverse(subjectNode, patternNode);\n}\n\nclass RelayQueryIntersector extends RelayQueryTransform<RelayQuery.Node> {\n  _filterUnterminatedRange: UnterminatedRangeFilter;\n\n  constructor(filterUnterminatedRange: UnterminatedRangeFilter) {\n    super();\n    this._filterUnterminatedRange = filterUnterminatedRange;\n  }\n\n  traverse<Tn: RelayQuery.Node>(\n    subjectNode: Tn,\n    patternNode: RelayQuery.Node,\n  ): ?Tn {\n    if (!subjectNode.canHaveSubselections()) {\n      // Since `patternNode` exists, `subjectNode` must be in the intersection.\n      return subjectNode;\n    }\n    if (!hasChildren(patternNode)) {\n      if (subjectNode instanceof RelayQuery.Field &&\n          subjectNode.isConnection() &&\n          this._filterUnterminatedRange(subjectNode)) {\n        return filterRangeFields(subjectNode);\n      }\n      // Unterminated `patternNode` is the same as containing every descendant\n      // sub-field, so `subjectNode` must be in the intersection.\n      return subjectNode;\n    }\n    return subjectNode.clone(subjectNode.getChildren().map(subjectChild => {\n      if (subjectChild instanceof RelayQuery.Fragment) {\n        return this.visit(subjectChild, patternNode);\n      }\n      if (subjectChild instanceof RelayQuery.Field) {\n        var schemaName = subjectChild.getSchemaName();\n        var patternChild;\n        var patternChildren = patternNode.getChildren();\n        for (var ii = 0; ii < patternChildren.length; ii++) {\n          var child = patternChildren[ii];\n          invariant(\n            child instanceof RelayQuery.Field,\n            'intersectRelayQuery(): Nodes in `patternNode` must be fields.'\n          );\n          if (child.getSchemaName() === schemaName) {\n            patternChild = child;\n            break;\n          }\n        }\n        if (patternChild) {\n          return this.visit(subjectChild, patternChild);\n        }\n      }\n      return null;\n    }));\n  }\n}\n\n/**\n * @private\n */\nclass RelayQueryRangeFilter extends RelayQueryTransform<void> {\n  visitField(node: RelayQuery.Field): ?RelayQuery.Node {\n    var schemaName = node.getSchemaName();\n    if (schemaName === RelayConnectionInterface.EDGES ||\n        schemaName === RelayConnectionInterface.PAGE_INFO) {\n      return null;\n    } else {\n      return node;\n    }\n  }\n}\n\nvar rangeFilter = new RelayQueryRangeFilter();\nfunction filterRangeFields<Tn: RelayQuery.Field>(node: Tn): ?Tn {\n  return rangeFilter.traverse(node, undefined);\n}\n\nfunction returnsFalse(): boolean {\n  return false;\n}\n\nfunction hasChildren(node: RelayQuery.Node): boolean {\n  return !node.getChildren().every(isGenerated);\n}\n\nfunction isGenerated(node: RelayQuery.Node): boolean {\n  return node.isGenerated();\n}\n\nmodule.exports = intersectRelayQuery;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/inferRelayFieldsFromData.js":{"metadata":{"mtime":1455679339000},"data":{"name":"inferRelayFieldsFromData","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule inferRelayFieldsFromData\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayRecord = require('RelayRecord');\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nconst ARGUMENTS = /^(\\w+)(?:\\((.+?)\\))?$/;\nconst ARGUMENT_NAME = /(\\w+)(?=\\s*:)/;\nconst DEPRECATED_CALLS = /^\\w+(?:\\.\\w+\\(.*?\\))+$/;\nconst DEPRECATED_CALL = /^(\\w+)\\((.*?)\\)$/;\nconst {NODE, EDGES} = RelayConnectionInterface;\nconst {ANY_TYPE, ID} = RelayNodeInterface;\n\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  type: 'String',\n});\nconst cursorField = RelayQuery.Field.build({\n  fieldName: 'cursor',\n  type: 'String',\n});\n\n/**\n * @internal\n *\n * Given a record-like object, infers fields that could be used to fetch them.\n * Properties that are fetched via fields with arguments can be encoded by\n * serializing the arguments in property keys.\n */\nfunction inferRelayFieldsFromData(\n  data: Object\n): Array<RelayQuery.Field> {\n  const fields = [];\n  forEachObject(data, (value, key) => {\n    if (!RelayRecord.isMetadataKey(key)) {\n      fields.push(inferField(value, key));\n    }\n  });\n  return fields;\n}\n\nfunction inferField(value: mixed, key: string): RelayQuery.Field {\n  const metadata = {\n    canHaveSubselections: true,\n    isPlural: false,\n  };\n  let children;\n  if (Array.isArray(value)) {\n    const element = value[0];\n    if (element && typeof element === 'object') {\n      children = inferRelayFieldsFromData(element);\n    } else {\n      metadata.canHaveSubselections = false;\n      children = [];\n    }\n    metadata.isPlural = true;\n  } else if (typeof value === 'object' && value !== null) {\n    children = inferRelayFieldsFromData(value);\n  } else {\n    metadata.canHaveSubselections = false;\n    children = [];\n  }\n  if (key === NODE) {\n    children.push(idField);\n  } else if (key === EDGES) {\n    children.push(cursorField);\n  }\n  return buildField(key, children, metadata);\n}\n\nfunction buildField(\n  key: string,\n  children: Array<RelayQuery.Field>,\n  metadata: ?{[key: string]: mixed}\n): RelayQuery.Field {\n  let fieldName = key;\n  let calls = null;\n  if (DEPRECATED_CALLS.test(key)) {\n    warning(\n      false,\n      'inferRelayFieldsFromData(): Encountered an optimistic payload with ' +\n      'a deprecated field call string, `%s`. Use valid GraphQL OSS syntax.',\n      key\n    );\n    const parts = key.split('.');\n    if (parts.length > 1) {\n      fieldName = parts.shift();\n      calls = parts.map(callString => {\n        const captures = callString.match(DEPRECATED_CALL);\n        invariant(\n          captures,\n          'inferRelayFieldsFromData(): Malformed data key, `%s`.',\n          key\n        );\n        const value = captures[2].split(',');\n        return {\n          name: captures[1],\n          value: value.length === 1 ? value[0] : value,\n        };\n      });\n    }\n  } else {\n    const captures = key.match(ARGUMENTS);\n    invariant(\n      captures,\n      'inferRelayFieldsFromData(): Malformed data key, `%s`.',\n      key\n    );\n    fieldName = captures[1];\n    if (captures[2]) {\n      try {\n        // Relay does not currently have a GraphQL argument parser, so...\n        const args = JSON.parse(\n          '{' + captures[2].replace(ARGUMENT_NAME, '\"$1\"') + '}'\n        );\n        calls = Object.keys(args).map(name => ({name, value: args[name]}));\n      } catch (error) {\n        invariant(\n          false,\n          'inferRelayFieldsFromData(): Malformed or unsupported data key, ' +\n          '`%s`. Only booleans, strings, and numbers are currenly supported, ' +\n          'and commas are required. Parse failure reason was `%s`.',\n          key,\n          error.message\n        );\n      }\n    }\n  }\n  return RelayQuery.Field.build({\n    calls,\n    children,\n    fieldName,\n    metadata,\n    type: ANY_TYPE,\n  });\n}\n\nmodule.exports = inferRelayFieldsFromData;\n","dependencies":["RelayConnectionInterface","RelayNodeInterface","RelayQuery","RelayRecord","forEachObject","invariant","warning","inferRelayFieldsFromData"],"id":"inferRelayFieldsFromData","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule inferRelayFieldsFromData\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayQuery = require('RelayQuery');\nconst RelayRecord = require('RelayRecord');\n\nconst forEachObject = require('forEachObject');\nconst invariant = require('invariant');\nconst warning = require('warning');\n\nconst ARGUMENTS = /^(\\w+)(?:\\((.+?)\\))?$/;\nconst ARGUMENT_NAME = /(\\w+)(?=\\s*:)/;\nconst DEPRECATED_CALLS = /^\\w+(?:\\.\\w+\\(.*?\\))+$/;\nconst DEPRECATED_CALL = /^(\\w+)\\((.*?)\\)$/;\nconst {NODE, EDGES} = RelayConnectionInterface;\nconst {ANY_TYPE, ID} = RelayNodeInterface;\n\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  type: 'String',\n});\nconst cursorField = RelayQuery.Field.build({\n  fieldName: 'cursor',\n  type: 'String',\n});\n\n/**\n * @internal\n *\n * Given a record-like object, infers fields that could be used to fetch them.\n * Properties that are fetched via fields with arguments can be encoded by\n * serializing the arguments in property keys.\n */\nfunction inferRelayFieldsFromData(\n  data: Object\n): Array<RelayQuery.Field> {\n  const fields = [];\n  forEachObject(data, (value, key) => {\n    if (!RelayRecord.isMetadataKey(key)) {\n      fields.push(inferField(value, key));\n    }\n  });\n  return fields;\n}\n\nfunction inferField(value: mixed, key: string): RelayQuery.Field {\n  const metadata = {\n    canHaveSubselections: true,\n    isPlural: false,\n  };\n  let children;\n  if (Array.isArray(value)) {\n    const element = value[0];\n    if (element && typeof element === 'object') {\n      children = inferRelayFieldsFromData(element);\n    } else {\n      metadata.canHaveSubselections = false;\n      children = [];\n    }\n    metadata.isPlural = true;\n  } else if (typeof value === 'object' && value !== null) {\n    children = inferRelayFieldsFromData(value);\n  } else {\n    metadata.canHaveSubselections = false;\n    children = [];\n  }\n  if (key === NODE) {\n    children.push(idField);\n  } else if (key === EDGES) {\n    children.push(cursorField);\n  }\n  return buildField(key, children, metadata);\n}\n\nfunction buildField(\n  key: string,\n  children: Array<RelayQuery.Field>,\n  metadata: ?{[key: string]: mixed}\n): RelayQuery.Field {\n  let fieldName = key;\n  let calls = null;\n  if (DEPRECATED_CALLS.test(key)) {\n    warning(\n      false,\n      'inferRelayFieldsFromData(): Encountered an optimistic payload with ' +\n      'a deprecated field call string, `%s`. Use valid GraphQL OSS syntax.',\n      key\n    );\n    const parts = key.split('.');\n    if (parts.length > 1) {\n      fieldName = parts.shift();\n      calls = parts.map(callString => {\n        const captures = callString.match(DEPRECATED_CALL);\n        invariant(\n          captures,\n          'inferRelayFieldsFromData(): Malformed data key, `%s`.',\n          key\n        );\n        const value = captures[2].split(',');\n        return {\n          name: captures[1],\n          value: value.length === 1 ? value[0] : value,\n        };\n      });\n    }\n  } else {\n    const captures = key.match(ARGUMENTS);\n    invariant(\n      captures,\n      'inferRelayFieldsFromData(): Malformed data key, `%s`.',\n      key\n    );\n    fieldName = captures[1];\n    if (captures[2]) {\n      try {\n        // Relay does not currently have a GraphQL argument parser, so...\n        const args = JSON.parse(\n          '{' + captures[2].replace(ARGUMENT_NAME, '\"$1\"') + '}'\n        );\n        calls = Object.keys(args).map(name => ({name, value: args[name]}));\n      } catch (error) {\n        invariant(\n          false,\n          'inferRelayFieldsFromData(): Malformed or unsupported data key, ' +\n          '`%s`. Only booleans, strings, and numbers are currenly supported, ' +\n          'and commas are required. Parse failure reason was `%s`.',\n          key,\n          error.message\n        );\n      }\n    }\n  }\n  return RelayQuery.Field.build({\n    calls,\n    children,\n    fieldName,\n    metadata,\n    type: ANY_TYPE,\n  });\n}\n\nmodule.exports = inferRelayFieldsFromData;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/flattenSplitRelayQueries.js":{"metadata":{"mtime":1455679339000},"data":{"name":"flattenSplitRelayQueries","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenSplitRelayQueries\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\nimport type {SplitQueries} from 'splitDeferredRelayQueries';\n\n/**\n * Flattens the nested structure returned by `splitDeferredRelayQueries`.\n *\n * Right now our internals discard the information about the relationship\n * between the queries that is encoded in the nested structure.\n *\n * @internal\n */\nfunction flattenSplitRelayQueries(\n  splitQueries: SplitQueries\n): Array<RelayQuery.Root> {\n  var flattenedQueries = [];\n  var queue = [splitQueries];\n  while (queue.length) {\n    splitQueries = queue.shift();\n    var {required, deferred} = splitQueries;\n    if (required) {\n      flattenedQueries.push(required);\n    }\n    if (deferred.length) {\n      queue.push(...deferred);\n    }\n  }\n  return flattenedQueries;\n}\n\nmodule.exports = flattenSplitRelayQueries;\n","dependencies":["RelayQuery","splitDeferredRelayQueries","flattenSplitRelayQueries"],"id":"flattenSplitRelayQueries","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenSplitRelayQueries\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\nimport type {SplitQueries} from 'splitDeferredRelayQueries';\n\n/**\n * Flattens the nested structure returned by `splitDeferredRelayQueries`.\n *\n * Right now our internals discard the information about the relationship\n * between the queries that is encoded in the nested structure.\n *\n * @internal\n */\nfunction flattenSplitRelayQueries(\n  splitQueries: SplitQueries\n): Array<RelayQuery.Root> {\n  var flattenedQueries = [];\n  var queue = [splitQueries];\n  while (queue.length) {\n    splitQueries = queue.shift();\n    var {required, deferred} = splitQueries;\n    if (required) {\n      flattenedQueries.push(required);\n    }\n    if (deferred.length) {\n      queue.push(...deferred);\n    }\n  }\n  return flattenedQueries;\n}\n\nmodule.exports = flattenSplitRelayQueries;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/flattenRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"name":"flattenRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst Map = require('Map');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\n\nconst sortTypeFirst = require('sortTypeFirst');\n\ntype FlattenedQuery = {\n  node: RelayQuery.Node;\n  type: string;\n  flattenedFieldMap: Map<string, FlattenedQuery>;\n  flattenedFragmentMap: Map<string, FlattenedQuery>;\n};\nexport type FlattenRelayQueryOptions = {\n  preserveEmptyNodes?: boolean;\n  shouldRemoveFragments?: boolean;\n};\n\n/**\n * @internal\n *\n * `flattenRelayQuery(query)` returns a clone of `query` with fields inside of\n * fragments recursively flattened into the nearest ancestor field.\n *\n * The result can be null if `node` only contains empty fragments or fragments\n * that only contain empty fragments.\n */\nfunction flattenRelayQuery<Tn: RelayQuery.Node>(\n  node: Tn,\n  options?: FlattenRelayQueryOptions\n): ?Tn {\n  const flattener = new RelayQueryFlattener(\n    options && options.shouldRemoveFragments\n  );\n  const state = {\n    node,\n    type: node.getType(),\n    flattenedFieldMap: new Map(),\n    flattenedFragmentMap: new Map(),\n  };\n  flattener.traverse(node, state);\n  return toQuery(node, state, !!(options && options.preserveEmptyNodes));\n}\n\nfunction toQuery<Tn: RelayQuery.Node>(\n  node: Tn,\n  {\n    flattenedFieldMap,\n    flattenedFragmentMap,\n  }: FlattenedQuery,\n  preserveEmptyNodes: boolean\n): ?Tn {\n  const children = [];\n  const aliases = Array.from(flattenedFieldMap.keys()).sort(sortTypeFirst);\n  aliases.forEach(alias => {\n    var field = flattenedFieldMap.get(alias);\n    if (field) {\n      children.push(toQuery(field.node, field, preserveEmptyNodes));\n    }\n  });\n  Array.from(flattenedFragmentMap.keys()).forEach(type => {\n    var fragment = flattenedFragmentMap.get(type);\n    if (fragment) {\n      children.push(toQuery(fragment.node, fragment, preserveEmptyNodes));\n    }\n  });\n  // Pattern nodes may contain non-scalar fields without children that\n  // should not be removed.\n  if (preserveEmptyNodes && node.canHaveSubselections() && !children.length) {\n    return node;\n  }\n  return node.clone(children);\n}\n\nclass RelayQueryFlattener extends RelayQueryVisitor<FlattenedQuery> {\n  _shouldRemoveFragments: boolean;\n\n  constructor(shouldRemoveFragments: ?boolean) {\n    super();\n    this._shouldRemoveFragments = !!shouldRemoveFragments;\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    state: FlattenedQuery\n  ): void {\n    const type = node.getType();\n    if (this._shouldRemoveFragments || type === state.type) {\n      this.traverse(node, state);\n      return;\n    }\n    let flattenedFragment = state.flattenedFragmentMap.get(type);\n    if (!flattenedFragment) {\n      flattenedFragment = {\n        node,\n        type,\n        flattenedFieldMap: new Map(),\n        flattenedFragmentMap: new Map(),\n      };\n      state.flattenedFragmentMap.set(type, flattenedFragment);\n    }\n    this.traverse(node, flattenedFragment);\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    state: FlattenedQuery\n  ): void {\n    var hash = node.getShallowHash();\n    var flattenedField = state.flattenedFieldMap.get(hash);\n    if (!flattenedField) {\n      flattenedField = {\n        node,\n        type: node.getType(),\n        flattenedFieldMap: new Map(),\n        flattenedFragmentMap: new Map(),\n      };\n      state.flattenedFieldMap.set(hash, flattenedField);\n    }\n    this.traverse(node, flattenedField);\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'flattenRelayQuery',\n  flattenRelayQuery\n);\n","dependencies":["Map","RelayProfiler","RelayQuery","RelayQueryVisitor","sortTypeFirst","flattenRelayQuery"],"id":"flattenRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst Map = require('Map');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryVisitor = require('RelayQueryVisitor');\n\nconst sortTypeFirst = require('sortTypeFirst');\n\ntype FlattenedQuery = {\n  node: RelayQuery.Node;\n  type: string;\n  flattenedFieldMap: Map<string, FlattenedQuery>;\n  flattenedFragmentMap: Map<string, FlattenedQuery>;\n};\nexport type FlattenRelayQueryOptions = {\n  preserveEmptyNodes?: boolean;\n  shouldRemoveFragments?: boolean;\n};\n\n/**\n * @internal\n *\n * `flattenRelayQuery(query)` returns a clone of `query` with fields inside of\n * fragments recursively flattened into the nearest ancestor field.\n *\n * The result can be null if `node` only contains empty fragments or fragments\n * that only contain empty fragments.\n */\nfunction flattenRelayQuery<Tn: RelayQuery.Node>(\n  node: Tn,\n  options?: FlattenRelayQueryOptions\n): ?Tn {\n  const flattener = new RelayQueryFlattener(\n    options && options.shouldRemoveFragments\n  );\n  const state = {\n    node,\n    type: node.getType(),\n    flattenedFieldMap: new Map(),\n    flattenedFragmentMap: new Map(),\n  };\n  flattener.traverse(node, state);\n  return toQuery(node, state, !!(options && options.preserveEmptyNodes));\n}\n\nfunction toQuery<Tn: RelayQuery.Node>(\n  node: Tn,\n  {\n    flattenedFieldMap,\n    flattenedFragmentMap,\n  }: FlattenedQuery,\n  preserveEmptyNodes: boolean\n): ?Tn {\n  const children = [];\n  const aliases = Array.from(flattenedFieldMap.keys()).sort(sortTypeFirst);\n  aliases.forEach(alias => {\n    var field = flattenedFieldMap.get(alias);\n    if (field) {\n      children.push(toQuery(field.node, field, preserveEmptyNodes));\n    }\n  });\n  Array.from(flattenedFragmentMap.keys()).forEach(type => {\n    var fragment = flattenedFragmentMap.get(type);\n    if (fragment) {\n      children.push(toQuery(fragment.node, fragment, preserveEmptyNodes));\n    }\n  });\n  // Pattern nodes may contain non-scalar fields without children that\n  // should not be removed.\n  if (preserveEmptyNodes && node.canHaveSubselections() && !children.length) {\n    return node;\n  }\n  return node.clone(children);\n}\n\nclass RelayQueryFlattener extends RelayQueryVisitor<FlattenedQuery> {\n  _shouldRemoveFragments: boolean;\n\n  constructor(shouldRemoveFragments: ?boolean) {\n    super();\n    this._shouldRemoveFragments = !!shouldRemoveFragments;\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    state: FlattenedQuery\n  ): void {\n    const type = node.getType();\n    if (this._shouldRemoveFragments || type === state.type) {\n      this.traverse(node, state);\n      return;\n    }\n    let flattenedFragment = state.flattenedFragmentMap.get(type);\n    if (!flattenedFragment) {\n      flattenedFragment = {\n        node,\n        type,\n        flattenedFieldMap: new Map(),\n        flattenedFragmentMap: new Map(),\n      };\n      state.flattenedFragmentMap.set(type, flattenedFragment);\n    }\n    this.traverse(node, flattenedFragment);\n  }\n\n  visitField(\n    node: RelayQuery.Field,\n    state: FlattenedQuery\n  ): void {\n    var hash = node.getShallowHash();\n    var flattenedField = state.flattenedFieldMap.get(hash);\n    if (!flattenedField) {\n      flattenedField = {\n        node,\n        type: node.getType(),\n        flattenedFieldMap: new Map(),\n        flattenedFragmentMap: new Map(),\n      };\n      state.flattenedFieldMap.set(hash, flattenedField);\n    }\n    this.traverse(node, flattenedField);\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'flattenRelayQuery',\n  flattenRelayQuery\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/findRelayQueryLeaves.js":{"metadata":{"mtime":1455679339000},"data":{"name":"findRelayQueryLeaves","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule findRelayQueryLeaves\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  DataID,\n} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nimport type {RecordMap} from 'RelayRecord';\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\n\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\n\nexport type PendingItem = {\n  node: RelayQuery.Node;\n  path: RelayQueryPath;\n  rangeCalls: ?Array<Call>;\n};\n\nexport type PendingNodes = {[key: string]: Array<PendingItem>};\nexport type FinderResult = {\n  missingData: boolean;\n  pendingNodes: PendingNodes;\n};\n\ntype FinderState = {\n  dataID: DataID;\n  missingData: boolean;\n  path: RelayQueryPath;\n  rangeCalls: ?Array<Call>;\n  rangeInfo: ?RangeInfo;\n};\n\nconst {EDGES, PAGE_INFO} = RelayConnectionInterface;\n\n/**\n * @internal\n *\n * Traverses a query and data in the record store to determine if there are\n * additional nodes that needs to be read from disk cache. If it  ncounters\n * a node that is not in `cachedRecords`, it will queued that node by adding it\n * into the `pendingNodes` list. If it encounters a node that was already read\n * but still missing data, then it will short circuit the evaluation since\n * there is no way for us to satisfy this query even with additional data from\n * disk cache and resturn\n */\nfunction findRelayQueryLeaves(\n  store: RelayRecordStore,\n  cachedRecords: RecordMap,\n  queryNode: RelayQuery.Node,\n  dataID: DataID,\n  path: RelayQueryPath,\n  rangeCalls: ?Array<Call>\n): FinderResult {\n  var finder = new RelayQueryLeavesFinder(store, cachedRecords);\n\n  var state = {\n    dataID,\n    missingData: false,\n    path,\n    rangeCalls,\n    rangeInfo: undefined,\n  };\n  finder.visit(queryNode, state);\n  return {\n    missingData: state.missingData,\n    pendingNodes: finder.getPendingNodes(),\n  };\n}\n\nclass RelayQueryLeavesFinder extends RelayQueryVisitor<FinderState> {\n  _cachedRecords: RecordMap;\n  _pendingNodes: PendingNodes;\n  _store: RelayRecordStore;\n\n  constructor(store: RelayRecordStore, cachedRecords: RecordMap = {}) {\n    super();\n    this._store = store;\n    this._cachedRecords = cachedRecords;\n    this._pendingNodes = {};\n  }\n\n  getPendingNodes(): PendingNodes {\n    return this._pendingNodes;\n  }\n\n  /**\n   * Skip visiting children if missingData is already false.\n   */\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    state: FinderState\n  ): ?Tn {\n    var children = node.getChildren();\n    for (var ii = 0; ii < children.length; ii++) {\n      if (state.missingData) {\n        return;\n      }\n      this.visit(children[ii], state);\n    }\n  }\n\n  visitFragment(\n    fragment: RelayQuery.Fragment,\n    state: FinderState\n  ): void {\n    var dataID = state.dataID;\n    var recordState = this._store.getRecordState(dataID);\n    if (recordState === RelayRecordState.UNKNOWN) {\n      this._handleMissingData(fragment, state);\n      return;\n    } else if (recordState === RelayRecordState.NONEXISTENT) {\n      return;\n    }\n\n    if (isCompatibleRelayFragmentType(\n      fragment,\n      this._store.getType(dataID)\n    )) {\n      this.traverse(fragment, state);\n    }\n  }\n\n  visitField(\n    field: RelayQuery.Field,\n    state: FinderState\n  ): void {\n    var dataID = state.dataID;\n    var recordState = this._store.getRecordState(dataID);\n    if (recordState === RelayRecordState.UNKNOWN) {\n      this._handleMissingData(field, state);\n      return;\n    } else if (recordState === RelayRecordState.NONEXISTENT) {\n      return;\n    }\n\n    if (state.rangeCalls && !state.rangeInfo) {\n      var metadata = this._store.getRangeMetadata(dataID, state.rangeCalls);\n      if (metadata) {\n        state.rangeInfo = metadata;\n      }\n    }\n    var rangeInfo = state.rangeInfo;\n    if (rangeInfo && field.getSchemaName() === EDGES) {\n      this._visitEdges(field, state);\n    } else if (rangeInfo && field.getSchemaName() === PAGE_INFO) {\n      this._visitPageInfo(field, state);\n    } else if (!field.canHaveSubselections()) {\n      this._visitScalar(field, state);\n    } else if (field.isPlural()) {\n      this._visitPlural(field, state);\n    } else if (field.isConnection()) {\n      this._visitConnection(field, state);\n    } else {\n      this._visitLinkedField(field, state);\n    }\n  }\n\n  _visitScalar(field: RelayQuery.Field, state: FinderState): void {\n    var fieldData = this._store.getField(state.dataID, field.getStorageKey());\n    if (fieldData === undefined) {\n      this._handleMissingData(field, state);\n    }\n  }\n\n  _visitPlural(field: RelayQuery.Field, state: FinderState): void {\n    var dataIDs = this._store.getLinkedRecordIDs(\n      state.dataID,\n      field.getStorageKey()\n    );\n    if (dataIDs === undefined) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (dataIDs) {\n      for (var ii = 0; ii < dataIDs.length; ii++) {\n        if (state.missingData) {\n          break;\n        }\n        var nextState = {\n          dataID: dataIDs[ii],\n          missingData: false,\n          path: state.path.getPath(field, dataIDs[ii]),\n          rangeCalls: undefined,\n          rangeInfo: undefined,\n        };\n        this.traverse(field, nextState);\n        state.missingData = nextState.missingData;\n      }\n    }\n  }\n\n  _visitConnection(field: RelayQuery.Field, state: FinderState): void {\n    var calls = field.getCallsWithValues();\n    var dataID = this._store.getLinkedRecordID(\n      state.dataID,\n      field.getStorageKey()\n    );\n    if (dataID === undefined) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (dataID) {\n      var nextState: FinderState = {\n        dataID,\n        missingData: false,\n        path: state.path.getPath(field, dataID),\n        rangeCalls: calls,\n        rangeInfo: null,\n      };\n      var metadata = this._store.getRangeMetadata(dataID, calls);\n      if (metadata) {\n        nextState.rangeInfo = metadata;\n      }\n      this.traverse(field, nextState);\n      state.missingData = state.missingData || nextState.missingData;\n    }\n  }\n\n  _visitEdges(field: RelayQuery.Field, state: FinderState): void {\n    var rangeInfo = state.rangeInfo;\n    // Doesn't have  `__range__` loaded\n    if (!rangeInfo) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (rangeInfo.diffCalls.length) {\n      state.missingData = true;\n      return;\n    }\n    var edgeIDs = rangeInfo.requestedEdgeIDs;\n    for (var ii = 0; ii < edgeIDs.length; ii++) {\n      if (state.missingData) {\n        break;\n      }\n      var nextState = {\n        dataID: edgeIDs[ii],\n        missingData: false,\n        path: state.path.getPath(field, edgeIDs[ii]),\n        rangeCalls: undefined,\n        rangeInfo: undefined,\n      };\n      this.traverse(field, nextState);\n      state.missingData = state.missingData || nextState.missingData;\n    }\n  }\n\n  _visitPageInfo(field: RelayQuery.Field, state: FinderState): void {\n    const {rangeInfo} = state;\n    if (!rangeInfo || !rangeInfo.pageInfo) {\n      this._handleMissingData(field, state);\n      return;\n    }\n  }\n\n  _visitLinkedField(field: RelayQuery.Field, state: FinderState): void {\n    var dataID =\n      this._store.getLinkedRecordID(state.dataID, field.getStorageKey());\n    if (dataID === undefined) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (dataID) {\n      var nextState = {\n        dataID,\n        missingData: false,\n        path: state.path.getPath(field, dataID),\n        rangeCalls: undefined,\n        rangeInfo: undefined,\n      };\n      this.traverse(field, nextState);\n      state.missingData = state.missingData || nextState.missingData;\n    }\n  }\n\n  _handleMissingData(node: RelayQuery.Node, state: FinderState): void {\n    var dataID = state.dataID;\n    if (this._cachedRecords.hasOwnProperty(dataID)) {\n      // We have read data for this `dataID` from disk, but\n      // we still don't have data for the relevant field.\n      state.missingData = true;\n    } else {\n      // Store node in `pendingNodes` because we have not read data for\n      // this `dataID` from disk.\n      this._pendingNodes[dataID] = this._pendingNodes[dataID] || [];\n      this._pendingNodes[dataID].push({\n        node,\n        path: state.path,\n        rangeCalls: state.rangeCalls,\n      });\n    }\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'findRelayQueryLeaves',\n  findRelayQueryLeaves\n);\n","dependencies":["RelayInternalTypes","RelayQuery","RelayQueryPath","RelayRecord","RelayRecordStore","RelayConnectionInterface","RelayProfiler","RelayQueryVisitor","RelayRecordState","isCompatibleRelayFragmentType","findRelayQueryLeaves"],"id":"findRelayQueryLeaves","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule findRelayQueryLeaves\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {\n  Call,\n  DataID,\n} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nimport type RelayQueryPath from 'RelayQueryPath';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nimport type {RecordMap} from 'RelayRecord';\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\n\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\n\nexport type PendingItem = {\n  node: RelayQuery.Node;\n  path: RelayQueryPath;\n  rangeCalls: ?Array<Call>;\n};\n\nexport type PendingNodes = {[key: string]: Array<PendingItem>};\nexport type FinderResult = {\n  missingData: boolean;\n  pendingNodes: PendingNodes;\n};\n\ntype FinderState = {\n  dataID: DataID;\n  missingData: boolean;\n  path: RelayQueryPath;\n  rangeCalls: ?Array<Call>;\n  rangeInfo: ?RangeInfo;\n};\n\nconst {EDGES, PAGE_INFO} = RelayConnectionInterface;\n\n/**\n * @internal\n *\n * Traverses a query and data in the record store to determine if there are\n * additional nodes that needs to be read from disk cache. If it  ncounters\n * a node that is not in `cachedRecords`, it will queued that node by adding it\n * into the `pendingNodes` list. If it encounters a node that was already read\n * but still missing data, then it will short circuit the evaluation since\n * there is no way for us to satisfy this query even with additional data from\n * disk cache and resturn\n */\nfunction findRelayQueryLeaves(\n  store: RelayRecordStore,\n  cachedRecords: RecordMap,\n  queryNode: RelayQuery.Node,\n  dataID: DataID,\n  path: RelayQueryPath,\n  rangeCalls: ?Array<Call>\n): FinderResult {\n  var finder = new RelayQueryLeavesFinder(store, cachedRecords);\n\n  var state = {\n    dataID,\n    missingData: false,\n    path,\n    rangeCalls,\n    rangeInfo: undefined,\n  };\n  finder.visit(queryNode, state);\n  return {\n    missingData: state.missingData,\n    pendingNodes: finder.getPendingNodes(),\n  };\n}\n\nclass RelayQueryLeavesFinder extends RelayQueryVisitor<FinderState> {\n  _cachedRecords: RecordMap;\n  _pendingNodes: PendingNodes;\n  _store: RelayRecordStore;\n\n  constructor(store: RelayRecordStore, cachedRecords: RecordMap = {}) {\n    super();\n    this._store = store;\n    this._cachedRecords = cachedRecords;\n    this._pendingNodes = {};\n  }\n\n  getPendingNodes(): PendingNodes {\n    return this._pendingNodes;\n  }\n\n  /**\n   * Skip visiting children if missingData is already false.\n   */\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    state: FinderState\n  ): ?Tn {\n    var children = node.getChildren();\n    for (var ii = 0; ii < children.length; ii++) {\n      if (state.missingData) {\n        return;\n      }\n      this.visit(children[ii], state);\n    }\n  }\n\n  visitFragment(\n    fragment: RelayQuery.Fragment,\n    state: FinderState\n  ): void {\n    var dataID = state.dataID;\n    var recordState = this._store.getRecordState(dataID);\n    if (recordState === RelayRecordState.UNKNOWN) {\n      this._handleMissingData(fragment, state);\n      return;\n    } else if (recordState === RelayRecordState.NONEXISTENT) {\n      return;\n    }\n\n    if (isCompatibleRelayFragmentType(\n      fragment,\n      this._store.getType(dataID)\n    )) {\n      this.traverse(fragment, state);\n    }\n  }\n\n  visitField(\n    field: RelayQuery.Field,\n    state: FinderState\n  ): void {\n    var dataID = state.dataID;\n    var recordState = this._store.getRecordState(dataID);\n    if (recordState === RelayRecordState.UNKNOWN) {\n      this._handleMissingData(field, state);\n      return;\n    } else if (recordState === RelayRecordState.NONEXISTENT) {\n      return;\n    }\n\n    if (state.rangeCalls && !state.rangeInfo) {\n      var metadata = this._store.getRangeMetadata(dataID, state.rangeCalls);\n      if (metadata) {\n        state.rangeInfo = metadata;\n      }\n    }\n    var rangeInfo = state.rangeInfo;\n    if (rangeInfo && field.getSchemaName() === EDGES) {\n      this._visitEdges(field, state);\n    } else if (rangeInfo && field.getSchemaName() === PAGE_INFO) {\n      this._visitPageInfo(field, state);\n    } else if (!field.canHaveSubselections()) {\n      this._visitScalar(field, state);\n    } else if (field.isPlural()) {\n      this._visitPlural(field, state);\n    } else if (field.isConnection()) {\n      this._visitConnection(field, state);\n    } else {\n      this._visitLinkedField(field, state);\n    }\n  }\n\n  _visitScalar(field: RelayQuery.Field, state: FinderState): void {\n    var fieldData = this._store.getField(state.dataID, field.getStorageKey());\n    if (fieldData === undefined) {\n      this._handleMissingData(field, state);\n    }\n  }\n\n  _visitPlural(field: RelayQuery.Field, state: FinderState): void {\n    var dataIDs = this._store.getLinkedRecordIDs(\n      state.dataID,\n      field.getStorageKey()\n    );\n    if (dataIDs === undefined) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (dataIDs) {\n      for (var ii = 0; ii < dataIDs.length; ii++) {\n        if (state.missingData) {\n          break;\n        }\n        var nextState = {\n          dataID: dataIDs[ii],\n          missingData: false,\n          path: state.path.getPath(field, dataIDs[ii]),\n          rangeCalls: undefined,\n          rangeInfo: undefined,\n        };\n        this.traverse(field, nextState);\n        state.missingData = nextState.missingData;\n      }\n    }\n  }\n\n  _visitConnection(field: RelayQuery.Field, state: FinderState): void {\n    var calls = field.getCallsWithValues();\n    var dataID = this._store.getLinkedRecordID(\n      state.dataID,\n      field.getStorageKey()\n    );\n    if (dataID === undefined) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (dataID) {\n      var nextState: FinderState = {\n        dataID,\n        missingData: false,\n        path: state.path.getPath(field, dataID),\n        rangeCalls: calls,\n        rangeInfo: null,\n      };\n      var metadata = this._store.getRangeMetadata(dataID, calls);\n      if (metadata) {\n        nextState.rangeInfo = metadata;\n      }\n      this.traverse(field, nextState);\n      state.missingData = state.missingData || nextState.missingData;\n    }\n  }\n\n  _visitEdges(field: RelayQuery.Field, state: FinderState): void {\n    var rangeInfo = state.rangeInfo;\n    // Doesn't have  `__range__` loaded\n    if (!rangeInfo) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (rangeInfo.diffCalls.length) {\n      state.missingData = true;\n      return;\n    }\n    var edgeIDs = rangeInfo.requestedEdgeIDs;\n    for (var ii = 0; ii < edgeIDs.length; ii++) {\n      if (state.missingData) {\n        break;\n      }\n      var nextState = {\n        dataID: edgeIDs[ii],\n        missingData: false,\n        path: state.path.getPath(field, edgeIDs[ii]),\n        rangeCalls: undefined,\n        rangeInfo: undefined,\n      };\n      this.traverse(field, nextState);\n      state.missingData = state.missingData || nextState.missingData;\n    }\n  }\n\n  _visitPageInfo(field: RelayQuery.Field, state: FinderState): void {\n    const {rangeInfo} = state;\n    if (!rangeInfo || !rangeInfo.pageInfo) {\n      this._handleMissingData(field, state);\n      return;\n    }\n  }\n\n  _visitLinkedField(field: RelayQuery.Field, state: FinderState): void {\n    var dataID =\n      this._store.getLinkedRecordID(state.dataID, field.getStorageKey());\n    if (dataID === undefined) {\n      this._handleMissingData(field, state);\n      return;\n    }\n    if (dataID) {\n      var nextState = {\n        dataID,\n        missingData: false,\n        path: state.path.getPath(field, dataID),\n        rangeCalls: undefined,\n        rangeInfo: undefined,\n      };\n      this.traverse(field, nextState);\n      state.missingData = state.missingData || nextState.missingData;\n    }\n  }\n\n  _handleMissingData(node: RelayQuery.Node, state: FinderState): void {\n    var dataID = state.dataID;\n    if (this._cachedRecords.hasOwnProperty(dataID)) {\n      // We have read data for this `dataID` from disk, but\n      // we still don't have data for the relevant field.\n      state.missingData = true;\n    } else {\n      // Store node in `pendingNodes` because we have not read data for\n      // this `dataID` from disk.\n      this._pendingNodes[dataID] = this._pendingNodes[dataID] || [];\n      this._pendingNodes[dataID].push({\n        node,\n        path: state.path,\n        rangeCalls: state.rangeCalls,\n      });\n    }\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'findRelayQueryLeaves',\n  findRelayQueryLeaves\n);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/filterRelayQuery.js":{"metadata":{"mtime":1455679339000},"data":{"name":"filterRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule filterRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\ntype Filter = (node: RelayQuery.Node) => boolean;\n\n/**\n * @internal\n *\n * `filterRelayQuery` filters query nodes for which `callback` returns false.\n * This is intended as a generic filter module and therefore contains no special\n * logic for handling requisite or generated fields.\n */\nfunction filterRelayQuery(\n  node: RelayQuery.Node,\n  callback: Filter\n): ?RelayQuery.Node {\n  if (callback(node)) {\n    return node.clone(node.getChildren().map(\n      child => filterRelayQuery(child, callback)\n    ));\n  }\n  return null;\n}\n\nmodule.exports = filterRelayQuery;\n","dependencies":["RelayQuery","filterRelayQuery"],"id":"filterRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule filterRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\ntype Filter = (node: RelayQuery.Node) => boolean;\n\n/**\n * @internal\n *\n * `filterRelayQuery` filters query nodes for which `callback` returns false.\n * This is intended as a generic filter module and therefore contains no special\n * logic for handling requisite or generated fields.\n */\nfunction filterRelayQuery(\n  node: RelayQuery.Node,\n  callback: Filter\n): ?RelayQuery.Node {\n  if (callback(node)) {\n    return node.clone(node.getChildren().map(\n      child => filterRelayQuery(child, callback)\n    ));\n  }\n  return null;\n}\n\nmodule.exports = filterRelayQuery;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/diffRelayQuery.js":{"metadata":{"mtime":1456974578000},"data":{"name":"diffRelayQuery","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule diffRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nimport type RelayQueryTracker from 'RelayQueryTracker';\nconst RelayRecord = require('RelayRecord');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst invariant = require('invariant');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\nconst warning = require('warning');\n\nconst {ID, ID_TYPE, NODE_TYPE, TYPENAME} = RelayNodeInterface;\nconst {EDGES, NODE, PAGE_INFO} = RelayConnectionInterface;\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  metadata: {\n    isRequisite: true,\n  },\n  type: 'String',\n});\nconst typeField = RelayQuery.Field.build({\n  fieldName: TYPENAME,\n  metadata: {\n    isRequisite: true,\n  },\n  type: 'String',\n});\nconst nodeWithID = RelayQuery.Field.build({\n  fieldName: RelayNodeInterface.NODE,\n  children: [idField, typeField],\n  metadata: {\n    canHaveSubselections: true,\n  },\n  type: NODE_TYPE,\n});\n\nimport type {DataID} from 'RelayInternalTypes';\n\ntype DiffScope = {\n  connectionField: ?RelayQuery.Field;\n  dataID: DataID,\n  edgeID: ?DataID,\n  rangeInfo: ?RangeInfo;\n};\ntype DiffOutput = {\n  diffNode: ?RelayQuery.Node;\n  trackedNode: ?RelayQuery.Node;\n};\n\n/**\n * @internal\n *\n * Computes the difference between the data requested in `root` and the data\n * available in `store`. It returns a minimal set of queries that will fulfill\n * the difference, or an empty array if the query can be resolved locally.\n */\nfunction diffRelayQuery(\n  root: RelayQuery.Root,\n  store: RelayRecordStore,\n  tracker: RelayQueryTracker\n): Array<RelayQuery.Root> {\n  var path = new RelayQueryPath(root);\n  var queries = [];\n\n  var visitor = new RelayDiffQueryBuilder(store, tracker);\n  const rootIdentifyingArg = root.getIdentifyingArg();\n  const rootIdentifyingArgValue =\n    (rootIdentifyingArg && rootIdentifyingArg.value) || null;\n  var isPluralCall = (\n    Array.isArray(rootIdentifyingArgValue) &&\n    rootIdentifyingArgValue.length > 1\n  );\n  let metadata;\n  if (rootIdentifyingArg != null) {\n    metadata = {\n      identifyingArgName: rootIdentifyingArg.name,\n      identifyingArgType: rootIdentifyingArg.type != null ?\n        rootIdentifyingArg.type :\n        ID_TYPE,\n      isAbstract: true,\n      isDeferred: false,\n      isPlural: false,\n    };\n  }\n  const fieldName = root.getFieldName();\n  const storageKey = root.getStorageKey();\n  forEachRootCallArg(root, identifyingArgValue => {\n    var nodeRoot;\n    if (isPluralCall) {\n      invariant(\n        identifyingArgValue != null,\n        'diffRelayQuery(): Unexpected null or undefined value in root call ' +\n        'argument array for query, `%s(...).',\n        fieldName\n      );\n      nodeRoot = RelayQuery.Root.build(\n        root.getName(),\n        fieldName,\n        [identifyingArgValue],\n        root.getChildren(),\n        metadata,\n        root.getType()\n      );\n    } else {\n      // Reuse `root` if it only maps to one result.\n      nodeRoot = root;\n    }\n\n    // The whole query must be fetched if the root dataID is unknown.\n    var dataID = store.getDataID(storageKey, identifyingArgValue);\n    if (dataID == null) {\n      queries.push(nodeRoot);\n      return;\n    }\n\n    // Diff the current dataID\n    var scope = makeScope(dataID);\n    var diffOutput = visitor.visit(nodeRoot, path, scope);\n    var diffNode = diffOutput ? diffOutput.diffNode : null;\n    if (diffNode) {\n      invariant(\n        diffNode instanceof RelayQuery.Root,\n        'diffRelayQuery(): Expected result to be a root query.'\n      );\n      queries.push(diffNode);\n    }\n  });\n  return queries.concat(visitor.getSplitQueries());\n}\n\n/**\n * @internal\n *\n * A transform for (node + store) -> (diff + tracked queries). It is analagous\n * to `RelayQueryTransform` with the main differences as follows:\n * - there is no `state` (which allowed for passing data up and down the tree).\n * - data is passed down via `scope`, which flows from a parent field down\n *   through intermediary fragments to the nearest child field.\n * - data is passed up via the return type `{diffNode, trackedNode}`, where:\n *   - `diffNode`: subset of the input that could not diffed out\n *   - `trackedNode`: subset of the input that must be tracked\n *\n * The provided `tracker` is updated whenever the traversal of a node results\n * in a `trackedNode` being created. New top-level queries are not returned\n * up the tree, and instead are available via `getSplitQueries()`.\n */\nclass RelayDiffQueryBuilder {\n  _store: RelayRecordStore;\n  _splitQueries: Array<RelayQuery.Root>;\n  _tracker: RelayQueryTracker;\n\n  constructor(store: RelayRecordStore, tracker: RelayQueryTracker) {\n    this._store = store;\n    this._splitQueries = [];\n    this._tracker = tracker;\n  }\n\n  splitQuery(\n    root: RelayQuery.Root\n  ): void {\n    this._splitQueries.push(root);\n  }\n\n  getSplitQueries(): Array<RelayQuery.Root> {\n    return this._splitQueries;\n  }\n\n  visit(\n    node: RelayQuery.Node,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    if (node instanceof RelayQuery.Field) {\n      return this.visitField(node, path, scope);\n    } else if (node instanceof RelayQuery.Fragment) {\n      return this.visitFragment(node, path, scope);\n    } else if (node instanceof RelayQuery.Root) {\n      return this.visitRoot(node, path, scope);\n    }\n  }\n\n  visitRoot(\n    node: RelayQuery.Root,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    return this.traverse(node, path, scope);\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    return this.traverse(node, path, scope);\n  }\n\n  /**\n   * Diffs the field conditionally based on the `scope` from the nearest\n   * ancestor field.\n   */\n  visitField(\n    node: RelayQuery.Field,\n    path: RelayQueryPath,\n    {connectionField, dataID, edgeID, rangeInfo}: DiffScope\n  ): ?DiffOutput {\n    // special case when inside a connection traversal\n    if (connectionField && rangeInfo) {\n      if (edgeID) {\n        // When traversing a specific connection edge only look at `edges`\n        if (node.getSchemaName() === EDGES) {\n          return this.diffConnectionEdge(\n            connectionField,\n            node, // edge field\n            path.getPath(node, edgeID),\n            edgeID,\n            rangeInfo\n          );\n        } else {\n          return null;\n        }\n      } else {\n        // When traversing connection metadata fields, edges/page_info are\n        // only kept if there are range extension calls. Other fields fall\n        // through to regular diffing.\n        if (\n          node.getSchemaName() === EDGES ||\n          node.getSchemaName() === PAGE_INFO\n        ) {\n          return rangeInfo.diffCalls.length > 0 ?\n            {\n              diffNode: node,\n              trackedNode: null,\n            } :\n            null;\n        }\n      }\n    }\n\n    // default field diffing algorithm\n    if (!node.canHaveSubselections()) {\n      return this.diffScalar(node, dataID);\n    } else if (node.isGenerated()) {\n      return {\n        diffNode: node,\n        trackedNode: null,\n      };\n    } else if (node.isConnection()) {\n      return this.diffConnection(node, path, dataID);\n    } else if (node.isPlural()) {\n      return this.diffPluralLink(node, path, dataID);\n    } else {\n      return this.diffLink(node, path, dataID);\n    }\n  }\n\n  /**\n   * Visit all the children of the given `node` and merge their results.\n   */\n  traverse(\n    node: RelayQuery.Node,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    let diffNode;\n    let diffChildren;\n    let trackedNode;\n    let trackedChildren;\n    let hasDiffField = false;\n    let hasTrackedField = false;\n\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Field) {\n        const diffOutput = this.visitField(child, path, scope);\n        const diffChild = diffOutput ? diffOutput.diffNode : null;\n        const trackedChild = diffOutput ? diffOutput.trackedNode : null;\n\n        // Diff uses child nodes and keeps requisite fields\n        if (diffChild) {\n          diffChildren = diffChildren || [];\n          diffChildren.push(diffChild);\n          hasDiffField = hasDiffField || !diffChild.isGenerated();\n        } else if (child.isRequisite() && !scope.rangeInfo) {\n          // The presence of `rangeInfo` indicates that we are traversing\n          // connection metadata fields, in which case `visitField` will ensure\n          // that `edges` and `page_info` are kept when necessary. The requisite\n          // check alone could cause these fields to be added back when not\n          // needed.\n          //\n          // Example: `friends.first(3) {count, edges {...}, page_info {...} }\n          // If all `edges` were fetched but `count` is unfetched, the diff\n          // should be `friends.first(3) {count}` and not include `page_info`.\n          diffChildren = diffChildren || [];\n          diffChildren.push(child);\n        }\n        // Tracker uses tracked children and keeps requisite fields\n        if (trackedChild) {\n          trackedChildren = trackedChildren || [];\n          trackedChildren.push(trackedChild);\n          hasTrackedField = hasTrackedField || !trackedChild.isGenerated();\n        } else if (child.isRequisite()) {\n          trackedChildren = trackedChildren || [];\n          trackedChildren.push(child);\n        }\n      } else if (child instanceof RelayQuery.Fragment) {\n        const isCompatibleType = isCompatibleRelayFragmentType(\n          child,\n          this._store.getType(scope.dataID)\n        );\n        if (isCompatibleType) {\n          const diffOutput = this.traverse(child, path, scope);\n          const diffChild = diffOutput ? diffOutput.diffNode : null;\n          const trackedChild = diffOutput ? diffOutput.trackedNode : null;\n\n          if (diffChild) {\n            diffChildren = diffChildren || [];\n            diffChildren.push(diffChild);\n            hasDiffField = true;\n          }\n          if (trackedChild) {\n            trackedChildren = trackedChildren || [];\n            trackedChildren.push(trackedChild);\n            hasTrackedField = true;\n          }\n        } else {\n          // Non-matching fragment types are similar to requisite fields:\n          // they don't need to be diffed against and should only be included\n          // if something *else* is missing from the node.\n          diffChildren = diffChildren || [];\n          diffChildren.push(child);\n        }\n      }\n    });\n\n    // Only return diff/tracked node if there are non-generated fields\n    if (diffChildren && hasDiffField) {\n      diffNode = node.clone(diffChildren);\n    }\n    if (trackedChildren && hasTrackedField) {\n      trackedNode = node.clone(trackedChildren);\n    }\n    // Record tracked nodes. Fragments can be skipped because these will\n    // always be composed into, and therefore tracked by, their nearest\n    // non-fragment parent.\n    if (trackedNode && !(trackedNode instanceof RelayQuery.Fragment)) {\n      this._tracker.trackNodeForID(trackedNode, scope.dataID, path);\n    }\n\n    return {\n      diffNode,\n      trackedNode,\n    };\n  }\n\n  /**\n   * Diff a scalar field such as `name` or `id`.\n   */\n  diffScalar(\n    field: RelayQuery.Field,\n    dataID: DataID,\n  ): ?DiffOutput {\n    if (this._store.getField(dataID, field.getStorageKey()) === undefined) {\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Diff a field-of-fields such as `profile_picture {...}`. Returns early if\n   * the field has not been fetched, otherwise the result of traversal.\n   */\n  diffLink(\n    field: RelayQuery.Field,\n    path: RelayQueryPath,\n    dataID: DataID,\n  ): ?DiffOutput {\n    var nextDataID =\n      this._store.getLinkedRecordID(dataID, field.getStorageKey());\n    if (nextDataID === undefined) {\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    }\n    if (nextDataID === null) {\n      return {\n        diffNode: null,\n        trackedNode: field,\n      };\n    }\n\n    return this.traverse(\n      field,\n      path.getPath(field, nextDataID),\n      makeScope(nextDataID)\n    );\n  }\n\n  /**\n   * Diffs a non-connection plural field against each of the fetched items.\n   * Note that scalar plural fields are handled by `_diffScalar`.\n   */\n  diffPluralLink(\n    field: RelayQuery.Field,\n    path: RelayQueryPath,\n    dataID: DataID\n  ): ?DiffOutput {\n    var linkedIDs =\n      this._store.getLinkedRecordIDs(dataID, field.getStorageKey());\n    if (linkedIDs === undefined) {\n      // not fetched\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    } else if (linkedIDs === null || linkedIDs.length === 0) {\n      // Don't fetch if array is null or empty, but still track the fragment\n      return {\n        diffNode: null,\n        trackedNode: field,\n      };\n    } else if (field.getInferredRootCallName() === NODE) {\n      // The items in this array are fetchable and may have been filled in\n      // from other sources, so check them all. For example, `Story{actors}`\n      // is an array (but not a range), and the Actors in that array likely\n      // had data fetched for them elsewhere (like `viewer(){actor}`).\n      var hasSplitQueries = false;\n      linkedIDs.forEach(itemID => {\n        var itemState = this.traverse(\n          field,\n          path.getPath(field, itemID),\n          makeScope(itemID)\n        );\n        if (itemState) {\n          // If any child was tracked then `field` will also be tracked\n          hasSplitQueries =\n            hasSplitQueries || !!itemState.trackedNode || !!itemState.diffNode;\n          // split diff nodes into root queries\n          if (itemState.diffNode) {\n            this.splitQuery(buildRoot(\n              itemID,\n              itemState.diffNode.getChildren(),\n              path.getName(),\n              field.getType()\n            ));\n          }\n        }\n      });\n      // if sub-queries are split then this *entire* field will be tracked,\n      // therefore we don't need to merge the `trackedNode` from each item\n      if (hasSplitQueries) {\n        return {\n          diffNode: null,\n          trackedNode: field,\n        };\n      }\n    } else {\n      // The items in this array are not fetchable by ID, so nothing else\n      // could have fetched additional data for individual items. Therefore,\n      // we only need to diff the first record to figure out which fields have\n      // previously been fetched.\n      var sampleItemID = linkedIDs[0];\n      return this.traverse(\n        field,\n        path.getPath(field, sampleItemID),\n        makeScope(sampleItemID)\n      );\n    }\n    return null;\n  }\n\n  /**\n   * Diff a connection field such as `news_feed.first(3)`. Returns early if\n   * the range has not been fetched or the entire range has already been\n   * fetched. Otherwise the diff output is a clone of `field` with updated\n   * after/first and before/last calls.\n   */\n  diffConnection(\n    field: RelayQuery.Field,\n    path: RelayQueryPath,\n    dataID: DataID,\n  ): ?DiffOutput {\n    var store: RelayRecordStore = this._store;\n    var connectionID = store.getLinkedRecordID(dataID, field.getStorageKey());\n    var rangeInfo = store.getRangeMetadata(\n      connectionID,\n      field.getCallsWithValues()\n    );\n    // Keep the field if the connection is unfetched\n    if (connectionID === undefined) {\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    }\n    // Don't fetch if connection is null, but continue to track the fragment\n    if (connectionID === null) {\n      return {\n        diffNode: null,\n        trackedNode: field,\n      };\n    }\n    // If metadata fields but not edges are fetched, diff as a normal field.\n    // In practice, `rangeInfo` is `undefined` if unfetched, `null` if the\n    // connection was deleted (in which case `connectionID` is null too).\n    if (rangeInfo == null) {\n      return this.traverse(\n        field,\n        path.getPath(field, connectionID),\n        makeScope(connectionID)\n      );\n    }\n    var {diffCalls, filteredEdges} = rangeInfo;\n\n    // check existing edges for missing fields\n    var hasSplitQueries = false;\n    filteredEdges.forEach(edge => {\n      // Flow loses type information in closures\n      if (rangeInfo && connectionID) {\n        var scope = {\n          connectionField: field,\n          dataID: connectionID,\n          edgeID: edge.edgeID,\n          rangeInfo,\n        };\n        var diffOutput = this.traverse(\n          field,\n          path.getPath(field, edge.edgeID),\n          scope\n        );\n        // If any edges were missing data (resulting in a split query),\n        // then the entire original connection field must be tracked.\n        if (diffOutput) {\n          hasSplitQueries = hasSplitQueries || !!diffOutput.trackedNode;\n        }\n      }\n    });\n\n    // Scope has null `edgeID` to skip looking at `edges` fields.\n    var scope = {\n      connectionField: field,\n      dataID: connectionID,\n      edgeID: null,\n      rangeInfo,\n    };\n    // diff non-`edges` fields such as `count`\n    var diffOutput = this.traverse(\n      field,\n      path.getPath(field, connectionID),\n      scope\n    );\n    var diffNode = diffOutput ? diffOutput.diffNode : null;\n    var trackedNode = diffOutput ? diffOutput.trackedNode : null;\n    if (diffCalls.length && diffNode instanceof RelayQuery.Field) {\n      diffNode = diffNode.cloneFieldWithCalls(\n        diffNode.getChildren(),\n        diffCalls\n      );\n    }\n    // if a sub-query was split, then we must track the entire field, which will\n    // be a superset of the `trackedNode` from traversing any metadata fields.\n    // Example:\n    // dataID: `4`\n    // node: `friends.first(3)`\n    // diffNode: null\n    // splitQueries: `node(friend1) {...}`, `node(friend2) {...}`\n    //\n    // In this case the two fetched `node` queries do not reflect the fact that\n    // `friends.first(3)` were fetched for item `4`, so `friends.first(3)` has\n    // to be tracked as-is.\n    if (hasSplitQueries) {\n      trackedNode = field;\n    }\n\n    return {\n      diffNode,\n      trackedNode,\n    };\n  }\n\n  /**\n   * Diff an `edges` field for the edge rooted at `edgeID`, splitting a new\n   * root query to fetch any missing data (via a `node(id)` root if the\n   * field is refetchable or a `...{connection.find(id){}}` query if the\n   * field is not refetchable).\n   */\n  diffConnectionEdge(\n    connectionField: RelayQuery.Field,\n    edgeField: RelayQuery.Field,\n    path: RelayQueryPath,\n    edgeID: DataID,\n    rangeInfo: RangeInfo\n  ): DiffOutput {\n\n    var hasSplitQueries = false;\n    var diffOutput = this.traverse(\n      edgeField,\n      path.getPath(edgeField, edgeID),\n      makeScope(edgeID)\n    );\n    var diffNode = diffOutput ? diffOutput.diffNode : null;\n    var trackedNode = diffOutput ? diffOutput.trackedNode : null;\n    var nodeID = this._store.getLinkedRecordID(edgeID, NODE);\n\n    if (diffNode) {\n      if (!nodeID || RelayRecord.isClientID(nodeID)) {\n        warning(\n          connectionField.isConnectionWithoutNodeID(),\n          'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n          'retrieved if it does not have an `id` field. If you expect fields ' +\n          'to be retrieved on this field, add an `id` field in the schema. ' +\n          'If you choose to ignore this warning, you can silence it by ' +\n          'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n          'connection field.',\n          connectionField.getStorageKey()\n        );\n      } else {\n        var {\n          edges: diffEdgesField,\n          node: diffNodeField,\n        } = splitNodeAndEdgesFields(diffNode);\n\n        // split missing `node` fields into a `node(id)` root query\n        if (diffNodeField) {\n          hasSplitQueries = true;\n          const nodeField = edgeField.getFieldByStorageKey('node');\n          invariant(\n            nodeField,\n            'RelayDiffQueryBuilder: Expected connection `%s` to have a ' +\n            '`node` field.',\n            connectionField.getSchemaName()\n          );\n          this.splitQuery(buildRoot(\n            nodeID,\n            diffNodeField.getChildren(),\n            path.getName(),\n            nodeField.getType()\n          ));\n        }\n\n        // split missing `edges` fields into a `connection.find(id)` query\n        // if `find` is supported, otherwise warn\n        if (diffEdgesField) {\n          if (connectionField.isFindable()) {\n            diffEdgesField = diffEdgesField\n              .clone(diffEdgesField.getChildren().concat(nodeWithID));\n            var connectionFind = connectionField.cloneFieldWithCalls(\n              [diffEdgesField],\n              rangeInfo.filterCalls.concat({name: 'find', value: nodeID})\n            );\n            if (connectionFind) {\n              hasSplitQueries = true;\n              // current path has `parent`, `connection`, `edges`; pop to parent\n              var connectionParent = path.getParent().getParent();\n              var connectionQuery =\n                connectionParent.getQuery(this._store, connectionFind);\n              this.splitQuery(connectionQuery);\n            }\n          } else {\n            warning(\n              false,\n              'RelayDiffQueryBuilder: connection `edges{*}` fields can only ' +\n              'be refetched if the connection supports the `find` call. ' +\n              'Cannot refetch data for field `%s`.',\n              connectionField.getStorageKey()\n            );\n          }\n        }\n      }\n    }\n\n    // Connection edges will never return diff nodes; instead missing fields\n    // are fetched by new root queries. Tracked nodes are returned if either\n    // a child field was tracked or missing fields were split into a new query.\n    // The returned `trackedNode` is never tracked directly: instead it serves\n    // as an indicator to `diffConnection` that the entire connection field must\n    // be tracked.\n    return {\n      diffNode: null,\n      trackedNode: hasSplitQueries ? edgeField : trackedNode,\n    };\n  }\n}\n\n/**\n * Helper to construct a plain scope for the given `dataID`.\n */\nfunction makeScope(dataID: DataID): DiffScope {\n  return {\n    connectionField: null,\n    dataID,\n    edgeID: null,\n    rangeInfo: null,\n  };\n}\n\n/**\n * Returns a clone of the input with `edges` and `node` sub-fields split into\n * separate `edges` and `node` roots. Example:\n *\n * Input:\n * edges {\n *   edge_field,\n *   node {\n *     a,\n *     b\n *   },\n *   ${\n *     Fragment {\n *       edge_field_2,\n *       node {\n *         c\n *       }\n *     }\n *   }\n * }\n *\n * Output:\n * node:\n *   edges {\n *     a,      // flattened\n *     b,      // flattend\n *     ${\n *       Fragment {\n *         c  // flattened\n *       }\n *     }\n *   }\n * edges:\n *   edges {\n *     edge_field,\n *     ${\n *       Fragment {\n *         edge_field_2\n *       }\n *     }\n *   }\n */\nfunction splitNodeAndEdgesFields(\n  edgeOrFragment: RelayQuery.Node\n): {\n  edges: ?RelayQuery.Node,\n  node: ?RelayQuery.Node\n} {\n  var children = edgeOrFragment.getChildren();\n  var edgeChildren = [];\n  var hasNodeChild = false;\n  var nodeChildren = [];\n  var hasEdgeChild = false;\n  for (var ii = 0; ii < children.length; ii++) {\n    var child = children[ii];\n    if (child instanceof RelayQuery.Field) {\n      if (child.getSchemaName() === NODE) {\n        var subFields = child.getChildren();\n        nodeChildren = nodeChildren.concat(subFields);\n        // can skip if `node` only has an `id` field\n        hasNodeChild = (\n          hasNodeChild ||\n          subFields.length !== 1 ||\n          !(subFields[0] instanceof RelayQuery.Field) ||\n          /* $FlowFixMe(>=0.13.0) - subFields[0] needs to be in a local for Flow to\n           * narrow its type, otherwise Flow thinks its a RelayQueryNode without\n           * method `getSchemaName`\n           */\n          subFields[0].getSchemaName() !== 'id'\n        );\n      } else {\n        edgeChildren.push(child);\n        hasEdgeChild = hasEdgeChild || !child.isRequisite();\n      }\n    } else if (child instanceof RelayQuery.Fragment) {\n      var {edges, node} = splitNodeAndEdgesFields(child);\n      if (edges) {\n        edgeChildren.push(edges);\n        hasEdgeChild = true;\n      }\n      if (node) {\n        nodeChildren.push(node);\n        hasNodeChild = true;\n      }\n    }\n  }\n  return {\n    edges: hasEdgeChild ? edgeOrFragment.clone(edgeChildren) : null,\n    node: hasNodeChild ? edgeOrFragment.clone(nodeChildren) : null,\n  };\n}\n\nfunction buildRoot(\n  rootID: DataID,\n  nodes: Array<RelayQuery.Node>,\n  name: string,\n  type: string\n): RelayQuery.Root {\n  const children = [idField, typeField];\n  const fields = [];\n  nodes.forEach(node => {\n    if (node instanceof RelayQuery.Field) {\n      fields.push(node);\n    } else {\n      children.push(node);\n    }\n  });\n  children.push(RelayQuery.Fragment.build(\n    'diffRelayQuery',\n    type,\n    fields\n  ));\n\n  return RelayQuery.Root.build(\n    name,\n    NODE,\n    rootID,\n    children,\n    {\n      identifyingArgName: ID,\n      identifyingArgType: ID_TYPE,\n      isAbstract: true,\n      isDeferred: false,\n      isPlural: false,\n    },\n    NODE_TYPE\n  );\n}\n\nmodule.exports = RelayProfiler.instrument('diffRelayQuery', diffRelayQuery);\n","dependencies":["RelayQueryTracker","RelayRecordStore","RelayInternalTypes","RelayConnectionInterface","RelayNodeInterface","RelayProfiler","RelayQuery","RelayQueryPath","RelayRecord","forEachRootCallArg","invariant","isCompatibleRelayFragmentType","warning","diffRelayQuery"],"id":"diffRelayQuery","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule diffRelayQuery\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nconst RelayNodeInterface = require('RelayNodeInterface');\nconst RelayProfiler = require('RelayProfiler');\nconst RelayQuery = require('RelayQuery');\nconst RelayQueryPath = require('RelayQueryPath');\nimport type RelayQueryTracker from 'RelayQueryTracker';\nconst RelayRecord = require('RelayRecord');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst invariant = require('invariant');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\nconst warning = require('warning');\n\nconst {ID, ID_TYPE, NODE_TYPE, TYPENAME} = RelayNodeInterface;\nconst {EDGES, NODE, PAGE_INFO} = RelayConnectionInterface;\nconst idField = RelayQuery.Field.build({\n  fieldName: ID,\n  metadata: {\n    isRequisite: true,\n  },\n  type: 'String',\n});\nconst typeField = RelayQuery.Field.build({\n  fieldName: TYPENAME,\n  metadata: {\n    isRequisite: true,\n  },\n  type: 'String',\n});\nconst nodeWithID = RelayQuery.Field.build({\n  fieldName: RelayNodeInterface.NODE,\n  children: [idField, typeField],\n  metadata: {\n    canHaveSubselections: true,\n  },\n  type: NODE_TYPE,\n});\n\nimport type {DataID} from 'RelayInternalTypes';\n\ntype DiffScope = {\n  connectionField: ?RelayQuery.Field;\n  dataID: DataID,\n  edgeID: ?DataID,\n  rangeInfo: ?RangeInfo;\n};\ntype DiffOutput = {\n  diffNode: ?RelayQuery.Node;\n  trackedNode: ?RelayQuery.Node;\n};\n\n/**\n * @internal\n *\n * Computes the difference between the data requested in `root` and the data\n * available in `store`. It returns a minimal set of queries that will fulfill\n * the difference, or an empty array if the query can be resolved locally.\n */\nfunction diffRelayQuery(\n  root: RelayQuery.Root,\n  store: RelayRecordStore,\n  tracker: RelayQueryTracker\n): Array<RelayQuery.Root> {\n  var path = new RelayQueryPath(root);\n  var queries = [];\n\n  var visitor = new RelayDiffQueryBuilder(store, tracker);\n  const rootIdentifyingArg = root.getIdentifyingArg();\n  const rootIdentifyingArgValue =\n    (rootIdentifyingArg && rootIdentifyingArg.value) || null;\n  var isPluralCall = (\n    Array.isArray(rootIdentifyingArgValue) &&\n    rootIdentifyingArgValue.length > 1\n  );\n  let metadata;\n  if (rootIdentifyingArg != null) {\n    metadata = {\n      identifyingArgName: rootIdentifyingArg.name,\n      identifyingArgType: rootIdentifyingArg.type != null ?\n        rootIdentifyingArg.type :\n        ID_TYPE,\n      isAbstract: true,\n      isDeferred: false,\n      isPlural: false,\n    };\n  }\n  const fieldName = root.getFieldName();\n  const storageKey = root.getStorageKey();\n  forEachRootCallArg(root, identifyingArgValue => {\n    var nodeRoot;\n    if (isPluralCall) {\n      invariant(\n        identifyingArgValue != null,\n        'diffRelayQuery(): Unexpected null or undefined value in root call ' +\n        'argument array for query, `%s(...).',\n        fieldName\n      );\n      nodeRoot = RelayQuery.Root.build(\n        root.getName(),\n        fieldName,\n        [identifyingArgValue],\n        root.getChildren(),\n        metadata,\n        root.getType()\n      );\n    } else {\n      // Reuse `root` if it only maps to one result.\n      nodeRoot = root;\n    }\n\n    // The whole query must be fetched if the root dataID is unknown.\n    var dataID = store.getDataID(storageKey, identifyingArgValue);\n    if (dataID == null) {\n      queries.push(nodeRoot);\n      return;\n    }\n\n    // Diff the current dataID\n    var scope = makeScope(dataID);\n    var diffOutput = visitor.visit(nodeRoot, path, scope);\n    var diffNode = diffOutput ? diffOutput.diffNode : null;\n    if (diffNode) {\n      invariant(\n        diffNode instanceof RelayQuery.Root,\n        'diffRelayQuery(): Expected result to be a root query.'\n      );\n      queries.push(diffNode);\n    }\n  });\n  return queries.concat(visitor.getSplitQueries());\n}\n\n/**\n * @internal\n *\n * A transform for (node + store) -> (diff + tracked queries). It is analagous\n * to `RelayQueryTransform` with the main differences as follows:\n * - there is no `state` (which allowed for passing data up and down the tree).\n * - data is passed down via `scope`, which flows from a parent field down\n *   through intermediary fragments to the nearest child field.\n * - data is passed up via the return type `{diffNode, trackedNode}`, where:\n *   - `diffNode`: subset of the input that could not diffed out\n *   - `trackedNode`: subset of the input that must be tracked\n *\n * The provided `tracker` is updated whenever the traversal of a node results\n * in a `trackedNode` being created. New top-level queries are not returned\n * up the tree, and instead are available via `getSplitQueries()`.\n */\nclass RelayDiffQueryBuilder {\n  _store: RelayRecordStore;\n  _splitQueries: Array<RelayQuery.Root>;\n  _tracker: RelayQueryTracker;\n\n  constructor(store: RelayRecordStore, tracker: RelayQueryTracker) {\n    this._store = store;\n    this._splitQueries = [];\n    this._tracker = tracker;\n  }\n\n  splitQuery(\n    root: RelayQuery.Root\n  ): void {\n    this._splitQueries.push(root);\n  }\n\n  getSplitQueries(): Array<RelayQuery.Root> {\n    return this._splitQueries;\n  }\n\n  visit(\n    node: RelayQuery.Node,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    if (node instanceof RelayQuery.Field) {\n      return this.visitField(node, path, scope);\n    } else if (node instanceof RelayQuery.Fragment) {\n      return this.visitFragment(node, path, scope);\n    } else if (node instanceof RelayQuery.Root) {\n      return this.visitRoot(node, path, scope);\n    }\n  }\n\n  visitRoot(\n    node: RelayQuery.Root,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    return this.traverse(node, path, scope);\n  }\n\n  visitFragment(\n    node: RelayQuery.Fragment,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    return this.traverse(node, path, scope);\n  }\n\n  /**\n   * Diffs the field conditionally based on the `scope` from the nearest\n   * ancestor field.\n   */\n  visitField(\n    node: RelayQuery.Field,\n    path: RelayQueryPath,\n    {connectionField, dataID, edgeID, rangeInfo}: DiffScope\n  ): ?DiffOutput {\n    // special case when inside a connection traversal\n    if (connectionField && rangeInfo) {\n      if (edgeID) {\n        // When traversing a specific connection edge only look at `edges`\n        if (node.getSchemaName() === EDGES) {\n          return this.diffConnectionEdge(\n            connectionField,\n            node, // edge field\n            path.getPath(node, edgeID),\n            edgeID,\n            rangeInfo\n          );\n        } else {\n          return null;\n        }\n      } else {\n        // When traversing connection metadata fields, edges/page_info are\n        // only kept if there are range extension calls. Other fields fall\n        // through to regular diffing.\n        if (\n          node.getSchemaName() === EDGES ||\n          node.getSchemaName() === PAGE_INFO\n        ) {\n          return rangeInfo.diffCalls.length > 0 ?\n            {\n              diffNode: node,\n              trackedNode: null,\n            } :\n            null;\n        }\n      }\n    }\n\n    // default field diffing algorithm\n    if (!node.canHaveSubselections()) {\n      return this.diffScalar(node, dataID);\n    } else if (node.isGenerated()) {\n      return {\n        diffNode: node,\n        trackedNode: null,\n      };\n    } else if (node.isConnection()) {\n      return this.diffConnection(node, path, dataID);\n    } else if (node.isPlural()) {\n      return this.diffPluralLink(node, path, dataID);\n    } else {\n      return this.diffLink(node, path, dataID);\n    }\n  }\n\n  /**\n   * Visit all the children of the given `node` and merge their results.\n   */\n  traverse(\n    node: RelayQuery.Node,\n    path: RelayQueryPath,\n    scope: DiffScope\n  ): ?DiffOutput {\n    let diffNode;\n    let diffChildren;\n    let trackedNode;\n    let trackedChildren;\n    let hasDiffField = false;\n    let hasTrackedField = false;\n\n    node.getChildren().forEach(child => {\n      if (child instanceof RelayQuery.Field) {\n        const diffOutput = this.visitField(child, path, scope);\n        const diffChild = diffOutput ? diffOutput.diffNode : null;\n        const trackedChild = diffOutput ? diffOutput.trackedNode : null;\n\n        // Diff uses child nodes and keeps requisite fields\n        if (diffChild) {\n          diffChildren = diffChildren || [];\n          diffChildren.push(diffChild);\n          hasDiffField = hasDiffField || !diffChild.isGenerated();\n        } else if (child.isRequisite() && !scope.rangeInfo) {\n          // The presence of `rangeInfo` indicates that we are traversing\n          // connection metadata fields, in which case `visitField` will ensure\n          // that `edges` and `page_info` are kept when necessary. The requisite\n          // check alone could cause these fields to be added back when not\n          // needed.\n          //\n          // Example: `friends.first(3) {count, edges {...}, page_info {...} }\n          // If all `edges` were fetched but `count` is unfetched, the diff\n          // should be `friends.first(3) {count}` and not include `page_info`.\n          diffChildren = diffChildren || [];\n          diffChildren.push(child);\n        }\n        // Tracker uses tracked children and keeps requisite fields\n        if (trackedChild) {\n          trackedChildren = trackedChildren || [];\n          trackedChildren.push(trackedChild);\n          hasTrackedField = hasTrackedField || !trackedChild.isGenerated();\n        } else if (child.isRequisite()) {\n          trackedChildren = trackedChildren || [];\n          trackedChildren.push(child);\n        }\n      } else if (child instanceof RelayQuery.Fragment) {\n        const isCompatibleType = isCompatibleRelayFragmentType(\n          child,\n          this._store.getType(scope.dataID)\n        );\n        if (isCompatibleType) {\n          const diffOutput = this.traverse(child, path, scope);\n          const diffChild = diffOutput ? diffOutput.diffNode : null;\n          const trackedChild = diffOutput ? diffOutput.trackedNode : null;\n\n          if (diffChild) {\n            diffChildren = diffChildren || [];\n            diffChildren.push(diffChild);\n            hasDiffField = true;\n          }\n          if (trackedChild) {\n            trackedChildren = trackedChildren || [];\n            trackedChildren.push(trackedChild);\n            hasTrackedField = true;\n          }\n        } else {\n          // Non-matching fragment types are similar to requisite fields:\n          // they don't need to be diffed against and should only be included\n          // if something *else* is missing from the node.\n          diffChildren = diffChildren || [];\n          diffChildren.push(child);\n        }\n      }\n    });\n\n    // Only return diff/tracked node if there are non-generated fields\n    if (diffChildren && hasDiffField) {\n      diffNode = node.clone(diffChildren);\n    }\n    if (trackedChildren && hasTrackedField) {\n      trackedNode = node.clone(trackedChildren);\n    }\n    // Record tracked nodes. Fragments can be skipped because these will\n    // always be composed into, and therefore tracked by, their nearest\n    // non-fragment parent.\n    if (trackedNode && !(trackedNode instanceof RelayQuery.Fragment)) {\n      this._tracker.trackNodeForID(trackedNode, scope.dataID, path);\n    }\n\n    return {\n      diffNode,\n      trackedNode,\n    };\n  }\n\n  /**\n   * Diff a scalar field such as `name` or `id`.\n   */\n  diffScalar(\n    field: RelayQuery.Field,\n    dataID: DataID,\n  ): ?DiffOutput {\n    if (this._store.getField(dataID, field.getStorageKey()) === undefined) {\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Diff a field-of-fields such as `profile_picture {...}`. Returns early if\n   * the field has not been fetched, otherwise the result of traversal.\n   */\n  diffLink(\n    field: RelayQuery.Field,\n    path: RelayQueryPath,\n    dataID: DataID,\n  ): ?DiffOutput {\n    var nextDataID =\n      this._store.getLinkedRecordID(dataID, field.getStorageKey());\n    if (nextDataID === undefined) {\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    }\n    if (nextDataID === null) {\n      return {\n        diffNode: null,\n        trackedNode: field,\n      };\n    }\n\n    return this.traverse(\n      field,\n      path.getPath(field, nextDataID),\n      makeScope(nextDataID)\n    );\n  }\n\n  /**\n   * Diffs a non-connection plural field against each of the fetched items.\n   * Note that scalar plural fields are handled by `_diffScalar`.\n   */\n  diffPluralLink(\n    field: RelayQuery.Field,\n    path: RelayQueryPath,\n    dataID: DataID\n  ): ?DiffOutput {\n    var linkedIDs =\n      this._store.getLinkedRecordIDs(dataID, field.getStorageKey());\n    if (linkedIDs === undefined) {\n      // not fetched\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    } else if (linkedIDs === null || linkedIDs.length === 0) {\n      // Don't fetch if array is null or empty, but still track the fragment\n      return {\n        diffNode: null,\n        trackedNode: field,\n      };\n    } else if (field.getInferredRootCallName() === NODE) {\n      // The items in this array are fetchable and may have been filled in\n      // from other sources, so check them all. For example, `Story{actors}`\n      // is an array (but not a range), and the Actors in that array likely\n      // had data fetched for them elsewhere (like `viewer(){actor}`).\n      var hasSplitQueries = false;\n      linkedIDs.forEach(itemID => {\n        var itemState = this.traverse(\n          field,\n          path.getPath(field, itemID),\n          makeScope(itemID)\n        );\n        if (itemState) {\n          // If any child was tracked then `field` will also be tracked\n          hasSplitQueries =\n            hasSplitQueries || !!itemState.trackedNode || !!itemState.diffNode;\n          // split diff nodes into root queries\n          if (itemState.diffNode) {\n            this.splitQuery(buildRoot(\n              itemID,\n              itemState.diffNode.getChildren(),\n              path.getName(),\n              field.getType()\n            ));\n          }\n        }\n      });\n      // if sub-queries are split then this *entire* field will be tracked,\n      // therefore we don't need to merge the `trackedNode` from each item\n      if (hasSplitQueries) {\n        return {\n          diffNode: null,\n          trackedNode: field,\n        };\n      }\n    } else {\n      // The items in this array are not fetchable by ID, so nothing else\n      // could have fetched additional data for individual items. Therefore,\n      // we only need to diff the first record to figure out which fields have\n      // previously been fetched.\n      var sampleItemID = linkedIDs[0];\n      return this.traverse(\n        field,\n        path.getPath(field, sampleItemID),\n        makeScope(sampleItemID)\n      );\n    }\n    return null;\n  }\n\n  /**\n   * Diff a connection field such as `news_feed.first(3)`. Returns early if\n   * the range has not been fetched or the entire range has already been\n   * fetched. Otherwise the diff output is a clone of `field` with updated\n   * after/first and before/last calls.\n   */\n  diffConnection(\n    field: RelayQuery.Field,\n    path: RelayQueryPath,\n    dataID: DataID,\n  ): ?DiffOutput {\n    var store: RelayRecordStore = this._store;\n    var connectionID = store.getLinkedRecordID(dataID, field.getStorageKey());\n    var rangeInfo = store.getRangeMetadata(\n      connectionID,\n      field.getCallsWithValues()\n    );\n    // Keep the field if the connection is unfetched\n    if (connectionID === undefined) {\n      return {\n        diffNode: field,\n        trackedNode: null,\n      };\n    }\n    // Don't fetch if connection is null, but continue to track the fragment\n    if (connectionID === null) {\n      return {\n        diffNode: null,\n        trackedNode: field,\n      };\n    }\n    // If metadata fields but not edges are fetched, diff as a normal field.\n    // In practice, `rangeInfo` is `undefined` if unfetched, `null` if the\n    // connection was deleted (in which case `connectionID` is null too).\n    if (rangeInfo == null) {\n      return this.traverse(\n        field,\n        path.getPath(field, connectionID),\n        makeScope(connectionID)\n      );\n    }\n    var {diffCalls, filteredEdges} = rangeInfo;\n\n    // check existing edges for missing fields\n    var hasSplitQueries = false;\n    filteredEdges.forEach(edge => {\n      // Flow loses type information in closures\n      if (rangeInfo && connectionID) {\n        var scope = {\n          connectionField: field,\n          dataID: connectionID,\n          edgeID: edge.edgeID,\n          rangeInfo,\n        };\n        var diffOutput = this.traverse(\n          field,\n          path.getPath(field, edge.edgeID),\n          scope\n        );\n        // If any edges were missing data (resulting in a split query),\n        // then the entire original connection field must be tracked.\n        if (diffOutput) {\n          hasSplitQueries = hasSplitQueries || !!diffOutput.trackedNode;\n        }\n      }\n    });\n\n    // Scope has null `edgeID` to skip looking at `edges` fields.\n    var scope = {\n      connectionField: field,\n      dataID: connectionID,\n      edgeID: null,\n      rangeInfo,\n    };\n    // diff non-`edges` fields such as `count`\n    var diffOutput = this.traverse(\n      field,\n      path.getPath(field, connectionID),\n      scope\n    );\n    var diffNode = diffOutput ? diffOutput.diffNode : null;\n    var trackedNode = diffOutput ? diffOutput.trackedNode : null;\n    if (diffCalls.length && diffNode instanceof RelayQuery.Field) {\n      diffNode = diffNode.cloneFieldWithCalls(\n        diffNode.getChildren(),\n        diffCalls\n      );\n    }\n    // if a sub-query was split, then we must track the entire field, which will\n    // be a superset of the `trackedNode` from traversing any metadata fields.\n    // Example:\n    // dataID: `4`\n    // node: `friends.first(3)`\n    // diffNode: null\n    // splitQueries: `node(friend1) {...}`, `node(friend2) {...}`\n    //\n    // In this case the two fetched `node` queries do not reflect the fact that\n    // `friends.first(3)` were fetched for item `4`, so `friends.first(3)` has\n    // to be tracked as-is.\n    if (hasSplitQueries) {\n      trackedNode = field;\n    }\n\n    return {\n      diffNode,\n      trackedNode,\n    };\n  }\n\n  /**\n   * Diff an `edges` field for the edge rooted at `edgeID`, splitting a new\n   * root query to fetch any missing data (via a `node(id)` root if the\n   * field is refetchable or a `...{connection.find(id){}}` query if the\n   * field is not refetchable).\n   */\n  diffConnectionEdge(\n    connectionField: RelayQuery.Field,\n    edgeField: RelayQuery.Field,\n    path: RelayQueryPath,\n    edgeID: DataID,\n    rangeInfo: RangeInfo\n  ): DiffOutput {\n\n    var hasSplitQueries = false;\n    var diffOutput = this.traverse(\n      edgeField,\n      path.getPath(edgeField, edgeID),\n      makeScope(edgeID)\n    );\n    var diffNode = diffOutput ? diffOutput.diffNode : null;\n    var trackedNode = diffOutput ? diffOutput.trackedNode : null;\n    var nodeID = this._store.getLinkedRecordID(edgeID, NODE);\n\n    if (diffNode) {\n      if (!nodeID || RelayRecord.isClientID(nodeID)) {\n        warning(\n          connectionField.isConnectionWithoutNodeID(),\n          'RelayDiffQueryBuilder: Field `node` on connection `%s` cannot be ' +\n          'retrieved if it does not have an `id` field. If you expect fields ' +\n          'to be retrieved on this field, add an `id` field in the schema. ' +\n          'If you choose to ignore this warning, you can silence it by ' +\n          'adding `@relay(isConnectionWithoutNodeID: true)` to the ' +\n          'connection field.',\n          connectionField.getStorageKey()\n        );\n      } else {\n        var {\n          edges: diffEdgesField,\n          node: diffNodeField,\n        } = splitNodeAndEdgesFields(diffNode);\n\n        // split missing `node` fields into a `node(id)` root query\n        if (diffNodeField) {\n          hasSplitQueries = true;\n          const nodeField = edgeField.getFieldByStorageKey('node');\n          invariant(\n            nodeField,\n            'RelayDiffQueryBuilder: Expected connection `%s` to have a ' +\n            '`node` field.',\n            connectionField.getSchemaName()\n          );\n          this.splitQuery(buildRoot(\n            nodeID,\n            diffNodeField.getChildren(),\n            path.getName(),\n            nodeField.getType()\n          ));\n        }\n\n        // split missing `edges` fields into a `connection.find(id)` query\n        // if `find` is supported, otherwise warn\n        if (diffEdgesField) {\n          if (connectionField.isFindable()) {\n            diffEdgesField = diffEdgesField\n              .clone(diffEdgesField.getChildren().concat(nodeWithID));\n            var connectionFind = connectionField.cloneFieldWithCalls(\n              [diffEdgesField],\n              rangeInfo.filterCalls.concat({name: 'find', value: nodeID})\n            );\n            if (connectionFind) {\n              hasSplitQueries = true;\n              // current path has `parent`, `connection`, `edges`; pop to parent\n              var connectionParent = path.getParent().getParent();\n              var connectionQuery =\n                connectionParent.getQuery(this._store, connectionFind);\n              this.splitQuery(connectionQuery);\n            }\n          } else {\n            warning(\n              false,\n              'RelayDiffQueryBuilder: connection `edges{*}` fields can only ' +\n              'be refetched if the connection supports the `find` call. ' +\n              'Cannot refetch data for field `%s`.',\n              connectionField.getStorageKey()\n            );\n          }\n        }\n      }\n    }\n\n    // Connection edges will never return diff nodes; instead missing fields\n    // are fetched by new root queries. Tracked nodes are returned if either\n    // a child field was tracked or missing fields were split into a new query.\n    // The returned `trackedNode` is never tracked directly: instead it serves\n    // as an indicator to `diffConnection` that the entire connection field must\n    // be tracked.\n    return {\n      diffNode: null,\n      trackedNode: hasSplitQueries ? edgeField : trackedNode,\n    };\n  }\n}\n\n/**\n * Helper to construct a plain scope for the given `dataID`.\n */\nfunction makeScope(dataID: DataID): DiffScope {\n  return {\n    connectionField: null,\n    dataID,\n    edgeID: null,\n    rangeInfo: null,\n  };\n}\n\n/**\n * Returns a clone of the input with `edges` and `node` sub-fields split into\n * separate `edges` and `node` roots. Example:\n *\n * Input:\n * edges {\n *   edge_field,\n *   node {\n *     a,\n *     b\n *   },\n *   ${\n *     Fragment {\n *       edge_field_2,\n *       node {\n *         c\n *       }\n *     }\n *   }\n * }\n *\n * Output:\n * node:\n *   edges {\n *     a,      // flattened\n *     b,      // flattend\n *     ${\n *       Fragment {\n *         c  // flattened\n *       }\n *     }\n *   }\n * edges:\n *   edges {\n *     edge_field,\n *     ${\n *       Fragment {\n *         edge_field_2\n *       }\n *     }\n *   }\n */\nfunction splitNodeAndEdgesFields(\n  edgeOrFragment: RelayQuery.Node\n): {\n  edges: ?RelayQuery.Node,\n  node: ?RelayQuery.Node\n} {\n  var children = edgeOrFragment.getChildren();\n  var edgeChildren = [];\n  var hasNodeChild = false;\n  var nodeChildren = [];\n  var hasEdgeChild = false;\n  for (var ii = 0; ii < children.length; ii++) {\n    var child = children[ii];\n    if (child instanceof RelayQuery.Field) {\n      if (child.getSchemaName() === NODE) {\n        var subFields = child.getChildren();\n        nodeChildren = nodeChildren.concat(subFields);\n        // can skip if `node` only has an `id` field\n        hasNodeChild = (\n          hasNodeChild ||\n          subFields.length !== 1 ||\n          !(subFields[0] instanceof RelayQuery.Field) ||\n          /* $FlowFixMe(>=0.13.0) - subFields[0] needs to be in a local for Flow to\n           * narrow its type, otherwise Flow thinks its a RelayQueryNode without\n           * method `getSchemaName`\n           */\n          subFields[0].getSchemaName() !== 'id'\n        );\n      } else {\n        edgeChildren.push(child);\n        hasEdgeChild = hasEdgeChild || !child.isRequisite();\n      }\n    } else if (child instanceof RelayQuery.Fragment) {\n      var {edges, node} = splitNodeAndEdgesFields(child);\n      if (edges) {\n        edgeChildren.push(edges);\n        hasEdgeChild = true;\n      }\n      if (node) {\n        nodeChildren.push(node);\n        hasNodeChild = true;\n      }\n    }\n  }\n  return {\n    edges: hasEdgeChild ? edgeOrFragment.clone(edgeChildren) : null,\n    node: hasNodeChild ? edgeOrFragment.clone(nodeChildren) : null,\n  };\n}\n\nfunction buildRoot(\n  rootID: DataID,\n  nodes: Array<RelayQuery.Node>,\n  name: string,\n  type: string\n): RelayQuery.Root {\n  const children = [idField, typeField];\n  const fields = [];\n  nodes.forEach(node => {\n    if (node instanceof RelayQuery.Field) {\n      fields.push(node);\n    } else {\n      children.push(node);\n    }\n  });\n  children.push(RelayQuery.Fragment.build(\n    'diffRelayQuery',\n    type,\n    fields\n  ));\n\n  return RelayQuery.Root.build(\n    name,\n    NODE,\n    rootID,\n    children,\n    {\n      identifyingArgName: ID,\n      identifyingArgType: ID_TYPE,\n      isAbstract: true,\n      isDeferred: false,\n      isPlural: false,\n    },\n    NODE_TYPE\n  );\n}\n\nmodule.exports = RelayProfiler.instrument('diffRelayQuery', diffRelayQuery);\n"}}},"/Users/cpojer/Projects/relay/src/traversal/containsRelayQueryRootCall.js":{"metadata":{"mtime":1455679339000},"data":{"name":"containsRelayQueryRootCall","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule containsRelayQueryRootCall\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\n/**\n * @internal\n *\n * Compares two query root nodes and returns true if the nodes fetched by\n * `thisRoot` would be a superset of the nodes fetched by `thatRoot`.\n */\nfunction containsRelayQueryRootCall(\n  thisRoot: RelayQuery.Root,\n  thatRoot: RelayQuery.Root\n): boolean {\n  if (thisRoot === thatRoot) {\n    return true;\n  }\n  if (\n    getCanonicalName(thisRoot.getFieldName()) !==\n    getCanonicalName(thatRoot.getFieldName())\n  ) {\n    return false;\n  }\n  const thisIdentifyingArg = thisRoot.getIdentifyingArg();\n  const thatIdentifyingArg = thatRoot.getIdentifyingArg();\n  const thisValue = (thisIdentifyingArg && thisIdentifyingArg.value) || null;\n  const thatValue = (thatIdentifyingArg && thatIdentifyingArg.value) || null;\n  if (thisValue == null && thatValue == null) {\n    return true;\n  }\n  if (thisValue == null || thatValue == null) {\n    return false;\n  }\n  if (Array.isArray(thisValue)) {\n    var thisArray = thisValue;\n    if (Array.isArray(thatValue)) {\n      return thatValue.every(eachValue => thisArray.indexOf(eachValue) >= 0);\n    } else {\n      return thisValue.indexOf(thatValue) >= 0;\n    }\n  } else {\n    if (Array.isArray(thatValue)) {\n      return thatValue.every(eachValue => eachValue === thisValue);\n    } else {\n      return thatValue === thisValue;\n    }\n  }\n}\n\nvar canonicalRootCalls = {\n  'nodes': 'node',\n  'usernames': 'username',\n};\n\n/**\n * @private\n *\n * This is required to support legacy versions of GraphQL.\n */\nfunction getCanonicalName(name: string): string {\n  if (canonicalRootCalls.hasOwnProperty(name)) {\n    return canonicalRootCalls[name];\n  }\n  return name;\n}\n\nmodule.exports = containsRelayQueryRootCall;\n","dependencies":["RelayQuery","containsRelayQueryRootCall"],"id":"containsRelayQueryRootCall","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule containsRelayQueryRootCall\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nimport type RelayQuery from 'RelayQuery';\n\n/**\n * @internal\n *\n * Compares two query root nodes and returns true if the nodes fetched by\n * `thisRoot` would be a superset of the nodes fetched by `thatRoot`.\n */\nfunction containsRelayQueryRootCall(\n  thisRoot: RelayQuery.Root,\n  thatRoot: RelayQuery.Root\n): boolean {\n  if (thisRoot === thatRoot) {\n    return true;\n  }\n  if (\n    getCanonicalName(thisRoot.getFieldName()) !==\n    getCanonicalName(thatRoot.getFieldName())\n  ) {\n    return false;\n  }\n  const thisIdentifyingArg = thisRoot.getIdentifyingArg();\n  const thatIdentifyingArg = thatRoot.getIdentifyingArg();\n  const thisValue = (thisIdentifyingArg && thisIdentifyingArg.value) || null;\n  const thatValue = (thatIdentifyingArg && thatIdentifyingArg.value) || null;\n  if (thisValue == null && thatValue == null) {\n    return true;\n  }\n  if (thisValue == null || thatValue == null) {\n    return false;\n  }\n  if (Array.isArray(thisValue)) {\n    var thisArray = thisValue;\n    if (Array.isArray(thatValue)) {\n      return thatValue.every(eachValue => thisArray.indexOf(eachValue) >= 0);\n    } else {\n      return thisValue.indexOf(thatValue) >= 0;\n    }\n  } else {\n    if (Array.isArray(thatValue)) {\n      return thatValue.every(eachValue => eachValue === thisValue);\n    } else {\n      return thatValue === thisValue;\n    }\n  }\n}\n\nvar canonicalRootCalls = {\n  'nodes': 'node',\n  'usernames': 'username',\n};\n\n/**\n * @private\n *\n * This is required to support legacy versions of GraphQL.\n */\nfunction getCanonicalName(name: string): string {\n  if (canonicalRootCalls.hasOwnProperty(name)) {\n    return canonicalRootCalls[name];\n  }\n  return name;\n}\n\nmodule.exports = containsRelayQueryRootCall;\n"}}},"/Users/cpojer/Projects/relay/src/traversal/checkRelayQueryData.js":{"metadata":{"mtime":1455679339000},"data":{"name":"checkRelayQueryData","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule checkRelayQueryData\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\n\ntype CheckerState = {\n  dataID: ?DataID;\n  rangeInfo: ?RangeInfo;\n  result: boolean;\n};\n\nconst {EDGES, PAGE_INFO} = RelayConnectionInterface;\n\n/**\n * @internal\n *\n * Traverses a query and data in the record store to determine whether we have\n * enough data to satisfy the query.\n */\nfunction checkRelayQueryData(\n  store: RelayRecordStore,\n  query: RelayQuery.Root\n): boolean {\n\n  var checker = new RelayQueryChecker(store);\n\n  var state = {\n    dataID: undefined,\n    rangeInfo: undefined,\n    result: true,\n  };\n\n  checker.visit(query, state);\n  return state.result;\n}\n\nclass RelayQueryChecker extends RelayQueryVisitor<CheckerState> {\n  _store: RelayRecordStore;\n\n  constructor(store: RelayRecordStore) {\n    super();\n    this._store = store;\n  }\n\n  /**\n   * Skip visiting children if result is already false.\n   */\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    state: CheckerState\n  ): ?Tn {\n    var children = node.getChildren();\n    for (var ii = 0; ii < children.length; ii++) {\n      if (!state.result) {\n        return;\n      }\n      this.visit(children[ii], state);\n    }\n  }\n\n  visitRoot(\n    root: RelayQuery.Root,\n    state: CheckerState\n  ): void {\n    var nextState;\n    const storageKey = root.getStorageKey();\n    forEachRootCallArg(root, identifyingArgValue => {\n      var dataID = this._store.getDataID(storageKey, identifyingArgValue);\n      if (dataID == null) {\n        state.result = false;\n      } else {\n        nextState = {\n          dataID,\n          rangeInfo: undefined,\n          result: true,\n        };\n        this.traverse(root, nextState);\n        state.result = state.result && nextState.result;\n      }\n    });\n  }\n\n  visitFragment(\n    fragment: RelayQuery.Fragment,\n    state: CheckerState\n  ): void {\n    const dataID = state.dataID;\n    // The dataID check is for Flow; it must be non-null to have gotten here.\n    if (dataID && isCompatibleRelayFragmentType(\n      fragment,\n      this._store.getType(dataID)\n    )) {\n      this.traverse(fragment, state);\n    }\n  }\n\n  visitField(\n    field: RelayQuery.Field,\n    state: CheckerState\n  ): void {\n    var dataID = state.dataID;\n    var recordState = dataID && this._store.getRecordState(dataID);\n    if (recordState === RelayRecordState.UNKNOWN) {\n      state.result = false;\n      return;\n    } else if (recordState === RelayRecordState.NONEXISTENT) {\n      return;\n    }\n    var rangeInfo = state.rangeInfo;\n    if (rangeInfo && field.getSchemaName() === EDGES) {\n      this._checkEdges(field, state);\n    } else if (rangeInfo && field.getSchemaName() === PAGE_INFO) {\n      this._checkPageInfo(field, state);\n    } else if (!field.canHaveSubselections()) {\n      this._checkScalar(field, state);\n    } else if (field.isPlural()) {\n      this._checkPlural(field, state);\n    } else if (field.isConnection()) {\n      this._checkConnection(field, state);\n    } else {\n      this._checkLinkedField(field, state);\n    }\n  }\n\n  _checkScalar(field: RelayQuery.Field, state: CheckerState): void {\n    var fieldData = state.dataID &&\n      this._store.getField(state.dataID, field.getStorageKey());\n    if (fieldData === undefined) {\n      state.result = false;\n    }\n  }\n\n  _checkPlural(field: RelayQuery.Field, state: CheckerState): void {\n    var dataIDs = state.dataID &&\n      this._store.getLinkedRecordIDs(state.dataID, field.getStorageKey());\n    if (dataIDs === undefined) {\n      state.result = false;\n      return;\n    }\n    if (dataIDs) {\n      for (var ii = 0; ii < dataIDs.length; ii++) {\n        if (!state.result) {\n          break;\n        }\n        var nextState = {\n          dataID: dataIDs[ii],\n          rangeInfo: undefined,\n          result: true,\n        };\n        this.traverse(field, nextState);\n        state.result = nextState.result;\n      }\n    }\n  }\n\n  _checkConnection(field: RelayQuery.Field, state: CheckerState): void {\n    var calls = field.getCallsWithValues();\n    var dataID = state.dataID &&\n      this._store.getLinkedRecordID(state.dataID, field.getStorageKey());\n    if (dataID === undefined) {\n      state.result = false;\n      return;\n    }\n    var nextState: CheckerState = {\n      dataID,\n      rangeInfo: null, // Flow rejects `undefined` here\n      result: true,\n    };\n    var metadata = this._store.getRangeMetadata(dataID, calls);\n    if (metadata) {\n      nextState.rangeInfo = metadata;\n    }\n    this.traverse(field, nextState);\n    state.result = state.result && nextState.result;\n  }\n\n  _checkEdges(field: RelayQuery.Field, state: CheckerState): void {\n    var rangeInfo = state.rangeInfo;\n    if (!rangeInfo) {\n      state.result = false;\n      return;\n    }\n    if (rangeInfo.diffCalls.length) {\n      state.result = false;\n      return;\n    }\n    var edges = rangeInfo.filteredEdges;\n    for (var ii = 0; ii < edges.length; ii++) {\n      if (!state.result) {\n        break;\n      }\n      var nextState = {\n        dataID: edges[ii].edgeID,\n        rangeInfo: undefined,\n        result: true,\n      };\n      this.traverse(field, nextState);\n      state.result = nextState.result;\n    }\n  }\n\n  _checkPageInfo(field: RelayQuery.Field, state: CheckerState): void {\n    var rangeInfo = state.rangeInfo;\n    if (!rangeInfo || !rangeInfo.pageInfo) {\n      state.result = false;\n      return;\n    }\n  }\n\n  _checkLinkedField(field: RelayQuery.Field, state: CheckerState): void {\n    var dataID = state.dataID &&\n        this._store.getLinkedRecordID(state.dataID, field.getStorageKey());\n    if (dataID === undefined) {\n      state.result = false;\n      return;\n    }\n    if (dataID) {\n      var nextState = {\n        dataID,\n        rangeInfo: undefined,\n        result: true,\n      };\n      this.traverse(field, nextState);\n      state.result = state.result && nextState.result;\n    }\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'checkRelayQueryData',\n  checkRelayQueryData\n);\n","dependencies":["RelayInternalTypes","RelayQuery","RelayRecordStore","RelayConnectionInterface","RelayProfiler","RelayQueryVisitor","RelayRecordState","forEachRootCallArg","isCompatibleRelayFragmentType","checkRelayQueryData"],"id":"checkRelayQueryData","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule checkRelayQueryData\n * @flow\n * @typechecks\n */\n\n'use strict';\n\nconst RelayConnectionInterface = require('RelayConnectionInterface');\nimport type {DataID} from 'RelayInternalTypes';\nconst RelayProfiler = require('RelayProfiler');\nimport type RelayQuery from 'RelayQuery';\nconst RelayQueryVisitor = require('RelayQueryVisitor');\nconst RelayRecordState = require('RelayRecordState');\nimport type RelayRecordStore from 'RelayRecordStore';\nimport type {RangeInfo} from 'RelayRecordStore';\n\nconst forEachRootCallArg = require('forEachRootCallArg');\nconst isCompatibleRelayFragmentType = require('isCompatibleRelayFragmentType');\n\ntype CheckerState = {\n  dataID: ?DataID;\n  rangeInfo: ?RangeInfo;\n  result: boolean;\n};\n\nconst {EDGES, PAGE_INFO} = RelayConnectionInterface;\n\n/**\n * @internal\n *\n * Traverses a query and data in the record store to determine whether we have\n * enough data to satisfy the query.\n */\nfunction checkRelayQueryData(\n  store: RelayRecordStore,\n  query: RelayQuery.Root\n): boolean {\n\n  var checker = new RelayQueryChecker(store);\n\n  var state = {\n    dataID: undefined,\n    rangeInfo: undefined,\n    result: true,\n  };\n\n  checker.visit(query, state);\n  return state.result;\n}\n\nclass RelayQueryChecker extends RelayQueryVisitor<CheckerState> {\n  _store: RelayRecordStore;\n\n  constructor(store: RelayRecordStore) {\n    super();\n    this._store = store;\n  }\n\n  /**\n   * Skip visiting children if result is already false.\n   */\n  traverse<Tn: RelayQuery.Node>(\n    node: Tn,\n    state: CheckerState\n  ): ?Tn {\n    var children = node.getChildren();\n    for (var ii = 0; ii < children.length; ii++) {\n      if (!state.result) {\n        return;\n      }\n      this.visit(children[ii], state);\n    }\n  }\n\n  visitRoot(\n    root: RelayQuery.Root,\n    state: CheckerState\n  ): void {\n    var nextState;\n    const storageKey = root.getStorageKey();\n    forEachRootCallArg(root, identifyingArgValue => {\n      var dataID = this._store.getDataID(storageKey, identifyingArgValue);\n      if (dataID == null) {\n        state.result = false;\n      } else {\n        nextState = {\n          dataID,\n          rangeInfo: undefined,\n          result: true,\n        };\n        this.traverse(root, nextState);\n        state.result = state.result && nextState.result;\n      }\n    });\n  }\n\n  visitFragment(\n    fragment: RelayQuery.Fragment,\n    state: CheckerState\n  ): void {\n    const dataID = state.dataID;\n    // The dataID check is for Flow; it must be non-null to have gotten here.\n    if (dataID && isCompatibleRelayFragmentType(\n      fragment,\n      this._store.getType(dataID)\n    )) {\n      this.traverse(fragment, state);\n    }\n  }\n\n  visitField(\n    field: RelayQuery.Field,\n    state: CheckerState\n  ): void {\n    var dataID = state.dataID;\n    var recordState = dataID && this._store.getRecordState(dataID);\n    if (recordState === RelayRecordState.UNKNOWN) {\n      state.result = false;\n      return;\n    } else if (recordState === RelayRecordState.NONEXISTENT) {\n      return;\n    }\n    var rangeInfo = state.rangeInfo;\n    if (rangeInfo && field.getSchemaName() === EDGES) {\n      this._checkEdges(field, state);\n    } else if (rangeInfo && field.getSchemaName() === PAGE_INFO) {\n      this._checkPageInfo(field, state);\n    } else if (!field.canHaveSubselections()) {\n      this._checkScalar(field, state);\n    } else if (field.isPlural()) {\n      this._checkPlural(field, state);\n    } else if (field.isConnection()) {\n      this._checkConnection(field, state);\n    } else {\n      this._checkLinkedField(field, state);\n    }\n  }\n\n  _checkScalar(field: RelayQuery.Field, state: CheckerState): void {\n    var fieldData = state.dataID &&\n      this._store.getField(state.dataID, field.getStorageKey());\n    if (fieldData === undefined) {\n      state.result = false;\n    }\n  }\n\n  _checkPlural(field: RelayQuery.Field, state: CheckerState): void {\n    var dataIDs = state.dataID &&\n      this._store.getLinkedRecordIDs(state.dataID, field.getStorageKey());\n    if (dataIDs === undefined) {\n      state.result = false;\n      return;\n    }\n    if (dataIDs) {\n      for (var ii = 0; ii < dataIDs.length; ii++) {\n        if (!state.result) {\n          break;\n        }\n        var nextState = {\n          dataID: dataIDs[ii],\n          rangeInfo: undefined,\n          result: true,\n        };\n        this.traverse(field, nextState);\n        state.result = nextState.result;\n      }\n    }\n  }\n\n  _checkConnection(field: RelayQuery.Field, state: CheckerState): void {\n    var calls = field.getCallsWithValues();\n    var dataID = state.dataID &&\n      this._store.getLinkedRecordID(state.dataID, field.getStorageKey());\n    if (dataID === undefined) {\n      state.result = false;\n      return;\n    }\n    var nextState: CheckerState = {\n      dataID,\n      rangeInfo: null, // Flow rejects `undefined` here\n      result: true,\n    };\n    var metadata = this._store.getRangeMetadata(dataID, calls);\n    if (metadata) {\n      nextState.rangeInfo = metadata;\n    }\n    this.traverse(field, nextState);\n    state.result = state.result && nextState.result;\n  }\n\n  _checkEdges(field: RelayQuery.Field, state: CheckerState): void {\n    var rangeInfo = state.rangeInfo;\n    if (!rangeInfo) {\n      state.result = false;\n      return;\n    }\n    if (rangeInfo.diffCalls.length) {\n      state.result = false;\n      return;\n    }\n    var edges = rangeInfo.filteredEdges;\n    for (var ii = 0; ii < edges.length; ii++) {\n      if (!state.result) {\n        break;\n      }\n      var nextState = {\n        dataID: edges[ii].edgeID,\n        rangeInfo: undefined,\n        result: true,\n      };\n      this.traverse(field, nextState);\n      state.result = nextState.result;\n    }\n  }\n\n  _checkPageInfo(field: RelayQuery.Field, state: CheckerState): void {\n    var rangeInfo = state.rangeInfo;\n    if (!rangeInfo || !rangeInfo.pageInfo) {\n      state.result = false;\n      return;\n    }\n  }\n\n  _checkLinkedField(field: RelayQuery.Field, state: CheckerState): void {\n    var dataID = state.dataID &&\n        this._store.getLinkedRecordID(state.dataID, field.getStorageKey());\n    if (dataID === undefined) {\n      state.result = false;\n      return;\n    }\n    if (dataID) {\n      var nextState = {\n        dataID,\n        rangeInfo: undefined,\n        result: true,\n      };\n      this.traverse(field, nextState);\n      state.result = state.result && nextState.result;\n    }\n  }\n}\n\nmodule.exports = RelayProfiler.instrument(\n  'checkRelayQueryData',\n  checkRelayQueryData\n);\n"}}},"/Users/cpojer/Projects/relay/src/RelayPublic.js":{"metadata":{"mtime":1455679338000},"data":{"name":"RelayPublic","isHaste":true,"moduleData":{"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayPublic\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayContainer = require('RelayContainer');\nconst RelayMutation = require('RelayMutation');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayPropTypes = require('RelayPropTypes');\nconst RelayQL = require('RelayQL');\nconst RelayRootContainer = require('RelayRootContainer');\nconst RelayRoute = require('RelayRoute');\nconst RelayStore = require('RelayStore');\nconst RelayTaskScheduler = require('RelayTaskScheduler');\nconst RelayInternals = require('RelayInternals');\n\nconst createRelayQuery = require('createRelayQuery');\nconst getRelayQueries = require('getRelayQueries');\nconst isRelayContainer = require('isRelayContainer');\n\nif (typeof global.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined') {\n  global.__REACT_DEVTOOLS_GLOBAL_HOOK__._relayInternals = RelayInternals;\n}\n\n/**\n * Relay contains the set of public methods used to initialize and orchestrate\n * a React application that uses GraphQL to declare data dependencies.\n */\nvar RelayPublic = {\n  Mutation: RelayMutation,\n  PropTypes: RelayPropTypes,\n  QL: RelayQL,\n  RootContainer: RelayRootContainer,\n  Route: RelayRoute,\n  Store: RelayStore,\n\n  createContainer: RelayContainer.create,\n  createQuery: createRelayQuery,\n  getQueries: getRelayQueries,\n  injectNetworkLayer: RelayNetworkLayer.injectNetworkLayer,\n  injectTaskScheduler: RelayTaskScheduler.injectScheduler,\n  isContainer: isRelayContainer,\n};\n\nmodule.exports = RelayPublic;\n","dependencies":["RelayContainer","RelayMutation","RelayNetworkLayer","RelayPropTypes","RelayQL","RelayRootContainer","RelayRoute","RelayStore","RelayTaskScheduler","RelayInternals","createRelayQuery","getRelayQueries","isRelayContainer","RelayPublic"],"id":"RelayPublic","source":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule RelayPublic\n * @typechecks\n * @flow\n */\n\n'use strict';\n\nconst RelayContainer = require('RelayContainer');\nconst RelayMutation = require('RelayMutation');\nconst RelayNetworkLayer = require('RelayNetworkLayer');\nconst RelayPropTypes = require('RelayPropTypes');\nconst RelayQL = require('RelayQL');\nconst RelayRootContainer = require('RelayRootContainer');\nconst RelayRoute = require('RelayRoute');\nconst RelayStore = require('RelayStore');\nconst RelayTaskScheduler = require('RelayTaskScheduler');\nconst RelayInternals = require('RelayInternals');\n\nconst createRelayQuery = require('createRelayQuery');\nconst getRelayQueries = require('getRelayQueries');\nconst isRelayContainer = require('isRelayContainer');\n\nif (typeof global.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined') {\n  global.__REACT_DEVTOOLS_GLOBAL_HOOK__._relayInternals = RelayInternals;\n}\n\n/**\n * Relay contains the set of public methods used to initialize and orchestrate\n * a React application that uses GraphQL to declare data dependencies.\n */\nvar RelayPublic = {\n  Mutation: RelayMutation,\n  PropTypes: RelayPropTypes,\n  QL: RelayQL,\n  RootContainer: RelayRootContainer,\n  Route: RelayRoute,\n  Store: RelayStore,\n\n  createContainer: RelayContainer.create,\n  createQuery: createRelayQuery,\n  getQueries: getRelayQueries,\n  injectNetworkLayer: RelayNetworkLayer.injectNetworkLayer,\n  injectTaskScheduler: RelayTaskScheduler.injectScheduler,\n  isContainer: isRelayContainer,\n};\n\nmodule.exports = RelayPublic;\n"}}},"/Users/cpojer/Projects/relay/src/container/RelayContainer.js":{"metadata":{"mtime":1457637590000},"data":{"name":"RelayContainer"}}}