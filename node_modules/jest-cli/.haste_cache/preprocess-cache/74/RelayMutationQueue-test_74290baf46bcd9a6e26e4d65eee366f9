'use strict';












require('configureForRelayOSS');

jest.
dontMock('RelayMutationTransaction').
dontMock('RelayMutationTransactionStatus');













describe('RelayMutationQueue',function(){
var storeData=undefined;
var mutationQueue=undefined;
var networkLayer=undefined;

beforeEach(function(){
jest.resetModuleRegistry();

require('RelayStoreData').prototype.handleUpdatePayload=jest.genMockFunction();
storeData=require('RelayStore').getStoreData();
mutationQueue=storeData.getMutationQueue();
networkLayer=storeData.getNetworkLayer();

jasmine.addMatchers(require('RelayTestUtils').matchers);});


describe('constructor',function(){
var mockMutation=undefined,mutationNode=undefined,fatQuery=undefined;

beforeEach(function(){
mutationNode=function(){return {calls:[{kind:'Call',metadata:{},name:'commentCreate',value:{kind:'CallVariable',callVariableName:'input'}}],children:[{fieldName:'clientMutationId',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],kind:'Mutation',metadata:{inputType:'CommentCreateInput'},name:'RelayMutationQueue',responseType:'CommentCreateResponsePayload'};}();
fatQuery=function(){return {children:[{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'},{children:[{fieldName:'likers',kind:'Field',metadata:{canHaveSubselections:true,isConnection:true},type:'LikersOfContentConnection'},{fieldName:'doesViewerLike',kind:'Field',metadata:{},type:'Boolean'},{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{},name:'Comment',type:'Comment'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{pattern:true},name:'RelayMutationQueueRelayQL',type:'Comment'};}();





mockMutation=new (require('RelayMutation'))();
mockMutation.getFatQuery.mockReturnValue(fatQuery);
mockMutation.getMutation.mockReturnValue(mutationNode);
mockMutation.getConfigs.mockReturnValue('configs');});


it('does not update store if there is no optimistic response',function(){
var transaction=mutationQueue.createTransaction(mockMutation);

expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').UNCOMMITTED);

expect(storeData.handleUpdatePayload).not.toBeCalled();});


it('updates store if there is a optimistic response',function(){
var input={foo:'bar'};
mockMutation.getVariables.mockReturnValue(input);
mockMutation.getOptimisticResponse.mockReturnValue({});
mockMutation.getOptimisticConfigs.mockReturnValue('optimisticConfigs');
require('RelayMutationQuery').buildQuery.mockReturnValue('optimisticQuery');

var transaction=mutationQueue.createTransaction(mockMutation);

expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').UNCOMMITTED);

var buildQueryCalls=require('RelayMutationQuery').buildQuery.mock.calls;
expect(buildQueryCalls.length).toBe(1);
expect(buildQueryCalls[0][0].configs).toBe('optimisticConfigs');
expect(buildQueryCalls[0][0].input).toEqual(babelHelpers.extends({},
input,babelHelpers.defineProperty({},
require('RelayConnectionInterface').CLIENT_MUTATION_ID,'0')));

expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);
expect(buildQueryCalls[0][0].mutationName).toBe('RelayMutation');
expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());
expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(
require('flattenRelayQuery')(require('fromGraphQL').Fragment(fatQuery),{
preserveEmptyNodes:true,
shouldRemoveFragments:true}));


expect(storeData.handleUpdatePayload.mock.calls).toEqual([[
'optimisticQuery',babelHelpers.defineProperty({},
require('RelayConnectionInterface').CLIENT_MUTATION_ID,'0'),
{configs:'optimisticConfigs',isOptimisticUpdate:true}]]);});



it('infers optimistic query if mutation does not have one',function(){
mockMutation.getOptimisticResponse.mockReturnValue({});
require('RelayMutationQuery').buildQueryForOptimisticUpdate.mockReturnValue(
'optimisticQuery');


mutationQueue.createTransaction(mockMutation);

var buildQueryCalls=
require('RelayMutationQuery').buildQueryForOptimisticUpdate.mock.calls;
expect(buildQueryCalls.length).toBe(1);
expect(buildQueryCalls[0][0].mutation).toBe(mutationNode);
expect(buildQueryCalls[0][0].response).toEqual(babelHelpers.defineProperty({},
require('RelayConnectionInterface').CLIENT_MUTATION_ID,'0'));

expect(buildQueryCalls[0][0].tracker).toBe(storeData.getQueryTracker());
expect(buildQueryCalls[0][0].fatQuery).toEqualQueryNode(
require('flattenRelayQuery')(require('fromGraphQL').Fragment(fatQuery),{
preserveEmptyNodes:true,
shouldRemoveFragments:true}));


expect(storeData.handleUpdatePayload.mock.calls).toEqual([[
'optimisticQuery',babelHelpers.defineProperty({},
require('RelayConnectionInterface').CLIENT_MUTATION_ID,'0'),
{configs:'configs',isOptimisticUpdate:true}]]);});});




describe('commit',function(){
var mockMutation1=undefined;
var mockMutation2=undefined;
var mockMutation3=undefined;

beforeEach(function(){
var fatQuery=function(){return {children:[{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'},{children:[{fieldName:'doesViewerLike',kind:'Field',metadata:{},type:'Boolean'},{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{},name:'Comment',type:'Comment'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{pattern:true},name:'RelayMutationQueueRelayQL',type:'Comment'};}();




var mutationNode=function(){return {calls:[{kind:'Call',metadata:{},name:'commentCreate',value:{kind:'CallVariable',callVariableName:'input'}}],children:[{fieldName:'clientMutationId',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],kind:'Mutation',metadata:{inputType:'CommentCreateInput'},name:'RelayMutationQueue',responseType:'CommentCreateResponsePayload'};}();

require('RelayMutation').prototype.getFatQuery.mockReturnValue(fatQuery);
require('RelayMutation').prototype.getMutation.mockReturnValue(mutationNode);
require('RelayMutation').prototype.getCollisionKey.mockReturnValue(null);
require('RelayMutation').prototype.getVariables.mockReturnValue({});
require('RelayMutation').prototype.getConfigs.mockReturnValue('configs');

mockMutation1=new (require('RelayMutation'))();
mockMutation2=new (require('RelayMutation'))();
mockMutation3=new (require('RelayMutation'))();
mockMutation1.getCollisionKey.mockReturnValue('key');
mockMutation2.getCollisionKey.mockReturnValue('anotherKey');});


it('throws if commit is called more than once',function(){
var transaction=mutationQueue.createTransaction(mockMutation1);
transaction.commit();
expect(function(){return transaction.commit();}).toFailInvariant(
'RelayMutationTransaction: Only transactions with status '+
'`UNCOMMITTED` can be comitted.');});



it('calls `onSuccess` with response',function(){
var successCallback1=jest.genMockFunction();
var transaction1=mutationQueue.createTransaction(
mockMutation1,
{onSuccess:successCallback1});

transaction1.commit();
expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

var request=networkLayer.sendMutation.mock.calls[0][0];
request.resolve({response:{'res':'ponse'}});
jest.runAllTimers();
expect(successCallback1.mock.calls).toEqual([[{'res':'ponse'}]]);});


it('calls `onFailure` with transaction',function(){
var failureCallback1=jest.genMockFunction().mockImplementation(
function(transaction){
expect(transaction).toBe(transaction1);
expect(transaction.getError()).toBe(mockError);});


var transaction1=mutationQueue.createTransaction(
mockMutation1,
{onFailure:failureCallback1});

var mockError=new Error('error');
transaction1.commit();

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);
var request=networkLayer.sendMutation.mock.calls[0][0];
request.reject(mockError);
jest.runAllTimers();
expect(failureCallback1).toBeCalled();});


it('queues commits for colliding transactions',function(){
var successCallback1=jest.genMockFunction();
var transaction1=mutationQueue.createTransaction(
mockMutation1,
{onSuccess:successCallback1});

transaction1.commit();

expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);


var transaction2=mutationQueue.createTransaction(mockMutation1);
transaction2.commit();

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

var request=networkLayer.sendMutation.mock.calls[0][0];
request.resolve({response:{}});
jest.runAllTimers();

expect(successCallback1).toBeCalled();
expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);});


it('does not queue commits for non-colliding transactions',function(){
var transaction1=mutationQueue.createTransaction(mockMutation1);
transaction1.commit();

expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

var transaction2=mutationQueue.createTransaction(mockMutation2);
transaction2.commit();

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);});


it('does not queue commits for `null` collision key transactions',function(){
var transaction1=mutationQueue.createTransaction(mockMutation3);
transaction1.commit();

expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

var transaction2=mutationQueue.createTransaction(mockMutation3);
transaction2.commit();

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);});


it('empties collision queue after a failure',function(){
var failureCallback1=jest.genMockFunction().mockImplementation(
function(transaction,preventAutoRollback){
expect(transaction).toBe(transaction1);
expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_FAILED);});



var transaction1=mutationQueue.createTransaction(
mockMutation1,
{onFailure:failureCallback1});

transaction1.commit();

expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

var failureCallback2=jest.genMockFunction().mockImplementation(
function(transaction,preventAutoRollback){
expect(transaction).toBe(transaction2);
expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);


preventAutoRollback();});


var transaction2=mutationQueue.createTransaction(
mockMutation1,
{onFailure:failureCallback2});

transaction2.commit();

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

var request=networkLayer.sendMutation.mock.calls[0][0];
request.reject(new Error('error'));
jest.runAllTimers();

expect(failureCallback1).toBeCalled();
expect(failureCallback2).toBeCalled();
expect(function(){return transaction1.getStatus();}).toFailInvariant(
'RelayMutationQueue: `0` is not a valid pending transaction ID.');

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);


var transaction3=mutationQueue.createTransaction(mockMutation1);
transaction3.commit();

expect(transaction3.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);});


it('rolls back colliding transactions on failure unless prevented',function(){
var failureCallback1=jest.genMockFunction().mockImplementation(
function(transaction,preventAutoRollback){
expect(transaction).toBe(transaction1);
expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_FAILED);

preventAutoRollback();});


var transaction1=mutationQueue.createTransaction(
mockMutation1,
{onFailure:failureCallback1});

transaction1.commit();

var failureCallback2=jest.genMockFunction().mockImplementation(
function(transaction,preventAutoRollback){
expect(transaction).toBe(transaction2);
expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);});



var transaction2=mutationQueue.createTransaction(
mockMutation1,
{onFailure:failureCallback2});

transaction2.commit();

var failureCallback3=jest.genMockFunction().mockImplementation(
function(transaction,preventAutoRollback){
expect(transaction).toBe(transaction3);
expect(transaction.getStatus()).toBe(
require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);

preventAutoRollback();});


var transaction3=mutationQueue.createTransaction(
mockMutation1,
{onFailure:failureCallback3});

transaction3.commit();

expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);

expect(transaction3.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);


var failureCallback4=jest.genMockFunction().mockImplementation();
var transaction4=mutationQueue.createTransaction(
mockMutation2,
{onFailure:failureCallback4});

transaction4.commit();

var failureCallback5=jest.genMockFunction().mockImplementation();
var transaction5=mutationQueue.createTransaction(
mockMutation2,
{onFailure:failureCallback5});

transaction5.commit();

expect(transaction4.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(transaction5.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);

var request=networkLayer.sendMutation.mock.calls[0][0];
request.reject(new Error('error'));
jest.runAllTimers();

expect(failureCallback1).toBeCalled();
expect(failureCallback2).toBeCalled();
expect(failureCallback3).toBeCalled();
expect(failureCallback4).not.toBeCalled();
expect(failureCallback5).not.toBeCalled();
expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_FAILED);

expect(function(){return transaction2.getStatus();}).toFailInvariant(
'RelayMutationQueue: `1` is not a valid pending transaction ID.');

expect(transaction3.getStatus()).toBe(
require('RelayMutationTransactionStatus').COLLISION_COMMIT_FAILED);

expect(transaction4.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);

expect(transaction5.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);});});




describe('recommit',function(){
var mockMutation=undefined;

beforeEach(function(){
var fatQuery=function(){return {children:[{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'},{children:[{fieldName:'doesViewerLike',kind:'Field',metadata:{},type:'Boolean'},{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{},name:'Comment',type:'Comment'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{pattern:true},name:'RelayMutationQueueRelayQL',type:'Comment'};}();




var mutationNode=function(){return {calls:[{kind:'Call',metadata:{},name:'commentCreate',value:{kind:'CallVariable',callVariableName:'input'}}],children:[{fieldName:'clientMutationId',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],kind:'Mutation',metadata:{inputType:'CommentCreateInput'},name:'RelayMutationQueue',responseType:'CommentCreateResponsePayload'};}();
require('RelayMutation').prototype.getFatQuery.mockReturnValue(fatQuery);
require('RelayMutation').prototype.getMutation.mockReturnValue(mutationNode);
require('RelayMutation').prototype.getCollisionKey.mockReturnValue('key');
require('RelayMutation').prototype.getVariables.mockReturnValue({});
require('RelayMutation').prototype.getConfigs.mockReturnValue('configs');

mockMutation=new (require('RelayMutation'))();});


it('re-queues the transaction',function(){
var successCallback1=jest.genMockFunction();
var failureCallback1=jest.genMockFunction().mockImplementation(
function(transaction,preventAutoRollback){
preventAutoRollback();});


var transaction1=mutationQueue.createTransaction(
mockMutation,
{
onSuccess:successCallback1,
onFailure:failureCallback1});


transaction1.commit();

expect(networkLayer.sendMutation.mock.calls.length).toBe(1);
var request=networkLayer.sendMutation.mock.calls[0][0];
request.reject(new Error('error'));
jest.runAllTimers();

expect(failureCallback1).toBeCalled();
expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_FAILED);


var successCallback2=jest.genMockFunction();
var transaction2=mutationQueue.createTransaction(
mockMutation,
{onSuccess:successCallback2});

transaction2.commit();

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);

transaction1.recommit();
expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);


request=networkLayer.sendMutation.mock.calls[1][0];
request.resolve({response:{}});
jest.runAllTimers();
expect(successCallback2).toBeCalled();

expect(networkLayer.sendMutation.mock.calls.length).toBe(3);
expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);


request=networkLayer.sendMutation.mock.calls[2][0];
request.resolve({response:{}});
jest.runAllTimers();

expect(successCallback1).toBeCalled();});});



describe('rollback',function(){
var mockMutation1=undefined;

beforeEach(function(){
var fatQuery=function(){return {children:[{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'},{children:[{fieldName:'doesViewerLike',kind:'Field',metadata:{},type:'Boolean'},{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{},name:'Comment',type:'Comment'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{pattern:true},name:'RelayMutationQueueRelayQL',type:'Comment'};}();




var mutationNode=function(){return {calls:[{kind:'Call',metadata:{},name:'commentCreate',value:{kind:'CallVariable',callVariableName:'input'}}],children:[{fieldName:'clientMutationId',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],kind:'Mutation',metadata:{inputType:'CommentCreateInput'},name:'RelayMutationQueue',responseType:'CommentCreateResponsePayload'};}();
require('RelayMutation').prototype.getFatQuery.mockReturnValue(fatQuery);
require('RelayMutation').prototype.getMutation.mockReturnValue(mutationNode);
require('RelayMutation').prototype.getCollisionKey.mockReturnValue('key');
require('RelayMutation').prototype.getVariables.mockReturnValue({});
require('RelayMutation').prototype.getConfigs.mockReturnValue('configs');

mockMutation1=new (require('RelayMutation'))();
mockMutation1.getCollisionKey.mockReturnValue('key');});


it('rollback queued transaction',function(){
var transaction1=mutationQueue.createTransaction(mockMutation1);
transaction1.commit();

expect(transaction1.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);


var transaction2=mutationQueue.createTransaction(mockMutation1);
transaction2.commit();

expect(transaction2.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);


var transaction3=mutationQueue.createTransaction(mockMutation1);
transaction3.commit();

expect(transaction3.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMIT_QUEUED);


expect(networkLayer.sendMutation.mock.calls.length).toBe(1);

transaction2.rollback();

expect(function(){return transaction2.getStatus();}).toFailInvariant(
'RelayMutationQueue: `1` is not a valid pending transaction ID.');


var request=networkLayer.sendMutation.mock.calls[0][0];
request.resolve({response:{'res':'ponse'}});
jest.runAllTimers();

expect(networkLayer.sendMutation.mock.calls.length).toBe(2);

expect(transaction3.getStatus()).toBe(
require('RelayMutationTransactionStatus').COMMITTING);});});});