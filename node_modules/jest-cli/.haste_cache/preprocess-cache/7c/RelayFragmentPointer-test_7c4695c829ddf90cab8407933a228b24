/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.dontMock('RelayFragmentPointer');







describe('RelayFragmentPointer', function () {var 
  getNode = require('RelayTestUtils').getNode;var getRefNode = require('RelayTestUtils').getRefNode;

  beforeEach(function () {
    jest.resetModuleRegistry();

    jasmine.addMatchers(require('RelayTestUtils').matchers);
    jasmine.addMatchers({ 
      toEqualPointer: function () {
        return { 
          compare: function (actual, expected) {
            return { 
              pass: actual.equals(expected) };} };} });});







  describe('create()', function () {
    var dataID = '123';

    it('creates a fragment prop for a singular fragment', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'gihKjxdz4fiO:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})());
      var fragmentProp = require('RelayFragmentPointer').create(dataID, fragment);
      expect(fragmentProp).toEqual({ 
        __dataID__: dataID, 
        __fragments__: _defineProperty({}, 
        fragment.getConcreteFragmentID(), dataID) });});




    it('adds plural fragments to objects', function () {
      var pluralFragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'hukUn54XssR7:0', kind: 'Fragment', metadata: { plural: true, isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})());


      var fragmentProp = require('RelayFragmentPointer').create(dataID, pluralFragment);
      expect(fragmentProp).toEqual({ 
        __dataID__: dataID, 
        __fragments__: _defineProperty({}, 
        pluralFragment.getConcreteFragmentID(), dataID) });});});





  describe('createForRoot', function () {
    var recordStore;

    beforeEach(function () {
      var records = {};
      recordStore = new (require('RelayRecordStore'))({ records: records });});


    it('creates a wrapped fragment pointer', function () {
      var rootFragment = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'u/tui/+qE3zd:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var root = getNode((function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayFragmentPointer', type: 'Node' };})(rootFragment));

      var result = require('RelayFragmentPointer').createForRoot(recordStore, root);
      expect(result).toEqual({ 
        __dataID__: '123', 
        __fragments__: _defineProperty({}, 
        getNode(rootFragment).getConcreteFragmentID(), '123') });});




    it('throws if multiple root fragments are present', function () {
      var rootFragmentA = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: '8oGhJjCIGen5:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var rootFragmentB = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: '11Gq99h53LkK:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var root = getNode((function (RQL_0, RQL_1) {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'foo' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0), require('Relay').QL.__frag(RQL_1)]), fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayFragmentPointer', type: 'Actor' };})(

      rootFragmentA, rootFragmentB));



      expect(function () {
        require('RelayFragmentPointer').createForRoot(recordStore, root);}).
      toFailInvariant(
      'Queries supplied at the root should contain exactly one fragment ' + 
      '(e.g. `${Component.getFragment(\'...\')}`). Query ' + 
      '`RelayFragmentPointer` contains more than one fragment.');});



    it('throws if non-fragments are present', function () {
      var root = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'foo' } }], children: [{ fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayFragmentPointer', type: 'Actor' };})());

      expect(function () {
        require('RelayFragmentPointer').createForRoot(recordStore, root);}).
      toFailInvariant(
      'Queries supplied at the root should contain exactly one fragment ' + 
      'and no fields. Query `RelayFragmentPointer` contains a field, ' + 
      '`name`. If you need to fetch fields, declare them in a Relay ' + 
      'container.');});



    it('throws for unknown ref queries', function () {
      var rootFragment = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'ByBtvAhYL4pF:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})();
      var root = getRefNode((function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'ids', value: { kind: 'CallVariable', callVariableName: 'ref_q0' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'nodes', kind: 'Query', metadata: { isPlural: true, isAbstract: true, identifyingArgName: 'ids' }, name: 'RelayFragmentPointer', type: 'Node' };})(
      rootFragment), 
      { path: '$.*.id' });


      expect(function () {
        require('RelayFragmentPointer').createForRoot(recordStore, root);}).
      toFailInvariant(
      'Queries supplied at the root cannot have batch call variables. ' + 
      'Query `RelayFragmentPointer` has a batch call variable, `ref_q0`.');});



    it('returns null when the root call was not fetched', function () {
      // When a root call is not fetched since it only contained empty
      // fragments, we shouldn't throw.
      var ref = (function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], id: 'cC+asDnxrz2k:0', kind: 'Fragment', metadata: {}, name: 'RelayFragmentPointerRelayQL', type: 'Viewer' };})();
      var root = getNode((function (RQL_0) {return { children: [].concat.apply([], [require('Relay').QL.__frag(RQL_0)]), fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayFragmentPointer', type: 'Viewer' };})(ref));

      expect(
      require('RelayFragmentPointer').createForRoot(recordStore, root)).
      toBeNull();});});



  describe('addFragment()', function () {
    var dataID = '123';
    var obj = undefined;

    beforeEach(function () {
      obj = { foo: 'bar' };});


    it('adds singular fragments to objects', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'dUAC19z3EgyQ:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})());
      require('RelayFragmentPointer').addFragment(obj, fragment, dataID);

      expect(obj).toEqual({ 
        foo: 'bar', 
        __fragments__: _defineProperty({}, 
        fragment.getConcreteFragmentID(), dataID) });});




    it('adds plural fragments to objects', function () {
      var pluralFragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'H+D3tWIHnSx8:0', kind: 'Fragment', metadata: { plural: true, isAbstract: true }, name: 'RelayFragmentPointerRelayQL', type: 'Node' };})());


      require('RelayFragmentPointer').addFragment(obj, pluralFragment, dataID);

      expect(obj).toEqual({ 
        foo: 'bar', 
        __fragments__: _defineProperty({}, 
        pluralFragment.getConcreteFragmentID(), dataID) });});});});