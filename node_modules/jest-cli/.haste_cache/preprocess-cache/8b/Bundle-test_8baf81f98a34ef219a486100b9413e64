'use strict';









jest.autoMockOff();



var SourceMapGenerator=require('source-map').SourceMapGenerator;


describe('Bundle',function(){
var bundle;

beforeEach(function(){
bundle=new (require('../Bundle'))({sourceMapUrl:'test_url'});
bundle.getSourceMap=jest.genMockFn().mockImpl(function(){
return 'test-source-map';});});



describe('source bundle',function(){
pit('should create a bundle and get the source',function(){
return require('Promise').resolve().then(function(){
return addModule({
bundle:bundle,
code:'transformed foo;',
sourceCode:'source foo',
sourcePath:'foo path'});}).

then(function(){
return addModule({
bundle:bundle,
code:'transformed bar;',
sourceCode:'source bar',
sourcePath:'bar path'});}).

then(function(){
bundle.finalize({});
expect(bundle.getSource({dev:true})).toBe([
'transformed foo;',
'transformed bar;',
'\/\/# sourceMappingURL=test_url'].
join('\n'));});});



pit('should be ok to leave out the source map url',function(){
var otherBundle=new (require('../Bundle'))();
return require('Promise').resolve().then(function(){
return addModule({
bundle:otherBundle,
code:'transformed foo;',
sourceCode:'source foo',
sourcePath:'foo path'});}).

then(function(){
return addModule({
bundle:otherBundle,
code:'transformed bar;',
sourceCode:'source bar',
sourcePath:'bar path'});}).

then(function(){
otherBundle.finalize({});
expect(otherBundle.getSource({dev:true})).toBe([
'transformed foo;',
'transformed bar;'].
join('\n'));});});



pit('should create a bundle and add run module code',function(){
return require('Promise').resolve().then(function(){
return addModule({
bundle:bundle,
code:'transformed foo;',
sourceCode:'source foo',
sourcePath:'foo path'});}).

then(function(){
return addModule({
bundle:bundle,
code:'transformed bar;',
sourceCode:'source bar',
sourcePath:'bar path'});}).

then(function(){
bundle.setMainModuleId('foo');
bundle.finalize({
runBeforeMainModule:['bar'],
runMainModule:true});

expect(bundle.getSource({dev:true})).toBe([
'transformed foo;',
'transformed bar;',
';require("bar");',
';require("foo");',
'\/\/# sourceMappingURL=test_url'].
join('\n'));});});});




describe('sourcemap bundle',function(){
pit('should create sourcemap',function(){
var otherBundle=new (require('../Bundle'))({sourceMapUrl:'test_url'});

return require('Promise').resolve().then(function(){
return addModule({
bundle:otherBundle,
code:[
'transformed foo',
'transformed foo',
'transformed foo'].
join('\n'),
sourceCode:[
'source foo',
'source foo',
'source foo'].
join('\n'),
sourcePath:'foo path'});}).

then(function(){
return addModule({
bundle:otherBundle,
code:[
'transformed bar',
'transformed bar',
'transformed bar'].
join('\n'),
sourceCode:[
'source bar',
'source bar',
'source bar'].
join('\n'),
sourcePath:'bar path'});}).

then(function(){
otherBundle.setMainModuleId('foo');
otherBundle.finalize({
runBeforeMainModule:[],
runMainModule:true});

var sourceMap=otherBundle.getSourceMap({dev:true});
expect(sourceMap).toEqual(genSourceMap(otherBundle.getModules()));});});



pit('should combine sourcemaps',function(){
var otherBundle=new (require('../Bundle'))({sourceMapUrl:'test_url'});

return require('Promise').resolve().then(function(){
return addModule({
bundle:otherBundle,
code:'transformed foo;\n',
sourceCode:'source foo',
map:{name:'sourcemap foo'},
sourcePath:'foo path'});}).

then(function(){
return addModule({
bundle:otherBundle,
code:'transformed bar;\n',
sourceCode:'source bar',
map:{name:'sourcemap bar'},
sourcePath:'bar path'});}).

then(function(){
return addModule({
bundle:otherBundle,
code:'image module;\nimage module;',
virtual:true,
sourceCode:'image module;\nimage module;',
sourcePath:'image.png'});}).

then(function(){
otherBundle.setMainModuleId('foo');
otherBundle.finalize({
runBeforeMainModule:['InitializeJavaScriptAppEngine'],
runMainModule:true});


var sourceMap=otherBundle.getSourceMap({dev:true});
expect(sourceMap).toEqual({
file:'test_url',
version:3,
sections:[
{offset:{line:0,column:0},map:{name:'sourcemap foo'}},
{offset:{line:2,column:0},map:{name:'sourcemap bar'}},
{
offset:{
column:0,
line:4},

map:{
file:'image.png',
mappings:'AAAA;AACA;',
names:[],
sources:['image.png'],
sourcesContent:['image module;\nimage module;'],
version:3}},


{
offset:{
column:0,
line:6},

map:{
file:'require-InitializeJavaScriptAppEngine.js',
mappings:'AAAA;',
names:[],
sources:['require-InitializeJavaScriptAppEngine.js'],
sourcesContent:[';require("InitializeJavaScriptAppEngine");'],
version:3}},


{
offset:{
column:0,
line:7},

map:{
file:'require-foo.js',
mappings:'AAAA;',
names:[],
sources:['require-foo.js'],
sourcesContent:[';require("foo");'],
version:3}}]});});});});








describe('getAssets()',function(){
it('should save and return asset objects',function(){
var p=new (require('../Bundle'))({sourceMapUrl:'test_url'});
var asset1={};
var asset2={};
p.addAsset(asset1);
p.addAsset(asset2);
p.finalize();
expect(p.getAssets()).toEqual([asset1,asset2]);});});



describe('getJSModulePaths()',function(){
pit('should return module paths',function(){
var otherBundle=new (require('../Bundle'))({sourceMapUrl:'test_url'});
return require('Promise').resolve().then(function(){
return addModule({
bundle:otherBundle,
code:'transformed foo;\n',
sourceCode:'source foo',
sourcePath:'foo path'});}).

then(function(){
return addModule({
bundle:otherBundle,
code:'image module;\nimage module;',
virtual:true,
sourceCode:'image module;\nimage module;',
sourcePath:'image.png'});}).

then(function(){
expect(otherBundle.getJSModulePaths()).toEqual(['foo path']);});});});




describe('getEtag()',function(){
it('should return an etag',function(){
var bundle=new (require('../Bundle'))({sourceMapUrl:'test_url'});
bundle.finalize({});
var eTag=require('crypto').createHash('md5').update(bundle.getSource()).digest('hex');
expect(bundle.getEtag()).toEqual(eTag);});});



describe('main module id:',function(){
it('can save a main module ID',function(){
var id='arbitrary module ID';
bundle.setMainModuleId(id);
expect(bundle.getMainModuleId()).toEqual(id);});


it('can serialize and deserialize the module ID',function(){
var id='arbitrary module ID';
bundle.setMainModuleId(id);
bundle.finalize({});

var deserialized=require('../Bundle').fromJSON(bundle.toJSON());

expect(deserialized.getMainModuleId()).toEqual(id);});});});





function genSourceMap(modules){
var sourceMapGen=new SourceMapGenerator({file:'test_url',version:3});
var bundleLineNo=0;
for(var i=0;i<modules.length;i++){
var module=modules[i];
var transformedCode=module.code;
var sourcePath=module.sourcePath;
var sourceCode=module.sourceCode;
var transformedLineCount=0;
var lastCharNewLine=false;
for(var t=0;t<transformedCode.length;t++){
if(t===0||lastCharNewLine){
sourceMapGen.addMapping({
generated:{line:bundleLineNo+1,column:0},
original:{line:transformedLineCount+1,column:0},
source:sourcePath});}


lastCharNewLine=transformedCode[t]==='\n';
if(lastCharNewLine){
transformedLineCount++;
bundleLineNo++;}}


bundleLineNo++;
sourceMapGen.setSourceContent(
sourcePath,
sourceCode);}


return sourceMapGen.toJSON();}


function resolverFor(code,map){
return {
wrapModule:function(){return require('Promise').resolve({code:code,map:map});}};}



function addModule(_ref){var bundle=_ref.bundle;var code=_ref.code;var sourceCode=_ref.sourceCode;var sourcePath=_ref.sourcePath;var map=_ref.map;var virtual=_ref.virtual;
return bundle.addModule(
resolverFor(code,map),
null,
null,
{code:code,sourceCode:sourceCode,sourcePath:sourcePath,map:map,virtual:virtual});}