'use strict';









jest.setMock('worker-farm',function(){return function(){};}).
dontMock('node-haste/node_modules/throat').
dontMock('os').
dontMock('underscore').
dontMock('path').
dontMock('url').
setMock('timers',{setImmediate:function(fn){return setTimeout(fn,0);}}).
setMock('uglify-js').
dontMock('../').
setMock('crypto');








var FileWatcher;

describe('processRequest',function(){
var server;

var options={
projectRoots:['root'],
blacklistRE:null,
cacheVersion:null,
polyfillModuleNames:null};


var makeRequest=function(reqHandler,requrl,reqOptions){return new (require('promise'))(function(resolve){return (
reqHandler(babelHelpers.extends({
url:requrl,headers:{}},reqOptions),
{
headers:{},
getHeader:function(header){return this.headers[header];},
setHeader:function(header,value){this.headers[header]=value;},
end:function(body){
this.body=body;
resolve(this);}},


{next:function(){}}));});};



var invalidatorFunc=jest.genMockFunction();
var watcherFunc=jest.genMockFunction();
var requestHandler;
var triggerFileChange;

beforeEach(function(){
FileWatcher=require('node-haste').FileWatcher;
require('../../Bundler').prototype.bundle=jest.genMockFunction().mockImpl(function(){return (
require('promise').resolve({
getSource:function(){return 'this is the source';},
getSourceMap:function(){return 'this is the source map';},
getEtag:function(){return 'this is an etag';}}));});



FileWatcher.prototype.on=function(eventType,callback){
if(eventType!=='all'){
throw new Error('Can only handle "all" event in watcher.');}

watcherFunc.apply(this,arguments);
triggerFileChange=callback;
return this;};


require('../../Bundler').prototype.invalidateFile=invalidatorFunc;

server=new (require('../../Server'))(options);
requestHandler=server.processRequest.bind(server);});


pit('returns JS bundle source on request of *.bundle',function(){
return makeRequest(
requestHandler,
'mybundle.bundle?runModule=true',
null).
then(function(response){return (
expect(response.body).toEqual('this is the source'));});});



pit('returns JS bundle source on request of *.bundle (compat)',function(){
return makeRequest(
requestHandler,
'mybundle.runModule.bundle').
then(function(response){return (
expect(response.body).toEqual('this is the source'));});});



pit('returns ETag header on request of *.bundle',function(){
return makeRequest(
requestHandler,
'mybundle.bundle?runModule=true').
then(function(response){
expect(response.getHeader('ETag')).toBeDefined();});});



pit('returns 304 on request of *.bundle when if-none-match equals the ETag',function(){
return makeRequest(
requestHandler,
'mybundle.bundle?runModule=true',
{headers:{'if-none-match':'this is an etag'}}).
then(function(response){
expect(response.statusCode).toEqual(304);});});



pit('returns sourcemap on request of *.map',function(){
return makeRequest(
requestHandler,
'mybundle.map?runModule=true').
then(function(response){return (
expect(response.body).toEqual('this is the source map'));});});



pit('works with .ios.js extension',function(){
return makeRequest(
requestHandler,
'index.ios.includeRequire.bundle').
then(function(response){
expect(response.body).toEqual('this is the source');
expect(require('../../Bundler').prototype.bundle).toBeCalledWith({
entryFile:'index.ios.js',
inlineSourceMap:false,
minify:false,
hot:false,
runModule:true,
sourceMapUrl:'index.ios.includeRequire.map',
dev:true,
platform:undefined,
runBeforeMainModule:['InitializeJavaScriptAppEngine'],
unbundle:false,
entryModuleOnly:false});});});




pit('passes in the platform param',function(){
return makeRequest(
requestHandler,
'index.bundle?platform=ios').
then(function(response){
expect(response.body).toEqual('this is the source');
expect(require('../../Bundler').prototype.bundle).toBeCalledWith({
entryFile:'index.js',
inlineSourceMap:false,
minify:false,
hot:false,
runModule:true,
sourceMapUrl:'index.map?platform=ios',
dev:true,
platform:'ios',
runBeforeMainModule:['InitializeJavaScriptAppEngine'],
unbundle:false,
entryModuleOnly:false});});});




pit('watches all files in projectRoot',function(){
return makeRequest(
requestHandler,
'mybundle.bundle?runModule=true').
then(function(){
expect(watcherFunc.mock.calls[0][0]).toEqual('all');
expect(watcherFunc.mock.calls[0][1]).not.toBe(null);});});



describe('file changes',function(){
pit('invalides files in bundle when file is updated',function(){
return makeRequest(
requestHandler,
'mybundle.bundle?runModule=true').
then(function(){
var onFileChange=watcherFunc.mock.calls[0][1];
onFileChange('all','path/file.js',options.projectRoots[0]);
expect(invalidatorFunc.mock.calls[0][0]).toEqual('root/path/file.js');});});



it('does not rebuild the bundles that contain a file when that file is changed',function(){
var bundleFunc=jest.genMockFunction();
bundleFunc.
mockReturnValueOnce(
require('promise').resolve({
getSource:function(){return 'this is the first source';},
getSourceMap:function(){},
getEtag:function(){return function(){return 'this is an etag';};}})).


mockReturnValue(
require('promise').resolve({
getSource:function(){return 'this is the rebuilt source';},
getSourceMap:function(){},
getEtag:function(){return function(){return 'this is an etag';};}}));



require('../../Bundler').prototype.bundle=bundleFunc;

server=new (require('../../Server'))(options);

requestHandler=server.processRequest.bind(server);

makeRequest(requestHandler,'mybundle.bundle?runModule=true').
done(function(response){
expect(response.body).toEqual('this is the first source');
expect(bundleFunc.mock.calls.length).toBe(1);});


jest.runAllTicks();

triggerFileChange('all','path/file.js',options.projectRoots[0]);
jest.runAllTimers();
jest.runAllTicks();

expect(bundleFunc.mock.calls.length).toBe(1);

makeRequest(requestHandler,'mybundle.bundle?runModule=true').
done(function(response){return (
expect(response.body).toEqual('this is the rebuilt source'));});

jest.runAllTicks();});


it('does not rebuild the bundles that contain a file when that file is changed, even when hot loading is enabled',function(){
var bundleFunc=jest.genMockFunction();
bundleFunc.
mockReturnValueOnce(
require('promise').resolve({
getSource:function(){return 'this is the first source';},
getSourceMap:function(){},
getEtag:function(){return function(){return 'this is an etag';};}})).


mockReturnValue(
require('promise').resolve({
getSource:function(){return 'this is the rebuilt source';},
getSourceMap:function(){},
getEtag:function(){return function(){return 'this is an etag';};}}));



require('../../Bundler').prototype.bundle=bundleFunc;

var server=new (require('../../Server'))(options);
server.setHMRFileChangeListener(function(){});

requestHandler=server.processRequest.bind(server);

makeRequest(requestHandler,'mybundle.bundle?runModule=true').
done(function(response){
expect(response.body).toEqual('this is the first source');
expect(bundleFunc.mock.calls.length).toBe(1);});


jest.runAllTicks();

triggerFileChange('all','path/file.js',options.projectRoots[0]);
jest.runAllTimers();
jest.runAllTicks();

expect(bundleFunc.mock.calls.length).toBe(1);
server.setHMRFileChangeListener(null);

makeRequest(requestHandler,'mybundle.bundle?runModule=true').
done(function(response){
expect(response.body).toEqual('this is the rebuilt source');
expect(bundleFunc.mock.calls.length).toBe(2);});

jest.runAllTicks();});});



describe('/onchange endpoint',function(){
var EventEmitter;
var req;
var res;

beforeEach(function(){
EventEmitter=require.requireActual('events').EventEmitter;
req=new EventEmitter();
req.url='/onchange';
res={
writeHead:jest.genMockFn(),
end:jest.genMockFn()};});



it('should hold on to request and inform on change',function(){
server.processRequest(req,res);
triggerFileChange('all','path/file.js',options.projectRoots[0]);
jest.runAllTimers();
expect(res.end).toBeCalledWith(JSON.stringify({changed:true}));});


it('should not inform changes on disconnected clients',function(){
server.processRequest(req,res);
req.emit('close');
jest.runAllTimers();
triggerFileChange('all','path/file.js',options.projectRoots[0]);
jest.runAllTimers();
expect(res.end).not.toBeCalled();});});



describe('/assets endpoint',function(){
it('should serve simple case',function(){
var req={url:'/assets/imgs/a.png'};
var res={end:jest.genMockFn()};

require('../../AssetServer').prototype.get.mockImpl(function(){return require('promise').resolve('i am image');});

server.processRequest(req,res);
jest.runAllTimers();
expect(res.end).toBeCalledWith('i am image');});


it('should parse the platform option',function(){
var req={url:'/assets/imgs/a.png?platform=ios'};
var res={end:jest.genMockFn()};

require('../../AssetServer').prototype.get.mockImpl(function(){return require('promise').resolve('i am image');});

server.processRequest(req,res);
jest.runAllTimers();
expect(require('../../AssetServer').prototype.get).toBeCalledWith('imgs/a.png','ios');
expect(res.end).toBeCalledWith('i am image');});});



describe('buildbundle(options)',function(){
pit('Calls the bundler with the correct args',function(){
return server.buildBundle({
entryFile:'foo file'}).
then(function(){return (
expect(require('../../Bundler').prototype.bundle).toBeCalledWith({
entryFile:'foo file',
inlineSourceMap:false,
minify:false,
hot:false,
runModule:true,
dev:true,
platform:undefined,
runBeforeMainModule:['InitializeJavaScriptAppEngine'],
unbundle:false,
entryModuleOnly:false}));});});});





describe('buildBundleFromUrl(options)',function(){
pit('Calls the bundler with the correct args',function(){
return server.buildBundleFromUrl('/path/to/foo.bundle?dev=false&runModule=false').
then(function(){return (
expect(require('../../Bundler').prototype.bundle).toBeCalledWith({
entryFile:'path/to/foo.js',
inlineSourceMap:false,
minify:false,
hot:false,
runModule:false,
sourceMapUrl:'/path/to/foo.map?dev=false&runModule=false',
dev:false,
platform:undefined,
runBeforeMainModule:['InitializeJavaScriptAppEngine'],
unbundle:false,
entryModuleOnly:false}));});});});});