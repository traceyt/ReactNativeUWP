/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

require('configureForRelayOSS');

jest.dontMock('RelayRenderer');








describe('RelayRenderer.renderArgs', function () {
  var MockComponent = undefined;
  var MockContainer = undefined;

  var container = undefined;
  var queryConfig = undefined;
  var render = undefined;

  beforeEach(function () {
    jest.resetModuleRegistry();

    MockComponent = require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createClass({ displayName: 'MockComponent', render: function () {return require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createElement('div', null);} });
    MockContainer = require('Relay').createContainer(MockComponent, { 
      fragments: {} });


    container = document.createElement('div');
    queryConfig = require('RelayQueryConfig').genMockInstance();

    render = jest.genMockFunction();
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react-dom').render(
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createElement(require('RelayRenderer'), { 
      Container: MockContainer, 
      queryConfig: queryConfig, 
      render: render }), 

    container);

    jasmine.addMatchers({ 
      toRenderWithArgs: function () {
        return { 
          compare: function (actual, expected) {
            // Assume that if `forceFetch` requests exist, they were last.
            var requests = require('RelayStore').forceFetch.mock.requests.length > 0 ? 
            require('RelayStore').forceFetch.mock.requests : 
            require('RelayStore').primeCache.mock.requests;
            actual(requests[requests.length - 1]);
            var renders = render.mock.calls;
            var renderArgs = renders[renders.length - 1][0];
            return { 
              pass: Object.keys(expected).every(function (argName) {
                expect(renderArgs[argName]).toEqual(expected[argName]);
                return true;}) };} };} });});








  it('has default values before request is sent', function () {
    expect(function () {
      // Nothing.
    }).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: null, 
      stale: false });});



  it('has no `props` until request is resolved', function () {
    expect(function (request) {return request.block();}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: null, 
      stale: false });

    expect(function (request) {return request.resolve();}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: {}, 
      stale: false });});



  it('is not `done` until request succeeds', function () {
    expect(function (request) {return request.block();}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: null, 
      stale: false });

    expect(function (request) {return request.succeed();}).toRenderWithArgs({ 
      done: true, 
      error: null, 
      props: {}, 
      stale: false });});



  it('has `error` when request fails before request is sent', function () {
    var error = new Error('Expected error.');
    expect(function (request) {return request.fail(error);}).toRenderWithArgs({ 
      done: false, 
      error: error, 
      props: null, 
      stale: false });});



  it('has `error` when request fails after request is sent', function () {
    var error = new Error('Expected error.');
    expect(function (request) {return request.block();}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: null, 
      stale: false });

    expect(function (request) {return request.fail(error);}).toRenderWithArgs({ 
      done: false, 
      error: error, 
      props: null, 
      stale: false });});



  it('has `error` and `props` when request is resolved and fails', function () {
    var error = new Error('Expected error.');
    expect(function (request) {return request.resolve();}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: {}, 
      stale: false });

    expect(function (request) {return request.fail(error);}).toRenderWithArgs({ 
      done: false, 
      error: error, 
      props: {}, 
      stale: false });});



  it('is `stale` if force fetching when data is fulfillable', function () {
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react-dom').render(
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createElement(require('RelayRenderer'), { 
      Container: MockContainer, 
      queryConfig: queryConfig, 
      forceFetch: true, 
      render: render }), 

    container);

    expect(function (request) {return request.resolve({ stale: true });}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: {}, 
      stale: true });

    expect(function (request) {return request.resolve({ stale: false });}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: {}, 
      stale: false });

    expect(function (request) {return request.succeed();}).toRenderWithArgs({ 
      done: true, 
      error: null, 
      props: {}, 
      stale: false });});



  it('has a `retry` function that retries the request', function () {
    var error = new Error('Expected error.');
    expect(function (request) {return request.fail(error);}).toRenderWithArgs({ error: error });var 

    retry = render.mock.calls[1][0].retry;
    expect(typeof retry).toBe('function');
    expect(require('RelayStore').primeCache.mock.calls.length).toBe(1);
    retry();
    expect(require('RelayStore').primeCache.mock.calls.length).toBe(2);});


  it('has a `retry` function that throws if called without failure', function () {
    expect(function (request) {return request.block();}).toRenderWithArgs({ error: null });var 

    retry = render.mock.calls[1][0].retry;
    expect(typeof retry).toBe('function');
    expect(function () {return retry();}).toThrowError(
    'RelayRenderer: You tried to call `retry`, but the last request did ' + 
    'not fail. You can only call this when the last request has failed.');});



  it('passes query config variables as props', function () {
    var MockQueryConfig = require('RelayQueryConfig').genMock();
    queryConfig = new MockQueryConfig({ foo: 123, bar: 456 });

    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react-dom').render(
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/react').createElement(require('RelayRenderer'), { 
      Container: MockContainer, 
      queryConfig: queryConfig, 
      render: render }), 

    container);

    expect(function (request) {return request.resolve();}).toRenderWithArgs({ 
      done: false, 
      error: null, 
      props: { foo: 123, bar: 456 }, 
      stale: false });});});