/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';var _slicedToArray = (function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i['return']) _i['return']();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError('Invalid attempt to destructure non-iterable instance');}};})();function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.
dontMock('GraphQLRange').
dontMock('GraphQLSegment');











describe('RelayStoreData', function () {
  var cacheManager;
  var storeData;var 

  getNode = require('RelayTestUtils').getNode;
  var CLIENT_MUTATION_ID, HAS_NEXT_PAGE, HAS_PREV_PAGE, PAGE_INFO;

  function getPathToRecord(dataID) {
    return storeData.getRecordStore().getPathToRecord(dataID);}


  function getRangeForRecord(dataID) {
    var nodeData = storeData.getNodeData();
    expect(Object.keys(nodeData)).toContain(dataID);
    return nodeData[dataID].__range__;}


  beforeEach(function () {
    jest.resetModuleRegistry();


    CLIENT_MUTATION_ID = require('RelayConnectionInterface').CLIENT_MUTATION_ID;
    HAS_NEXT_PAGE = require('RelayConnectionInterface').HAS_NEXT_PAGE;
    HAS_PREV_PAGE = require('RelayConnectionInterface').HAS_PREV_PAGE;
    PAGE_INFO = require('RelayConnectionInterface').PAGE_INFO;


    cacheManager = require('RelayMockCacheManager').genCacheManager();
    storeData = new (require('RelayStoreData'))();
    storeData.injectCacheManager(cacheManager);

    jasmine.addMatchers({ 
      toContainCalledMethods: function () {return { 
          compare: function (actual, calls) {
            var message = undefined;
            var pass = Object.keys(calls).every(function (methodName) {
              var expected = calls[methodName];
              var value = actual[methodName].mock.calls.length;
              var pass = expected === value;

              var expTimes = expected + ' time' + (expected === 1 ? '' : 's');
              var actTimes = value + ' time' + (value === 1 ? '' : 's');
              var not = pass ? 'not ' : '';
              message = 'Expected `' + methodName + '` ' + not + 'to be called ' + 
              expTimes + ', was called ' + actTimes + '.';
              return pass;});

            return { pass: pass, message: message };} };}, 


      toBeCalledWithNodeFields: function (util, customEqualityTesters) {return { 
          compare: function (actual, nodeFields) {
            var message = undefined;
            var pass = Object.keys(nodeFields).every(
            function (expectedID) {return Object.keys(nodeFields[expectedID]).every(
              function (expectedFieldName) {
                message = 
                'Expected function to be called with (' + 
                expectedID + ', ' + 
                expectedFieldName + ', ' + 
                nodeFields[expectedID][expectedFieldName] + ').';
                return actual.mock.calls.some(
                function (_ref) {var _ref2 = _slicedToArray(_ref, 3);var actualID = _ref2[0];var actualFieldName = _ref2[1];var actualFieldValue = _ref2[2];return (
                    actualID === expectedID && 
                    actualFieldName === expectedFieldName && 
                    util.equals(
                    actualFieldValue, 
                    nodeFields[expectedID][actualFieldName], 
                    customEqualityTesters));});});});






            return { pass: pass, message: message };} };} });});





  it('caches node metadata', function () {
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());
    var response = { 
      node: { 
        __typename: 'User', 
        id: '123' } };


    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 3, 
      writeRootCall: 0 });

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        __dataID__: '123', 
        __typename: 'User', 
        id: '123' } });});




  it('caches custom root calls', function () {
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'yuzhi' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayStoreData_cacheManager', type: 'Actor' };})());
    var response = { 
      username: { 
        __typename: 'User', 
        id: '123' } };


    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 3, 
      writeRootCall: 1 });

    expect(queryWriter.writeRootCall).toBeCalledWith(
    'username', 
    'yuzhi', 
    '123');

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        __dataID__: '123', 
        __typename: 'User', 
        id: '123' } });});




  it('caches nodes with client IDs', function () {
    var query = getNode((function () {return { children: [{ fieldName: 'isFbEmployee', kind: 'Field', metadata: {}, type: 'Boolean' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayStoreData_cacheManager', type: 'Viewer' };})());
    var response = { 
      viewer: { 
        __typename: 'User', 
        isFbEmployee: true } };


    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 2, 
      writeRootCall: 1 });

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      'client:1': { 
        __dataID__: 'client:1', 
        isFbEmployee: true } });});




  it('caches linked records', function () {
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'url', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'hometown', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Page' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());










    var response = { 
      node: { 
        __typename: 'User', 
        id: '123', 
        hometown: { 
          __typename: 'Page', 
          id: '456', 
          url: 'http://...' } } };



    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 7, 
      writeRootCall: 0 });

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        __dataID__: '123', 
        id: '123', 
        hometown: { __dataID__: '456' } }, 

      '456': { 
        __dataID__: '456', 
        id: '456', 
        url: 'http://...' } });});




  it('caches plural fields', function () {
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'service', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'screennames', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'Screenname' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());









    var response = { 
      node: { 
        __typename: 'User', 
        id: '123', 
        screennames: [
        { service: 'GTALK' }, 
        { service: 'TWITTER' }] } };



    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(getPathToRecord('client:1')).toEqual(getPathToRecord('client:2'));
    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 8, 
      writeRootCall: 0 });

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        __dataID__: '123', 
        __typename: 'User', 
        id: '123', 
        screennames: [
        { __dataID__: 'client:1' }, 
        { __dataID__: 'client:2' }] }, 


      'client:1': { 
        __dataID__: 'client:1', 
        service: 'GTALK' }, 

      'client:2': { 
        __dataID__: 'client:2', 
        service: 'TWITTER' } });});




  it('caches connection fields', function () {var _PAGE_INFO;
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '2' } }], children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasNextPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());


















    var response = require('transformRelayQueryPayload')(query, { 
      node: { 
        __typename: 'User', 
        id: '123', 
        friends: _defineProperty({ 
          edges: [
          { 
            node: { 
              __typename: 'User', 
              id: '1' }, 

            cursor: '1' }, 

          { 
            node: { 
              __typename: 'User', 
              id: '2' }, 

            cursor: '2' }] }, 


        PAGE_INFO, (_PAGE_INFO = {}, _defineProperty(_PAGE_INFO, 
        HAS_PREV_PAGE, false), _defineProperty(_PAGE_INFO, 
        HAS_NEXT_PAGE, true), _PAGE_INFO)) } });




    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 19, 
      writeRootCall: 0 });

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        __dataID__: '123', 
        id: '123', 
        friends: { __dataID__: 'client:1' } }, 

      'client:1': { 
        __dataID__: 'client:1', 
        __filterCalls__: [], 
        __forceIndex__: 0, 
        __range__: getRangeForRecord('client:1') }, 

      'client:client:1:1': { 
        __dataID__: 'client:client:1:1', 
        node: { __dataID__: '1' }, 
        cursor: '1' }, 

      '1': { 
        __dataID__: '1', 
        id: '1' }, 

      'client:client:1:2': { 
        __dataID__: 'client:client:1:2', 
        node: { __dataID__: '2' }, 
        cursor: '2' }, 

      '2': { 
        __dataID__: '2', 
        id: '2' } });});




  it('caches connection fields with no edges', function () {var _PAGE_INFO2;
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '2' } }], children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasNextPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());


















    var response = require('transformRelayQueryPayload')(query, { 
      node: { 
        __typename: 'User', 
        id: '123', 
        friends: _defineProperty({ 
          edges: [] }, 
        PAGE_INFO, (_PAGE_INFO2 = {}, _defineProperty(_PAGE_INFO2, 
        HAS_PREV_PAGE, false), _defineProperty(_PAGE_INFO2, 
        HAS_NEXT_PAGE, true), _PAGE_INFO2)) } });




    storeData.handleQueryPayload(query, response);var 
    queryWriter = cacheManager.mocks.queryWriter;

    expect(queryWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 9, 
      writeRootCall: 0 });

    expect(queryWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        __dataID__: '123', 
        id: '123', 
        friends: { __dataID__: 'client:1' } }, 

      'client:1': { 
        __dataID__: 'client:1', 
        __filterCalls__: [], 
        __forceIndex__: 0, 
        __range__: getRangeForRecord('client:1') } });});




  it('caches simple mutations', function () {var _payload;
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());
    var response = { 
      node: { 
        __typename: 'User', 
        id: '123', 
        doesViewerLike: false } };


    storeData.handleQueryPayload(query, response);var 
    mutationWriter = cacheManager.mocks.mutationWriter;

    var mutationQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'feedbackLike', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], kind: 'Mutation', metadata: { inputType: 'FeedbackLikeInput' }, name: 'RelayStoreData_cacheManager', responseType: 'FeedbackLikeResponsePayload' };})());










    var payload = (_payload = {}, _defineProperty(_payload, 
    CLIENT_MUTATION_ID, 'abc'), _defineProperty(_payload, 'feedback', 
    { 
      id: '123', 
      doesViewerLike: true }), _payload);


    storeData.handleUpdatePayload(
    mutationQuery, 
    payload, 
    { configs: [], isOptimisticUpdate: false });


    expect(mutationWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 2, // both scalar fields are updated
      writeRootCall: 0 });

    expect(mutationWriter.writeField).toBeCalledWithNodeFields({ 
      '123': { 
        doesViewerLike: true } });});




  it('caches mutation that inserts an edge', function () {var _PAGE_INFO3, _payload2;
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }, { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'CommentsEdge' }, { children: [{ fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasNextPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'comments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'CommentsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());



















    var response = require('transformRelayQueryPayload')(query, { 
      node: { 
        __typename: 'Story', 
        id: '123', 
        comments: _defineProperty({ 
          count: 2, 
          edges: [
          { 
            node: { 
              id: '1' }, 

            cursor: '1' }] }, 


        PAGE_INFO, (_PAGE_INFO3 = {}, _defineProperty(_PAGE_INFO3, 
        HAS_PREV_PAGE, false), _defineProperty(_PAGE_INFO3, 
        HAS_NEXT_PAGE, true), _PAGE_INFO3)) } });




    storeData.handleQueryPayload(query, response);var 
    mutationWriter = cacheManager.mocks.mutationWriter;

    var configs = [{ 
      type: require('RelayMutationType').RANGE_ADD, 
      connectionName: 'comments', 
      edgeName: 'feedbackCommentEdge', 
      rangeBehaviors: { '': require('GraphQLMutatorConstants').PREPEND } }];


    var mutationQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'comments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'CommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'source', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], fieldName: 'feedbackCommentEdge', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'CommentsEdge' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'RelayStoreData_cacheManager', responseType: 'CommentCreateResponsePayload' };})());





















    var payload = (_payload2 = {}, _defineProperty(_payload2, 
    CLIENT_MUTATION_ID, 'abc'), _defineProperty(_payload2, 'feedback', 
    { 
      comments: { 
        count: 3 }, 

      id: '123' }), _defineProperty(_payload2, 'feedbackCommentEdge', 

    { 
      __typename: 'User', 
      node: { 
        id: '2' }, 

      cursor: '2', 
      source: { 
        id: '123' } }), _payload2);



    storeData.handleUpdatePayload(
    mutationQuery, 
    payload, 
    { configs: configs, isOptimisticUpdate: false });


    expect(mutationWriter).toContainCalledMethods({ 
      writeNode: 0, 
      writeField: 11, 
      writeRootCall: 0 });

    expect(mutationWriter.writeField).toBeCalledWithNodeFields({ 
      'client:1': { 
        __range__: getRangeForRecord('client:1'), 
        count: 3 }, 

      'client:client:1:2': { 
        __dataID__: 'client:client:1:2', 
        node: { __dataID__: '2' }, 
        cursor: '2', 
        source: { __dataID__: '123' } }, 

      '2': { 
        __dataID__: '2', 
        id: '2' } });});




  it('caches mutation that deletes an edge', function () {var _PAGE_INFO4, _payload3;
    var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }, { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'CommentsEdge' }, { children: [{ fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasNextPage', kind: 'Field', metadata: { isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'comments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'CommentsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData_cacheManager', type: 'Node' };})());



















    var response = require('transformRelayQueryPayload')(query, { 
      node: { 
        __typename: 'Story', 
        id: '123', 
        comments: _defineProperty({ 
          count: 2, 
          edges: [
          { 
            node: { 
              id: '1' }, 

            cursor: '1' }] }, 


        PAGE_INFO, (_PAGE_INFO4 = {}, _defineProperty(_PAGE_INFO4, 
        HAS_PREV_PAGE, false), _defineProperty(_PAGE_INFO4, 
        HAS_NEXT_PAGE, true), _PAGE_INFO4)) } });




    storeData.handleQueryPayload(query, response);var 
    mutationWriter = cacheManager.mocks.mutationWriter;

    var configs = [{ 
      type: require('RelayMutationType').RANGE_DELETE, 
      pathToConnection: ['feedback', 'comments'], 
      deletedIDFieldName: 'deletedCommentId' }];


    var mutationQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentDelete', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { fieldName: 'deletedCommentId', kind: 'Field', metadata: {}, type: 'ID' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'comments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'CommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], kind: 'Mutation', metadata: { inputType: 'CommentDeleteInput' }, name: 'RelayStoreData_cacheManager', responseType: 'CommentDeleteResponsePayload' };})());













    var payload = (_payload3 = {}, _defineProperty(_payload3, 
    CLIENT_MUTATION_ID, 'abc'), _defineProperty(_payload3, 'deletedCommentId', 
    '1'), _defineProperty(_payload3, 'feedback', 
    { 
      id: '123', 
      comments: { 
        count: 1 } }), _payload3);



    storeData.handleUpdatePayload(
    mutationQuery, 
    payload, 
    { configs: configs, isOptimisticUpdate: false });


    expect(mutationWriter).toContainCalledMethods({ 
      writeNode: 1, 
      writeField: 4, 
      writeRootCall: 0 });

    expect(mutationWriter.writeField).toBeCalledWithNodeFields({ 
      'client:1': { 
        __range__: getRangeForRecord('client:1'), 
        count: 1 } });});




  it('clears cache manager', function () {
    storeData.clearCacheManager();
    expect(storeData.hasCacheManager()).toBe(false);});});