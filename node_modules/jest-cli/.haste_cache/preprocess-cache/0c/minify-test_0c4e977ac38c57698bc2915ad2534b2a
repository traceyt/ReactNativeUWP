'use strict';









jest.autoMockOff();

var uglify={
minify:jest.genMockFunction().mockImplementation(function(code){
return {
code:code.replace(/(^|\W)\s+/g,'$1'),
map:{}};})};



jest.setMock('uglify-js',uglify);var _jasmine=


jasmine;var objectContaining=_jasmine.objectContaining;

describe('Minification:',function(){
var filename='/arbitrary/file.js';
var code='arbitrary(code)';
var map=undefined;

beforeEach(function(){
uglify.minify.mockClear();
uglify.minify.mockReturnValue({code:'',map:'{}'});
map={version:3,sources:['?'],mappings:''};});


it('passes file name, code, and source map to `uglify`',function(){
require('../minify')(filename,code,map);
expect(uglify.minify).toBeCalledWith(code,objectContaining({
fromString:true,
inSourceMap:map,
outSourceMap:true}));});



it('returns the code provided by uglify',function(){
uglify.minify.mockReturnValue({code:code,map:'{}'});
var result=require('../minify')('','',{});
expect(result.code).toBe(code);});


it('parses the source map object provided by uglify and sets the sources property',function(){
uglify.minify.mockReturnValue({map:JSON.stringify(map),code:''});
var result=require('../minify')(filename,'',{});
expect(result.map).toEqual(babelHelpers.extends({},map,{sources:[filename]}));});});