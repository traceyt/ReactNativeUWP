'use strict';









jest.
dontMock('../../lib/ModuleTransport').
dontMock('../');

var fs={writeFileSync:jest.genMockFn()};
var temp={path:function(){return '/arbitrary/path';}};
var workerFarm=jest.genMockFn();
jest.setMock('fs',fs);
jest.setMock('temp',temp);
jest.setMock('worker-farm',workerFarm);var _jasmine=



jasmine;var any=_jasmine.any;

describe('Transformer',function(){
var options=undefined,workers=undefined,Cache=undefined;
var fileName='/an/arbitrary/file.js';
var transformModulePath=__filename;

beforeEach(function(){
Cache=jest.genMockFn();
Cache.prototype.get=jest.genMockFn().mockImpl(function(a,b,c){return c();});

fs.writeFileSync.mockClear();
options={transformModulePath:transformModulePath};
workerFarm.mockClear();
workerFarm.mockImpl(function(opts,path,methods){
var api=workers={};
methods.forEach(function(method){return api[method]=jest.genMockFn();});
return api;});});



it('passes transform module path, file path, source code, and options to the worker farm when transforming',function(){
var transformOptions={arbitrary:'options'};
var code='arbitrary(code)';
new (require('../'))(options).transformFile(fileName,code,transformOptions);
expect(workers.transformAndExtractDependencies).toBeCalledWith(
transformModulePath,
fileName,
code,
transformOptions,
any(Function));});



pit('passes the data produced by the worker back',function(){
var transformer=new (require('../'))(options);
var result={code:'transformed',map:'sourceMap'};
workers.transformAndExtractDependencies.mockImpl(function(transformPath,filename,code,options,callback){
callback(null,result);});


return transformer.transformFile(fileName,'',{}).
then(function(data){return expect(data).toBe(result);});});


pit('should add file info to parse errors',function(){
var transformer=new (require('../'))(options);
var message='message';
var snippet='snippet';

workers.transformAndExtractDependencies.mockImpl(function(transformPath,filename,code,options,callback){
var babelError=new SyntaxError(message);
babelError.type='SyntaxError';
babelError.description=message;
babelError.loc={
line:2,
column:15};

babelError.codeFrame=snippet;
callback(babelError);});


return transformer.transformFile(fileName,'',{}).
catch(function(error){
expect(error.type).toEqual('TransformError');
expect(error.message).toBe('SyntaxError '+message);
expect(error.lineNumber).toBe(2);
expect(error.column).toBe(15);
expect(error.filename).toBe(fileName);
expect(error.description).toBe(message);
expect(error.snippet).toBe(snippet);});});});