/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

jest.dontMock('RelayProfiler');



describe('RelayProfiler', function () {
  var DEV = __DEV__;

  var mockMethod;
  var mockMethod2;
  var mockObject;
  var mockDisableDEV = function () {
    window.__DEV__ = 0;};


  beforeEach(function () {
    jest.resetModuleRegistry();

    mockMethod = jest.genMockFunction();
    mockMethod2 = jest.genMockFunction();
    mockObject = { 
      mockMethod: require('RelayProfiler').instrument('mock', mockMethod), 
      mockMethod2: require('RelayProfiler').instrument('mock2', mockMethod2) };});



  afterEach(function () {
    window.__DEV__ = DEV;});


  describe('instance', function () {
    it('preserves context, arguments, and return value', function () {
      var expectedArgument = {};
      var expectedContext = mockObject;
      var expectedReturnValue = {};

      mockMethod.mockImplementation(function (actualArgument) {
        expect(actualArgument).toBe(expectedArgument);
        expect(this).toBe(expectedContext);
        return expectedReturnValue;});


      var actualReturnValue = mockObject.mockMethod(expectedArgument);

      expect(actualReturnValue).toBe(expectedReturnValue);});


    it('invokes attached handlers', function () {
      var actualOrdering = [];

      mockMethod.mockImplementation(function () {
        actualOrdering.push('mockMethod');});


      mockObject.mockMethod.attachHandler(function (name, callback) {
        expect(name).toBe('mock');
        actualOrdering.push('beforeCallback');
        callback();
        actualOrdering.push('afterCallback');});


      mockObject.mockMethod();

      expect(actualOrdering).toEqual([
      'beforeCallback', 
      'mockMethod', 
      'afterCallback']);});



    it('invokes nested attached handlers', function () {
      var actualOrdering = [];

      mockMethod.mockImplementation(function () {
        actualOrdering.push('0: mockMethod');});


      mockObject.mockMethod.attachHandler(function (name, callback) {
        expect(name).toBe('mock');
        actualOrdering.push('1: beforeCallback');
        callback();
        actualOrdering.push('1: afterCallback');});


      mockObject.mockMethod.attachHandler(function (name, callback) {
        expect(name).toBe('mock');
        actualOrdering.push('2: beforeCallback');
        callback();
        actualOrdering.push('2: afterCallback');});


      mockObject.mockMethod();

      expect(actualOrdering).toEqual([
      '2: beforeCallback', 
      '1: beforeCallback', 
      '0: mockMethod', 
      '1: afterCallback', 
      '2: afterCallback']);});



    it('does not invoke detached handlers', function () {
      var mockHandler = jest.genMockFunction().
      mockImplementation(function (name, callback) {
        callback();});


      mockObject.mockMethod.attachHandler(mockHandler);
      mockObject.mockMethod.detachHandler(mockHandler);
      mockObject.mockMethod();

      expect(mockHandler).not.toBeCalled();});


    it('throws if callback is not invoked by handler', function () {
      mockObject.mockMethod.attachHandler(jest.genMockFunction());

      expect(function () {
        mockObject.mockMethod();}).
      toThrowError(
      'RelayProfiler: Handler did not invoke original function.');});



    it('ignores names starting with "@" unless __DEV__', function () {
      mockDisableDEV();

      mockMethod = jest.genMockFunction();
      mockObject = { mockMethod: require('RelayProfiler').instrument('@mock', mockMethod) };

      expect(mockObject.mockMethod).toBe(mockMethod);
      expect(function () {
        mockObject.mockMethod.attachHandler();
        mockObject.mockMethod.detachHandler();}).
      not.toThrow();});


    it('instruments names without "@" when not in __DEV__', function () {
      mockDisableDEV();

      mockMethod = jest.genMockFunction();
      mockObject = { mockMethod: require('RelayProfiler').instrument('mock', mockMethod) };

      expect(mockObject.mockMethod).not.toBe(mockMethod);});});



  describe('aggregate', function () {
    it('invokes aggregate handlers first', function () {
      var actualOrdering = [];

      mockMethod.mockImplementation(function () {
        actualOrdering.push('0: mockMethod');});


      mockObject.mockMethod.attachHandler(function (name, callback) {
        actualOrdering.push('1: beforeCallback');
        callback();
        actualOrdering.push('1: afterCallback');});


      require('RelayProfiler').attachAggregateHandler('mock', function (name, callback) {
        expect(name).toBe('mock');
        actualOrdering.push('3: beforeCallback (aggregate)');
        callback();
        actualOrdering.push('3: afterCallback (aggregate)');});


      require('RelayProfiler').attachAggregateHandler('*', function (name, callback) {
        actualOrdering.push('5: beforeCallback (aggregate *): ' + name);
        callback();
        actualOrdering.push('5: afterCallback (aggregate *): ' + name);});


      require('RelayProfiler').attachAggregateHandler('mock', function (name, callback) {
        expect(name).toBe('mock');
        actualOrdering.push('4: beforeCallback (aggregate)');
        callback();
        actualOrdering.push('4: afterCallback (aggregate)');});


      mockObject.mockMethod.attachHandler(function (name, callback) {
        actualOrdering.push('2: beforeCallback');
        callback();
        actualOrdering.push('2: afterCallback');});


      mockObject.mockMethod();
      mockObject.mockMethod2();

      expect(actualOrdering).toEqual([
      '5: beforeCallback (aggregate *): mock', 
      '4: beforeCallback (aggregate)', 
      '3: beforeCallback (aggregate)', 
      '2: beforeCallback', 
      '1: beforeCallback', 
      '0: mockMethod', 
      '1: afterCallback', 
      '2: afterCallback', 
      '3: afterCallback (aggregate)', 
      '4: afterCallback (aggregate)', 
      '5: afterCallback (aggregate *): mock', 
      '5: beforeCallback (aggregate *): mock2', 
      '5: afterCallback (aggregate *): mock2']);});



    it('aggregates methods instrumented after being attached', function () {
      var mockHandler = jest.genMockFunction().
      mockImplementation(function (name, callback) {
        callback();});

      require('RelayProfiler').attachAggregateHandler('mockFuture', mockHandler);

      var mockFutureMethod = require('RelayProfiler').instrument('mockFuture', mockMethod);

      expect(mockHandler).not.toBeCalled();
      mockFutureMethod();
      expect(mockHandler).toBeCalled();});


    it('detaches aggregate handlers', function () {
      var mockHandler = jest.genMockFunction().
      mockImplementation(function (name, callback) {
        callback();});


      require('RelayProfiler').attachAggregateHandler('mock', mockHandler);
      require('RelayProfiler').detachAggregateHandler('mock', mockHandler);
      mockObject.mockMethod();

      expect(mockHandler).not.toBeCalled();});});



  describe('profile', function () {
    it('invokes attached profile handlers', function () {
      var actualOrdering = [];

      require('RelayProfiler').attachProfileHandler('mockBehavior', function (name) {
        expect(name).toBe('mockBehavior');
        actualOrdering.push('1: beforeEnd');
        return function () {
          actualOrdering.push('1: afterEnd');};});



      require('RelayProfiler').attachProfileHandler('mockBehavior', function (name) {
        expect(name).toBe('mockBehavior');
        actualOrdering.push('2: beforeEnd');
        return function () {
          actualOrdering.push('2: afterEnd');};});



      var profiler = require('RelayProfiler').profile('mockBehavior');

      expect(actualOrdering).toEqual([
      '2: beforeEnd', 
      '1: beforeEnd']);


      profiler.stop();

      expect(actualOrdering).toEqual([
      '2: beforeEnd', 
      '1: beforeEnd', 
      '1: afterEnd', 
      '2: afterEnd']);});



    it('does not invoke detached profile handlers', function () {
      var mockStop = jest.genMockFunction();
      var mockStart = jest.genMockFunction().mockReturnValue(mockStop);

      require('RelayProfiler').attachProfileHandler('mockBehavior', mockStart);
      require('RelayProfiler').detachProfileHandler('mockBehavior', mockStart);
      require('RelayProfiler').profile('mockBehavior');

      expect(mockStop).not.toBeCalled();
      expect(mockStart).not.toBeCalled();});


    it('passes state to each profile handler', function () {
      var mockStop = jest.genMockFunction();
      var mockStart = jest.genMockFunction().mockReturnValue(mockStop);
      var state = {};

      require('RelayProfiler').attachProfileHandler('mockBehavior', mockStart);
      var profiler = require('RelayProfiler').profile('mockBehavior', state);
      profiler.stop();

      expect(mockStart).toBeCalledWith('mockBehavior', state);
      expect(mockStop).toBeCalled();
      expect(mockStop.mock.calls[0].length).toBe(0);});});});