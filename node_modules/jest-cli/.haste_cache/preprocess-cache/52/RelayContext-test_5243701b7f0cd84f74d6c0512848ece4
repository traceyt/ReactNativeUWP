/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';

jest.dontMock('RelayContext');

require('configureForRelayOSS');












describe('RelayContext', function () {
  var relayContext;
  var filter;
  var dataIDs;
  var queries;
  var callback;
  var recordWriter;
  var queryRunner;var 

  getNode = require('RelayTestUtils').getNode;

  beforeEach(function () {
    jest.resetModuleRegistry();

    relayContext = new (require('RelayContext'))();

    filter = function () {return true;};
    dataIDs = ['feedback_id', 'likers_id'];
    queries = {};
    callback = jest.genMockFunction();
    queryRunner = relayContext.getStoreData().getQueryRunner();
    recordWriter = relayContext.getStoreData().getRecordWriter();});


  describe('primeCache', function () {
    it('invokes `GraphQLQueryRunner#run`', function () {
      relayContext.primeCache(queries, callback);

      expect(queryRunner.run).toBeCalled();
      expect(queryRunner.run.mock.calls[0][0]).toBe(queries);
      expect(queryRunner.run.mock.calls[0][1]).toBe(callback);});});



  describe('forceFetch', function () {
    it('invokes `GraphQLQueryRunner#forceFetch`', function () {
      relayContext.forceFetch(queries, callback);

      expect(queryRunner.forceFetch).toBeCalled();
      expect(queryRunner.forceFetch.mock.calls[0][0]).toBe(queries);
      expect(queryRunner.forceFetch.mock.calls[0][1]).toBe(callback);});});



  describe('read', function () {
    it('invokes `readRelayQueryData`', function () {
      relayContext.read(queries, dataIDs[0]);
      expect(require('readRelayQueryData')).toBeCalled();
      expect(require('readRelayQueryData').mock.calls[0][1]).toEqual(queries);
      expect(require('readRelayQueryData').mock.calls[0][2]).toBe(dataIDs[0]);
      expect(require('readRelayQueryData').mock.calls[0][3]).toBeUndefined();});


    it('invokes `readRelayQueryData` with a filter', function () {
      relayContext.read(queries, dataIDs[0], filter);
      expect(require('readRelayQueryData')).toBeCalled();
      expect(require('readRelayQueryData').mock.calls[0][3]).toBe(filter);});});



  describe('readAll', function () {
    it('invokes `readRelayQueryData`', function () {
      relayContext.readAll(queries, dataIDs);
      expect(require('readRelayQueryData').mock.calls.length).toBe(dataIDs.length);
      expect(require('readRelayQueryData').mock.calls.map(function (call) {return call[2];})).toEqual(
      dataIDs);});



    it('invokes `readRelayQueryData` with a filter', function () {
      relayContext.readAll(queries, dataIDs, filter);
      expect(require('readRelayQueryData').mock.calls.length).toBe(dataIDs.length);
      require('readRelayQueryData').mock.calls.forEach(function (call) {
        expect(call[3]).toBe(filter);});});});




  describe('readQuery', function () {
    it('accepts a query with no arguments', function () {
      recordWriter.putDataID('viewer', null, 'client:1');
      relayContext.readQuery(getNode((function () {return { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'RelayContext', type: 'Viewer' };})()));
      expect(require('readRelayQueryData').mock.calls.length).toBe(1);
      expect(require('readRelayQueryData').mock.calls[0][2]).toBe('client:1');});


    it('accepts a query with arguments', function () {
      relayContext.readQuery(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'ids', value: [{ kind: 'CallValue', callValue: '123' }, { kind: 'CallValue', callValue: '456' }] }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'nodes', kind: 'Query', metadata: { isPlural: true, isAbstract: true, identifyingArgName: 'ids' }, name: 'RelayContext', type: 'Node' };})()));






      expect(require('readRelayQueryData').mock.calls.length).toBe(2);
      expect(require('readRelayQueryData').mock.calls[0][2]).toBe('123');
      expect(require('readRelayQueryData').mock.calls[1][2]).toBe('456');});


    it('accepts a query with unrecognized arguments', function () {
      var result = relayContext.readQuery(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'name', value: { kind: 'CallValue', callValue: 'foo' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'username', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'name' }, name: 'RelayContext', type: 'Actor' };})()));






      expect(require('readRelayQueryData').mock.calls.length).toBe(0);
      expect(result).toEqual([undefined]);});});



  describe('observe', function () {
    it('instantiates RelayQueryResultObservable', function () {
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], id: 'LJjRXhXr1A1g:0', kind: 'Fragment', metadata: { isAbstract: true }, name: 'RelayContextRelayQL', type: 'Node' };})());




      require('GraphQLStoreQueryResolver').mockDefaultResolveImplementation(
      function (pointerFragment, dataID) {
        expect(pointerFragment).toBe(fragment);
        expect(dataID).toBe('123');
        return { 
          __dataID__: '123', 
          id: '123' };});




      var observer = relayContext.observe(fragment, '123');
      var onNext = jest.genMockFunction();
      expect(observer instanceof require('RelayQueryResultObservable')).toBe(true);
      observer.subscribe({ onNext: onNext });
      expect(onNext).toBeCalledWith({ 
        __dataID__: '123', 
        id: '123' });});});




  describe('update functions', function () {
    var mockMutation, createTransactionMock, mockTransaction, mockCallbacks;

    beforeEach(function () {
      mockTransaction = new (require('RelayMutationTransaction'))();
      mockTransaction.commit = jest.genMockFunction();
      createTransactionMock = jest.genMockFunction();
      createTransactionMock.mockReturnValue(mockTransaction);
      require('RelayMutationQueue').prototype.createTransaction = createTransactionMock;
      mockMutation = new (require('RelayMutation'))();
      mockCallbacks = jest.genMockFunction();});


    describe('applyUpdate', function () {
      it('creates a new RelayMutationTransaction without committing it', function () {
        var transaction = 
        relayContext.applyUpdate(mockMutation, mockCallbacks);
        expect(transaction).toEqual(mockTransaction);
        expect(createTransactionMock).toBeCalledWith(
        mockMutation, 
        mockCallbacks);

        expect(mockTransaction.commit).not.toBeCalled();});});



    describe('commitUpdate', function () {
      it('creates a new RelayMutationTransaction and commits it', function () {
        relayContext.commitUpdate(mockMutation, mockCallbacks);
        expect(createTransactionMock).toBeCalledWith(
        mockMutation, 
        mockCallbacks);

        expect(mockTransaction.commit).toBeCalled();});});});});