{
  "_args": [
    [
      "reselect@https://registry.npmjs.org/reselect/-/reselect-2.0.3.tgz",
      "C:\\gitRepo\\f8app"
    ]
  ],
  "_from": "reselect@>=2.0.3 <2.1.0",
  "_id": "reselect@2.0.3",
  "_inCache": true,
  "_location": "/reselect",
  "_phantomChildren": {},
  "_requested": {
    "name": "reselect",
    "raw": "reselect@https://registry.npmjs.org/reselect/-/reselect-2.0.3.tgz",
    "rawSpec": "https://registry.npmjs.org/reselect/-/reselect-2.0.3.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/reselect/-/reselect-2.0.3.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/reselect/-/reselect-2.0.3.tgz",
  "_shasum": "cab04c867cf67381dcbe86f3be3caa1831b89259",
  "_shrinkwrap": null,
  "_spec": "reselect@https://registry.npmjs.org/reselect/-/reselect-2.0.3.tgz",
  "_where": "C:\\gitRepo\\f8app",
  "author": {
    "name": "Martijn Faassen"
  },
  "bugs": {
    "url": "https://github.com/rackt/reselect/issues"
  },
  "contributors": [
    {
      "name": "Martijn Faassen"
    },
    {
      "name": "Lee Bannard"
    },
    {
      "name": "Robert Binna"
    },
    {
      "name": "Philip Spitzlinger"
    },
    {
      "name": "Alex Guerra"
    },
    {
      "name": "ryanatkn"
    },
    {
      "name": "Adam Royle"
    },
    {
      "name": "Christian Schuhmann"
    },
    {
      "name": "Jason Huang"
    },
    {
      "name": "Daniel Barreto"
    },
    {
      "name": "Mihail Diordiev"
    },
    {
      "name": "Daniela Borges"
    },
    {
      "name": "C. T. Lin"
    },
    {
      "name": "SpainTrain"
    },
    {
      "name": "Mark Dalgleish"
    },
    {
      "name": "Brian Ng"
    }
  ],
  "dependencies": {},
  "description": "Selectors for Redux.",
  "devDependencies": {
    "babel": "^5.5.8",
    "babel-core": "^5.6.15",
    "babel-eslint": "^4.1.3",
    "chai": "^3.0.0",
    "codecov.io": "^0.1.6",
    "coveralls": "^2.11.4",
    "eslint": "^1.5",
    "eslint-config-rackt": "1.0.0",
    "eslint-plugin-react": "^3.5.1",
    "isparta": "^3.0.3",
    "lodash.memoize": "^3.0.4",
    "mocha": "^2.2.5"
  },
  "files": [
    "lib",
    "src",
    "README.md",
    "LICENSE",
    "package.json"
  ],
  "homepage": "https://github.com/rackt/reselect#readme",
  "jsnext:main": "src/index.js",
  "keywords": [
    "react",
    "redux"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "reselect",
  "optionalDependencies": {},
  "readme": "# Reselect\n[![Travis][build-badge]][build]\n[![npm package][npm-badge]][npm]\n[![Coveralls][coveralls-badge]][coveralls]\n\nSimple \"selector\" library for Redux inspired by getters in [NuclearJS](https://github.com/optimizely/nuclear-js.git), [subscriptions](https://github.com/Day8/re-frame#just-a-read-only-cursor) in [re-frame](https://github.com/Day8/re-frame) and this [proposal](https://github.com/gaearon/redux/pull/169) from [speedskater](https://github.com/speedskater).\n\n* Selectors can compute derived data, allowing Redux to store the minimal possible state.\n* Selectors are efficient. A selector is not recomputed unless one of its arguments change.\n* Selectors are composable. They can be used as input to other selectors.\n\n```js\nimport { createSelector } from 'reselect'\n\nconst shopItemsSelector = state => state.shop.items\nconst taxPercentSelector = state => state.shop.taxPercent\n\nconst subtotalSelector = createSelector(\n  shopItemsSelector,\n  items => items.reduce((acc, item) => acc + item.value, 0)\n)\n\nconst taxSelector = createSelector(\n  subtotalSelector,\n  taxPercentSelector,\n  (subtotal, taxPercent) => subtotal * (taxPercent / 100)\n)\n\nexport const totalSelector = createSelector(\n  subtotalSelector,\n  taxSelector,\n  (subtotal, tax) => ({ total: subtotal + tax })\n)\n```\n\n## Table of Contents\n\n- [Installation](#installation)\n- [Example](#example)\n  - [Motivation for Memoized Selectors](#motivation-for-memoized-selectors)\n  - [Creating a Memoized Selector](#creating-a-memoized-selector)\n  - [Composing Selectors](#composing-selectors)\n  - [Connecting a Selector to the Redux Store](#connecting-a-selector-to-the-redux-store)\n  - [Accessing React Props in Selectors](#accessing-react-props-in-selectors)\n- [API](#api)\n  - [`createSelector`](#createselectorinputselectors--inputselectors-resultfunc)\n  - [`defaultMemoize`](#defaultmemoizefunc-equalitycheck--defaultequalitycheck)\n  - [`createSelectorCreator`](#createselectorcreatormemoize-memoizeoptions)\n  - [`createStructuredSelector`](#createstructuredselectorinputselectors-selectorcreator--createselector)\n- [FAQ](#faq)\n  - [Why isn't my selector recomputing when the input state changes?](#q-why-isnt-my-selector-recomputing-when-the-input-state-changes)\n  - [Why is my selector recomputing when the input state stays the same?](#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same)\n  - [Can I use Reselect without Redux?](#q-can-i-use-reselect-without-redux)\n  - [The default memoization function is no good, can I use a different one?](#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one)\n  - [How do I test a selector?](#q-how-do-i-test-a-selector)\n  - [How do I create a selector that takes an argument? ](#q-how-do-i-create-a-selector-that-takes-an-argument)\n  - [How do I use Reselect with Immutable.js?](#q-how-do-i-use-reselect-with-immutablejs)\n  - [Can I share a selector across multiple modules?](#q-can-i-share-a-selector-across-multiple-modules)\n  - [Are there TypeScript Typings?](#q-are-there-typescript-typings)\n- [License](#license)\n\n## Installation\n    npm install reselect\n\n## Example\n\n### Motivation for Memoized Selectors\n\n> The examples in this section are based on the [Redux Todos List example](http://rackt.github.io/redux/docs/basics/UsageWithReact.html).\n\nConsider the following code:\n\n#### `containers/App.js`\n\n```js\nimport React, { Component, PropTypes } from 'react'\nimport { connect } from 'react-redux'\nimport AddTodo from '../components/AddTodo'\nimport TodoList from '../components/TodoList'\nimport Footer from '../components/Footer'\nimport {\n  addTodo,\n  completeTodo,\n  setVisibilityFilter,\n  VisibilityFilters\n} from '../actions'\n\nclass App extends Component {\n  render() {\n    // Injected by connect() call:\n    const { dispatch, visibleTodos, visibilityFilter } = this.props\n    return (\n      <div>\n        <AddTodo\n          onAddClick={text =>\n            dispatch(addTodo(text))\n          } />\n        <TodoList\n          todos={this.props.visibleTodos}\n          onTodoClick={index =>\n            dispatch(completeTodo(index))\n          } />\n        <Footer\n          filter={visibilityFilter}\n          onFilterChange={nextFilter =>\n            dispatch(setVisibilityFilter(nextFilter))\n          } />\n      </div>\n    )\n  }\n}\n\nApp.propTypes = {\n  visibleTodos: PropTypes.arrayOf(PropTypes.shape({\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired\n  })),\n  visibilityFilter: PropTypes.oneOf([\n    'SHOW_ALL',\n    'SHOW_COMPLETED',\n    'SHOW_ACTIVE'\n  ]).isRequired\n}\n\nfunction selectTodos(todos, filter) {\n  switch (filter) {\n  case VisibilityFilters.SHOW_ALL:\n    return todos\n  case VisibilityFilters.SHOW_COMPLETED:\n    return todos.filter(todo => todo.completed)\n  case VisibilityFilters.SHOW_ACTIVE:\n    return todos.filter(todo => !todo.completed)\n  }\n}\n\nfunction select(state) {\n  return {\n    visibleTodos: selectTodos(state.todos, state.visibilityFilter),\n    visibilityFilter: state.visibilityFilter\n  }\n}\n\n// Wrap the component to inject dispatch and state into it\nexport default connect(select)(App)\n```\n\nIn the above example, `select` calls `selectTodos` to calculate `visibleTodos`. This works great, but there is a drawback: `visibleTodos` is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations.\n\n### Creating a Memoized Selector\n\nWe would like to replace `select` with a memoized selector that recalculates `visibleTodos` when the value of `state.todos` or `state.visibilityFilter` changes, but not when changes occur in other (unrelated) parts of the state tree.\n\nReselect provides a function `createSelector` for creating memoized selectors. `createSelector` takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.\n\nLet's define a memoized selector named `visibleTodosSelector` to replace `select`:\n\n#### `selectors/todoSelectors.js`\n\n```js\nimport { createSelector } from 'reselect'\nimport { VisibilityFilters } from '../actions'\n\nfunction selectTodos(todos, filter) {\n  switch (filter) {\n  case VisibilityFilters.SHOW_ALL:\n    return todos\n  case VisibilityFilters.SHOW_COMPLETED:\n    return todos.filter(todo => todo.completed)\n  case VisibilityFilters.SHOW_ACTIVE:\n    return todos.filter(todo => !todo.completed)\n  }\n}\n\n/*\n * Definition of input-selectors.\n * Input-selectors should be used to abstract away the structure\n * of the store in cases where no calculations are needed\n * and memoization wouldn't provide any benefits.\n */\nconst visibilityFilterSelector = state => state.visibilityFilter\nconst todosSelector = state => state.todos\n\n/*\n * Definition of combined-selector.\n * In visibleTodosSelector, input-selectors are combined to derive new\n * information. To prevent expensive recalculation of the input-selectors\n * memoization is applied. Hence, these selectors are only recomputed when the\n * value of their input-selectors change. If none of the input-selectors return\n * a new value, the previously computed value is returned.\n */\nexport const visibleTodosSelector = createSelector(\n  visibilityFilterSelector,\n  todosSelector,\n  (visibilityFilter, todos) => {\n    return {\n      visibleTodos: selectTodos(todos, visibilityFilter),\n      visibilityFilter\n    }\n  }\n)\n```\n\nIn the example above, `visibilityFilterSelector` and `todosSelector` are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. `visibleTodosSelector` on the other hand is a memoized selector. It takes `visibilityFilterSelector` and `todosSelector` as input-selectors, and a transform function that calculates the filtered todos list.\n\n### Composing Selectors\n\nA memoized selector can itself be an input-selector to another memoized selector. Here is `visibleTodosSelector` being used as an input-selector to a selector that further filters the todos by keyword:\n\n```js\nconst keywordSelector = state => state.keyword\n\nconst keywordFilterSelector = createSelector(\n  [ visibleTodosSelector, keywordSelector ],\n  (visibleTodos, keyword) => visibleTodos.filter(\n    todo => todo.indexOf(keyword) > -1\n  )\n)\n```\n\n### Connecting a Selector to the Redux Store\n\nIf you are using React Redux, you connect a memoized selector to the Redux store using `connect`:\n\n#### `containers/TodoApp.js`\n\n```js\nimport React, { Component, PropTypes } from 'react'\nimport { connect } from 'react-redux'\nimport { addTodo, completeTodo, setVisibilityFilter } from '../actions'\nimport AddTodo from '../components/AddTodo'\nimport TodoList from '../components/TodoList'\nimport Footer from '../components/Footer'\n\n/*\n * Import the selector defined in ../selectors/todoSelectors.js.\n * This allows you to separate components from the structure of the store.\n */\nimport { visibleTodosSelector } from '../selectors/todoSelectors'\n\nclass App extends Component {\n  render() {\n    // Injected by connect() call:\n    const { dispatch, visibleTodos, visibilityFilter } = this.props\n    return (\n      <div>\n        <AddTodo\n          onAddClick={text =>\n            dispatch(addTodo(text))\n          } />\n        <TodoList\n          todos={this.props.visibleTodos}\n          onTodoClick={index =>\n            dispatch(completeTodo(index))\n          } />\n        <Footer\n          filter={visibilityFilter}\n          onFilterChange={nextFilter =>\n            dispatch(setVisibilityFilter(nextFilter))\n          } />\n      </div>\n    )\n  }\n}\n\nApp.propTypes = {\n  visibleTodos: PropTypes.arrayOf(PropTypes.shape({\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired\n  })),\n  visibilityFilter: PropTypes.oneOf([\n    'SHOW_ALL',\n    'SHOW_COMPLETED',\n    'SHOW_ACTIVE'\n  ]).isRequired\n}\n\n/*\n * Connect visibleTodosSelector to the App component.\n * The keys of the selector result are available on the props object for App.\n * In our example there is the 'visibleTodos' key which is\n * bound to this.props.visibleTodos\n */\nexport default connect(visibleTodosSelector)(App)\n```\n\n### Accessing React Props in Selectors\n\nSo far we have only seen selectors receive the Redux store state as input, but it is also possible for a selector to receive the props of a component wrapped by `connect`.\n\nConsider the following example:\n\n#### `index.js`\n\n```js\nimport React from 'react'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport todoApp from './reducers'\n\nlet store = createStore(todoApp)\n\nlet rootElement = document.getElementById('root')\nReact.render(\n  <Provider store={store}>\n    {() => <App maxTodos={5}/>}\n  </Provider>,\n  rootElement\n)\n```\n\nWe have introduced a prop named `maxTodos` to the `App` component. We would like to access `maxTodos` in `visibleTodosSelector` so we can make sure that we do not return more Todos than it specifies. To achieve this we can make the following changes to `selectors/todoSelectors.js`:\n\n#### `selectors/todoSelectors.js`\n\n```js\nimport { createSelector } from 'reselect'\nimport { VisibilityFilters } from './actions'\n\nfunction selectTodos(todos, filter) {\n  switch (filter) {\n  case VisibilityFilters.SHOW_ALL:\n    return todos\n  case VisibilityFilters.SHOW_COMPLETED:\n    return todos.filter(todo => todo.completed)\n  case VisibilityFilters.SHOW_ACTIVE:\n    return todos.filter(todo => !todo.completed)\n  }\n}\n\nconst visibilityFilterSelector = state => state.visibilityFilter\nconst todosSelector = state => state.todos\nconst maxTodosSelector = (state, props) => props.maxTodos\n\nexport const visibleTodosSelector = createSelector(\n  visibilityFilterSelector,\n  todosSelector,\n  maxTodosSelector,\n  (visibilityFilter, todos, maxTodos) => {\n    const visibleTodos = selectTodos(todos, visibilityFilter).slice(0, maxTodos)\n    return {\n      visibleTodos,\n      visibilityFilter\n    }\n  }\n)\n```\n\nWhen a selector is connected to a component with `connect`, the component props are passed as the second argument to the selector. In `visibleTodosSelector` we have added a new input-selector named `maxTodosSelector`, which returns the `maxTodos` property from its props argument.\n\n## API\n\n### createSelector(...inputSelectors | [inputSelectors], resultFunc)\n\nTakes one or more selectors, or an array of selectors, computes their values and passes them as arguments to `resultFunc`.\n\n`createSelector` determines if the value returned by an input-selector has changed between calls using reference equality (`===`). Inputs to selectors created with `createSelector` should be immutable.\n\nSelectors created with `createSelector` have a cache size of 1. This means they always recalculate when the value of an input-selector changes, as a selector only stores the preceding value of each input-selector.\n\n```js\nconst mySelector = createSelector(\n  state => state.values.value1,\n  state => state.values.value2,\n  (value1, value2) => value1 + value2\n)\n\n// You can also pass an array of selectors\nconst totalSelector = createSelector(\n  [\n    state => state.values.value1,\n    state => state.values.value2\n  ],\n  (value1, value2) => value1 + value2\n)\n```\n\nIt can be useful to access the props of a component from within a selector. When a selector is connected to a component with `connect`, the component props are passed as the second argument to the selector:\n\n```js\nconst abSelector = (state, props) => state.a * props.b\n\n// props only (ignoring state argument)\nconst cSelector =  (_, props) => props.c\n\n// state only (props argument omitted as not required)\nconst dSelector = state => state.d\n\nconst totalSelector = createSelector(\n  abSelector,\n  cSelector,\n  dSelector,\n  (ab, c, d) => ({\n    total: ab + c + d\n  })\n)\n\n```\n\n### defaultMemoize(func, equalityCheck = defaultEqualityCheck)\n\n`defaultMemoize` memoizes the function passed in the func parameter. It is the memoize function used by `createSelector`.\n\n`defaultMemoize` has a cache size of 1. This means it always recalculates when the value of an argument changes.\n\n`defaultMemoize` determines if an argument has changed by calling the `equalityCheck` function. As `defaultMemoize` is designed to be used with immutable data, the default `equalityCheck` function checks for changes using reference equality:\n\n```js\nfunction defaultEqualityCheck(currentVal, previousVal) {\n  return currentVal === previousVal\n}\n```\n\n`defaultMemoize` can be used with `createSelectorCreator` to [customize the `equalityCheck` function](#customize-equalitycheck-for-defaultmemoize).\n\n### createSelectorCreator(memoize, ...memoizeOptions)\n\n`createSelectorCreator` can be used to make a customized version of `createSelector`.\n\nThe `memoize` argument is a memoization function to replace `defaultMemoize`.\n\nThe `...memoizeOptions` rest parameters are zero or more configuration options to be passed to `memoizeFunc`. The selectors `resultFunc` is passed as the first argument to `memoize` and the `memoizeOptions` are passed as the second argument onwards:\n\n```js\nconst customSelectorCreator = createSelectorCreator(\n  customMemoize, // function to be used to memoize resultFunc\n  option1, // option1 will be passed as second argument to customMemoize\n  option2, // option2 will be passed as third argument to customMemoize\n  option3 // option3 will be passed as fourth argument to customMemoize\n)\n\nconst customSelector = customSelectorCreator(\n  input1,\n  input2,\n  resultFunc // resultFunc will be passed as first argument to customMemoize\n)\n```\n\nInternally `customSelector` calls the memoize function as follows:\n\n```js\ncustomMemoize(resultFunc, option1, option2, option3)\n```\n\nHere are some examples of how you might use `createSelectorCreator`:\n\n#### Customize `equalityCheck` for `defaultMemoize`\n\n```js\nimport { createSelectorCreator, defaultMemoize } from 'reselect'\nimport isEqual from 'lodash.isEqual'\n\n// create a \"selector creator\" that uses lodash.isEqual instead of ===\nconst createDeepEqualSelector = createSelectorCreator(\n  defaultMemoize,\n  isEqual\n)\n\n// use the new \"selector creator\" to create a selector\nconst mySelector = createDeepEqualSelector(\n  state => state.values.filter(val => val < 5),\n  values => values.reduce((acc, val) => acc + val, 0)\n)\n```\n\n#### Use memoize function from lodash for an unbounded cache\n\n```js\nimport { createSelectorCreator } from 'reselect'\nimport memoize from 'lodash.memoize'\n\nlet called = 0\nconst hashFn = (...args) => args.reduce(\n  (acc, val) => acc + '-' + JSON.stringify(val)\n)\nconst customSelectorCreator = createSelectorCreator(memoize, hashFn)\nconst selector = customSelectorCreator(\n  state => state.a,\n  state => state.b,\n  (a, b) => {\n    called++\n    return a + b\n  }\n)\n```\n\n### createStructuredSelector({inputSelectors}, selectorCreator = createSelector)\n\n`createStructuredSelector` is a convenience function for a common pattern that arises when using Reselect.  The selector passed to a `connect` decorator often just takes the values of its input-selectors and maps them to keys in an object:\n\n```js\nconst mySelectorA = state => state.a\nconst mySelectorB = state => state.b\n\n// The result function in the following selector\n// is simply building an object from the input selectors\nconst structuredSelector = createSelector(\n   mySelectorA,\n   mySelectorB,\n   mySelectorC,\n   (a, b, c) => ({\n     a,\n     b,\n     c\n   })\n)\n```\n\n`createStructuredSelector` takes an object whose properties are input-selectors and returns a structured selector. The structured selector returns an object with the same keys as the `inputSelectors` argument, but with the selectors replaced with their values.\n\n```js\nconst mySelectorA = state => state.a\nconst mySelectorB = state => state.b\n\nconst structuredSelector = createStructuredSelector({\n  x: mySelectorA,\n  y: mySelectorB\n})\n\nconst result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n```\n\nStructured selectors can be nested:\n\n```js\nconst nestedSelector = createStructuredSelector({\n  subA: createStructuredSelector({\n    selectorA,\n    selectorB\n  }),\n  subB: createStructuredSelector({\n    selectorC,\n    selectorD\n  })\n})\n\n```\n\n## FAQ\n\n### Q: Why isn't my selector recomputing when the input state changes?\n\nA: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with `createSelector` will not work with a state update function that mutates an existing object instead of creating a new one each time. `createSelector` uses an identity check (`===`) to detect that an input has changed, so mutating an existing object will not trigger the selector to recompute because mutating an object does not change its identity. Note that if you are using Redux, mutating the state object is [almost certainly a mistake](http://rackt.github.io/redux/docs/Troubleshooting.html).\n\nThe following example defines a simple selector that determines if the first todo item in an array of todos has been completed:\n\n```js\nconst isFirstTodoCompleteSelector = createSelector(\n  state => state.todos[0],\n  todo => todo && todo.completed\n)\n```\n\nThe following state update function **will not** work with `isFirstTodoCompleteSelector`:\n\n```js\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n  case COMPLETE_ALL:\n    const areAllMarked = state.every(todo => todo.completed)\n    // BAD: mutating an existing object\n    return state.map(todo => {\n      todo.completed = !areAllMarked\n      return todo\n    })\n\n  default:\n    return state\n  }\n}\n```\n\nThe following state update function **will** work with `isFirstTodoCompleteSelector`:\n\n```js\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n  case COMPLETE_ALL:\n    const areAllMarked = state.every(todo => todo.completed)\n    // GOOD: returning a new object each time with Object.assign\n    return state.map(todo => Object.assign({}, todo, {\n      completed: !areAllMarked\n    }))\n\n  default:\n    return state\n  }\n}\n```\n\nIf you are not using Redux and have a requirement to work with mutable data, you can use `createSelectorCreator` to replace the default memoization function and/or use a different equality check function. See [here](#use-memoize-function-from-lodash-for-an-unbounded-cache) and [here](#customize-equalitycheck-for-defaultmemoize) for examples.\n\n### Q: Why is my selector recomputing when the input state stays the same?\n\nA: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with `createSelector` that recomputes unexpectedly may be receiving a new object on each update whether the values it contains have changed or not. `createSelector` uses an identity check (`===`) to detect that an input has changed, so returning a new object on each update means that the selector will recompute on each update.\n\n```js\nimport { REMOVE_OLD } from '../constants/ActionTypes'\n\nconst initialState = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0,\n    timestamp: Date.now()\n  }\n]\n\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n  case REMOVE_OLD:\n    return state.filter(todo => {\n      return todo.timestamp + 30 * 24 * 60 * 60 * 1000 > Date.now()\n    })\n  default:\n    return state\n  }\n}\n```\n\nThe following selector is going to recompute every time REMOVE_OLD is invoked because Array.filter always returns a new object. However, in the majority of cases the REMOVE_OLD action will not change the list of todos so the recomputation is unnecessary.\n\n```js\nimport { createselector } from 'reselect'\n\nconst todosSelector = state => state.todos\n\nexport const visibletodosselector = createselector(\n  todosselector,\n  (todos) => {\n    ...\n  }\n)\n```\n\nYou can eliminate unnecessary recomputations by returning a new object from the state update function only when a deep equality check has found that the list of todos has actually changed:\n\n```js\nimport { REMOVE_OLD } from '../constants/ActionTypes'\nimport isEqual from 'lodash.isEqual'\n\nconst initialState = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0,\n    timestamp: Date.now()\n  }\n]\n\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n  case REMOVE_OLD:\n    const updatedState =  state.filter(todo => {\n      return todo.timestamp + 30 * 24 * 60 * 60 * 1000 > Date.now()\n    })\n    return isEqual(updatedState, state) ? state : updatedState\n  default:\n    return state\n  }\n}\n```\n\nAlternatively, the default `equalityCheck` function in the selector can be replaced by a deep equality check:\n\n```js\nimport { createSelectorCreator, defaultMemoize } from 'reselect'\nimport isEqual from 'lodash.isEqual'\n\nconst todosSelector = state => state.todos\n\n// create a \"selector creator\" that uses lodash.isEqual instead of ===\nconst createDeepEqualSelector = createSelectorCreator(\n  defaultMemoize,\n  isEqual\n)\n\n// use the new \"selector creator\" to create a selector\nconst mySelector = createDeepEqualSelector(\n  todosSelector,\n  (todos) => {\n    ...\n  }\n)\n```\n\nAlways check that the cost of an alternative `equalityCheck` function or deep equality check in the state update function is not greater than the cost of recomputing every time. If recomputing every time does work out to be the cheaper option, it may be that for this case Reselect is not giving you any benefit over passing a plain `mapStateToProps` function to `connect`.\n\n### Q: Can I use Reselect without Redux?\n\nA: Yes. Reselect has no dependencies on any other package, so although it was designed to be used with Redux it can be used independently. It is currently being used successfully in traditional Flux apps.\n\n> If you create selectors using `createSelector` make sure the objects in your store are immutable.\n> See [here](#createselectorinputselectors--inputselectors-resultfunc)\n\n### Q: How do I create a selector that takes an argument?\n\nA: Reselect doesn't have built-in support for creating selectors that accepts arguments, but here are some suggestions for implementing similar functionality...\n\nIf the argument is not dynamic you can use a factory function:\n\n```js\nconst expensiveItemSelectorFactory = minValue => {\n  return createSelector(\n    shopItemsSelector,\n    items => items.filter(item => item.value > minValue)\n  )\n}\n\nconst subtotalSelector = createSelector(\n  expensiveItemSelectorFactory(200),\n  items => items.reduce((acc, item) => acc + item.value, 0)\n)\n```\n\nThe general consensus [here](https://github.com/rackt/reselect/issues/38) and [over at nuclear-js](https://github.com/optimizely/nuclear-js/issues/14) is that if a selector needs a dynamic argument, then that argument should probably be state in the store. If you decide that you do require a selector with a dynamic argument, then a selector that returns a memoized function may be suitable:\n\n```js\nimport { createSelector } from 'reselect'\nimport memoize from 'lodash.memoize'\n\nconst expensiveSelector = createSelector(\n  state => state.items,\n  items => memoize(\n    minValue => items.filter(item => item.value > minValue)\n  )\n)\n\nconst expensiveFilter = expensiveSelector(state)\n\nconst slightlyExpensive = expensiveFilter(100)\nconst veryExpensive = expensiveFilter(1000000)\n```\n\n### Q: The default memoization function is no good, can I use a different one?\n\nA: We think it works great for a lot of use cases, but sure. See [these examples](#customize-equalitycheck-for-defaultmemoize).\n\n### Q: How do I test a selector?\n\nA: For a given input, a selector should always produce the same output. For this reason they are simple to unit test.\n\n```js\nconst selector = createSelector(\n  state => state.a,\n  state => state.b,\n  (a, b) => ({\n    c: a * 2,\n    d: b * 3\n  })\n)\n\ntest(\"selector unit test\", () => {\n  assert.deepEqual(selector({ a: 1, b: 2 }), { c: 2, d: 6 })\n  assert.deepEqual(selector({ a: 2, b: 3 }), { c: 4, d: 9 })\n})\n```\n\nIt may also be useful to check that the memoization function for a selector works correctly with the state update function (i.e. the reducer if you are using Redux). Each selector has a `recomputations` method that will return the number of times it has been recomputed:\n\n```js\nsuite('selector', () => {\n  let state = { a: 1, b: 2 }\n\n  const reducer = (state, action) => (\n    {\n      a: action(state.a),\n      b: action(state.b)\n    }\n  )\n\n  const selector = createSelector(\n    state => state.a,\n    state => state.b,\n    (a, b) => ({\n      c: a * 2,\n      d: b * 3\n    })\n  )\n\n  const plusOne = x => x + 1\n  const id = x => x\n\n  test(\"selector unit test\", () => {\n    state = reducer(state, plusOne)\n    assert.deepEqual(selector(state), { c: 4, d: 9 })\n    state = reducer(state, id)\n    assert.deepEqual(selector(state), { c: 4, d: 9 })\n    assert.equal(selector.recomputations(), 1)\n    state = reducer(state, plusOne)\n    assert.deepEqual(selector(state), { c: 6, d: 12 })\n    assert.equal(selector.recomputations(), 2)\n  })\n})\n```\n\n### Q: How do I use Reselect with Immutable.js?\n\nA: Selectors created with `createSelector` should work just fine with Immutable.js data structures.\n\nIf your selector is recomputing and you don't think the state has changed, make sure you are aware of which Immutable.js update methods **always** return a new object and which update methods only return a new object **when the collection actually changes**.\n\n```js\nimport Immutable from 'immutable'\n\nlet myMap = Immutable.Map({\n  a: 1,\n  b: 2,\n  c: 3\n})\n\n // set, merge and others only return a new obj when update changes collection\nlet newMap = myMap.set('a', 1)\nassert.equal(myMap, newMap)\nnewMap = myMap.merge({ 'a', 1 })\nassert.equal(myMap, newMap)\n// map, reduce, filter and others always return a new obj\nnewMap = myMap.map(a => a * 1)\nassert.notEqual(myMap, newMap)\n```\n\nIf a selector's input is updated by an operation that always returns a new object, it may be performing unnecessary recomputations. See [here](#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same) for a discussion on the pros and cons of using a deep equality check like `Immmutable.is` to eliminate unnecessary recomputations.\n\n### Q: Can I share a selector across multiple modules?\n\nA: Yes, but with the following caveatâ€”a selector can be shared across components and benefit from memoization, but a selector that is shared must receive the same arguments at each call site. Arguments are considered the same if they  pass the selectors equality check.\n\nIn the case of `createSelector` the equality check is `===`. The following example, which is a common case, memoizes because it receives state.x from the `connect` decorator for both components:\n\n```js\nconst doublexSelector = createSelector(\n  state => state.x,\n  x => x * 2\n)\n\nclass Component1 extends Component {\n...\n}\n\nComponent1 = connect(doublexSelector)(Component1)\n\nclass Component2 extends Component {\n...\n}\n\nComponent2 = connect(doublexSelector)(Component2)\n```\n\nThe following example may or may not memoize. Here memoization depends on the props passed into the components being `===` for each component:\n\n```js\nconst xPlusySelector = createSelector(\n  state => state.x,\n  (_, props) => props.y,\n  (x, y) => x + y\n)\n\nclass Component1 extends Component {\n...\n}\n\nComponent1 = connect(xPlusySelector)(Component1)\n\nclass Component2 extends Component {\n...\n}\n\nComponent2 = connect(xPlusySelector)(Component2)\n```\n\nThis example definitely won't memoize. The `ids` array passed into each selector are different objects:\n\n```js\nconst doubleIdsSelector = createSelector(\n  state => state.ids,\n  ids => ids.map(id => id * 2)\n)\n\nclass Component1 extends Component {\n...\n}\n\nComponent1 = connect(\n  state => doubleIdsSelector({ ids: [ ...state.ids1, ...state.ids2 ] })\n)(Component1)\n\nclass Component2 extends Component {\n...\n}\n\nComponent2 = connect(\n  state => doubleIdsSelector({ ids: [ ...state.ids1, ...state.ids2 ] })\n)(Component2)\n```\n\nNote that [`createSelectorCreator`](#createselectorcreatormemoize-memoizeoptions) could be used to memoize both of the failing examples above. The second example, where the props may be different, could use a memoization function with a larger cache. The last example could use a deep equality check.\n\n### Q: Are there TypeScript Typings?\n\nA: Yes! They are available from DefinitelyTyped. [Thanks to @frankwallis and @geon.](https://github.com/rackt/reselect/issues/55#issuecomment-173198641)\n\n## License\n\nMIT\n\n[build-badge]: https://img.shields.io/travis/rackt/reselect/master.svg?style=flat-square\n[build]: https://travis-ci.org/rackt/reselect\n\n[npm-badge]: https://img.shields.io/npm/v/reselect.svg?style=flat-square\n[npm]: https://www.npmjs.org/package/reselect\n\n[coveralls-badge]: https://img.shields.io/coveralls/rackt/reselect/master.svg?style=flat-square\n[coveralls]: https://coveralls.io/github/rackt/reselect\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rackt/reselect.git"
  },
  "scripts": {
    "compile": "babel --loose es6.modules -d lib/ src/",
    "lint": "eslint src test",
    "prepublish": "npm run compile",
    "test": "NODE_ENV=test mocha --compilers js:babel/register --recursive",
    "test:cov": "babel-node ./node_modules/.bin/isparta cover ./node_modules/.bin/_mocha -- --recursive"
  },
  "version": "2.0.3"
}
