'use strict';














var debug=require('debug')('ReactNativePackager:SocketInterface');



var tmpdir=require('os').tmpdir();var 
spawn=require('child_process').spawn;

var CREATE_SERVER_TIMEOUT=5*60*1000;

var SocketInterface={
getOrCreateSocketFor:function(options){
return new (require('promise'))(function(resolve,reject){
var hash=require('crypto').createHash('md5');
Object.keys(options).sort().forEach(function(key){
var value=options[key];
if(value){
hash.update(
options[key]!=null&&typeof value==='string'?
value:
JSON.stringify(value));}});




var sockPath=require('path').join(
tmpdir,
'react-packager-'+hash.digest('hex'));

if(process.platform==='win32'){


sockPath=sockPath.replace(/^\//,'');
sockPath=sockPath.replace(/\//g,'-');
sockPath='\\\\.\\pipe\\'+sockPath;}


if(existsSync(sockPath)){
var sock=require('net').connect(sockPath);
sock.on('connect',function(){
require('./SocketClient').create(sockPath).then(
function(client){
sock.end();
resolve(client);},

function(error){
sock.end();
reject(error);});});



sock.on('error',function(e){
try{
debug('deleting socket for not responding',sockPath);
require('fs').unlinkSync(sockPath);}
catch(err){}


createServer(resolve,reject,options,sockPath);});}else 

{
createServer(resolve,reject,options,sockPath);}});},




listenOnServerMessages:function(){
return require('./SocketServer').listenOnServerIPCMessages();}};



function createServer(resolve,reject,options,sockPath){
var logPath=require('path').join(tmpdir,'react-packager.log');

var timeout=setTimeout(
function(){return reject(
new Error(
'Took too long to start server. Server logs: \n'+
require('fs').readFileSync(logPath,'utf8')));},


CREATE_SERVER_TIMEOUT);


var log=require('fs').openSync(logPath,'a');


var env=require('underscore').clone(process.env);
env.DEBUG='ReactNativePackager:SocketServer';



var child=spawn(
process.execPath,
[require('path').join(__dirname,'..','..','index.js')],
{
detached:true,
env:env,
stdio:['ipc',log,log]});



child.unref();

child.on('message',function(m){
if(m&&m.type&&m.type==='createdServer'){
clearTimeout(timeout);
child.disconnect();

resolve(require('./SocketClient').create(sockPath));}});



if(options.blacklistRE){
options.blacklistRE={source:options.blacklistRE.source};}


child.send({
type:'createSocketServer',
data:{sockPath:sockPath,options:options}});}



function existsSync(filename){
try{
require('fs').accessSync(filename);
return true;}
catch(ex){
return false;}}



module.exports=SocketInterface;