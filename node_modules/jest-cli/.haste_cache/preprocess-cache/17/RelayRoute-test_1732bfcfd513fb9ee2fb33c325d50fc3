/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError('Cannot call a class as a function');}}function _inherits(subClass, superClass) {if (typeof superClass !== 'function' && superClass !== null) {throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;}

require('configureForRelayOSS');





describe('RelayRoute', function () {
  var makeRoute;

  beforeEach(function () {
    jest.resetModuleRegistry();

    makeRoute = function () {var 
      MockRoute = (function (_RelayRoute) {_inherits(MockRoute, _RelayRoute);function MockRoute() {_classCallCheck(this, MockRoute);_RelayRoute.apply(this, arguments);}return MockRoute;})(require('RelayRoute'));
      MockRoute.routeName = 'MockRoute';
      MockRoute.path = '/{required}';
      MockRoute.paramDefinitions = { 
        required: { 
          type: 'String', 
          required: true }, 

        optional: { 
          type: 'String', 
          required: false } };


      MockRoute.queries = { 
        required: function (Component) {return (function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallVariable', callVariableName: 'required' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayRoute', type: 'Node' };})(


          Component.getFragment('required'));}, 



        optional: function (Component) {return (function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallVariable', callVariableName: 'optional' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, require('Relay').QL.__frag(RQL_0)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayRoute', type: 'Node' };})(


          Component.getFragment('optional'));} };




      return MockRoute;};


    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  it('can be created using inheritance', function () {
    var MockRoute = makeRoute();
    var route = new MockRoute({ required: 'foo' });
    expect(route.name).toEqual('MockRoute');
    expect(route.params.required).toEqual('foo');
    expect(route.queries.required).toBeTruthy();});


  it('has an immutable spec in __DEV__', function () {
    var dev = __DEV__;
    window.__DEV__ = true;

    var MockRoute = makeRoute();
    var route = new MockRoute({ required: 'foo' });
    expect(function () {return route.name = 'yo';}).toThrow();
    expect(function () {return route.params = 'I am';}).toThrow();
    expect(function () {return route.queries = 'immutable';}).toThrow();
    expect(function () {return route.params.foo = 'bar';}).toThrow();
    expect(function () {return route.queries.myCustomQuery = function () {};}).toThrow();

    window.__DEV__ = dev;});


  it('allows params to be processed if `prepareParams` is defined', function () {
    var MockRoute = makeRoute();
    MockRoute.prepareParams = 
    jest.genMockFunction().mockReturnValue({ required: 'bar' });
    var route = new MockRoute({ required: 'foo' });
    expect(MockRoute.prepareParams).toBeCalledWith({ required: 'foo' });
    expect(route.params.required).toEqual('bar');});


  it('throws if a requires param is not supplied', function () {
    var MockRoute = makeRoute();
    expect(function () {
      /* eslint-disable no-new */
      new MockRoute({});
      /* eslint-enable no-new */}).
    toFailInvariant(
    'RelayRoute: Missing required parameter `required` in `MockRoute`. ' + 
    'Check the supplied params or URI.');});



  it('defaults optional param definitions to undefined', function () {
    var MockRoute = makeRoute();
    var route = new MockRoute({ required: 'foo' });
    expect(Object.keys(route.params)).toContain('optional');});


  it('exposes queries in the queries property', function () {
    var MockRoute = makeRoute();
    var route = new MockRoute({ required: 'foo' });
    expect(route.queries.required).toBeTruthy();
    expect(route.queries.optional).toBeTruthy();});


  it('allows to inject a URI creator', function () {
    require('RelayRoute').injectURICreator(
    function (_, params) {return '/foo/' + params.required;});

    var MockRoute = makeRoute();
    var route = new MockRoute({ required: 'bar' });

    expect(route.uri).not.toBe(null);
    expect(route.uri).toEqual('/foo/bar');});


  it('uses the injection only if the URI is not already passed in', function () {
    var mockCallback = jest.genMockFunction();
    require('RelayRoute').injectURICreator(mockCallback);
    var MockRoute = makeRoute();
    var uri = '/foo/bar';
    var route = new MockRoute({ required: 'bar' }, uri);

    expect(mockCallback).not.toBeCalled();
    expect(route.uri).toEqual(uri);});


  it('throws for route subclasses missing `routeName`', function () {var 
    InvalidRoute = (function (_RelayRoute2) {_inherits(InvalidRoute, _RelayRoute2);function InvalidRoute() {_classCallCheck(this, InvalidRoute);_RelayRoute2.apply(this, arguments);}return InvalidRoute;})(require('RelayRoute'));

    expect(function () {
      /* eslint-disable no-new */
      new InvalidRoute();
      /* eslint-enable no-new */}).
    toFailInvariant(
    'InvalidRoute: Subclasses of RelayRoute must define a `routeName`.');});});