/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.
dontMock('GraphQLRange').
dontMock('GraphQLSegment');






describe('RelayStoreData', function () {
  var Relay;var 

  getNode = require('RelayTestUtils').getNode;var getVerbatimNode = require('RelayTestUtils').getVerbatimNode;

  beforeEach(function () {
    jest.resetModuleRegistry();

    // @side-effect related to garbage collection
    Relay = require('Relay');

    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  describe('handleQueryPayload', function () {
    it('writes responses to `records`', function () {
      var storeData = new (require('RelayStoreData'))();

      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})());










      var response = { 
        node: { 
          id: '123', 
          doesViewerLike: false, 
          topLevelComments: { 
            count: 1 }, 

          __typename: 'Story' } };


      storeData.handleQueryPayload(query, response);

      // results are written to `records`
      var recordStore = storeData.getRecordStore();
      expect(recordStore.getRecordState('123')).toBe('EXISTENT');
      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);
      var commentsID = 
      recordStore.getLinkedRecordID('123', 'topLevelComments');
      expect(recordStore.getField(commentsID, 'count')).toBe(1);

      // `queuedRecords` is unchanged
      expect(storeData.getQueuedData()).toEqual({});});


    it('uses cached IDs for root fields without IDs', function () {
      var storeData = new (require('RelayStoreData'))();

      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})());










      var response = { 
        node: { 
          id: '123', 
          doesViewerLike: false, 
          topLevelComments: { 
            count: 1 }, 

          __typename: 'Story' } };


      storeData.handleQueryPayload(query, response);

      // results are written to `records`
      var recordStore = storeData.getRecordStore();
      expect(recordStore.getRecordState('123')).toBe('EXISTENT');
      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);
      var commentsID = 
      recordStore.getLinkedRecordID('123', 'topLevelComments');
      expect(recordStore.getField(commentsID, 'count')).toBe(1);

      // `queuedRecords` is unchanged
      expect(storeData.getQueuedData()).toEqual({});});});



  describe('handleUpdatePayload', function () {
    it('writes server payloads to `records`', function () {var _payload;
      var storeData = new (require('RelayStoreData'))();
      // create the root node
      storeData.getRecordWriter().putRecord('123');

      var mutationQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'feedbackLike', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], kind: 'Mutation', metadata: { inputType: 'FeedbackLikeInput' }, name: 'RelayStoreData', responseType: 'FeedbackLikeResponsePayload' };})());













      var payload = (_payload = {}, _defineProperty(_payload, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 'abc'), _defineProperty(_payload, 'feedback', 
      { 
        id: '123', 
        doesViewerLike: false, 
        topLevelComments: { 
          count: 1 } }), _payload);



      storeData.handleUpdatePayload(mutationQuery, payload, { 
        configs: [], 
        isOptimisticUpdate: false });


      // results are written to `records`
      var recordStore = storeData.getRecordStore();
      expect(recordStore.getRecordState('123')).toBe('EXISTENT');
      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);
      var commentsID = 
      recordStore.getLinkedRecordID('123', 'topLevelComments');
      expect(recordStore.getField(commentsID, 'count')).toBe(1);

      // `queuedRecords` is unchanged
      expect(storeData.getQueuedData()).toEqual({});});


    it('writes optimistic payloads to `queuedRecords`', function () {var _payload2;
      var storeData = new (require('RelayStoreData'))();
      // create the root node
      storeData.getRecordWriter().putRecord('123');

      var mutationQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'feedbackLike', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], kind: 'Mutation', metadata: { inputType: 'FeedbackLikeInput' }, name: 'RelayStoreData', responseType: 'FeedbackLikeResponsePayload' };})());













      var payload = (_payload2 = {}, _defineProperty(_payload2, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 'abc'), _defineProperty(_payload2, 'feedback', 
      { 
        id: '123', 
        doesViewerLike: false, 
        topLevelComments: { 
          count: 1 } }), _payload2);



      storeData.handleUpdatePayload(mutationQuery, payload, { 
        configs: [], 
        isOptimisticUpdate: true, 
        clientMutationID: 'mutationID' });


      // results are written to `queuedRecords`
      var queuedStore = storeData.getQueuedStore();
      expect(queuedStore.getRecordState('123')).toBe('EXISTENT');
      expect(queuedStore.getField('123', 'doesViewerLike')).toBe(false);
      var commentsID = 
      queuedStore.getLinkedRecordID('123', 'topLevelComments');
      expect(queuedStore.getField(commentsID, 'count')).toBe(1);

      // `records` is unchanged
      expect(storeData.getNodeData()).toEqual({ 
        '123': { 
          __dataID__: '123', 
          __typename: undefined } });});




    it(
    'writes optimistic payloads to `queuedRecords` even if values are ' + 
    'identical to those in `records`', 
    function () {var _payload3;
      // Example case: With a story unliked, quickly like and unlike it. The
      // second unlike will have the same value as the store
      // (`doesViewerLike === false`), but this must be recorded as an
      // optimistic value so that the first server payload (with the story
      // liked) is ignored.
      var storeData = new (require('RelayStoreData'))();

      // write starting values for a query
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})());










      var response = { 
        node: { 
          id: '123', 
          doesViewerLike: false, 
          topLevelComments: { 
            count: 1 }, 

          __typename: 'Story' } };


      storeData.handleQueryPayload(query, response);

      // write an optimistic update with the same values as the store
      var mutationQuery = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'feedbackLike', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'clientMutationId', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'doesViewerLike', kind: 'Field', metadata: {}, type: 'Boolean' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], kind: 'Mutation', metadata: { inputType: 'FeedbackLikeInput' }, name: 'RelayStoreData', responseType: 'FeedbackLikeResponsePayload' };})());













      var payload = (_payload3 = {}, _defineProperty(_payload3, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 'abc'), _defineProperty(_payload3, 'feedback', 
      { 
        id: '123', 
        doesViewerLike: false, 
        topLevelComments: { 
          count: 1 } }), _payload3);



      storeData.handleUpdatePayload(mutationQuery, payload, { 
        configs: [], 
        isOptimisticUpdate: true, 
        clientMutationID: 'mutationID' });


      // simulate a server response with different data
      response = { 
        node: { 
          id: '123', 
          doesViewerLike: true, // inverted
          topLevelComments: null } }; // delete


      storeData.handleQueryPayload(query, response);

      // verify that the optimistic update takes precedence over the
      // server update
      var recordStore = storeData.getQueuedStore();
      expect(recordStore.getField('123', 'doesViewerLike')).toBe(false);
      var commentsID = 
      recordStore.getLinkedRecordID('123', 'topLevelComments');
      expect(commentsID).toBeTruthy();
      expect(recordStore.getField(commentsID, 'count')).toBe(1);});});




  describe('buildFragmentQueryForDataID', function () {
    it('builds root queries for refetchable IDs', function () {
      var data = new (require('RelayStoreData'))();
      var fragment = getNode((function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }], id: 'cP6vzIQ80DOj:0', kind: 'Fragment', metadata: {}, name: 'RelayStoreDataRelayQL', type: 'User' };})());





      var query = data.buildFragmentQueryForDataID(
      fragment, 
      '123');

      expect(query).toEqualQueryRoot(getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: 'name', kind: 'Field', metadata: {}, type: 'String' }], id: 'F5G5ZCU/v+DN:0', kind: 'Fragment', metadata: {}, name: 'User', type: 'User' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})()));











      expect(query.getName()).toBe(fragment.getDebugName());
      expect(query.isAbstract()).toBe(true);});


    it('builds root queries using the path for non-refetchable IDs', function () {
      var storeData = new (require('RelayStoreData'))();
      var addressFragment = (function () {return { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }], id: 'Knbw+Uh26F3L:0', kind: 'Fragment', metadata: {}, name: 'RelayStoreDataRelayQL', type: 'User' };})();
      var node = getNode((function (RQL_0) {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: '123' } }], children: [].concat.apply([], [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, Relay.QL.__frag(RQL_0)]), fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})(



      addressFragment));



      var payload = { 
        node: { 
          id: '123', 
          __typename: 'User', 
          address: { 
            city: 'Menlo Park' } } };



      storeData.handleQueryPayload(node, payload);

      var fragment = getNode((function () {return { children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], id: 'a9ktneF2o0Qp:0', kind: 'Fragment', metadata: {}, name: 'RelayStoreDataRelayQL', type: 'StreetAddress' };})());




      var query = storeData.buildFragmentQueryForDataID(fragment, 'client:1');
      expect(query).toEqualQueryRoot(getVerbatimNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallVariable', callVariableName: 'id_0' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: {}, type: 'String' }, { children: [{ children: [{ fieldName: 'city', kind: 'Field', metadata: {}, type: 'String' }], id: 'L+OqdoB2wbDa:0', kind: 'Fragment', metadata: {}, name: 'StreetAddress', type: 'StreetAddress' }], fieldName: 'address', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'StreetAddress' }], id: 'L+OqdoB2wbDa:1', kind: 'Fragment', metadata: {}, name: 'User', type: 'User' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})(), 













      { id_0: '123' }));
      expect(query.getName()).toBe(node.getName());
      expect(query.isAbstract()).toBe(true);});});



  describe('garbage collection', function () {
    it('initializes the garbage collector if no data has been added', function () {
      var data = new (require('RelayStoreData'))();
      expect(data.getGarbageCollector()).toBe(undefined);
      expect(function () {return data.initializeGarbageCollector();}).not.toThrow();
      expect(
      data.getGarbageCollector() instanceof require('RelayGarbageCollector')).
      toBe(true);});


    it('warns if initialized after data has been added', function () {
      jest.mock('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning');

      var response = { node: { id: 0, __typename: 'User' } };
      var data = new (require('RelayStoreData'))();
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: 'a' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})());
      data.handleQueryPayload(query, response);

      var warningMsg = 
      'RelayStoreData: Garbage collection can only be initialized when ' + 
      'no data is present.';
      expect([warningMsg]).toBeWarnedNTimes(0);
      data.initializeGarbageCollector();
      expect([warningMsg]).toBeWarnedNTimes(1);});


    it(
    'registers created dataIDs in the garbage collector if it has been ' + 
    'initialized', 
    function () {
      require('RelayGarbageCollector').prototype.register = jest.genMockFunction();
      var response = { node: { id: 0 } };
      var data = new (require('RelayStoreData'))();
      data.initializeGarbageCollector();
      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: 'a' } }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'RelayStoreData', type: 'Node' };})());
      var garbageCollector = data.getGarbageCollector();

      expect(garbageCollector.register).not.toBeCalled();
      data.handleQueryPayload(query, response);
      expect(garbageCollector.register).toBeCalled();
      expect(garbageCollector.register.mock.calls[0][0]).toBe('a');});});});