'use strict';












require('configureForRelayOSS');

jest.
mock('warning').
dontMock('GraphQLQueryRunner').
dontMock('RelayTaskQueue');











describe('GraphQLQueryRunner',function(){
var networkLayer=undefined;
var queryRunner=undefined;
var pendingQueryTracker=undefined;

var mockCallback=undefined;
var mockQuerySet=undefined;var _RelayTestUtils=require('RelayTestUtils');var 

defer=_RelayTestUtils.defer;var getNode=_RelayTestUtils.getNode;





function deferQuery(relayQuery){
var node=babelHelpers.extends({},
relayQuery.getConcreteQueryNode(),{
isDeferred:true});

return getNode(node,relayQuery.getVariables());}


function mockSplitDeferredQueries(){
require('splitDeferredRelayQueries').mockImplementation(
function(query){return {
required:query,
deferred:[]};});}




beforeEach(function(){
jest.resetModuleRegistry();

var storeData=new (require('RelayStoreData'))();
networkLayer=storeData.getNetworkLayer();
queryRunner=storeData.getQueryRunner();
pendingQueryTracker=storeData.getPendingQueryTracker();

networkLayer.injectNetworkLayer({
supports:function(){return true;}});


mockCallback=jest.genMockFunction();
mockQuerySet={
foo:getNode(function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'name',kind:'Field',metadata:{},type:'String'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}()),
bar:getNode(function(){return {calls:[{kind:'Call',metadata:{type:'ID'},name:'id',value:{kind:'CallValue',callValue:'4'}}],children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'name',kind:'Field',metadata:{},type:'String'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'node',kind:'Query',metadata:{isAbstract:true,identifyingArgName:'id',identifyingArgType:'ID'},name:'GraphQLQueryRunner',type:'Node'};}()),
baz:null};


jasmine.addMatchers(require('RelayTestUtils').matchers);});


it('immediately succeeds for empty queries',function(){
queryRunner.run({},mockCallback);

expect(mockCallback).not.toBeCalled();
jest.runAllTimers();
expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:true,error:null,ready:true,stale:false}]]);});



it('immediately succeeds for no diff queries',function(){
require('diffRelayQuery').mockReturnValue([]);

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

var diffQueryCalls=require('diffRelayQuery').mock.calls;
expect(diffQueryCalls.length).toBe(2);
expect(diffQueryCalls[0][0]).toEqualQueryNode(mockQuerySet.foo);
expect(diffQueryCalls[1][0]).toEqualQueryNode(mockQuerySet.bar);
expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:true,error:null,ready:true,stale:false}]]);});



it('warns and uses fallback when defer is unsupported',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
require('checkRelayQueryData').mockImplementation(function(){return false;});
networkLayer.injectNetworkLayer({
supports:function(){return false;}});


var fragment=function(){return {children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],id:require('Relay').QL.__id(),kind:'Fragment',metadata:{isAbstract:true},name:'GraphQLQueryRunnerRelayQL',type:'Node'};}();
var querySet={
foo:getNode(function(RQL_0){return {calls:[{kind:'Call',metadata:{type:'ID'},name:'id',value:{kind:'CallValue',callValue:'123'}}],children:[].concat.apply([],[{fieldName:'id',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'ID'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'},require('Relay').QL.__frag(RQL_0)]),fieldName:'node',kind:'Query',metadata:{isAbstract:true,identifyingArgName:'id',identifyingArgType:'ID'},name:'GraphQLQueryRunner',type:'Node'};}(defer(fragment)))};


require('warning').mockClear();
queryRunner.run(querySet,mockCallback);
jest.runAllTimers();

expect(pendingQueryTracker.add.mock.calls.length).toBe(1);
expect(pendingQueryTracker.add.mock.calls[0][0].query).
toBe(querySet.foo);
expect(require('splitDeferredRelayQueries')).not.toBeCalled();
expect(require('warning').mock.calls[0]).toEqual([
false,
'Relay: Query `%s` contains a deferred fragment (e.g. '+
'`getFragment(\'foo\').defer()`) which is not supported by the '+
'default network layer. This query will be sent without deferral.',
querySet.foo.getName()]);});



it('is not ready if required data is being fetched',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
require('checkRelayQueryData').mockImplementation(function(){return false;});
mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}]]);});



it('adds all split and diff queries to the pending query tracker',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

expect(pendingQueryTracker.add.mock.calls.length).toBe(2);
expect(pendingQueryTracker.add.mock.calls[0][0].query).
toEqualQueryNode(mockQuerySet.foo);
expect(pendingQueryTracker.add.mock.calls[1][0].query).
toEqualQueryNode(mockQuerySet.bar);});


it('waits for all required data before being ready',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

pendingQueryTracker.add.mock.fetches[0].resolve();
jest.runAllTimers();
expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}]]);


pendingQueryTracker.add.mock.fetches[1].resolve();
jest.runAllTimers();
expect(mockCallback).lastCalledWith(
{aborted:false,done:true,error:null,ready:true,stale:false});});



it('throws to global if the callback throws',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
mockSplitDeferredQueries();

var mockError=new Error('Expected callback error.');
mockCallback.mockImplementation(function(){
throw mockError;});


queryRunner.run(mockQuerySet,mockCallback);
expect(function(){
jest.runAllTimers();}).
toThrow(mockError);});


it('is immediately ready for no required queries',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});

require('splitDeferredRelayQueries').mockImplementation(function(query){return {
required:null,
deferred:[{
required:deferQuery(query),
deferred:[]}]};});



queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:true,stale:false}]]);});



it('calls the callback for each deferred query',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
require('splitDeferredRelayQueries').mockImplementation(function(query){
if(query.getFieldName()==='viewer'){
return {
required:query,
deferred:[]};}else 

{

return {
query:null,
deferred:[{
required:deferQuery(query),
deferred:[]}]};}});





queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

pendingQueryTracker.add.mock.fetches[0].resolve();
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}],
[{aborted:false,done:false,error:null,ready:true,stale:false}]]);


pendingQueryTracker.add.mock.fetches[1].resolve();
jest.runAllTimers();

expect(mockCallback).lastCalledWith(
{aborted:false,done:true,error:null,ready:true,stale:false});});



it('calls the callback only once when completing all queries',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}]]);


pendingQueryTracker.add.mock.fetches[0].resolve();
pendingQueryTracker.add.mock.fetches[1].resolve();
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}],
[{aborted:false,done:true,error:null,ready:true,stale:false}]]);});



it('is done after all data is fetched',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

pendingQueryTracker.add.mock.fetches[0].resolve();
pendingQueryTracker.add.mock.fetches[1].resolve();
jest.runAllTimers();

expect(mockCallback).lastCalledWith(
{aborted:false,done:true,error:null,ready:true,stale:false});});



it('calls the callback when aborted',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback).abort();
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:true,done:false,error:null,ready:false,stale:false}]]);});



it('is ready if required data is in disk cache',function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});
require('RelayStoreData').prototype.hasCacheManager=
jest.genMockFunction().mockImplementation(function(){return true;});
require('RelayStoreData').prototype.readFromDiskCache=
jest.genMockFunction().mockImplementation(function(queries,callback){
callback.onSuccess();});

mockSplitDeferredQueries();

queryRunner.run(mockQuerySet,mockCallback);
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}],
[{aborted:false,done:false,error:null,ready:true,stale:true}]]);});



it('adds query on `forceFetch` even if there are no diff queries',function(){
require('diffRelayQuery').mockImplementation(function(query){return [];});
mockSplitDeferredQueries();

var singleMockQuery={foo:mockQuerySet.foo};
queryRunner.forceFetch(singleMockQuery,mockCallback);
jest.runAllTimers();

expect(pendingQueryTracker.add.mock.calls.length).toBe(1);
expect(pendingQueryTracker.add.mock.calls[0][0].query).
toEqualQueryNode(singleMockQuery.foo);});


it('is completely ready on `forceFetch` when all data is available',function(){
require('diffRelayQuery').mockImplementation(function(){return [];});
require('checkRelayQueryData').mockImplementation(function(){return true;});
mockSplitDeferredQueries();
var singleMockQuery={foo:mockQuerySet.foo};
queryRunner.forceFetch(singleMockQuery,mockCallback);
jest.runAllTimers();

expect(mockCallback.mock.calls).toEqual([
[{aborted:false,done:false,error:null,ready:false,stale:false}],
[{aborted:false,done:false,error:null,ready:true,stale:true}]]);

expect(pendingQueryTracker.add.mock.calls.length).toBe(1);

pendingQueryTracker.add.mock.fetches[0].resolve();
jest.runAllTimers();

expect(mockCallback).lastCalledWith(
{aborted:false,done:true,error:null,ready:true,stale:false});});



describe('Batch callback for multiple queries',function(){
var runTest=undefined;
var fetchMode=undefined;
beforeEach(function(){
require('diffRelayQuery').mockImplementation(function(query){return [query];});

var mockQuery=getNode(function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'firstName',kind:'Field',metadata:{},type:'String'},{fieldName:'lastName',kind:'Field',metadata:{},type:'String'},{fieldName:'name',kind:'Field',metadata:{},type:'String'},{children:[{fieldName:'city',kind:'Field',metadata:{},type:'String'}],fieldName:'address',kind:'Field',metadata:{canHaveSubselections:true},type:'StreetAddress'},{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'}],fieldName:'hometown',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id'},type:'Page'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}());





var mockSplitQueries={
required:getNode(function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'name',kind:'Field',metadata:{},type:'String'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}()),




deferred:[function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{children:[{fieldName:'city',kind:'Field',metadata:{},type:'String'}],fieldName:'address',kind:'Field',metadata:{canHaveSubselections:true},type:'StreetAddress'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}(),function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'}],fieldName:'hometown',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id'},type:'Page'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}(),function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'firstName',kind:'Field',metadata:{},type:'String'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}(),function(){return {children:[{children:[{fieldName:'id',kind:'Field',metadata:{isRequisite:true},type:'ID'},{fieldName:'lastName',kind:'Field',metadata:{},type:'String'},{fieldName:'__typename',kind:'Field',metadata:{isGenerated:true,isRequisite:true},type:'String'}],fieldName:'actor',kind:'Field',metadata:{canHaveSubselections:true,inferredRootCallName:'node',inferredPrimaryKey:'id',isAbstract:true},type:'Actor'}],fieldName:'viewer',kind:'Query',metadata:{},name:'GraphQLQueryRunner',type:'Viewer'};}()].




















map(function(query){return {
required:deferQuery(getNode(query)),
deferred:[]};})};



require('splitDeferredRelayQueries').mockImplementation(function(query){
expect(query).toEqualQueryNode(mockQuery);
return mockSplitQueries;});


var resolveSplitQueryByIndex=function(index){
pendingQueryTracker.add.mock.fetches[index].resolve();};

runTest=function(){
queryRunner.run(
{foo:mockQuery},
mockCallback,
fetchMode);

resolveSplitQueryByIndex(1);
resolveSplitQueryByIndex(0);
jest.runAllTimers();

var defaultState={
aborted:false,
done:false,
error:null,
ready:false,
stale:false};



expect(mockCallback.mock.calls).toEqual([
[babelHelpers.extends({},defaultState)],
[babelHelpers.extends({},defaultState,{ready:true})]]);


resolveSplitQueryByIndex(2);
resolveSplitQueryByIndex(3);
jest.runAllTimers();


expect(mockCallback.mock.calls).toEqual([
[babelHelpers.extends({},defaultState,{ready:false})],
[babelHelpers.extends({},defaultState,{ready:true})],
[babelHelpers.extends({},defaultState,{ready:true})]]);


resolveSplitQueryByIndex(4);
jest.runAllTimers();

expect(mockCallback).lastCalledWith(babelHelpers.extends({},
defaultState,{done:true,ready:true}));};});




it('does in preload mode',function(){
fetchMode=require('RelayFetchMode').PRELOAD;
runTest();});


it('does in client mode',function(){
fetchMode=require('RelayFetchMode').CLIENT;
runTest();});});});