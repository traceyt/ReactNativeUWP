/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @emails oncall+relay
 */

'use strict';function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}

require('configureForRelayOSS');

jest.
dontMock('GraphQLRange').
dontMock('GraphQLSegment').
mock('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning');















describe('writePayload()', function () {var 
  getNode = require('RelayTestUtils').getNode;var writePayload = require('RelayTestUtils').writePayload;

  beforeEach(function () {
    jest.resetModuleRegistry();

    jasmine.addMatchers(require('RelayTestUtils').matchers);});


  describe('range delete mutations', function () {
    var store, queueStore, writer, queueWriter, commentID, connectionID, edgeID;

    beforeEach(function () {
      var records = {};
      var queuedRecords = {};
      var nodeConnectionMap = {};
      var rootCallMap = {};
      var rootCallMaps = { rootCallMap: rootCallMap };

      commentID = '123';

      store = new (require('RelayRecordStore'))(
      { records: records }, 
      rootCallMaps, 
      nodeConnectionMap);

      queueStore = new (require('RelayRecordStore'))(
      { records: records, queuedRecords: queuedRecords }, 
      rootCallMaps, 
      nodeConnectionMap);

      writer = new (require('RelayRecordWriter'))(
      records, 
      rootCallMap, 
      false, 
      nodeConnectionMap);

      queueWriter = new (require('RelayRecordWriter'))(
      queuedRecords, 
      rootCallMap, 
      true, 
      nodeConnectionMap, 
      null, 
      'mutationID');


      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: 'feedback_id' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }, { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'CommentsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayUpdatePayload', type: 'Node' };})());













      var payload = { 
        node: { 
          id: 'feedback_id', 
          topLevelComments: { 
            count: 1, 
            edges: [
            { 
              cursor: commentID + ':cursor', 
              node: { 
                id: commentID } }] } } };






      writePayload(store, writer, query, payload);
      connectionID = store.getLinkedRecordID(
      'feedback_id', 
      'topLevelComments');

      edgeID = require('generateClientEdgeID')(connectionID, commentID);});


    it('optimistically removes range edges', function () {var _input, _payload, _updated;
      // create the mutation and payload
      var input = (_input = {}, _defineProperty(_input, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input, 'deletedCommentId', 
      commentID), _input);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentDelete', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'deletedCommentId', kind: 'Field', metadata: {}, type: 'ID' }, { children: [{ children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentDeleteInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentDeleteResponsePayload' };})(), 










      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').RANGE_DELETE, 
        deletedIDFieldName: 'deletedCommentId', 
        pathToConnection: ['feedback', 'topLevelComments'] }];


      var payload = (_payload = {}, _defineProperty(_payload, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload, 'deletedCommentId', 
      commentID), _defineProperty(_payload, 'feedback', 
      { 
        id: 'feedback_id', 
        topLevelComments: { 
          count: 0 } }), _payload);




      // write to the queued store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      queueStore, 
      queueWriter, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: true });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated = {}, _defineProperty(_updated, 
        connectionID, true), _defineProperty(_updated, 
        edgeID, true), _updated) }); // edge deleted
      // `commentID` is not modified



      expect(queueStore.getField(connectionID, 'count')).toBe(0);
      expect(queueStore.getRecordState(edgeID)).toBe('NONEXISTENT');
      expect(queueStore.getRecordState(commentID)).toBe('EXISTENT');
      // the range no longer returns this edge
      expect(queueStore.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '1' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([]);

      expect(store.getField(connectionID, 'count')).toBe(1);
      expect(store.getRecordState(edgeID)).toBe('EXISTENT');
      // the range still contains this edge
      expect(store.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '1' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      edgeID]);});



    it('non-optimistically removes range edges', function () {var _input2, _payload2, _updated2;
      // create the mutation and payload
      var input = (_input2 = {}, _defineProperty(_input2, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input2, 'deletedCommentId', 
      commentID), _input2);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentDelete', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'deletedCommentId', kind: 'Field', metadata: {}, type: 'ID' }, { children: [{ children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentDeleteInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentDeleteResponsePayload' };})(), 










      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').RANGE_DELETE, 
        deletedIDFieldName: 'deletedCommentId', 
        pathToConnection: ['feedback', 'topLevelComments'] }];


      var payload = (_payload2 = {}, _defineProperty(_payload2, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload2, 'deletedCommentId', 
      commentID), _defineProperty(_payload2, 'feedback', 
      { 
        id: 'feedback_id', 
        topLevelComments: { 
          count: 0 } }), _payload2);




      // write to the queued store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      store, 
      writer, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: false });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated2 = {}, _defineProperty(_updated2, 
        connectionID, true), _defineProperty(_updated2, 
        edgeID, true), _updated2) }); // edge deleted
      // `commentID` is not modified



      expect(store.getField(connectionID, 'count')).toBe(0);
      expect(store.getRecordState(edgeID)).toBe('NONEXISTENT');
      expect(store.getRecordState(commentID)).toBe('EXISTENT');
      // the range no longer returns this edge
      expect(store.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '1' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([]);});


    it('removes range edge with a "deleted field ID path"', function () {var _input3, _payload3, _updated3;
      writePayload(
      store, 
      writer, 
      getNode((function () {return { children: [{ children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }], fieldName: 'viewer', kind: 'Query', metadata: {}, name: 'WriteRelayUpdatePayload', type: 'Viewer' };})()), 














      { 
        viewer: { 
          actor: { 
            id: '123', 
            friends: { 
              edges: [
              { 
                node: { 
                  id: '456' } }] } } } });








      var friendConnectionID = store.getLinkedRecordID('123', 'friends');
      var friendEdgeID = require('generateClientEdgeID')(friendConnectionID, '456');

      var input = (_input3 = {}, _defineProperty(_input3, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input3, 'friendId', 
      '456'), _input3);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'unfriend', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'User' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'FriendsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'friends', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true, isFindable: true }, type: 'FriendsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'actor', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isAbstract: true }, type: 'Actor' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'formerFriend', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'User' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'UnfriendInput' }, name: 'WriteRelayUpdatePayload', responseType: 'UnfriendResponsePayload' };})(), 
















      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').RANGE_DELETE, 
        parentName: 'actor', 
        parentID: '123', 
        connectionName: 'friends', 
        deletedIDFieldName: ['formerFriend'], 
        pathToConnection: ['actor', 'friends'] }];


      var payload = (_payload3 = {}, _defineProperty(_payload3, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload3, 'actor', 
      { 
        id: '123', 
        friends: { 
          edges: [] } }), _defineProperty(_payload3, 'formerFriend', 


      { 
        id: '456' }), _payload3);


      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      store, 
      writer, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: false });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated3 = {}, _defineProperty(_updated3, 
        friendConnectionID, true), _defineProperty(_updated3, 
        friendEdgeID, true), _updated3) });



      expect(store.getRecordState(friendEdgeID)).toBe('NONEXISTENT');
      expect(store.getRecordState('456')).toBe('EXISTENT');
      // the range no longer returns this edge
      expect(store.getRangeMetadata(
      friendConnectionID, 
      [{ name: 'first', value: '1' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([]);});});



  describe('node/range delete mutations', function () {
    var store, queueStore, writer, queueWriter, feedbackID, connectionID, 
    firstCommentID, secondCommentID, firstEdgeID, secondEdgeID;

    beforeEach(function () {
      var records = {};
      var queuedRecords = {};
      var nodeConnectionMap = {};
      var rootCallMap = {};
      var rootCallMaps = { rootCallMap: rootCallMap };

      feedbackID = 'feedback123';
      firstCommentID = 'comment456';
      secondCommentID = 'comment789';
      store = new (require('RelayRecordStore'))(
      { records: records }, 
      rootCallMaps, 
      nodeConnectionMap);

      queueStore = new (require('RelayRecordStore'))(
      { records: records, queuedRecords: queuedRecords }, 
      rootCallMaps, 
      nodeConnectionMap);

      writer = new (require('RelayRecordWriter'))(
      records, 
      rootCallMap, 
      false, 
      nodeConnectionMap);

      queueWriter = new (require('RelayRecordWriter'))(
      queuedRecords, 
      rootCallMap, 
      true, 
      nodeConnectionMap, 
      null, 
      'mutationID');


      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: 'feedback123' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }, { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'CommentsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayUpdatePayload', type: 'Node' };})());













      var payload = { 
        node: { 
          id: feedbackID, 
          topLevelComments: { 
            count: 1, 
            edges: [
            { 
              cursor: firstCommentID + ':cursor', 
              node: { 
                id: firstCommentID } }, 


            { 
              cursor: secondCommentID + ':cursor', 
              node: { 
                id: secondCommentID } }] } } };







      writePayload(store, writer, query, payload);
      connectionID = store.getLinkedRecordID(feedbackID, 'topLevelComments');
      firstEdgeID = require('generateClientEdgeID')(connectionID, firstCommentID);
      secondEdgeID = require('generateClientEdgeID')(connectionID, secondCommentID);});


    it('optimistically deletes comments', function () {var _input4, _payload4, _updated4;
      // create the mutation and payload
      var input = (_input4 = { 
        actor_id: 'actor:123' }, _defineProperty(_input4, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input4, 'deletedCommentId', 
      firstCommentID), _input4);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentDelete', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'deletedCommentId', kind: 'Field', metadata: {}, type: 'ID' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentDeleteInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentDeleteResponsePayload' };})(), 











      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').NODE_DELETE, 
        deletedIDFieldName: 'deletedCommentId' }];


      var payload = (_payload4 = {}, _defineProperty(_payload4, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload4, 'deletedCommentId', 
      firstCommentID), _defineProperty(_payload4, 'feedback', 
      { 
        id: feedbackID, 
        topLevelComments: { 
          count: 0 } }), _payload4);




      // write to the queued store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      queueStore, 
      queueWriter, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: true });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated4 = {}, _defineProperty(_updated4, 
        connectionID, true), _defineProperty(_updated4, 
        firstEdgeID, true), _defineProperty(_updated4, 
        firstCommentID, true), _updated4) });



      // node is deleted
      // node deleted
      expect(queueStore.getRecordState(firstCommentID)).toBe('NONEXISTENT');expect(queueStore.getRecordState(secondCommentID)).toBe('EXISTENT');
      // corresponding edge is deleted for every range this node appears in
      expect(queueStore.getRecordState(firstEdgeID)).toBe('NONEXISTENT');
      expect(queueStore.getRecordState(secondEdgeID)).toBe('EXISTENT');
      // the range no longer returns this edge
      expect(queueStore.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '2' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      secondEdgeID]);

      // connection metadata is merged into the queued store
      expect(queueStore.getField(connectionID, 'count')).toBe(0);

      // base records are not modified: node & edge exist, the edge is still
      // in the range, and the connection metadata is unchanged
      expect(store.getRecordState(firstCommentID)).toBe('EXISTENT');
      expect(store.getRecordState(secondCommentID)).toBe('EXISTENT');
      expect(store.getRecordState(firstEdgeID)).toBe('EXISTENT');
      expect(store.getRecordState(secondEdgeID)).toBe('EXISTENT');
      expect(store.getField(connectionID, 'count')).toBe(1);
      expect(store.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '2' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      firstEdgeID, 
      secondEdgeID]);});



    it('non-optimistically deletes comments', function () {var _input5, _payload5, _updated5;
      // create the mutation and payload
      var input = (_input5 = { 
        actor_id: 'actor:123' }, _defineProperty(_input5, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input5, 'deletedCommentId', 
      firstCommentID), _input5);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentDelete', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'deletedCommentId', kind: 'Field', metadata: {}, type: 'ID' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentDeleteInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentDeleteResponsePayload' };})(), 











      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').NODE_DELETE, 
        deletedIDFieldName: 'deletedCommentId' }];


      var payload = (_payload5 = {}, _defineProperty(_payload5, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload5, 'deletedCommentId', 
      firstCommentID), _defineProperty(_payload5, 'feedback', 
      { 
        id: feedbackID, 
        topLevelComments: { 
          count: 0 } }), _payload5);




      // write to the base store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      store, 
      writer, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: false });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated5 = {}, _defineProperty(_updated5, 
        connectionID, true), _defineProperty(_updated5, 
        firstEdgeID, true), _defineProperty(_updated5, 
        firstCommentID, true), _updated5) });



      // node is deleted
      // node deleted
      expect(store.getRecordState(firstCommentID)).toBe('NONEXISTENT');expect(store.getRecordState(secondCommentID)).toBe('EXISTENT');
      // corresponding edge is deleted for every range this node appears in
      expect(store.getRecordState(firstEdgeID)).toBe('NONEXISTENT');
      expect(store.getRecordState(secondEdgeID)).toBe('EXISTENT');
      // the range no longer returns this edge
      expect(store.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '1' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      secondEdgeID]);

      // connection metadata is merged into the queued store
      expect(store.getField(connectionID, 'count')).toBe(0);});});



  describe('plural node delete mutation', function () {
    var store, queueStore, writer, queueWriter, firstRequestID, secondRequestID, 
    thirdRequestID;

    beforeEach(function () {
      var records = {};
      var queuedRecords = {};
      var rootCallMap = {};
      var rootCallMaps = { rootCallMap: rootCallMap };

      firstRequestID = 'request1';
      secondRequestID = 'request2';
      thirdRequestID = 'request3';

      store = new (require('RelayRecordStore'))(
      { records: records }, 
      rootCallMaps, 
      {});

      queueStore = new (require('RelayRecordStore'))(
      { records: records, queuedRecords: queuedRecords }, 
      rootCallMaps, 
      {});

      writer = new (require('RelayRecordWriter'))(
      records, 
      rootCallMap, 
      false);

      queueWriter = new (require('RelayRecordWriter'))(
      queuedRecords, 
      rootCallMap, 
      true, 
      {}, 
      null, 
      'mutationID');


      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'ids', value: [{ kind: 'CallValue', callValue: 'request1' }, { kind: 'CallValue', callValue: 'request2' }, { kind: 'CallValue', callValue: 'request3' }] }], children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'nodes', kind: 'Query', metadata: { isPlural: true, isAbstract: true, identifyingArgName: 'ids' }, name: 'WriteRelayUpdatePayload', type: 'Node' };})());






      var payload = { 
        nodes: [
        { id: firstRequestID }, 
        { id: secondRequestID }, 
        { id: thirdRequestID }] };



      writePayload(store, writer, query, payload);});


    it('optimistically deletes requests', function () {var _input6, _payload6, _updated6;
      // create the mutation and payload
      var input = (_input6 = { 
        actor_id: 'actor:123' }, _defineProperty(_input6, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input6, 'deletedRequestIds', 
      [firstRequestID, secondRequestID]), _input6);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'applicationRequestDeleteAll', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'deletedRequestIds', kind: 'Field', metadata: { isPlural: true }, type: 'ID' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'ApplicationRequestDeleteAllInput' }, name: 'WriteRelayUpdatePayload', responseType: 'ApplicationRequestDeleteAllResponsePayload' };})(), 





      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').NODE_DELETE, 
        deletedIDFieldName: 'deletedRequestIds' }];


      var payload = (_payload6 = {}, _defineProperty(_payload6, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload6, 'deletedRequestIds', 
      [firstRequestID, secondRequestID]), _payload6);


      // write to the queued store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      queueStore, 
      queueWriter, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: true });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated6 = {}, _defineProperty(_updated6, 
        firstRequestID, true), _defineProperty(_updated6, 
        secondRequestID, true), _updated6) });



      // node is deleted
      // node deleted
      expect(queueStore.getRecordState(firstRequestID)).toBe('NONEXISTENT');expect(queueStore.getRecordState(secondRequestID)).toBe('NONEXISTENT');
      // third node is not deleted
      expect(queueStore.getRecordState(thirdRequestID)).toBe('EXISTENT');

      // base records are not modified: node & edge exist, the edge is still
      // in the range, and the connection metadata is unchanged
      expect(store.getRecordState(firstRequestID)).toBe('EXISTENT');
      expect(store.getRecordState(secondRequestID)).toBe('EXISTENT');
      expect(store.getRecordState(thirdRequestID)).toBe('EXISTENT');});


    it('non-optimistically deletes requests', function () {var _input7, _payload7, _updated7;
      // create the mutation and payload
      var input = (_input7 = { 
        actor_id: 'actor:123' }, _defineProperty(_input7, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input7, 'deletedRequestIds', 
      [firstRequestID, secondRequestID]), _input7);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'applicationRequestDeleteAll', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ fieldName: 'deletedRequestIds', kind: 'Field', metadata: { isPlural: true }, type: 'ID' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'ApplicationRequestDeleteAllInput' }, name: 'WriteRelayUpdatePayload', responseType: 'ApplicationRequestDeleteAllResponsePayload' };})(), 





      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').NODE_DELETE, 
        deletedIDFieldName: 'deletedRequestIds' }];


      var payload = (_payload7 = {}, _defineProperty(_payload7, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload7, 'deletedRequestIds', 
      [firstRequestID, secondRequestID]), _payload7);


      // write to the base store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      store, 
      writer, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: false });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: {}, 
        updated: (_updated7 = {}, _defineProperty(_updated7, 
        firstRequestID, true), _defineProperty(_updated7, 
        secondRequestID, true), _updated7) });



      // node is deleted
      expect(store.getRecordState(firstRequestID)).toBe('NONEXISTENT');
      expect(store.getRecordState(secondRequestID)).toBe('NONEXISTENT');
      // third node is not deleted
      expect(store.getRecordState(thirdRequestID)).toBe('EXISTENT');});});



  describe('range add mutations', function () {
    var store, queueStore, writer, queueWriter, feedbackID, connectionID, 
    commentID, edgeID;

    beforeEach(function () {
      var records = {};
      var queuedRecords = {};
      var nodeConnectionMap = {};
      var rootCallMap = {};
      var rootCallMaps = { rootCallMap: rootCallMap };

      feedbackID = 'feedback123';
      commentID = 'comment456';
      store = new (require('RelayRecordStore'))(
      { records: records }, 
      rootCallMaps, 
      nodeConnectionMap);

      queueStore = new (require('RelayRecordStore'))(
      { records: records, queuedRecords: queuedRecords }, 
      rootCallMaps, 
      nodeConnectionMap);

      writer = new (require('RelayRecordWriter'))(
      records, 
      rootCallMap, 
      false, 
      nodeConnectionMap);

      queueWriter = new (require('RelayRecordWriter'))(
      queuedRecords, 
      rootCallMap, 
      true, 
      nodeConnectionMap, 
      null, 
      'mutationID');


      var query = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'id', value: { kind: 'CallValue', callValue: 'feedback123' } }], children: [{ calls: [{ kind: 'Call', metadata: {}, name: 'first', value: { kind: 'CallValue', callValue: '1' } }], children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }, { children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { fieldName: 'cursor', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'edges', kind: 'Field', metadata: { canHaveSubselections: true, isPlural: true }, type: 'CommentsEdge' }, { children: [{ fieldName: 'hasNextPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }, { fieldName: 'hasPreviousPage', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'Boolean' }], fieldName: 'pageInfo', kind: 'Field', metadata: { canHaveSubselections: true, isGenerated: true, isRequisite: true }, type: 'PageInfo' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }, { fieldName: 'id', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'ID' }, { fieldName: '__typename', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], fieldName: 'node', kind: 'Query', metadata: { isAbstract: true, identifyingArgName: 'id' }, name: 'WriteRelayUpdatePayload', type: 'Node' };})());













      var payload = { 
        node: { 
          id: feedbackID, 
          topLevelComments: { 
            count: 1, 
            edges: [
            { 
              cursor: commentID + ':cursor', 
              node: { 
                id: commentID } }] } } };







      writePayload(store, writer, query, payload);
      connectionID = store.getLinkedRecordID(feedbackID, 'topLevelComments');
      edgeID = require('generateClientEdgeID')(connectionID, commentID);});


    it('warns if the created `edge` field is missing in the payload', function () {var _input8, _payload8;
      var input = (_input8 = { 
        actor_id: 'actor:123' }, _defineProperty(_input8, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input8, 'feedback_id', 
      feedbackID), _input8);

      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentCreateResponsePayload' };})(), 










      { input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').RANGE_ADD, 
        connectionName: 'topLevelComments', 
        edgeName: 'feedbackCommentEdge', 
        rangeBehaviors: { '': require('GraphQLMutatorConstants').PREPEND } }];

      var payload = (_payload8 = {}, _defineProperty(_payload8, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload8, 'feedback', 
      { 
        id: feedbackID, 
        topLevelComments: { 
          count: 2 } }), _payload8);




      // write to queued store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      queueStore, 
      queueWriter, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: true });


      expect([
      'writeRelayUpdatePayload(): Expected response payload to include the ' + 
      'newly created edge `%s` and its `node` field. Did you forget to ' + 
      'update the `RANGE_ADD` mutation config?', 
      'feedbackCommentEdge']).
      toBeWarnedNTimes(1);

      // feedback is updated, but the edge is not added
      expect(queueStore.getField(connectionID, 'count')).toBe(2);
      expect(queueStore.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '2' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([edgeID]);});


    it('optimistically prepends comments', function () {var _input9, _payload9, _created;
      // create the mutation and payload
      var input = (_input9 = { 
        actor_id: 'actor:123' }, _defineProperty(_input9, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input9, 'feedback_id', 
      feedbackID), _defineProperty(_input9, 'message', 
      { 
        text: 'Hello!', 
        ranges: [] }), _input9);



      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { children: [{ fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'text', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'body', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Text' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'source', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], fieldName: 'feedbackCommentEdge', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'CommentsEdge' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentCreateResponsePayload' };})(), 






















      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').RANGE_ADD, 
        connectionName: 'topLevelComments', 
        edgeName: 'feedbackCommentEdge', 
        rangeBehaviors: { '': require('GraphQLMutatorConstants').PREPEND } }];


      var nextCursor = 'comment789:cursor';
      var nextNodeID = 'comment789';
      var bodyID = 'client:2';
      var nextEdgeID = require('generateClientEdgeID')(connectionID, nextNodeID);
      var payload = (_payload9 = {}, _defineProperty(_payload9, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload9, 'feedback', 
      { 
        id: feedbackID, 
        topLevelComments: { 
          count: 2 } }), _defineProperty(_payload9, 'feedbackCommentEdge', 


      { 
        cursor: nextCursor, 
        node: { 
          id: nextNodeID, 
          body: { 
            text: input.message.text } }, 


        source: { 
          id: feedbackID } }), _payload9);




      // write to queued store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      queueStore, 
      queueWriter, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: true });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: (_created = {}, _defineProperty(_created, 
        nextNodeID, true), _defineProperty(_created, 
        nextEdgeID, true), _defineProperty(_created, 
        bodyID, true), _created), // `body` subfield

        updated: _defineProperty({}, 
        connectionID, true) });



      // queued records are updated: edge/node added
      // range item added & count changed
      expect(queueStore.getField(connectionID, 'count')).toBe(2);expect(queueStore.getLinkedRecordID(nextEdgeID, 'source')).toBe(
      feedbackID);

      expect(queueStore.getField(nextEdgeID, 'cursor')).toBe(nextCursor);
      expect(queueStore.getLinkedRecordID(nextEdgeID, 'node')).toBe(nextNodeID);
      expect(queueStore.getField(nextNodeID, 'id')).toBe(nextNodeID);
      expect(queueStore.getLinkedRecordID(nextNodeID, 'body')).toBe(bodyID);
      expect(queueStore.getField(bodyID, 'text')).toBe(input.message.text);
      expect(queueStore.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '2' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      nextEdgeID, 
      edgeID]);


      // base records are not modified
      expect(store.getField(connectionID, 'count')).toBe(1);
      expect(store.getRecordState(nextEdgeID)).toBe('UNKNOWN');
      expect(store.getRecordState(nextNodeID)).toBe('UNKNOWN');
      expect(store.getRecordState(bodyID)).toBe('UNKNOWN');
      expect(store.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '2' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      edgeID]);});



    it('non-optimistically prepends comments', function () {var _input10, _payload10, _created2;
      // create the mutation and payload
      var input = (_input10 = { 
        actor_id: 'actor:123' }, _defineProperty(_input10, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, '0'), _defineProperty(_input10, 'feedback_id', 
      feedbackID), _defineProperty(_input10, 'message', 
      { 
        text: 'Hello!', 
        ranges: [] }), _input10);



      var mutation = getNode((function () {return { calls: [{ kind: 'Call', metadata: {}, name: 'commentCreate', value: { kind: 'CallVariable', callVariableName: 'input' } }], children: [{ children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'count', kind: 'Field', metadata: {}, type: 'Int' }], fieldName: 'topLevelComments', kind: 'Field', metadata: { canHaveSubselections: true, isConnection: true }, type: 'TopLevelCommentsConnection' }], fieldName: 'feedback', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }, { children: [{ fieldName: 'cursor', kind: 'Field', metadata: { isRequisite: true }, type: 'String' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }, { children: [{ fieldName: 'text', kind: 'Field', metadata: {}, type: 'String' }], fieldName: 'body', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'Text' }], fieldName: 'node', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id', isRequisite: true }, type: 'Comment' }, { children: [{ fieldName: 'id', kind: 'Field', metadata: { isRequisite: true }, type: 'ID' }], fieldName: 'source', kind: 'Field', metadata: { canHaveSubselections: true, inferredRootCallName: 'node', inferredPrimaryKey: 'id' }, type: 'Feedback' }], fieldName: 'feedbackCommentEdge', kind: 'Field', metadata: { canHaveSubselections: true }, type: 'CommentsEdge' }, { fieldName: 'clientMutationId', kind: 'Field', metadata: { isGenerated: true, isRequisite: true }, type: 'String' }], kind: 'Mutation', metadata: { inputType: 'CommentCreateInput' }, name: 'WriteRelayUpdatePayload', responseType: 'CommentCreateResponsePayload' };})(), 






















      { 
        input: JSON.stringify(input) });

      var configs = [{ 
        type: require('RelayMutationType').RANGE_ADD, 
        connectionName: 'topLevelComments', 
        edgeName: 'feedbackCommentEdge', 
        rangeBehaviors: { '': require('GraphQLMutatorConstants').PREPEND } }];


      var nextCursor = 'comment789:cursor';
      var nextNodeID = 'comment789';
      var bodyID = 'client:2';
      var nextEdgeID = require('generateClientEdgeID')(connectionID, nextNodeID);
      var payload = (_payload10 = {}, _defineProperty(_payload10, 
      require('RelayConnectionInterface').CLIENT_MUTATION_ID, 
      input[require('RelayConnectionInterface').CLIENT_MUTATION_ID]), _defineProperty(_payload10, 'feedback', 
      { 
        id: feedbackID, 
        topLevelComments: { 
          count: 2 } }), _defineProperty(_payload10, 'feedbackCommentEdge', 


      { 
        cursor: nextCursor, 
        node: { 
          id: nextNodeID, 
          body: { 
            text: input.message.text } }, 


        source: { 
          id: feedbackID } }), _payload10);




      // write to base store
      var changeTracker = new (require('RelayChangeTracker'))();
      var queryTracker = new (require('RelayQueryTracker'))();
      var queryWriter = new (require('RelayQueryWriter'))(
      store, 
      writer, 
      queryTracker, 
      changeTracker);


      require('writeRelayUpdatePayload')(
      queryWriter, 
      mutation, 
      payload, 
      { configs: configs, isOptimisticUpdate: false });


      expect(changeTracker.getChangeSet()).toEqual({ 
        created: (_created2 = {}, _defineProperty(_created2, 
        nextNodeID, true), _defineProperty(_created2, 
        nextEdgeID, true), _defineProperty(_created2, 
        bodyID, true), _created2), // `body` subfield

        updated: _defineProperty({}, 
        connectionID, true) });



      // base records are updated: edge/node added
      // range item added & count changed
      expect(store.getField(connectionID, 'count')).toBe(2);expect(store.getLinkedRecordID(nextEdgeID, 'source')).toBe(
      feedbackID);

      expect(store.getField(nextEdgeID, 'cursor')).toBe(nextCursor);
      expect(store.getLinkedRecordID(nextEdgeID, 'node')).toBe(nextNodeID);
      expect(store.getField(nextNodeID, 'id')).toBe(nextNodeID);
      expect(store.getType(nextNodeID)).toBe('Comment');
      expect(store.getLinkedRecordID(nextNodeID, 'body')).toBe(bodyID);
      expect(store.getField(bodyID, 'text')).toBe(input.message.text);
      expect(store.getRangeMetadata(
      connectionID, 
      [{ name: 'first', value: '2' }]).
      filteredEdges.map(function (edge) {return edge.edgeID;})).toEqual([
      nextEdgeID, 
      edgeID]);});});}); // range edge deleted & count changed
// range edge deleted & count changed
// range item deleted & count changed
// edge deleted
// range item deleted & count changed
// edge deleted
// node deleted
// node deleted
// node added
// edge added
// node added
// edge added