'use strict';










var t=require('babel-core').types;

var isLiteral=function(binaryExpression){return (
t.isLiteral(binaryExpression.left)&&t.isLiteral(binaryExpression.right));};

var Conditional={
exit:function(path){
var node=path.node;
var test=node.test;
if(t.isLiteral(test)){
if(test.value||node.alternate){
path.replaceWith(test.value?node.consequent:node.alternate);}else 
if(!test.value){
path.remove();}}}};





var plugin={
visitor:{
BinaryExpression:{
exit:function(path){
var node=path.node;
if(t.isLiteral(node.left)&&t.isLiteral(node.right)){
var result=path.evaluate();
if(result.confident){
path.replaceWith(t.valueToNode(result.value));}}}},




ConditionalExpression:Conditional,
IfStatement:Conditional,
LogicalExpression:{
exit:function(path){
var node=path.node;
var left=node.left;
if(t.isLiteral(left)){
var value=t.isNullLiteral(left)?null:left.value;
if(node.operator==='||'){
path.replaceWith(value?left:node.right);}else 
{
path.replaceWith(value?node.right:left);}}}},




UnaryExpression:{
exit:function(path){
var node=path.node;
if(node.operator==='!'&&t.isLiteral(node.argument)){
path.replaceWith(t.valueToNode(!node.argument.value));}}}}};






function constantFolding(filename,transformResult){
return require('babel-core').transformFromAst(transformResult.ast,transformResult.code,{
filename:filename,
plugins:[plugin],
inputSourceMap:transformResult.map,
sourceMaps:true,
sourceFileName:filename,
babelrc:false,
compact:true,
retainLines:true});}



module.exports=constantFolding;