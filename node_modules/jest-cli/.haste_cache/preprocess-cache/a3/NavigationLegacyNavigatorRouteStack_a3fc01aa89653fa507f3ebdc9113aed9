'use strict';
















function isRouteEmpty(route){
return route===undefined||route===null||route===''||false;}


function areRouteNodesEqual(
one,
two)
{
if(one===two){
return true;}


if(one.length!==two.length){
return false;}

for(var ii=0,jj=one.length;ii<jj;ii++){
if(one[ii]!==two[ii]){
return false;}}


return true;}


var _nextRouteNodeID=0;var 




RouteNode=function(){babelHelpers.createClass(RouteNode,null,[{key:'fromNavigationState',value:function fromNavigationState(







navigationState){
require('fbjs/lib/invariant')(
navigationState instanceof RouteNode,
'navigationState should be an instacne of RouteNode');

return navigationState;}}]);


function RouteNode(route){babelHelpers.classCallCheck(this,RouteNode);



var key=String(_nextRouteNodeID++);
if(__DEV__){

Object.defineProperty(this,'key',{
enumerable:true,
configurable:false,
writable:false,
value:key});

Object.defineProperty(this,'route',{
enumerable:true,
configurable:false,
writable:false,
value:route});}else 

{
this.key=key;
this.route=route;}}babelHelpers.createClass(RouteNode,[{key:'toNavigationState',value:function toNavigationState()



{
var state=this;
return state;}}]);return RouteNode;}();



var _nextRouteStackID=0;var 






RouteStack=function(){babelHelpers.createClass(RouteStack,null,[{key:'getRouteByNavigationState',value:function getRouteByNavigationState(




navigationState){
return RouteNode.fromNavigationState(navigationState).route;}}]);


function RouteStack(index,routes){babelHelpers.classCallCheck(this,RouteStack);
require('fbjs/lib/invariant')(
routes.length>0,
'routes must not be an empty array');


require('fbjs/lib/invariant')(
index>-1&&index<=routes.length-1,
'index out of bound');



var routeNodes=undefined;
if(routes[0] instanceof RouteNode){

routeNodes=routes;}else 
{

routeNodes=routes.map(function(route){
require('fbjs/lib/invariant')(!isRouteEmpty(route),'route must not be mepty');
return new RouteNode(route);});}



this._routeNodes=routeNodes;
this._index=index;
this._key=String(_nextRouteStackID++);}babelHelpers.createClass(RouteStack,[{key:'toArray',value:function toArray()













{
return this._routeNodes.map(function(node){return node.route;});}},{key:'toNavigationState',value:function toNavigationState()


{
return {
index:this._index,
key:this._key,
children:this._routeNodes.map(function(node){return node.toNavigationState();})};}},{key:'get',value:function get(



index){
if(index<0||index>this._routeNodes.length-1){
return null;}

return this._routeNodes[index].route;}},{key:'keyOf',value:function keyOf(








route){
if(isRouteEmpty(route)){
return null;}

var index=this.indexOf(route);
return index>-1?
this._routeNodes[index].key:
null;}},{key:'indexOf',value:function indexOf(


route){
if(isRouteEmpty(route)){
return -1;}


for(var ii=0,jj=this._routeNodes.length;ii<jj;ii++){
var node=this._routeNodes[ii];
if(node.route===route){
return ii;}}



return -1;}},{key:'slice',value:function slice(


begin,end){

var routeNodes=end===undefined||end===null?
this._routeNodes.slice(begin||0):
this._routeNodes.slice(begin||0,end||0);

var index=Math.min(this._index,routeNodes.length-1);
return this._update(index,routeNodes);}},{key:'push',value:function push(






route){

require('fbjs/lib/invariant')(
!isRouteEmpty(route),
'Must supply route to push');


require('fbjs/lib/invariant')(this.indexOf(route)===-1,'route must be unique');


var routeNodes=this._routeNodes.slice(0,this._index+1);
routeNodes.push(new RouteNode(route));
return this._update(routeNodes.length-1,routeNodes);}},{key:'pop',value:function pop()






{
require('fbjs/lib/invariant')(
this._routeNodes.length>1,
'should not pop routeNodes stack to empty');



var routeNodes=this._routeNodes.slice(0,this._index);
return this._update(routeNodes.length-1,routeNodes);}},{key:'jumpToIndex',value:function jumpToIndex(


index){
require('fbjs/lib/invariant')(
index>-1&&index<this._routeNodes.length,
'jumpToIndex: index out of bound');


return this._update(index,this._routeNodes);}},{key:'replaceAtIndex',value:function replaceAtIndex(








index,route){
require('fbjs/lib/invariant')(
!isRouteEmpty(route),
'Must supply route to replace');


if(this.get(index)===route){
return this;}


require('fbjs/lib/invariant')(this.indexOf(route)===-1,'route must be unique');

if(index<0){
index+=this._routeNodes.length;}


require('fbjs/lib/invariant')(
index>-1&&index<this._routeNodes.length,
'replaceAtIndex: index out of bound');


var routeNodes=this._routeNodes.slice(0);
routeNodes[index]=new RouteNode(route);
return this._update(index,routeNodes);}},{key:'forEach',value:function forEach(



callback,context){
this._routeNodes.forEach(function(node,index){
callback.call(context,node.route,index,node.key);});}},{key:'mapToArray',value:function mapToArray(



callback,context){
return this._routeNodes.map(function(node,index){
return callback.call(context,node.route,index,node.key);});}},{key:'_update',value:function _update(



index,routeNodes){
if(
this._index===index&&
areRouteNodesEqual(this._routeNodes,routeNodes))
{
return this;}


return new RouteStack(index,routeNodes);}},{key:'size',get:function(){return this._routeNodes.length;}},{key:'index',get:function(){return this._index;}}]);return RouteStack;}();



module.exports=RouteStack;