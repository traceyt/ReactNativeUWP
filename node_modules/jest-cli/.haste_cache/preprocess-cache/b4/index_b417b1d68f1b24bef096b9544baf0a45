'use strict';














var debug=require('debug')('ReactNativePackager:JStransformer');




var MAX_CALLS_PER_WORKER=600;


var DEFAULT_MAX_CALL_TIME=301000;


var MAX_RETRIES=2;

var validateOpts=require('../lib/declareOpts')({
transformModulePath:{
type:'string',
required:false},

transformTimeoutInterval:{
type:'number',
default:DEFAULT_MAX_CALL_TIME}});



var maxConcurrentWorkers=function(cores,override){
if(override){
return Math.min(cores,override);}


if(cores<3){
return cores;}

if(cores<8){
return Math.floor(cores*0.75);}

if(cores<24){
return Math.floor(3/8*cores+3);}

return cores/2;}(
require('os').cpus().length,process.env.REACT_NATIVE_MAX_WORKERS);var 

Transformer=function(){
function Transformer(options){babelHelpers.classCallCheck(this,Transformer);
var opts=this._opts=validateOpts(options);var 

transformModulePath=opts.transformModulePath;

if(transformModulePath){
this._transformModulePath=require.resolve(transformModulePath);

this._workers=require('worker-farm')(
{
autoStart:true,
maxConcurrentCallsPerWorker:1,
maxConcurrentWorkers:maxConcurrentWorkers,
maxCallsPerWorker:MAX_CALLS_PER_WORKER,
maxCallTime:opts.transformTimeoutInterval,
maxRetries:MAX_RETRIES},

require.resolve('./worker'),
['minify','transformAndExtractDependencies']);


this._transform=require('promise').denodeify(this._workers.transformAndExtractDependencies);
this.minify=require('promise').denodeify(this._workers.minify);}}babelHelpers.createClass(Transformer,[{key:'kill',value:function kill()



{
this._workers&&require('worker-farm').end(this._workers);}},{key:'transformFile',value:function transformFile(


fileName,code,options){var _this=this;
if(!this._transform){
return require('promise').reject(new Error('No transfrom module'));}

debug('transforming file',fileName);
return this.
_transform(this._transformModulePath,fileName,code,options).
then(function(result){
debug('done transforming file',fileName);
return result;}).

catch(function(error){
if(error.type==='TimeoutError'){
var timeoutErr=new Error(
'TimeoutError: transforming '+fileName+' took longer than '+(
_this._opts.transformTimeoutInterval/1000+' seconds.\n')+'You can adjust timeout via the \'transformTimeoutInterval\' option');


timeoutErr.type='TimeoutError';
throw timeoutErr;}else 
if(error.type==='ProcessTerminatedError'){
var uncaughtError=new Error(
'Uncaught error in the transformer worker: '+
_this._opts.transformModulePath);

uncaughtError.type='ProcessTerminatedError';
throw uncaughtError;}


throw formatError(error,fileName);});}}]);return Transformer;}();




module.exports=Transformer;

Transformer.TransformError=TransformError;

function TransformError(){
Error.captureStackTrace&&Error.captureStackTrace(this,TransformError);}

require('util').inherits(TransformError,SyntaxError);

function formatError(err,filename,source){
if(err.loc){
return formatBabelError(err,filename,source);}else 
{
return formatGenericError(err,filename,source);}}



function formatGenericError(err,filename){
var msg='TransformError: '+filename+': '+err.message;
var error=new TransformError();
var stack=(err.stack||'').split('\n').slice(0,-1);
stack.push(msg);
error.stack=stack.join('\n');
error.message=msg;
error.type='TransformError';
return error;}


function formatBabelError(err,filename){
var error=new TransformError();
error.type='TransformError';
error.message=(err.type||error.type)+' '+err.message;
error.stack=err.stack;
error.snippet=err.codeFrame;
error.lineNumber=err.loc.line;
error.column=err.loc.column;
error.filename=filename;
error.description=err.message;
return error;}