'use strict';var 



















































GraphQLQueryRunner=function(){


function GraphQLQueryRunner(storeData){babelHelpers.classCallCheck(this,GraphQLQueryRunner);
this.$GraphQLQueryRunner_storeData=storeData;}babelHelpers.createClass(GraphQLQueryRunner,[{key:'run',value:function run(







querySet,
callback)

{var fetchMode=arguments.length<=2||arguments[2]===undefined?require('RelayFetchMode').CLIENT:arguments[2];
return runQueries(this.$GraphQLQueryRunner_storeData,querySet,callback,fetchMode);}},{key:'forceFetch',value:function forceFetch(










querySet,
callback)
{
var fetchMode=require('RelayFetchMode').REFETCH;
return runQueries(this.$GraphQLQueryRunner_storeData,querySet,callback,fetchMode);}}]);return GraphQLQueryRunner;}();



function hasItems(map){
return !!Object.keys(map).length;}


function splitAndFlattenQueries(
storeData,
queries)
{
if(!storeData.getNetworkLayer().supports('defer')){
if(__DEV__){
queries.forEach(function(query){
require('warning')(
!query.hasDeferredDescendant(),
'Relay: Query `%s` contains a deferred fragment (e.g. '+
'`getFragment(\'foo\').defer()`) which is not supported by the '+
'default network layer. This query will be sent without deferral.',
query.getName());});}



return queries;}


var flattenedQueries=[];
queries.forEach(function(query){
return flattenedQueries.push.apply(flattenedQueries,babelHelpers.toConsumableArray(
require('flattenSplitRelayQueries')(
require('splitDeferredRelayQueries')(query))));});



return flattenedQueries;}


function runQueries(
storeData,
querySet,
callback,
fetchMode)
{
var profiler=fetchMode===require('RelayFetchMode').REFETCH?
require('RelayProfiler').profile('GraphQLQueryRunner.forceFetch'):
require('RelayProfiler').profile('GraphQLQueryRunner.primeCache');

var readyState=new (require('RelayReadyState'))(callback);

var remainingFetchMap={};
var remainingRequiredFetchMap={};

function onResolved(pendingFetch){
var pendingQuery=pendingFetch.getQuery();
var pendingQueryID=pendingQuery.getID();
delete remainingFetchMap[pendingQueryID];
if(!pendingQuery.isDeferred()){
delete remainingRequiredFetchMap[pendingQueryID];}


if(hasItems(remainingRequiredFetchMap)){
return;}


if(require('someObject')(remainingFetchMap,function(query){return query.isResolvable();})){


return;}


if(hasItems(remainingFetchMap)){
readyState.update({done:false,ready:true,stale:false});}else 
{
readyState.update({done:true,ready:true,stale:false});}}



function onRejected(pendingFetch,error){
readyState.update({error:error});

var pendingQuery=pendingFetch.getQuery();
var pendingQueryID=pendingQuery.getID();
delete remainingFetchMap[pendingQueryID];
if(!pendingQuery.isDeferred()){
delete remainingRequiredFetchMap[pendingQueryID];}}



function canResolve(fetch){
return require('checkRelayQueryData')(
storeData.getQueuedStore(),
fetch.getQuery());}



storeData.getTaskQueue().enqueue(function(){
var forceIndex=fetchMode===require('RelayFetchMode').REFETCH?
require('generateForceIndex')():
null;

var queries=[];
if(fetchMode===require('RelayFetchMode').CLIENT){
require('forEachObject')(querySet,function(query){
if(query){
queries.push.apply(queries,babelHelpers.toConsumableArray(require('diffRelayQuery')(
query,
storeData.getRecordStore(),
storeData.getQueryTracker())));}});}else 



{
require('forEachObject')(querySet,function(query){
if(query){
queries.push(query);}});}




splitAndFlattenQueries(storeData,queries).forEach(function(query){
var pendingFetch=storeData.getPendingQueryTracker().add(
{query:query,fetchMode:fetchMode,forceIndex:forceIndex,storeData:storeData});

var queryID=query.getID();
remainingFetchMap[queryID]=pendingFetch;
if(!query.isDeferred()){
remainingRequiredFetchMap[queryID]=pendingFetch;}

pendingFetch.getResolvedPromise().then(
onResolved.bind(null,pendingFetch),
onRejected.bind(null,pendingFetch));});



if(!hasItems(remainingFetchMap)){
readyState.update({done:true,ready:true});}else 
{
if(!hasItems(remainingRequiredFetchMap)){
readyState.update({ready:true});}else 
{
readyState.update({ready:false});
require('resolveImmediate')(function(){
if(storeData.hasCacheManager()){
var requiredQueryMap=require('mapObject')(
remainingRequiredFetchMap,
function(value){return value.getQuery();});

storeData.readFromDiskCache(requiredQueryMap,{
onSuccess:function(){
if(hasItems(remainingRequiredFetchMap)){
readyState.update({ready:true,stale:true});}}});}else 



{
if(require('everyObject')(remainingRequiredFetchMap,canResolve)){
if(hasItems(remainingRequiredFetchMap)){
readyState.update({ready:true,stale:true});}}}});}}







profiler.stop();}).
done();

return {
abort:function(){
readyState.update({aborted:true});}};}




module.exports=GraphQLQueryRunner;