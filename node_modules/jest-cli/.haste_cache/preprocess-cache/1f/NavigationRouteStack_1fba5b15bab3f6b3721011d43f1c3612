'use strict';var _immutable=require('immutable');var 












List=_immutable.List;var Set=_immutable.Set;

function isRouteEmpty(route){
return route===undefined||route===null||route===''||false;}


var _nextID=0;var 

RouteNode=


function RouteNode(route){babelHelpers.classCallCheck(this,RouteNode);



this.key=String(_nextID++);

this.value=route;};



var StackDiffRecord=require('immutable').Record({
key:null,
route:null,
index:null});var 





RouteStack=function(){




function RouteStack(index,routeNodes){babelHelpers.classCallCheck(this,RouteStack);
require('fbjs/lib/invariant')(
routeNodes.size>0,
'size must not be empty');


require('fbjs/lib/invariant')(
index>-1&&index<=routeNodes.size-1,
'index out of bound');


this._routeNodes=routeNodes;
this._index=index;}babelHelpers.createClass(RouteStack,[{key:'toArray',value:function toArray()












{
var result=[];
var ii=0;
var nodes=this._routeNodes;
while(ii<nodes.size){
result.push(nodes.get(ii).value);
ii++;}

return result;}},{key:'get',value:function get(


index){
if(index<0||index>this._routeNodes.size-1){
return null;}

return this._routeNodes.get(index).value;}},{key:'keyOf',value:function keyOf(








route){
if(isRouteEmpty(route)){
return null;}

var index=this.indexOf(route);
return index>-1?
this._routeNodes.get(index).key:
null;}},{key:'indexOf',value:function indexOf(


route){
if(isRouteEmpty(route)){
return -1;}


var finder=function(node){
return node.value===route;};


return this._routeNodes.findIndex(finder,this);}},{key:'slice',value:function slice(


begin,end){
var routeNodes=this._routeNodes.slice(begin,end);
var index=Math.min(this._index,routeNodes.size-1);
return this._update(index,routeNodes);}},{key:'push',value:function push(






route){var _this=this;

require('fbjs/lib/invariant')(
!isRouteEmpty(route),
'Must supply route to push');


require('fbjs/lib/invariant')(this._routeNodes.indexOf(route)===-1,'route must be unique');


var routeNodes=this._routeNodes.withMutations(function(list){
list.slice(0,_this._index+1).push(new RouteNode(route));});


return this._update(routeNodes.size-1,routeNodes);}},{key:'pop',value:function pop()






{
require('fbjs/lib/invariant')(this._routeNodes.size>1,'shoud not pop routeNodes stack to empty');


var routeNodes=this._routeNodes.slice(0,this._index);
return this._update(routeNodes.size-1,routeNodes);}},{key:'jumpToIndex',value:function jumpToIndex(


index){
require('fbjs/lib/invariant')(
index>-1&&index<this._routeNodes.size,
'index out of bound');


return this._update(index,this._routeNodes);}},{key:'replaceAtIndex',value:function replaceAtIndex(








index,route){
require('fbjs/lib/invariant')(
!isRouteEmpty(route),
'Must supply route to replace');


if(this.get(index)===route){
return this;}


require('fbjs/lib/invariant')(this.indexOf(route)===-1,'route must be unique');

if(index<0){
index+=this._routeNodes.size;}


require('fbjs/lib/invariant')(
index>-1&&index<this._routeNodes.size,
'index out of bound');


var routeNodes=this._routeNodes.set(index,new RouteNode(route));
return this._update(index,routeNodes);}},{key:'forEach',value:function forEach(



callback,context){
var ii=0;
var nodes=this._routeNodes;
while(ii<nodes.size){
var node=nodes.get(ii);
callback.call(context,node.value,ii,node.key);
ii++;}}},{key:'mapToArray',value:function mapToArray(



callback,context){
var result=[];
this.forEach(function(route,index,key){
result.push(callback.call(context,route,index,key));});

return result;}},{key:'subtract',value:function subtract(





stack){
var items=[];
this._routeNodes.forEach(function(node,index){
if(!stack._routeNodes.contains(node)){
items.push(
new StackDiffRecord({
route:node.value,
index:index,
key:node.key}));}});




return new Set(items);}},{key:'_update',value:function _update(


index,routeNodes){
if(this._index===index&&this._routeNodes===routeNodes){
return this;}

return new RouteStack(index,routeNodes);}},{key:'size',get:function(){return this._routeNodes.size;}},{key:'index',get:function(){return this._index;}}]);return RouteStack;}();var 







NavigationRouteStack=function(_RouteStack){babelHelpers.inherits(NavigationRouteStack,_RouteStack);
function NavigationRouteStack(index,routeNodes){babelHelpers.classCallCheck(this,NavigationRouteStack);




var nodes=routeNodes.map(function(route){
require('fbjs/lib/invariant')(!isRouteEmpty(route),'route must not be mepty');
return new RouteNode(route);});return babelHelpers.possibleConstructorReturn(this,Object.getPrototypeOf(NavigationRouteStack).call(this,


index,new List(nodes)));}return NavigationRouteStack;}(RouteStack);



module.exports=NavigationRouteStack;