'use strict';























var SECRET_KEY=require('keyOf')({_DONT_EVER_TYPE_THIS_SECRET_KEY:null});






var SIZE_NAME='__size_DoNotEverTouchThis';
var KEY_BY_INDEX_NAME='__keyByIndexDoNotEverTouchThis';
var INDEX_BY_KEY_NAME='__indexByKeyDoNotEverTouchThis';



















function isValidStringKey(key){
var nonNumber=isNaN(+key)||key.substring&&key.substring(0,1)==='.';
var isReserved=
key===KEY_BY_INDEX_NAME||key===INDEX_BY_KEY_NAME||key===SIZE_NAME;
return !isReserved&&typeof key==='string'&&key!==''&&nonNumber;}










function assertValidRangeIndices(start,length,actualLen){
!(
typeof start==='number'&&
typeof length==='number'&&
length>=0&&
start>=0&&
start+length<=actualLen)?require('invariant')(0,
'ImmutableMap: `mapRange` and `forEachRange` expect non-negative start and '+
'length arguments within the bounds of the instance. start: '+start+
', length: '+length+', actualLen: '+actualLen):undefined;}



function isImmutableMap(o){
return o instanceof require('Immutable')&&o.hasOwnProperty(SIZE_NAME);}


function assertImmutableMap(immutableMap){
!
isImmutableMap(immutableMap)?require('invariant')(0,
'ImmutableMap: Attempted to operate on object that is not ImmutableMap'):undefined;}













function considerNonEnumerable(key){
return key===SIZE_NAME||
key===KEY_BY_INDEX_NAME||
key===INDEX_BY_KEY_NAME;}








function setupBookkeeping(immutable,size,keyByIndex,indexByKey){
var sizeConfig=
{enumerable:false,configurable:true,writable:true,value:size};
var keyByIndexConfig=
{enumerable:false,configurable:true,writable:true,value:keyByIndex};
var indexByKeyConfig=
{enumerable:false,configurable:true,writable:true,value:indexByKey};
Object.defineProperty(immutable,SIZE_NAME,sizeConfig);
Object.defineProperty(immutable,KEY_BY_INDEX_NAME,keyByIndexConfig);
Object.defineProperty(immutable,INDEX_BY_KEY_NAME,indexByKeyConfig);}var 





ImmutableMap=function(){function ImmutableMap(){babelHelpers.classCallCheck(this,ImmutableMap);}babelHelpers.createClass(ImmutableMap,null,[{key:'create',value:function create()


















{
var immutable=new (require('Immutable'))(require('Immutable')[SECRET_KEY]);
var numProperties=
ImmutableMap.mergeAndValidateAllPropertiesInto(immutable,arguments);
setupBookkeeping(immutable,numProperties,[],[]);
immutable[KEY_BY_INDEX_NAME].areComputed=false;
if(__DEV__){
ImmutableMap.customDeepFreezeRootNode(immutable);}

return immutable;}},{key:'mergeAndValidateAllPropertiesInto',value:function mergeAndValidateAllPropertiesInto(







immutable,propertyObjects){
var argLength=propertyObjects.length;
var uniqueCount=0;
for(var i=0;i<argLength;i++){
var obj=propertyObjects[i];
for(var key in obj){
if(!obj.hasOwnProperty(key)||
isImmutableMap(obj)&&considerNonEnumerable(key)){
continue;}

if(!immutable.hasOwnProperty(key)){
!
isValidStringKey(key)?require('invariant')(0,
'ImmutableMap: Key must be truthy string not number-like.'):undefined;

uniqueCount++;}

var val=obj[key];
!(val!==undefined)?require('invariant')(0,'undefined ImmutableMap value'):undefined;
immutable[key]=val;}}


return uniqueCount;}},{key:'customDeepFreezeRootNode',value:function customDeepFreezeRootNode(
















immutableMap){
assertImmutableMap(immutableMap);
Object.freeze(immutableMap);
for(var key in immutableMap){
if(!immutableMap.hasOwnProperty(key)||considerNonEnumerable(key)){
continue;}

require('Immutable').recurseDeepFreeze(immutableMap[key]);}

Object.seal(immutableMap);}},{key:'set',value:function set(











immutableMap,put){
assertImmutableMap(immutableMap);
!(
put instanceof require('Immutable')||
typeof put==='object'&&put!==undefined&&!Array.isArray(put))?require('invariant')(0,
'Invalid ImmutableMap.set argument `put`'):undefined;

return ImmutableMap.create(immutableMap,put);}},{key:'fromArray',value:function fromArray(

















arr,keyExtractor){
var isArray=Array.isArray(arr);
var isFunction=typeof keyExtractor==='function';
!isArray?require('invariant')(0,'fromArray: First argument must be an array.'):undefined;
!isFunction?require('invariant')(0,'fromArray: Requires keyExtractor to be function'):undefined;
var immutable=new (require('Immutable'))(require('Immutable')[SECRET_KEY]);
var keyByIndex=[];
var indexByKey={};
setupBookkeeping(immutable,arr.length,keyByIndex,indexByKey);
for(var i=0;i<arr.length;i++){
var item=arr[i];
var key=keyExtractor(item,i);
!
!immutable.hasOwnProperty(key)?require('invariant')(0,
'Duplicate key in array passed to fromArray %s',
key):undefined;

!isValidStringKey(key)?require('invariant')(0,'invalid key for ImmutableMap',key):undefined;
immutable[key]=item;
keyByIndex[i]=''+key;
indexByKey[key]=i;}

keyByIndex.areComputed=true;
if(__DEV__){
ImmutableMap.customDeepFreezeRootNode(immutable);}

return immutable;}},{key:'size',value:function size(









immutableMap){
assertImmutableMap(immutableMap);
ImmutableMap.$ImmutableMap_computePositionsIfNeeded(immutableMap);
return immutableMap[SIZE_NAME];}},{key:'has',value:function has(










immutableMap,key){
!isValidStringKey(key)?require('invariant')(0,'invalid key for ImmutableMap',key):undefined;
assertImmutableMap(immutableMap);
return immutableMap.hasOwnProperty(key);}},{key:'get',value:function get(











immutableMap,key){
!isValidStringKey(key)?require('invariant')(0,'invalid key for ImmutableMap',key):undefined;
return immutableMap.hasOwnProperty(key)?immutableMap[key]:undefined;}},{key:'map',value:function map(










immutableMap,cb,context){
assertImmutableMap(immutableMap);
ImmutableMap.$ImmutableMap_computePositionsIfNeeded(immutableMap);
return ImmutableMap.mapRange(
immutableMap,
cb,
0,
immutableMap[SIZE_NAME],
context);}},{key:'mapRange',value:function mapRange(














immutableMap,cb,start,length,context){
assertImmutableMap(immutableMap);
ImmutableMap.$ImmutableMap_computePositionsIfNeeded(immutableMap);
var newSet={};
var i=0;
assertValidRangeIndices(start,length,ImmutableMap.size(immutableMap));
var end=start+length-1;
for(var key in immutableMap){
if(immutableMap.hasOwnProperty(key)){
if(i>=start){
if(i>end){
break;}

newSet[key]=cb.call(context,immutableMap[key],key,i);}

i++;}}


return ImmutableMap.create(newSet);}},{key:'filter',value:function filter(










immutableMap,cb,context){
return ImmutableMap.filterRange(
immutableMap,
cb,
0,
ImmutableMap.size(immutableMap),
context);}},{key:'filterRange',value:function filterRange(














immutableMap,cb,start,length,context){
var newSet={};
ImmutableMap.forEachRange(immutableMap,function(item,key,originalIndex){
if(cb.call(context,item,key,originalIndex)){
newSet[key]=item;}},

start,length);
return ImmutableMap.create(newSet);}},{key:'forEach',value:function forEach(


immutableMap,cb,context){
ImmutableMap.forEachRange(
immutableMap,
cb,
0,
ImmutableMap.size(immutableMap),
context);}},{key:'forEachRange',value:function forEachRange(



immutableMap,cb,start,length,context){
assertImmutableMap(immutableMap);
assertValidRangeIndices(start,length,ImmutableMap.size(immutableMap));
var i=0;
var end=start+length-1;
for(var key in immutableMap){
if(immutableMap.hasOwnProperty(key)){
if(i>=start){
if(i>end){
break;}

cb.call(context,immutableMap[key],key,i);}

i++;}}}},{key:'mapKeyRange',value:function mapKeyRange(










immutableMap,cb,startKey,endKey,context){
var startIndex=ImmutableMap.indexOfKey(immutableMap,startKey);
var endIndex=ImmutableMap.indexOfKey(immutableMap,endKey);
!(
startIndex!=null&&endIndex!=null)?require('invariant')(0,
'mapKeyRange must be given keys that are present.'):undefined;

!(
endIndex>=startIndex)?require('invariant')(0,
'ImmutableMap.mapKeyRange(...): `endKey` must be >= `startIndex`.'):undefined;

var len=endIndex-startIndex+1;
return ImmutableMap.mapRange(immutableMap,cb,startIndex,len,context);}},{key:'forEachKeyRange',value:function forEachKeyRange(


immutableMap,cb,startKey,endKey,context){
var startIndex=ImmutableMap.indexOfKey(immutableMap,startKey);
var endIndex=ImmutableMap.indexOfKey(immutableMap,endKey);
!(
startIndex!=null&&endIndex!=null)?require('invariant')(0,
'forEachKeyRange must be given keys that are present.'):undefined;

!(
endIndex>=startIndex)?require('invariant')(0,
'ImmutableMap.forEachKeyRange(...): `endKey` must not come before '+
'`startIndex`.'):undefined;

var len=endIndex-startIndex+1;
ImmutableMap.forEachRange(immutableMap,cb,startIndex,len,context);}},{key:'keyAtIndex',value:function keyAtIndex(








immutableMap,pos){
ImmutableMap.$ImmutableMap_computePositionsIfNeeded(immutableMap);
var keyAtPos=immutableMap[KEY_BY_INDEX_NAME][pos];
return keyAtPos?keyAtPos:undefined;}},{key:'valueAtIndex',value:function valueAtIndex(









immutableMap,pos){
var key=ImmutableMap.keyAtIndex(immutableMap,pos);
return key!==undefined?immutableMap[key]:undefined;}},{key:'keyAfter',value:function keyAfter(









immutableMap,key){
return ImmutableMap.nthKeyAfter(immutableMap,key,1);}},{key:'keyBefore',value:function keyBefore(









immutableMap,key){
return ImmutableMap.nthKeyBefore(immutableMap,key,1);}},{key:'nthKeyAfter',value:function nthKeyAfter(










immutableMap,key,n){
var curIndex=ImmutableMap.indexOfKey(immutableMap,key);
!(
curIndex!==undefined)?require('invariant')(0,
'ImmutableMap.nthKeyAfter: The key `%s` does not exist in this instance.',
key):undefined;

return ImmutableMap.keyAtIndex(immutableMap,curIndex+n);}},{key:'nthKeyBefore',value:function nthKeyBefore(










immutableMap,key,n){
return ImmutableMap.nthKeyAfter(immutableMap,key,-n);}},{key:'indexOfKey',value:function indexOfKey(














immutableMap,key){
!isValidStringKey(key)?require('invariant')(0,'invalid key for ImmutableMap',key):undefined;
ImmutableMap.$ImmutableMap_computePositionsIfNeeded(immutableMap);
var computedPosition=immutableMap[INDEX_BY_KEY_NAME][key];

return computedPosition===undefined?undefined:computedPosition;}},{key:'$ImmutableMap_computePositionsIfNeeded',value:function $ImmutableMap_computePositionsIfNeeded(













immutableMap){
if(immutableMap[KEY_BY_INDEX_NAME].areComputed===false){
ImmutableMap.$ImmutableMap_computePositionsFromDictionary(immutableMap);}}},{key:'$ImmutableMap_computePositionsFromDictionary',value:function $ImmutableMap_computePositionsFromDictionary(









immutableMap){
var keyByIndex=immutableMap[KEY_BY_INDEX_NAME];
var indexByKey=immutableMap[INDEX_BY_KEY_NAME];
var index=0;
for(var key in immutableMap){
if(immutableMap.hasOwnProperty(key)){
keyByIndex[index]=key;
indexByKey[key]=index;
index++;}}


immutableMap[KEY_BY_INDEX_NAME].areComputed=true;}}]);return ImmutableMap;}();



module.exports=ImmutableMap;