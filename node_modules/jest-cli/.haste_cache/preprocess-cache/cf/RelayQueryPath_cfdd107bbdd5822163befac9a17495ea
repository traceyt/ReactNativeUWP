/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule RelayQueryPath
 * 
 * @typechecks
 */

'use strict';var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError('Cannot call a class as a function');}}var 











ID = require('RelayNodeInterface').ID;var NODE_TYPE = require('RelayNodeInterface').NODE_TYPE;var TYPENAME = require('RelayNodeInterface').TYPENAME;

var idField = require('RelayQuery').Field.build({ 
  fieldName: ID, 
  type: 'String' });

var typeField = require('RelayQuery').Field.build({ 
  fieldName: TYPENAME, 
  type: 'String' });


/**
 * @internal
 *
 * Represents the path (root plus fields) within a query that fetched a
 * particular node. Each step of the path may represent a root query (for
 * refetchable nodes) or the field path from the nearest refetchable node.
 */var 
RelayQueryPath = (function () {




  function RelayQueryPath(
  node, 
  parent) 
  {_classCallCheck(this, RelayQueryPath);
    if (node instanceof require('RelayQuery').Root) {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
      !parent, 
      'RelayQueryPath: Root paths may not have a parent.');

      this._name = node.getName();} else 
    {
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
      parent, 
      'RelayQueryPath: A parent is required for field paths.');

      this._name = parent.getName();}

    this._node = node;
    this._parent = parent;}


  /**
   * Returns true if this is a root path (the node is a root node with an ID),
   * false otherwise.
   */RelayQueryPath.prototype.
  isRootPath = function isRootPath() {
    return !this._parent;};


  /**
   * Gets the parent path, throwing if it does not exist. Use `!isRootPath()`
   * to check if there is a parent.
   */RelayQueryPath.prototype.
  getParent = function getParent() {
    var parent = this._parent;
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
    parent, 
    'RelayQueryPath.getParent(): Cannot get the parent of a root path.');

    return parent;};


  /**
   * Helper to get the name of the root query node.
   */RelayQueryPath.prototype.
  getName = function getName() {
    return this._name;};


  /**
   * Gets a new path that describes how to access the given `node` via the
   * current path. Returns a new, root path if `dataID` is provided and
   * refetchable, otherwise returns an extension of the current path.
   */RelayQueryPath.prototype.
  getPath = function getPath(
  node, 
  dataID) 
  {
    if (require('RelayRecord').isClientID(dataID)) {
      return new RelayQueryPath(node, this);} else 
    {
      var root = require('RelayQuery').Root.build(
      this.getName(), 
      require('RelayNodeInterface').NODE, 
      dataID, 
      [idField, typeField], 
      { 
        identifyingArgName: require('RelayNodeInterface').ID, 
        identifyingArgType: require('RelayNodeInterface').ID_TYPE, 
        isAbstract: true, 
        isDeferred: false, 
        isPlural: false }, 

      NODE_TYPE);

      return new RelayQueryPath(root);}};



  /**
   * Returns a new root query that follows only the fields in this path and then
   * appends the specified field/fragment at the node reached by the path.
   *
   * The query also includes any ID fields along the way.
   */RelayQueryPath.prototype.
  getQuery = function getQuery(
  store, 
  appendNode) 
  {
    var node = this._node;
    var path = this;
    var child = appendNode;
    while (
    node instanceof require('RelayQuery').Field || 
    node instanceof require('RelayQuery').Fragment) 
    {
      var idFieldName = node instanceof require('RelayQuery').Field ? 
      node.getInferredPrimaryKey() : 
      ID;
      if (idFieldName) {
        child = node.clone([
        child, 
        node.getFieldByStorageKey(idFieldName), 
        node.getFieldByStorageKey(TYPENAME)]);} else 

      {
        child = node.clone([child]);}

      path = path._parent;
      require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
      path, 
      'RelayQueryPath.getQuery(): Expected a parent path.');

      node = path._node;}

    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(child, 'RelayQueryPath: Expected a leaf node.');
    require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
    node instanceof require('RelayQuery').Root, 
    'RelayQueryPath: Expected a root node.');

    var children = [
    child, 
    node.getFieldByStorageKey(ID), 
    node.getFieldByStorageKey(TYPENAME)];

    var metadata = _extends({}, node.getConcreteQueryNode().metadata);
    var identifyingArg = node.getIdentifyingArg();
    if (identifyingArg && identifyingArg.name != null) {
      metadata.identifyingArgName = identifyingArg.name;}

    // At this point `children` will be a partial query such as:
    //   id
    //   __typename
    //   fieldOnFoo { ${appendNode} }
    //
    // In which `fieldOnFoo` is a field of type `Foo`, and cannot be queried on
    // `Node`. To make the query valid it must be wrapped in a conditioning
    // fragment based on the concrete type of the root id:
    //   node(id: $rootID) {
    //     ... on TypeOFRootID {
    //        # above Fragment
    //     }
    //   }
    if (identifyingArg && identifyingArg.value != null) {
      var identifyingArgValue = identifyingArg.value;
      if (
      typeof identifyingArgValue !== 'string' && 
      typeof identifyingArgValue !== 'number') 
      {
        // TODO #8054994: Supporting aribtrary identifying value types
        require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/invariant')(
        false, 
        'Relay: Expected argument to root field `%s` to be a string or ' + 
        'number, got `%s`.', 
        node.getFieldName(), 
        JSON.stringify(identifyingArgValue));}


      var rootID = store.getDataID(
      node.getFieldName(), 
      '' + identifyingArgValue);

      var rootType = rootID && store.getType(rootID);
      if (rootType != null) {
        children = [require('RelayQuery').Fragment.build(
        this.getName(), 
        rootType, 
        children)];} else 

      {
        var recordState = rootID != null ? 
        store.getRecordState(rootID) : 
        require('RelayRecordState').UNKNOWN;
        require('/Users/cpojer/Projects/relay/scripts/jest/../../node_modules/fbjs/lib/warning')(
        false, 
        'RelayQueryPath: No typename found for %s record `%s`. ' + 
        'Generating a possibly invalid query.', 
        recordState.toLowerCase(), 
        identifyingArgValue);}}



    return require('RelayQuery').Root.build(
    this.getName(), 
    node.getFieldName(), 
    identifyingArg && identifyingArg.value || null, 
    children, 
    metadata, 
    node.getType());};return RelayQueryPath;})();




module.exports = RelayQueryPath;